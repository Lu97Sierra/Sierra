import { LineTokens } from '../core/lineTokens';
import { IRange, Range } from '../core/range';
import { LanguageId } from '../modes';
export declare const enum StringEOL {
    Unknown = 0,
    Invalid = 3,
    LF = 1,
    CRLF = 2
}
export declare function countEOL(text: string): [number, number, number, StringEOL];
export declare class MultilineTokensBuilder {
    readonly tokens: MultilineTokens[];
    constructor();
    add(lineNumber: number, lineTokens: Uint32Array): void;
    static deserialize(buff: Uint8Array): MultilineTokens[];
    serialize(): Uint8Array;
    private _serializeSize;
    private _serialize;
}
export declare class SparseEncodedTokens {
    /**
     * The encoding of tokens is:
     *  4*i    deltaLine (from `startLineNumber`)
     *  4*i+1  startCharacter (from the line start)
     *  4*i+2  endCharacter (from the line start)
     *  4*i+3  metadata
     */
    private readonly _tokens;
    private _tokenCount;
    constructor(tokens: Uint32Array);
    toString(startLineNumber: number): string;
    getMaxDeltaLine(): number;
    getRange(): Range | null;
    private _getTokenCount;
    private _getDeltaLine;
    private _getStartCharacter;
    private _getEndCharacter;
    isEmpty(): boolean;
    getLineTokens(deltaLine: number): LineTokens2 | null;
    clear(): void;
    removeTokens(startDeltaLine: number, startChar: number, endDeltaLine: number, endChar: number): number;
    split(startDeltaLine: number, startChar: number, endDeltaLine: number, endChar: number): [SparseEncodedTokens, SparseEncodedTokens, number];
    acceptDeleteRange(horizontalShiftForFirstLineTokens: number, startDeltaLine: number, startCharacter: number, endDeltaLine: number, endCharacter: number): void;
    acceptInsertText(deltaLine: number, character: number, eolCount: number, firstLineLength: number, lastLineLength: number, firstCharCode: number): void;
}
export declare class LineTokens2 {
    private readonly _tokens;
    constructor(tokens: Uint32Array);
    getCount(): number;
    getStartCharacter(tokenIndex: number): number;
    getEndCharacter(tokenIndex: number): number;
    getMetadata(tokenIndex: number): number;
}
export declare class MultilineTokens2 {
    startLineNumber: number;
    endLineNumber: number;
    tokens: SparseEncodedTokens;
    constructor(startLineNumber: number, tokens: SparseEncodedTokens);
    toString(): string;
    private _updateEndLineNumber;
    isEmpty(): boolean;
    getLineTokens(lineNumber: number): LineTokens2 | null;
    getRange(): Range | null;
    removeTokens(range: Range): void;
    split(range: Range): [MultilineTokens2, MultilineTokens2];
    applyEdit(range: IRange, text: string): void;
    acceptEdit(range: IRange, eolCount: number, firstLineLength: number, lastLineLength: number, firstCharCode: number): void;
    private _acceptDeleteRange;
    private _acceptInsertText;
}
export declare class MultilineTokens {
    startLineNumber: number;
    tokens: (Uint32Array | ArrayBuffer | null)[];
    constructor(startLineNumber: number, tokens: Uint32Array[]);
    static deserialize(buff: Uint8Array, offset: number, result: MultilineTokens[]): number;
    serializeSize(): number;
    serialize(destination: Uint8Array, offset: number): number;
    applyEdit(range: IRange, text: string): void;
    private _acceptDeleteRange;
    private _acceptInsertText;
    private _insertLines;
}
export declare class TokensStore2 {
    private _pieces;
    private _isComplete;
    constructor();
    flush(): void;
    isEmpty(): boolean;
    set(pieces: MultilineTokens2[] | null, isComplete: boolean): void;
    setPartial(_range: Range, pieces: MultilineTokens2[]): Range;
    isComplete(): boolean;
    addSemanticTokens(lineNumber: number, aTokens: LineTokens): LineTokens;
    private static _findFirstPieceWithLine;
    acceptEdit(range: IRange, eolCount: number, firstLineLength: number, lastLineLength: number, firstCharCode: number): void;
}
export declare class TokensStore {
    private _lineTokens;
    private _len;
    constructor();
    flush(): void;
    getTokens(topLevelLanguageId: LanguageId, lineIndex: number, lineText: string): LineTokens;
    private static _massageTokens;
    private _ensureLine;
    private _deleteLines;
    private _insertLines;
    setTokens(topLevelLanguageId: LanguageId, lineIndex: number, lineTextLength: number, _tokens: Uint32Array | ArrayBuffer | null, checkEquality: boolean): boolean;
    private static _equals;
    acceptEdit(range: IRange, eolCount: number, firstLineLength: number): void;
    private _acceptDeleteRange;
    private _acceptInsertText;
    static _deleteBeginning(lineTokens: Uint32Array | ArrayBuffer | null, toChIndex: number): Uint32Array | ArrayBuffer | null;
    static _deleteEnding(lineTokens: Uint32Array | ArrayBuffer | null, fromChIndex: number): Uint32Array | ArrayBuffer | null;
    static _delete(lineTokens: Uint32Array | ArrayBuffer | null, fromChIndex: number, toChIndex: number): Uint32Array | ArrayBuffer | null;
    static _append(lineTokens: Uint32Array | ArrayBuffer | null, _otherTokens: Uint32Array | ArrayBuffer | null): Uint32Array | ArrayBuffer | null;
    static _insert(lineTokens: Uint32Array | ArrayBuffer | null, chIndex: number, textLength: number): Uint32Array | ArrayBuffer | null;
}
