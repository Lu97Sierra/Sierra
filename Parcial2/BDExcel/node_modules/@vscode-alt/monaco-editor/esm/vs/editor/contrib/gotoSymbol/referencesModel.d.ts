import { Event, Emitter } from '../../../base/common/event';
import { IDisposable, IReference } from '../../../base/common/lifecycle';
import { URI } from '../../../base/common/uri';
import { IRange } from '../../common/core/range';
import { LocationLink } from '../../common/modes';
import { ITextModelService, ITextEditorModel } from '../../common/services/resolverService';
import { Position } from '../../common/core/position';
import { IMatch } from '../../../base/common/filters';
export declare class OneReference {
    readonly isProviderFirst: boolean;
    readonly parent: FileReferences;
    readonly uri: URI;
    private _range;
    private _rangeCallback;
    readonly id: string;
    constructor(isProviderFirst: boolean, parent: FileReferences, uri: URI, _range: IRange, _rangeCallback: (ref: OneReference) => void);
    get range(): IRange;
    set range(value: IRange);
    get ariaMessage(): string;
}
export declare class FilePreview implements IDisposable {
    private readonly _modelReference;
    constructor(_modelReference: IReference<ITextEditorModel>);
    dispose(): void;
    preview(range: IRange, n?: number): {
        value: string;
        highlight: IMatch;
    } | undefined;
}
export declare class FileReferences implements IDisposable {
    readonly parent: ReferencesModel;
    readonly uri: URI;
    readonly children: OneReference[];
    private _previews;
    constructor(parent: ReferencesModel, uri: URI);
    dispose(): void;
    getPreview(child: OneReference): FilePreview | undefined;
    get ariaMessage(): string;
    resolve(textModelResolverService: ITextModelService): Promise<FileReferences>;
}
export declare class ReferencesModel implements IDisposable {
    private readonly _disposables;
    private readonly _links;
    private readonly _title;
    readonly groups: FileReferences[];
    readonly references: OneReference[];
    readonly _onDidChangeReferenceRange: Emitter<OneReference>;
    readonly onDidChangeReferenceRange: Event<OneReference>;
    constructor(links: LocationLink[], title: string);
    dispose(): void;
    clone(): ReferencesModel;
    get title(): string;
    get isEmpty(): boolean;
    get ariaMessage(): string;
    nextOrPreviousReference(reference: OneReference, next: boolean): OneReference;
    nearestReference(resource: URI, position: Position): OneReference | undefined;
    referenceAt(resource: URI, position: Position): OneReference | undefined;
    firstReference(): OneReference | undefined;
    private static _compareReferences;
}
