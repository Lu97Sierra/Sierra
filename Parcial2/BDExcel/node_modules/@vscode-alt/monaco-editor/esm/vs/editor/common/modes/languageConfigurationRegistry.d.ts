import { Event } from '../../../base/common/event';
import { IDisposable } from '../../../base/common/lifecycle';
import { LineTokens } from '../core/lineTokens';
import { Range } from '../core/range';
import { ITextModel } from '../model';
import { LanguageId, LanguageIdentifier } from '../modes';
import { EnterAction, FoldingRules, IAutoClosingPair, IndentAction, IndentationRule, LanguageConfiguration, StandardAutoClosingPairConditional, CompleteEnterAction, AutoClosingPairs } from './languageConfiguration';
import { CharacterPairSupport } from './supports/characterPair';
import { BracketElectricCharacterSupport, IElectricAction } from './supports/electricCharacter';
import { IndentRulesSupport } from './supports/indentRules';
import { RichEditBrackets } from './supports/richEditBrackets';
import { EditorAutoIndentStrategy } from '../config/editorOptions';
/**
 * Interface used to support insertion of mode specific comments.
 */
export interface ICommentsConfiguration {
    lineCommentToken?: string;
    blockCommentStartToken?: string;
    blockCommentEndToken?: string;
}
export interface IVirtualModel {
    getLineTokens(lineNumber: number): LineTokens;
    getLanguageIdentifier(): LanguageIdentifier;
    getLanguageIdAtPosition(lineNumber: number, column: number): LanguageId;
    getLineContent(lineNumber: number): string;
}
export interface IIndentConverter {
    shiftIndent(indentation: string): string;
    unshiftIndent(indentation: string): string;
    normalizeIndentation?(indentation: string): string;
}
export declare class RichEditSupport {
    private readonly _conf;
    private readonly _languageIdentifier;
    private _brackets;
    private _electricCharacter;
    private readonly _onEnterSupport;
    readonly comments: ICommentsConfiguration | null;
    readonly characterPair: CharacterPairSupport;
    readonly wordDefinition: RegExp;
    readonly indentRulesSupport: IndentRulesSupport | null;
    readonly indentationRules: IndentationRule | undefined;
    readonly foldingRules: FoldingRules;
    constructor(languageIdentifier: LanguageIdentifier, previous: RichEditSupport | undefined, rawConf: LanguageConfiguration);
    get brackets(): RichEditBrackets | null;
    get electricCharacter(): BracketElectricCharacterSupport | null;
    onEnter(autoIndent: EditorAutoIndentStrategy, oneLineAboveText: string, beforeEnterText: string, afterEnterText: string): EnterAction | null;
    private static _mergeConf;
    private static _handleComments;
}
export declare class LanguageConfigurationChangeEvent {
    readonly languageIdentifier: LanguageIdentifier;
    constructor(languageIdentifier: LanguageIdentifier);
}
export declare class LanguageConfigurationRegistryImpl {
    private readonly _entries;
    private readonly _onDidChange;
    readonly onDidChange: Event<LanguageConfigurationChangeEvent>;
    register(languageIdentifier: LanguageIdentifier, configuration: LanguageConfiguration): IDisposable;
    private _getRichEditSupport;
    getIndentationRules(languageId: LanguageId): IndentationRule | null;
    private _getElectricCharacterSupport;
    getElectricCharacters(languageId: LanguageId): string[];
    /**
     * Should return opening bracket type to match indentation with
     */
    onElectricCharacter(character: string, context: LineTokens, column: number): IElectricAction | null;
    getComments(languageId: LanguageId): ICommentsConfiguration | null;
    private _getCharacterPairSupport;
    getAutoClosingPairs(languageId: LanguageId): AutoClosingPairs;
    getAutoCloseBeforeSet(languageId: LanguageId): string;
    getSurroundingPairs(languageId: LanguageId): IAutoClosingPair[];
    shouldAutoClosePair(autoClosingPair: StandardAutoClosingPairConditional, context: LineTokens, column: number): boolean;
    getWordDefinition(languageId: LanguageId): RegExp;
    getWordDefinitions(): [LanguageId, RegExp][];
    getFoldingRules(languageId: LanguageId): FoldingRules;
    getIndentRulesSupport(languageId: LanguageId): IndentRulesSupport | null;
    /**
     * Get nearest preceiding line which doesn't match unIndentPattern or contains all whitespace.
     * Result:
     * -1: run into the boundary of embedded languages
     * 0: every line above are invalid
     * else: nearest preceding line of the same language
     */
    private getPrecedingValidLine;
    /**
     * Get inherited indentation from above lines.
     * 1. Find the nearest preceding line which doesn't match unIndentedLinePattern.
     * 2. If this line matches indentNextLinePattern or increaseIndentPattern, it means that the indent level of `lineNumber` should be 1 greater than this line.
     * 3. If this line doesn't match any indent rules
     *   a. check whether the line above it matches indentNextLinePattern
     *   b. If not, the indent level of this line is the result
     *   c. If so, it means the indent of this line is *temporary*, go upward utill we find a line whose indent is not temporary (the same workflow a -> b -> c).
     * 4. Otherwise, we fail to get an inherited indent from aboves. Return null and we should not touch the indent of `lineNumber`
     *
     * This function only return the inherited indent based on above lines, it doesn't check whether current line should decrease or not.
     */
    getInheritIndentForLine(autoIndent: EditorAutoIndentStrategy, model: IVirtualModel, lineNumber: number, honorIntentialIndent?: boolean): {
        indentation: string;
        action: IndentAction | null;
        line?: number;
    } | null;
    getGoodIndentForLine(autoIndent: EditorAutoIndentStrategy, virtualModel: IVirtualModel, languageId: LanguageId, lineNumber: number, indentConverter: IIndentConverter): string | null;
    getIndentForEnter(autoIndent: EditorAutoIndentStrategy, model: ITextModel, range: Range, indentConverter: IIndentConverter): {
        beforeEnter: string;
        afterEnter: string;
    } | null;
    /**
     * We should always allow intentional indentation. It means, if users change the indentation of `lineNumber` and the content of
     * this line doesn't match decreaseIndentPattern, we should not adjust the indentation.
     */
    getIndentActionForType(autoIndent: EditorAutoIndentStrategy, model: ITextModel, range: Range, ch: string, indentConverter: IIndentConverter): string | null;
    getIndentMetadata(model: ITextModel, lineNumber: number): number | null;
    getEnterAction(autoIndent: EditorAutoIndentStrategy, model: ITextModel, range: Range): CompleteEnterAction | null;
    getIndentationAtPosition(model: ITextModel, lineNumber: number, column: number): string;
    private getScopedLineTokens;
    getBracketsSupport(languageId: LanguageId): RichEditBrackets | null;
}
export declare const LanguageConfigurationRegistry: LanguageConfigurationRegistryImpl;
