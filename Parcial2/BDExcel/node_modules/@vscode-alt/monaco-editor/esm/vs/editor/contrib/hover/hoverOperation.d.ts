import { CancellationToken } from '../../../base/common/cancellation';
export interface IHoverComputer<Result> {
    /**
     * This is called after half the hover time
     */
    computeAsync?: (token: CancellationToken) => Promise<Result>;
    /**
     * This is called after all the hover time
     */
    computeSync?: () => Result;
    /**
     * This is called whenever one of the compute* methods returns a truey value
     */
    onResult: (result: Result, isFromSynchronousComputation: boolean) => void;
    /**
     * This is what will be sent as progress/complete to the computation promise
     */
    getResult: () => Result;
    getResultWithLoadingMessage: () => Result;
}
export declare const enum HoverStartMode {
    Delayed = 0,
    Immediate = 1
}
export declare class HoverOperation<Result> {
    private readonly _computer;
    private _state;
    private _hoverTime;
    private readonly _firstWaitScheduler;
    private readonly _secondWaitScheduler;
    private readonly _loadingMessageScheduler;
    private _asyncComputationPromise;
    private _asyncComputationPromiseDone;
    private readonly _completeCallback;
    private readonly _errorCallback;
    private readonly _progressCallback;
    constructor(computer: IHoverComputer<Result>, success: (r: Result) => void, error: ((err: any) => void) | null | undefined, progress: (progress: any) => void, hoverTime: number);
    setHoverTime(hoverTime: number): void;
    private _firstWaitTime;
    private _secondWaitTime;
    private _loadingMessageTime;
    private _triggerAsyncComputation;
    private _triggerSyncComputation;
    private _showLoadingMessage;
    private _withAsyncResult;
    private _onComplete;
    private _onError;
    private _onProgress;
    start(mode: HoverStartMode): void;
    cancel(): void;
}
