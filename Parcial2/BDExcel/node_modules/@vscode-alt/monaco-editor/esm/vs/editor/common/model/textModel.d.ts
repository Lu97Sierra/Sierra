import { Event } from '../../../base/common/event';
import { IMarkdownString } from '../../../base/common/htmlContent';
import { Disposable, IDisposable } from '../../../base/common/lifecycle';
import { URI } from '../../../base/common/uri';
import { LineTokens } from '../core/lineTokens';
import { IPosition, Position } from '../core/position';
import { IRange, Range } from '../core/range';
import { Selection } from '../core/selection';
import * as model from '../model';
import { IModelContentChangedEvent, IModelDecorationsChangedEvent, IModelLanguageChangedEvent, IModelLanguageConfigurationChangedEvent, IModelOptionsChangedEvent, IModelTokensChangedEvent, InternalModelContentChangeEvent, ModelRawContentChangedEvent } from './textModelEvents';
import { LanguageId, LanguageIdentifier, FormattingOptions } from '../modes';
import { ThemeColor } from '../../../platform/theme/common/themeService';
import { VSBufferReadableStream, VSBuffer } from '../../../base/common/buffer';
import { MultilineTokens, MultilineTokens2 } from './tokensStore';
import { Color } from '../../../base/common/color';
import { EditorTheme } from '../view/viewContext';
import { IUndoRedoService, ResourceEditStackSnapshot } from '../../../platform/undoRedo/common/undoRedo';
import { TextChange } from './textChange';
export declare function createTextBufferFactory(text: string): model.ITextBufferFactory;
interface ITextStream {
    on(event: 'data', callback: (data: string) => void): void;
    on(event: 'error', callback: (err: Error) => void): void;
    on(event: 'end', callback: () => void): void;
    on(event: string, callback: any): void;
}
export declare function createTextBufferFactoryFromStream(stream: ITextStream, filter?: (chunk: string) => string, validator?: (chunk: string) => Error | undefined): Promise<model.ITextBufferFactory>;
export declare function createTextBufferFactoryFromStream(stream: VSBufferReadableStream, filter?: (chunk: VSBuffer) => VSBuffer, validator?: (chunk: VSBuffer) => Error | undefined): Promise<model.ITextBufferFactory>;
export declare function createTextBufferFactoryFromSnapshot(snapshot: model.ITextSnapshot): model.ITextBufferFactory;
export declare function createTextBuffer(value: string | model.ITextBufferFactory, defaultEOL: model.DefaultEndOfLine): model.ITextBuffer;
export declare const LONG_LINE_BOUNDARY = 10000;
export declare class TextModel extends Disposable implements model.ITextModel {
    private static readonly MODEL_SYNC_LIMIT;
    private static readonly LARGE_FILE_SIZE_THRESHOLD;
    private static readonly LARGE_FILE_LINE_COUNT_THRESHOLD;
    static DEFAULT_CREATION_OPTIONS: model.ITextModelCreationOptions;
    static resolveOptions(textBuffer: model.ITextBuffer, options: model.ITextModelCreationOptions): model.TextModelResolvedOptions;
    private readonly _onWillDispose;
    readonly onWillDispose: Event<void>;
    private readonly _onDidChangeDecorations;
    readonly onDidChangeDecorations: Event<IModelDecorationsChangedEvent>;
    private readonly _onDidChangeLanguage;
    readonly onDidChangeLanguage: Event<IModelLanguageChangedEvent>;
    private readonly _onDidChangeLanguageConfiguration;
    readonly onDidChangeLanguageConfiguration: Event<IModelLanguageConfigurationChangedEvent>;
    private readonly _onDidChangeTokens;
    readonly onDidChangeTokens: Event<IModelTokensChangedEvent>;
    private readonly _onDidChangeOptions;
    readonly onDidChangeOptions: Event<IModelOptionsChangedEvent>;
    private readonly _onDidChangeAttached;
    readonly onDidChangeAttached: Event<void>;
    private readonly _eventEmitter;
    onDidChangeRawContentFast(listener: (e: ModelRawContentChangedEvent) => void): IDisposable;
    onDidChangeRawContent(listener: (e: ModelRawContentChangedEvent) => void): IDisposable;
    onDidChangeContentFast(listener: (e: IModelContentChangedEvent) => void): IDisposable;
    onDidChangeContent(listener: (e: IModelContentChangedEvent) => void): IDisposable;
    readonly id: string;
    readonly isForSimpleWidget: boolean;
    private readonly _associatedResource;
    private readonly _undoRedoService;
    private _attachedEditorCount;
    private _buffer;
    private _options;
    private _isDisposed;
    private _isDisposing;
    private _versionId;
    /**
     * Unlike, versionId, this can go down (via undo) or go to previous values (via redo)
     */
    private _alternativeVersionId;
    private _initialUndoRedoSnapshot;
    private readonly _isTooLargeForSyncing;
    private readonly _isTooLargeForTokenization;
    private readonly _commandManager;
    private _isUndoing;
    private _isRedoing;
    private _trimAutoWhitespaceLines;
    /**
     * Used to workaround broken clients that might attempt using a decoration id generated by a different model.
     * It is not globally unique in order to limit it to one character.
     */
    private readonly _instanceId;
    private _lastDecorationId;
    private _decorations;
    private _decorationsTree;
    private _languageIdentifier;
    private readonly _languageRegistryListener;
    private readonly _tokens;
    private readonly _tokens2;
    private readonly _tokenization;
    constructor(source: string | model.ITextBufferFactory, creationOptions: model.ITextModelCreationOptions, languageIdentifier: LanguageIdentifier | null, associatedResource: URI | null | undefined, undoRedoService: IUndoRedoService);
    dispose(): void;
    private _assertNotDisposed;
    equalsTextBuffer(other: model.ITextBuffer): boolean;
    getTextBuffer(): model.ITextBuffer;
    private _emitContentChangedEvent;
    setValue(value: string): void;
    private _createContentChanged2;
    setValueFromTextBuffer(textBuffer: model.ITextBuffer): void;
    setEOL(eol: model.EndOfLineSequence): void;
    private _onBeforeEOLChange;
    private _onAfterEOLChange;
    onBeforeAttached(): void;
    onBeforeDetached(): void;
    isAttachedToEditor(): boolean;
    getAttachedEditorCount(): number;
    isTooLargeForSyncing(): boolean;
    isTooLargeForTokenization(): boolean;
    isDisposed(): boolean;
    isDominatedByLongLines(): boolean;
    get uri(): URI;
    getOptions(): model.TextModelResolvedOptions;
    getFormattingOptions(): FormattingOptions;
    updateOptions(_newOpts: model.ITextModelUpdateOptions): void;
    detectIndentation(defaultInsertSpaces: boolean, defaultTabSize: number): void;
    private static _normalizeIndentationFromWhitespace;
    static normalizeIndentation(str: string, indentSize: number, insertSpaces: boolean): string;
    normalizeIndentation(str: string): string;
    getVersionId(): number;
    mightContainRTL(): boolean;
    mightContainUnusualLineTerminators(): boolean;
    removeUnusualLineTerminators(selections?: Selection[] | null): void;
    mightContainNonBasicASCII(): boolean;
    getAlternativeVersionId(): number;
    getInitialUndoRedoSnapshot(): ResourceEditStackSnapshot | null;
    getOffsetAt(rawPosition: IPosition): number;
    getPositionAt(rawOffset: number): Position;
    private _increaseVersionId;
    _overwriteVersionId(versionId: number): void;
    _overwriteAlternativeVersionId(newAlternativeVersionId: number): void;
    _overwriteInitialUndoRedoSnapshot(newInitialUndoRedoSnapshot: ResourceEditStackSnapshot | null): void;
    getValue(eol?: model.EndOfLinePreference, preserveBOM?: boolean): string;
    createSnapshot(preserveBOM?: boolean): model.ITextSnapshot;
    getValueLength(eol?: model.EndOfLinePreference, preserveBOM?: boolean): number;
    getValueInRange(rawRange: IRange, eol?: model.EndOfLinePreference): string;
    getValueLengthInRange(rawRange: IRange, eol?: model.EndOfLinePreference): number;
    getCharacterCountInRange(rawRange: IRange, eol?: model.EndOfLinePreference): number;
    getLineCount(): number;
    getLineContent(lineNumber: number): string;
    getLineLength(lineNumber: number): number;
    getLinesContent(): string[];
    getEOL(): string;
    getEndOfLineSequence(): model.EndOfLineSequence;
    getLineMinColumn(lineNumber: number): number;
    getLineMaxColumn(lineNumber: number): number;
    getLineFirstNonWhitespaceColumn(lineNumber: number): number;
    getLineLastNonWhitespaceColumn(lineNumber: number): number;
    /**
     * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.
     * Will try to not allocate if possible.
     */
    private _validateRangeRelaxedNoAllocations;
    private _isValidPosition;
    private _validatePosition;
    validatePosition(position: IPosition): Position;
    private _isValidRange;
    validateRange(_range: IRange): Range;
    modifyPosition(rawPosition: IPosition, offset: number): Position;
    getFullModelRange(): Range;
    private findMatchesLineByLine;
    findMatches(searchString: string, rawSearchScope: any, isRegex: boolean, matchCase: boolean, wordSeparators: string | null, captureMatches: boolean, limitResultCount?: number): model.FindMatch[];
    findNextMatch(searchString: string, rawSearchStart: IPosition, isRegex: boolean, matchCase: boolean, wordSeparators: string, captureMatches: boolean): model.FindMatch | null;
    findPreviousMatch(searchString: string, rawSearchStart: IPosition, isRegex: boolean, matchCase: boolean, wordSeparators: string, captureMatches: boolean): model.FindMatch | null;
    pushStackElement(): void;
    popStackElement(): void;
    pushEOL(eol: model.EndOfLineSequence): void;
    private _validateEditOperation;
    private _validateEditOperations;
    pushEditOperations(beforeCursorState: Selection[] | null, editOperations: model.IIdentifiedSingleEditOperation[], cursorStateComputer: model.ICursorStateComputer | null): Selection[] | null;
    private _pushEditOperations;
    _applyUndo(changes: TextChange[], eol: model.EndOfLineSequence, resultingAlternativeVersionId: number, resultingSelection: Selection[] | null): void;
    _applyRedo(changes: TextChange[], eol: model.EndOfLineSequence, resultingAlternativeVersionId: number, resultingSelection: Selection[] | null): void;
    private _applyUndoRedoEdits;
    applyEdits(operations: model.IIdentifiedSingleEditOperation[]): void;
    applyEdits(operations: model.IIdentifiedSingleEditOperation[], computeUndoEdits: false): void;
    applyEdits(operations: model.IIdentifiedSingleEditOperation[], computeUndoEdits: true): model.IValidEditOperation[];
    private _doApplyEdits;
    undo(): void | Promise<void>;
    canUndo(): boolean;
    redo(): void | Promise<void>;
    canRedo(): boolean;
    changeDecorations<T>(callback: (changeAccessor: model.IModelDecorationsChangeAccessor) => T, ownerId?: number): T | null;
    private _changeDecorations;
    deltaDecorations(oldDecorations: string[], newDecorations: model.IModelDeltaDecoration[], ownerId?: number): string[];
    _getTrackedRange(id: string): Range | null;
    _setTrackedRange(id: string | null, newRange: null, newStickiness: model.TrackedRangeStickiness): null;
    _setTrackedRange(id: string | null, newRange: Range, newStickiness: model.TrackedRangeStickiness): string;
    removeAllDecorationsWithOwnerId(ownerId: number): void;
    getDecorationOptions(decorationId: string): model.IModelDecorationOptions | null;
    getDecorationRange(decorationId: string): Range | null;
    getLineDecorations(lineNumber: number, ownerId?: number, filterOutValidation?: boolean): model.IModelDecoration[];
    getLinesDecorations(_startLineNumber: number, _endLineNumber: number, ownerId?: number, filterOutValidation?: boolean): model.IModelDecoration[];
    getDecorationsInRange(range: IRange, ownerId?: number, filterOutValidation?: boolean): model.IModelDecoration[];
    getOverviewRulerDecorations(ownerId?: number, filterOutValidation?: boolean): model.IModelDecoration[];
    getAllDecorations(ownerId?: number, filterOutValidation?: boolean): model.IModelDecoration[];
    private _getDecorationsInRange;
    private _ensureNodesHaveRanges;
    private _getRangeAt;
    private _changeDecorationImpl;
    private _changeDecorationOptionsImpl;
    private _deltaDecorationsImpl;
    setLineTokens(lineNumber: number, tokens: Uint32Array | ArrayBuffer | null): void;
    setTokens(tokens: MultilineTokens[]): void;
    setSemanticTokens(tokens: MultilineTokens2[] | null, isComplete: boolean): void;
    hasCompleteSemanticTokens(): boolean;
    hasSomeSemanticTokens(): boolean;
    setPartialSemanticTokens(range: Range, tokens: MultilineTokens2[]): void;
    tokenizeViewport(startLineNumber: number, endLineNumber: number): void;
    clearTokens(): void;
    clearSemanticTokens(): void;
    private _emitModelTokensChangedEvent;
    resetTokenization(): void;
    forceTokenization(lineNumber: number): void;
    isCheapToTokenize(lineNumber: number): boolean;
    tokenizeIfCheap(lineNumber: number): void;
    getLineTokens(lineNumber: number): LineTokens;
    private _getLineTokens;
    getLanguageIdentifier(): LanguageIdentifier;
    getModeId(): string;
    setMode(languageIdentifier: LanguageIdentifier): void;
    getLanguageIdAtPosition(lineNumber: number, column: number): LanguageId;
    getWordAtPosition(_position: IPosition): model.IWordAtPosition | null;
    private static _findLanguageBoundaries;
    getWordUntilPosition(position: IPosition): model.IWordAtPosition;
    findMatchingBracketUp(_bracket: string, _position: IPosition): Range | null;
    matchBracket(position: IPosition): [Range, Range] | null;
    private _matchBracket;
    private _matchFoundBracket;
    private _findMatchingBracketUp;
    private _findMatchingBracketDown;
    findPrevBracket(_position: IPosition): model.IFoundBracket | null;
    findNextBracket(_position: IPosition): model.IFoundBracket | null;
    findEnclosingBrackets(_position: IPosition, maxDuration?: number): [Range, Range] | null;
    private _toFoundBracket;
    /**
     * Returns:
     *  - -1 => the line consists of whitespace
     *  - otherwise => the indent level is returned value
     */
    static computeIndentLevel(line: string, tabSize: number): number;
    private _computeIndentLevel;
    getActiveIndentGuide(lineNumber: number, minLineNumber: number, maxLineNumber: number): model.IActiveIndentGuideInfo;
    getLinesIndentGuides(startLineNumber: number, endLineNumber: number): number[];
    private _getIndentLevelForWhitespaceLine;
}
declare class DecorationOptions implements model.IDecorationOptions {
    readonly color: string | ThemeColor;
    readonly darkColor: string | ThemeColor;
    constructor(options: model.IDecorationOptions);
}
export declare class ModelDecorationOverviewRulerOptions extends DecorationOptions {
    readonly position: model.OverviewRulerLane;
    private _resolvedColor;
    constructor(options: model.IModelDecorationOverviewRulerOptions);
    getColor(theme: EditorTheme): string;
    invalidateCachedColor(): void;
    private _resolveColor;
}
export declare class ModelDecorationMinimapOptions extends DecorationOptions {
    readonly position: model.MinimapPosition;
    private _resolvedColor;
    constructor(options: model.IModelDecorationMinimapOptions);
    getColor(theme: EditorTheme): Color | undefined;
    invalidateCachedColor(): void;
    private _resolveColor;
}
export declare class ModelDecorationOptions implements model.IModelDecorationOptions {
    static EMPTY: ModelDecorationOptions;
    static register(options: model.IModelDecorationOptions): ModelDecorationOptions;
    static createDynamic(options: model.IModelDecorationOptions): ModelDecorationOptions;
    readonly stickiness: model.TrackedRangeStickiness;
    readonly zIndex: number;
    readonly className: string | null;
    readonly hoverMessage: IMarkdownString | IMarkdownString[] | null;
    readonly glyphMarginHoverMessage: IMarkdownString | IMarkdownString[] | null;
    readonly isWholeLine: boolean;
    readonly showIfCollapsed: boolean;
    readonly collapseOnReplaceEdit: boolean;
    readonly overviewRuler: ModelDecorationOverviewRulerOptions | null;
    readonly minimap: ModelDecorationMinimapOptions | null;
    readonly glyphMarginClassName: string | null;
    readonly linesDecorationsClassName: string | null;
    readonly firstLineDecorationClassName: string | null;
    readonly marginClassName: string | null;
    readonly inlineClassName: string | null;
    readonly inlineClassNameAffectsLetterSpacing: boolean;
    readonly beforeContentClassName: string | null;
    readonly afterContentClassName: string | null;
    private constructor();
}
export declare class DidChangeDecorationsEmitter extends Disposable {
    private readonly _actual;
    readonly event: Event<IModelDecorationsChangedEvent>;
    private _deferredCnt;
    private _shouldFire;
    private _affectsMinimap;
    private _affectsOverviewRuler;
    constructor();
    beginDeferredEmit(): void;
    endDeferredEmit(): void;
    checkAffectedAndFire(options: ModelDecorationOptions): void;
    fire(): void;
}
export declare class DidChangeContentEmitter extends Disposable {
    /**
     * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.
     */
    private readonly _fastEmitter;
    readonly fastEvent: Event<InternalModelContentChangeEvent>;
    private readonly _slowEmitter;
    readonly slowEvent: Event<InternalModelContentChangeEvent>;
    private _deferredCnt;
    private _deferredEvent;
    constructor();
    beginDeferredEmit(): void;
    endDeferredEmit(resultingSelection?: Selection[] | null): void;
    fire(e: InternalModelContentChangeEvent): void;
}
export {};
