import { ICollapseStateChangeEvent, ITreeElement, ITreeFilter, ITreeFilterDataResult, ITreeModel, ITreeNode, TreeVisibility, ITreeModelSpliceEvent } from './tree';
import { Event } from '../../../common/event';
import { ISpliceable } from '../../../common/sequence';
export interface IIndexTreeNode<T, TFilterData = void> extends ITreeNode<T, TFilterData> {
    readonly parent: IIndexTreeNode<T, TFilterData> | undefined;
    readonly children: IIndexTreeNode<T, TFilterData>[];
    visibleChildrenCount: number;
    visibleChildIndex: number;
    collapsible: boolean;
    collapsed: boolean;
    renderNodeCount: number;
    visibility: TreeVisibility;
    visible: boolean;
    filterData: TFilterData | undefined;
}
export declare function isFilterResult<T>(obj: any): obj is ITreeFilterDataResult<T>;
export declare function getVisibleState(visibility: boolean | TreeVisibility): TreeVisibility;
export interface IIndexTreeModelOptions<T, TFilterData> {
    readonly collapseByDefault?: boolean;
    readonly filter?: ITreeFilter<T, TFilterData>;
    readonly autoExpandSingleChildren?: boolean;
}
export interface IList<T> extends ISpliceable<T> {
    updateElementHeight(index: number, height: number): void;
}
export declare class IndexTreeModel<T extends Exclude<any, undefined>, TFilterData = void> implements ITreeModel<T, TFilterData, number[]> {
    private user;
    private list;
    readonly rootRef: never[];
    private root;
    private eventBufferer;
    private readonly _onDidChangeCollapseState;
    readonly onDidChangeCollapseState: Event<ICollapseStateChangeEvent<T, TFilterData>>;
    private readonly _onDidChangeRenderNodeCount;
    readonly onDidChangeRenderNodeCount: Event<ITreeNode<T, TFilterData>>;
    private collapseByDefault;
    private filter?;
    private autoExpandSingleChildren;
    private readonly _onDidSplice;
    readonly onDidSplice: Event<ITreeModelSpliceEvent<T, TFilterData>>;
    constructor(user: string, list: IList<ITreeNode<T, TFilterData>>, rootElement: T, options?: IIndexTreeModelOptions<T, TFilterData>);
    splice(location: number[], deleteCount: number, toInsert?: Iterable<ITreeElement<T>>, onDidCreateNode?: (node: ITreeNode<T, TFilterData>) => void, onDidDeleteNode?: (node: ITreeNode<T, TFilterData>) => void): void;
    rerender(location: number[]): void;
    updateElementHeight(location: number[], height: number): void;
    has(location: number[]): boolean;
    getListIndex(location: number[]): number;
    getListRenderCount(location: number[]): number;
    isCollapsible(location: number[]): boolean;
    setCollapsible(location: number[], collapsible?: boolean): boolean;
    isCollapsed(location: number[]): boolean;
    setCollapsed(location: number[], collapsed?: boolean, recursive?: boolean): boolean;
    private _setCollapseState;
    private _setListNodeCollapseState;
    private _setNodeCollapseState;
    expandTo(location: number[]): void;
    refilter(): void;
    private createTreeNode;
    private updateNodeAfterCollapseChange;
    private _updateNodeAfterCollapseChange;
    private updateNodeAfterFilterChange;
    private _updateNodeAfterFilterChange;
    private _updateAncestorsRenderNodeCount;
    private _filterNode;
    private hasTreeNode;
    private getTreeNode;
    private getTreeNodeWithListIndex;
    private getParentNodeWithListIndex;
    getNode(location?: number[]): ITreeNode<T, TFilterData>;
    getNodeLocation(node: ITreeNode<T, TFilterData>): number[];
    getParentNodeLocation(location: number[]): number[] | undefined;
    getFirstElementChild(location: number[]): T | undefined;
    getLastElementAncestor(location?: number[]): T | undefined;
    private _getLastElementAncestor;
}
