import { AbstractTree, IAbstractTreeOptions, IAbstractTreeOptionsUpdate } from './abstractTree';
import { ITreeNode, ITreeModel, ITreeElement, ITreeRenderer, ITreeSorter, ICollapseStateChangeEvent } from './tree';
import { IObjectTreeModel } from './objectTreeModel';
import { IListVirtualDelegate, IKeyboardNavigationLabelProvider } from '../list/list';
import { Event } from '../../../common/event';
import { CompressibleObjectTreeModel, ElementMapper, ICompressedTreeNode, ICompressedTreeElement } from './compressedObjectTreeModel';
import { IList } from './indexTreeModel';
export interface IObjectTreeOptions<T, TFilterData = void> extends IAbstractTreeOptions<T, TFilterData> {
    readonly sorter?: ITreeSorter<T>;
}
export declare class ObjectTree<T extends NonNullable<any>, TFilterData = void> extends AbstractTree<T | null, TFilterData, T | null> {
    protected model: IObjectTreeModel<T, TFilterData>;
    get onDidChangeCollapseState(): Event<ICollapseStateChangeEvent<T | null, TFilterData>>;
    constructor(user: string, container: HTMLElement, delegate: IListVirtualDelegate<T>, renderers: ITreeRenderer<T, TFilterData, any>[], options?: IObjectTreeOptions<T, TFilterData>);
    setChildren(element: T | null, children?: Iterable<ITreeElement<T>>): void;
    rerender(element?: T): void;
    updateElementHeight(element: T, height: number): void;
    resort(element: T, recursive?: boolean): void;
    hasElement(element: T): boolean;
    protected createModel(user: string, view: IList<ITreeNode<T, TFilterData>>, options: IObjectTreeOptions<T, TFilterData>): ITreeModel<T | null, TFilterData, T | null>;
}
interface ICompressedTreeNodeProvider<T, TFilterData> {
    getCompressedTreeNode(location: T | null): ITreeNode<ICompressedTreeNode<T> | null, TFilterData>;
}
export interface ICompressibleTreeRenderer<T, TFilterData = void, TTemplateData = void> extends ITreeRenderer<T, TFilterData, TTemplateData> {
    renderCompressedElements(node: ITreeNode<ICompressedTreeNode<T>, TFilterData>, index: number, templateData: TTemplateData, height: number | undefined): void;
    disposeCompressedElements?(node: ITreeNode<ICompressedTreeNode<T>, TFilterData>, index: number, templateData: TTemplateData, height: number | undefined): void;
}
export interface ICompressibleKeyboardNavigationLabelProvider<T> extends IKeyboardNavigationLabelProvider<T> {
    getCompressedNodeKeyboardNavigationLabel(elements: T[]): {
        toString(): string | undefined;
    } | undefined;
}
export interface ICompressibleObjectTreeOptions<T, TFilterData = void> extends IObjectTreeOptions<T, TFilterData> {
    readonly compressionEnabled?: boolean;
    readonly elementMapper?: ElementMapper<T>;
    readonly keyboardNavigationLabelProvider?: ICompressibleKeyboardNavigationLabelProvider<T>;
}
export interface ICompressibleObjectTreeOptionsUpdate extends IAbstractTreeOptionsUpdate {
    readonly compressionEnabled?: boolean;
}
export declare class CompressibleObjectTree<T extends NonNullable<any>, TFilterData = void> extends ObjectTree<T, TFilterData> implements ICompressedTreeNodeProvider<T, TFilterData> {
    protected model: CompressibleObjectTreeModel<T, TFilterData>;
    constructor(user: string, container: HTMLElement, delegate: IListVirtualDelegate<T>, renderers: ICompressibleTreeRenderer<T, TFilterData, any>[], options?: ICompressibleObjectTreeOptions<T, TFilterData>);
    setChildren(element: T | null, children?: Iterable<ICompressedTreeElement<T>>): void;
    protected createModel(user: string, view: IList<ITreeNode<T, TFilterData>>, options: ICompressibleObjectTreeOptions<T, TFilterData>): ITreeModel<T | null, TFilterData, T | null>;
    updateOptions(optionsUpdate?: ICompressibleObjectTreeOptionsUpdate): void;
    getCompressedTreeNode(element?: T | null): ITreeNode<ICompressedTreeNode<T> | null, TFilterData>;
}
export {};
