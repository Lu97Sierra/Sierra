/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { CancellationToken } from '../../../base/common/cancellation.js';
import { isUNC } from '../../../base/common/extpath.js';
import { Schemas } from '../../../base/common/network.js';
import { sep } from '../../../base/common/path.js';
import { URI } from '../../../base/common/uri.js';
import { getWebviewContentMimeType } from './mimeTypes.js';
export const webviewPartitionId = 'webview';
export var WebviewResourceResponse;
(function (WebviewResourceResponse) {
    let Type;
    (function (Type) {
        Type[Type["Success"] = 0] = "Success";
        Type[Type["Failed"] = 1] = "Failed";
        Type[Type["AccessDenied"] = 2] = "AccessDenied";
    })(Type = WebviewResourceResponse.Type || (WebviewResourceResponse.Type = {}));
    class StreamSuccess {
        constructor(stream, mimeType) {
            this.stream = stream;
            this.mimeType = mimeType;
            this.type = Type.Success;
        }
    }
    WebviewResourceResponse.StreamSuccess = StreamSuccess;
    WebviewResourceResponse.Failed = { type: Type.Failed };
    WebviewResourceResponse.AccessDenied = { type: Type.AccessDenied };
})(WebviewResourceResponse || (WebviewResourceResponse = {}));
export function loadLocalResource(requestUri, options, fileReader, requestService) {
    return __awaiter(this, void 0, void 0, function* () {
        let resourceToLoad = getResourceToLoad(requestUri, options.roots);
        if (!resourceToLoad) {
            return WebviewResourceResponse.AccessDenied;
        }
        const mime = getWebviewContentMimeType(requestUri); // Use the original path for the mime
        // Perform extra normalization if needed
        if (options.rewriteUri) {
            resourceToLoad = options.rewriteUri(resourceToLoad);
        }
        if (resourceToLoad.scheme === Schemas.http || resourceToLoad.scheme === Schemas.https) {
            const response = yield requestService.request({ url: resourceToLoad.toString(true) }, CancellationToken.None);
            if (response.res.statusCode === 200) {
                return new WebviewResourceResponse.StreamSuccess(response.stream, mime);
            }
            return WebviewResourceResponse.Failed;
        }
        try {
            const contents = yield fileReader.readFileStream(resourceToLoad);
            return new WebviewResourceResponse.StreamSuccess(contents, mime);
        }
        catch (err) {
            console.log(err);
            return WebviewResourceResponse.Failed;
        }
    });
}
function getResourceToLoad(requestUri, roots) {
    const normalizedPath = normalizeRequestPath(requestUri);
    for (const root of roots) {
        if (containsResource(root, normalizedPath)) {
            return normalizedPath;
        }
    }
    return undefined;
}
function normalizeRequestPath(requestUri) {
    if (requestUri.scheme === Schemas.vscodeWebviewResource) {
        // The `vscode-webview-resource` scheme has the following format:
        //
        // vscode-webview-resource://id/scheme//authority?/path
        //
        // Encode requestUri.path so that URI.parse can properly parse special characters like '#', '?', etc.
        const resourceUri = URI.parse(encodeURIComponent(requestUri.path).replace(/%2F/gi, '/').replace(/^\/([a-z0-9\-]+)(\/{1,2})/i, (_, scheme, sep) => {
            if (sep.length === 1) {
                return `${scheme}:///`; // Add empty authority.
            }
            else {
                return `${scheme}://`; // Url has own authority.
            }
        }));
        return resourceUri.with({
            query: requestUri.query,
            fragment: requestUri.fragment
        });
    }
    else {
        return requestUri;
    }
}
function containsResource(root, resource) {
    let rootPath = root.fsPath + (root.fsPath.endsWith(sep) ? '' : sep);
    let resourceFsPath = resource.fsPath;
    if (isUNC(root.fsPath) && isUNC(resource.fsPath)) {
        rootPath = rootPath.toLowerCase();
        resourceFsPath = resourceFsPath.toLowerCase();
    }
    return resourceFsPath.startsWith(rootPath);
}
