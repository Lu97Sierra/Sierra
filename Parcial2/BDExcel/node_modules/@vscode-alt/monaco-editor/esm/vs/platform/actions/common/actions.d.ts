import { Action, SubmenuAction } from '../../../base/common/actions';
import { SyncDescriptor0 } from '../../instantiation/common/descriptors';
import { BrandedService, ServicesAccessor } from '../../instantiation/common/instantiation';
import { IKeybindings, IKeybindingRule } from '../../keybinding/common/keybindingsRegistry';
import { IContextKeyService, ContextKeyExpression } from '../../contextkey/common/contextkey';
import { ICommandService, ICommandHandlerDescription } from '../../commands/common/commands';
import { IDisposable } from '../../../base/common/lifecycle';
import { Event } from '../../../base/common/event';
import { URI } from '../../../base/common/uri';
import { ThemeIcon } from '../../theme/common/themeService';
import { UriDto } from '../../../base/common/types';
export interface ILocalizedString {
    value: string;
    original: string;
}
export declare type Icon = {
    dark?: URI;
    light?: URI;
} | ThemeIcon;
export interface ICommandAction {
    id: string;
    title: string | ILocalizedString;
    category?: string | ILocalizedString;
    tooltip?: string | ILocalizedString;
    icon?: Icon;
    precondition?: ContextKeyExpression;
    toggled?: ContextKeyExpression | {
        condition: ContextKeyExpression;
        icon?: Icon;
        tooltip?: string | ILocalizedString;
    };
}
export declare type ISerializableCommandAction = UriDto<ICommandAction>;
export interface IMenuItem {
    command: ICommandAction;
    alt?: ICommandAction;
    when?: ContextKeyExpression;
    group?: 'navigation' | string;
    order?: number;
}
export interface ISubmenuItem {
    title: string | ILocalizedString;
    submenu: MenuId;
    icon?: Icon;
    when?: ContextKeyExpression;
    group?: 'navigation' | string;
    order?: number;
}
export declare function isIMenuItem(item: IMenuItem | ISubmenuItem): item is IMenuItem;
export declare function isISubmenuItem(item: IMenuItem | ISubmenuItem): item is ISubmenuItem;
export declare class MenuId {
    private static _idPool;
    static readonly CommandPalette: MenuId;
    static readonly DebugBreakpointsContext: MenuId;
    static readonly DebugCallStackContext: MenuId;
    static readonly DebugConsoleContext: MenuId;
    static readonly DebugVariablesContext: MenuId;
    static readonly DebugWatchContext: MenuId;
    static readonly DebugToolBar: MenuId;
    static readonly EditorContext: MenuId;
    static readonly EditorContextPeek: MenuId;
    static readonly EditorTitle: MenuId;
    static readonly EditorTitleContext: MenuId;
    static readonly EmptyEditorGroupContext: MenuId;
    static readonly ExplorerContext: MenuId;
    static readonly ExtensionContext: MenuId;
    static readonly GlobalActivity: MenuId;
    static readonly MenubarAppearanceMenu: MenuId;
    static readonly MenubarDebugMenu: MenuId;
    static readonly MenubarEditMenu: MenuId;
    static readonly MenubarFileMenu: MenuId;
    static readonly MenubarGoMenu: MenuId;
    static readonly MenubarHelpMenu: MenuId;
    static readonly MenubarLayoutMenu: MenuId;
    static readonly MenubarNewBreakpointMenu: MenuId;
    static readonly MenubarPreferencesMenu: MenuId;
    static readonly MenubarRecentMenu: MenuId;
    static readonly MenubarSelectionMenu: MenuId;
    static readonly MenubarSwitchEditorMenu: MenuId;
    static readonly MenubarSwitchGroupMenu: MenuId;
    static readonly MenubarTerminalMenu: MenuId;
    static readonly MenubarViewMenu: MenuId;
    static readonly MenubarHomeMenu: MenuId;
    static readonly OpenEditorsContext: MenuId;
    static readonly ProblemsPanelContext: MenuId;
    static readonly SCMChangeContext: MenuId;
    static readonly SCMResourceContext: MenuId;
    static readonly SCMResourceFolderContext: MenuId;
    static readonly SCMResourceGroupContext: MenuId;
    static readonly SCMSourceControl: MenuId;
    static readonly SCMTitle: MenuId;
    static readonly SearchContext: MenuId;
    static readonly StatusBarWindowIndicatorMenu: MenuId;
    static readonly TouchBarContext: MenuId;
    static readonly TitleBarContext: MenuId;
    static readonly TunnelContext: MenuId;
    static readonly TunnelInline: MenuId;
    static readonly TunnelTitle: MenuId;
    static readonly ViewItemContext: MenuId;
    static readonly ViewContainerTitleContext: MenuId;
    static readonly ViewTitle: MenuId;
    static readonly ViewTitleContext: MenuId;
    static readonly CommentThreadTitle: MenuId;
    static readonly CommentThreadActions: MenuId;
    static readonly CommentTitle: MenuId;
    static readonly CommentActions: MenuId;
    static readonly NotebookCellTitle: MenuId;
    static readonly NotebookCellInsert: MenuId;
    static readonly NotebookCellBetween: MenuId;
    static readonly NotebookCellListTop: MenuId;
    static readonly NotebookDiffCellInputTitle: MenuId;
    static readonly NotebookDiffCellMetadataTitle: MenuId;
    static readonly NotebookDiffCellOutputsTitle: MenuId;
    static readonly BulkEditTitle: MenuId;
    static readonly BulkEditContext: MenuId;
    static readonly TimelineItemContext: MenuId;
    static readonly TimelineTitle: MenuId;
    static readonly TimelineTitleContext: MenuId;
    static readonly AccountsContext: MenuId;
    readonly id: number;
    readonly _debugName: string;
    constructor(debugName: string);
}
export interface IMenuActionOptions {
    arg?: any;
    shouldForwardArgs?: boolean;
}
export interface IMenu extends IDisposable {
    readonly onDidChange: Event<IMenu | undefined>;
    getActions(options?: IMenuActionOptions): [string, Array<MenuItemAction | SubmenuItemAction>][];
}
export declare const IMenuService: import("../../instantiation/common/instantiation").ServiceIdentifier<IMenuService>;
export interface IMenuService {
    readonly _serviceBrand: undefined;
    createMenu(id: MenuId, scopedKeybindingService: IContextKeyService): IMenu;
}
export declare type ICommandsMap = Map<string, ICommandAction>;
export interface IMenuRegistryChangeEvent {
    has(id: MenuId): boolean;
}
export interface IMenuRegistry {
    readonly onDidChangeMenu: Event<IMenuRegistryChangeEvent>;
    addCommands(newCommands: Iterable<ICommandAction>): IDisposable;
    addCommand(userCommand: ICommandAction): IDisposable;
    getCommand(id: string): ICommandAction | undefined;
    getCommands(): ICommandsMap;
    appendMenuItems(items: Iterable<{
        id: MenuId;
        item: IMenuItem | ISubmenuItem;
    }>): IDisposable;
    appendMenuItem(menu: MenuId, item: IMenuItem | ISubmenuItem): IDisposable;
    getMenuItems(loc: MenuId): Array<IMenuItem | ISubmenuItem>;
}
export declare const MenuRegistry: IMenuRegistry;
export declare class ExecuteCommandAction extends Action {
    private readonly _commandService;
    constructor(id: string, label: string, _commandService: ICommandService);
    run(...args: any[]): Promise<any>;
}
export declare class SubmenuItemAction extends SubmenuAction {
    readonly item: ISubmenuItem;
    constructor(item: ISubmenuItem, menuService: IMenuService, contextKeyService: IContextKeyService, options?: IMenuActionOptions);
}
export declare class MenuItemAction extends ExecuteCommandAction {
    readonly item: ICommandAction;
    readonly alt: MenuItemAction | undefined;
    private _options;
    constructor(item: ICommandAction, alt: ICommandAction | undefined, options: IMenuActionOptions, contextKeyService: IContextKeyService, commandService: ICommandService);
    dispose(): void;
    run(...args: any[]): Promise<any>;
}
export declare class SyncActionDescriptor {
    private readonly _descriptor;
    private readonly _id;
    private readonly _label?;
    private readonly _keybindings;
    private readonly _keybindingContext;
    private readonly _keybindingWeight;
    static create<Services extends BrandedService[]>(ctor: {
        new (id: string, label: string, ...services: Services): Action;
    }, id: string, label: string | undefined, keybindings?: IKeybindings, keybindingContext?: ContextKeyExpression, keybindingWeight?: number): SyncActionDescriptor;
    static from<Services extends BrandedService[]>(ctor: {
        new (id: string, label: string, ...services: Services): Action;
        readonly ID: string;
        readonly LABEL: string;
    }, keybindings?: IKeybindings, keybindingContext?: ContextKeyExpression, keybindingWeight?: number): SyncActionDescriptor;
    private constructor();
    get syncDescriptor(): SyncDescriptor0<Action>;
    get id(): string;
    get label(): string | undefined;
    get keybindings(): IKeybindings | undefined;
    get keybindingContext(): ContextKeyExpression | undefined;
    get keybindingWeight(): number | undefined;
}
declare type OneOrN<T> = T | T[];
export interface IAction2Options extends ICommandAction {
    /**
     * Shorthand to add this command to the command palette
     */
    f1?: boolean;
    /**
     * One or many menu items.
     */
    menu?: OneOrN<{
        id: MenuId;
    } & Omit<IMenuItem, 'command'>>;
    /**
     * One keybinding.
     */
    keybinding?: OneOrN<Omit<IKeybindingRule, 'id'>>;
    /**
     * Metadata about this command, used for API commands or when
     * showing keybindings that have no other UX.
     */
    description?: ICommandHandlerDescription;
}
export declare abstract class Action2 {
    readonly desc: Readonly<IAction2Options>;
    constructor(desc: Readonly<IAction2Options>);
    abstract run(accessor: ServicesAccessor, ...args: any[]): any;
}
export declare function registerAction2(ctor: {
    new (): Action2;
}): IDisposable;
export {};
