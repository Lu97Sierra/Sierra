import { Client, PersistentProtocol, ISocket } from '../../../base/parts/ipc/common/ipc.net';
import { RemoteAgentConnectionContext } from './remoteAgentEnvironment';
import { Disposable } from '../../../base/common/lifecycle';
import { ISignService } from '../../sign/common/sign';
import { CancelablePromise } from '../../../base/common/async';
import { ILogService } from '../../log/common/log';
import { IIPCLogger } from '../../../base/parts/ipc/common/ipc';
export declare const enum ConnectionType {
    Management = 1,
    ExtensionHost = 2,
    Tunnel = 3
}
export interface AuthRequest {
    type: 'auth';
    auth: string;
}
export interface SignRequest {
    type: 'sign';
    data: string;
}
export interface ConnectionTypeRequest {
    type: 'connectionType';
    commit?: string;
    signedData?: string;
    desiredConnectionType?: ConnectionType;
    args?: any;
}
export interface ErrorMessage {
    type: 'error';
    reason: string;
}
export interface OKMessage {
    type: 'ok';
}
export declare type HandshakeMessage = AuthRequest | SignRequest | ConnectionTypeRequest | ErrorMessage | OKMessage;
interface ISimpleConnectionOptions {
    commit: string | undefined;
    host: string;
    port: number;
    connectionToken: string | undefined;
    reconnectionToken: string;
    reconnectionProtocol: PersistentProtocol | null;
    socketFactory: ISocketFactory;
    signService: ISignService;
    logService: ILogService;
}
export interface IConnectCallback {
    (err: any | undefined, socket: ISocket | undefined): void;
}
export interface ISocketFactory {
    connect(host: string, port: number, query: string, callback: IConnectCallback): void;
}
export interface IRemoteExtensionHostStartParams {
    language: string;
    debugId?: string;
    break?: boolean;
    port?: number | null;
    env?: {
        [key: string]: string | null;
    };
}
export interface ITunnelConnectionStartParams {
    port: number;
}
export interface IConnectionOptions {
    commit: string | undefined;
    socketFactory: ISocketFactory;
    addressProvider: IAddressProvider;
    signService: ISignService;
    logService: ILogService;
    ipcLogger: IIPCLogger | null;
}
export interface IAddress {
    host: string;
    port: number;
    connectionToken: string | undefined;
}
export interface IAddressProvider {
    getAddress(): Promise<IAddress>;
}
export declare function connectRemoteAgentManagement(options: IConnectionOptions, remoteAuthority: string, clientId: string): Promise<ManagementPersistentConnection>;
export declare function connectRemoteAgentExtensionHost(options: IConnectionOptions, startArguments: IRemoteExtensionHostStartParams): Promise<ExtensionHostPersistentConnection>;
export declare function connectRemoteAgentTunnel(options: IConnectionOptions, tunnelRemotePort: number): Promise<PersistentProtocol>;
export declare const enum PersistentConnectionEventType {
    ConnectionLost = 0,
    ReconnectionWait = 1,
    ReconnectionRunning = 2,
    ReconnectionPermanentFailure = 3,
    ConnectionGain = 4
}
export declare class ConnectionLostEvent {
    readonly type = PersistentConnectionEventType.ConnectionLost;
}
export declare class ReconnectionWaitEvent {
    readonly durationSeconds: number;
    private readonly cancellableTimer;
    readonly type = PersistentConnectionEventType.ReconnectionWait;
    constructor(durationSeconds: number, cancellableTimer: CancelablePromise<void>);
    skipWait(): void;
}
export declare class ReconnectionRunningEvent {
    readonly type = PersistentConnectionEventType.ReconnectionRunning;
}
export declare class ConnectionGainEvent {
    readonly type = PersistentConnectionEventType.ConnectionGain;
}
export declare class ReconnectionPermanentFailureEvent {
    readonly type = PersistentConnectionEventType.ReconnectionPermanentFailure;
}
export declare type PersistentConnectionEvent = ConnectionGainEvent | ConnectionLostEvent | ReconnectionWaitEvent | ReconnectionRunningEvent | ReconnectionPermanentFailureEvent;
declare abstract class PersistentConnection extends Disposable {
    private readonly _connectionType;
    static triggerPermanentFailure(): void;
    private static _permanentFailure;
    private static _instances;
    private readonly _onDidStateChange;
    readonly onDidStateChange: import("../../../base/common/event").Event<PersistentConnectionEvent>;
    protected readonly _options: IConnectionOptions;
    readonly reconnectionToken: string;
    readonly protocol: PersistentProtocol;
    private _isReconnecting;
    constructor(_connectionType: ConnectionType, options: IConnectionOptions, reconnectionToken: string, protocol: PersistentProtocol);
    private _beginReconnecting;
    private _runReconnectingLoop;
    private _gotoPermanentFailure;
    protected abstract _reconnect(options: ISimpleConnectionOptions): Promise<void>;
}
export declare class ManagementPersistentConnection extends PersistentConnection {
    readonly client: Client<RemoteAgentConnectionContext>;
    constructor(options: IConnectionOptions, remoteAuthority: string, clientId: string, reconnectionToken: string, protocol: PersistentProtocol);
    protected _reconnect(options: ISimpleConnectionOptions): Promise<void>;
}
export declare class ExtensionHostPersistentConnection extends PersistentConnection {
    private readonly _startArguments;
    readonly debugPort: number | undefined;
    constructor(options: IConnectionOptions, startArguments: IRemoteExtensionHostStartParams, reconnectionToken: string, protocol: PersistentProtocol, debugPort: number | undefined);
    protected _reconnect(options: ISimpleConnectionOptions): Promise<void>;
}
export {};
