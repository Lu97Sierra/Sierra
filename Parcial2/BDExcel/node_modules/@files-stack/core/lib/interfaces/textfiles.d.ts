import { IDisposable } from '@vscode-alt/monaco-editor/esm/vs/base/common/lifecycle';
import { URI } from '@vscode-alt/monaco-editor/esm/vs/base/common/uri';
import { IFileStatWithMetadata, IResourceEncoding, ITextFileOperationResult, IUpdateDelayedResource, ITextFileStreamContent, ITextFileContent, ITextFilePublishContent, IChangesChunk } from './generated-models';
import { IRevertOptions, ConfirmResult } from '@workbench-stack/core';
import { ITextSnapshot } from '@vscode-alt/monaco-editor/esm/vs/editor/common/model';
import { Event } from '@vscode-alt/monaco-editor/esm/vs/base/common/event';
import { IReadTextFileOptions, IWriteTextFileOptions, ISaveOptions } from './type-redirects';
import { IModelContentChangedEvent } from '@vscode-alt/monaco-editor/esm/vs/editor/common/model/textModelEvents';
export interface ITextFileService extends IDisposable {
    readonly onWillMove: Event<IWillMoveEvent>;
    readonly onAutoSaveConfigurationChange: Event<IAutoSaveConfiguration>;
    readonly onFilesAssociationChange: Event<void>;
    readonly isHotExitEnabled: boolean;
    /**
     * Access to the manager of text file editor models providing further methods to work with them.
     */
    /**
     * Helper to determine encoding for resources.
     */
    readonly encoding: IResourceEncodings;
    /**
     * A resource is dirty if it has unsaved changes or is an untitled file not yet saved.
     *
     * @param resource the resource to check for being dirty. If it is not specified, will check for
     * all dirty resources.
     */
    isDirty(resource?: URI): boolean;
    /**
     * Returns all resources that are currently dirty matching the provided resources or all dirty resources.
     *
     * @param resources the resources to check for being dirty. If it is not specified, will check for
     * all dirty resources.
     */
    getDirty(resources?: URI[]): URI[];
    /**
     * Saves the resource.
     *
     * @param resource the resource to save
     * @param options optional save options
     * @return true if the resource was saved.
     */
    save(resource: URI, versionId: number, options?: ISaveOptions): Promise<boolean>;
    /**
     * Saves the provided resource asking the user for a file name or using the provided one.
     *
     * @param resource the resource to save as.
     * @param targetResource the optional target to save to.
     * @param options optional save options
     * @return Path of the saved resource.
     */
    saveAs(resource: URI, targetResource?: URI, options?: ISaveOptions): Promise<URI | undefined>;
    /**
     * Saves the set of resources and returns a promise with the operation result.
     *
     * @param resources can be null to save all.
     * @param includeUntitled to save all resources and optionally exclude untitled ones.
     */
    saveAll(includeUntitled?: boolean, options?: ISaveOptions): Promise<ITextFileOperationResult>;
    saveAll(resources: URI[], options?: ISaveOptions): Promise<ITextFileOperationResult>;
    /**
     * Reverts the provided resource.
     *
     * @param resource the resource of the file to revert.
     * @param force to force revert even when the file is not dirty
     */
    revert(resource: URI, options?: IRevertOptions): Promise<boolean>;
    /**
     * Reverts all the provided resources and returns a promise with the operation result.
     */
    revertAll(resources?: URI[], options?: IRevertOptions): Promise<ITextFileOperationResult>;
    /**
     * Create a file. If the file exists it will be overwritten with the contents if
     * the options enable to overwrite.
     */
    create(resource: URI, contents?: string | ITextSnapshot, options?: {
        overwrite?: boolean;
    }): Promise<IFileStatWithMetadata>;
    /**
     * Read the contents of a file identified by the resource.
     */
    read(resource: URI, options?: IReadTextFileOptions): Promise<ITextFileContent>;
    /**
     * Read the contents of a file identified by the resource as stream.
     */
    readStream(resource: URI, options?: IReadTextFileOptions): Promise<ITextFileStreamContent>;
    /**
     * Update a file with given contents.
     */
    write(resource: URI, value: string | ITextSnapshot, options?: IWriteTextFileOptions): Promise<IFileStatWithMetadata>;
    /**
     * Delete a file. If the file is dirty, it will get reverted and then deleted from disk.
     */
    delete(resource: URI, options?: {
        useTrash?: boolean;
        recursive?: boolean;
    }): Promise<void>;
    /**
     * Move a file. If the file is dirty, its contents will be preserved and restored.
     */
    move(source: URI, target: URI, overwrite?: boolean): Promise<IFileStatWithMetadata>;
    /**
     * Brings up the confirm dialog to either save, don't save or cancel.
     *
     * @param resources the resources of the files to ask for confirmation or null if
     * confirming for all dirty resources.
     */
    confirmSave(resources?: URI[]): Promise<ConfirmResult>;
    /**
     * Convinient fast access to the current auto save mode.
     */
    getAutoSaveMode(): AutoSaveMode;
    /**
     * Convinient fast access to the raw configured auto save settings.
     */
    getAutoSaveConfiguration(): IAutoSaveConfiguration;
}
export interface ICustomTextFileService extends Pick<ITextFileService, 'create' | 'delete' | 'move' | 'dispose'>, INodeTextFileService {
    /**
     *
     * @custom DataSource to connect external resources
     * @param {*} dataSource
     * @returns {ICustomTextFileService}
     * @memberof ICustomTextFileService
     */
    setDataCache?(cachedService: ICacheTextFileService): ICustomTextFileService;
    readonly encoding: Promise<IResourceEncodings> | any;
    /**
     * @custom
     * Updates the file based on the chunks received
     */
    writeChunk(resource: URI, chunks: IChangesChunk[], options?: IWriteTextFileOptions): Promise<IFileStatWithMetadata>;
    /**
     * @custom
     * Updates the file based on the chunks received after some delay.
     */
    writeChunkWithDelay(resource: URI, chunks: IChangesChunk[], options?: IWriteTextFileOptions): Promise<IUpdateDelayedResource>;
    /**
     *
     * @custom Write to based implemented class
     * @param {URI} resource
     * @param {(string | ITextSnapshot)} value
     * @param {IWriteTextFileOptions} [options]
     * @returns {Promise<IFileStatWithMetadata>}
     * @memberof ICustomTextFileService
     */
    writeStream(resource: URI, value: string | ITextSnapshot, options?: IWriteTextFileOptions): Promise<IFileStatWithMetadata>;
}
export interface ICacheTextFileService {
    readCache?(resource: URI, options?: IReadTextFileOptions): Promise<ITextFileContent>;
    writeCache?(resource: URI, value: string | ITextSnapshot, options?: IWriteTextFileOptions): Promise<IFileStatWithMetadata>;
    deleteCache?(resource: URI, options?: {
        useTrash?: boolean;
        recursive?: boolean;
    }): any;
}
export interface INodeTextFileService extends Pick<ITextFileService, 'read' | 'readStream' | 'write'> {
    /**
     * Read the contents of a file identified by the resource as string stream.
     */
    readStringStream(resource: URI, options?: IReadTextFileOptions): Promise<ITextFilePublishContent>;
    /**
     * Update a file with given contents.
     */
    write(resource: URI, value: string | ITextSnapshot, options?: IWriteTextFileOptions): Promise<IFileStatWithMetadata>;
}
/**
 * TextFile content resolution and changes.
 *
 * @export
 * @interface IClientTextFileContent
 */
export interface IClientTextFileContent {
    removeChangedContent(resource: URI, reset: boolean): boolean;
    updateChangedContent(resource: URI, changedEvent: IModelContentChangedEvent): boolean;
    updateFileDirtyState(resource: URI, isFileDirty: boolean): boolean;
}
export interface IClientTextFileService extends IClientTextFileContent, Pick<ITextFileService, 'read' | 'write' | 'save' | 'saveAs' | 'saveAll' | 'revert' | 'revertAll' | 'isDirty' | 'getDirty'> {
}
/**
 * States the text file editor model can be in.
 */
export declare enum ModelState {
    SAVED = 0,
    DIRTY = 1,
    PENDING_SAVE = 2,
    /**
     * A model is in conflict mode when changes cannot be saved because the
     * underlying file has changed. Models in conflict mode are always dirty.
     */
    CONFLICT = 3,
    /**
     * A model is in orphan state when the underlying file has been deleted.
     */
    ORPHAN = 4,
    /**
     * Any error that happens during a save that is not causing the CONFLICT state.
     * Models in error mode are always diry.
     */
    ERROR = 5
}
export declare const enum StateChange {
    DIRTY = 0,
    SAVING = 1,
    SAVE_ERROR = 2,
    SAVED = 3,
    REVERTED = 4,
    ENCODING = 5,
    CONTENT_CHANGE = 6,
    ORPHANED_CHANGE = 7
}
export interface IAutoSaveConfiguration {
    autoSaveDelay: number;
    autoSaveFocusChange: boolean;
    autoSaveApplicationChange: boolean;
}
export declare const enum AutoSaveMode {
    OFF = 0,
    AFTER_SHORT_DELAY = 1,
    AFTER_LONG_DELAY = 2,
    ON_FOCUS_CHANGE = 3,
    ON_WINDOW_CHANGE = 4
}
export declare enum SaveReason {
    EXPLICIT = 1,
    AUTO = 2,
    FOCUS_CHANGE = 3,
    WINDOW_CHANGE = 4
}
export declare enum LoadReason {
    EDITOR = 1,
    REFERENCE = 2,
    OTHER = 3
}
export interface IWillMoveEvent {
    oldResource: URI;
    newResource: URI;
    waitUntil(p: Promise<unknown>): void;
}
export interface IResourceEncodings {
    getPreferredWriteEncoding(resource: URI, preferredEncoding?: string): IResourceEncoding;
}
export declare enum FileContentStatus {
    PENDING = "PENDING",
    START = "START",
    IN_PROGRESS = "IN-PROGRESS",
    END = "END",
    ERROR = "ERROR",
    RESTORE = "RESTORE"
}
