{"version":3,"file":"index.min.js","sources":["../src/util.js","../src/logger.js"],"sourcesContent":["export const CALL_STACK_ERROR = 'call-stack-error';\n\n/**\n * A shallow copy of an object. Bunyan logging attempts to never cause\n * exceptions, so this function attempts to handle non-objects gracefully.\n */\nexport function objCopy(obj) {\n    if (typeof  obj === 'undefined' || obj ===  null) {  // null or undefined\n        return obj;\n    } else if (Array.isArray(obj)) {\n        return obj.slice();\n    } else if (typeof (obj) === 'object') {\n        const copy = {};\n        Object.keys(obj).forEach(function (k) {\n            copy[k] = obj[k];\n        });\n        return copy;\n    } else {\n        return obj;\n    }\n}\n\n//---- These are simplified versions of util.format without importing the whole module, which would be bulky when browserified\n\nexport function inspect(obj) {\n    if(typeof obj === 'undefined') {\n        return 'undefined';\n    }\n    if(obj === null) {\n        return 'null';\n    }\n    if(Array.isArray(obj)) {\n        const items = obj.map(obj => inspect(obj));\n        return '[ ' + items.join(', ') + ' ]';\n    }\n    if(typeof obj === 'object') {\n        return JSON.stringify(obj);\n    }\n    if(typeof obj === 'function') {\n        return '[Function: ' + obj.name + ']';\n    }\n    if(typeof obj === 'boolean' || typeof obj === 'number') {\n        return obj;\n    }\n    return '\\'' + obj.toString() + '\\'';\n}\n\nexport function format(f) {\n    if (typeof f !== 'string') {\n        const objects = new Array(arguments.length);\n        for (let i = 0; i < arguments.length; i++) {\n            objects[i] = inspect(arguments[i]);\n        }\n        return objects.join(' ');\n    }\n\n    const formatRegExp = /%[sdj%]/g;\n\n    let i = 1;\n    const args = arguments;\n    const len = args.length;\n    let str = String(f).replace(formatRegExp, x => {\n        if (x === '%%') {\n            return '%';\n        }\n        if (i >= len) {\n            return x;\n        }\n        switch (x) {\n        case '%s': return String(args[i++]);\n        case '%d': return Number(args[i++]);\n        case '%j':\n            try {\n                return JSON.stringify(args[i++]);\n            } catch (_) {\n                return '[Circular]';\n            }\n        default:\n            return x;\n        }\n    });\n    for (let x = args[i]; i < len; x = args[++i]) {\n        if (x === null || typeof (x) !== 'object') {\n            str += ' ' + x;\n        } else {\n            str += ' ' + inspect(x);\n        }\n    }\n    return str;\n}\n\nexport function extractSrcFromStacktrace(stack, level) {\n    const stackLines = stack.split('\\n');\n\n    //chrome starts with error\n    if(stackLines[0] && stackLines[0].indexOf(CALL_STACK_ERROR) >= 0) {\n        stackLines.shift();\n    }\n\n    //the line of the stacktrace\n    const targetLine = stackLines[level];\n    let lineInfo = null;\n    if(targetLine) {\n        const execResult = /^\\s*(at|.*@)\\s*(.+)?$/.exec(targetLine);\n        if(Array.isArray(execResult) && execResult[2]) {\n            lineInfo = execResult[2];\n        } else {\n            lineInfo = targetLine;\n        }\n    }\n    return lineInfo;\n}\n\nexport function _indent(s, indent) {\n    if (!indent) {\n        indent = '    ';\n    }\n    const lines = s.split(/\\r?\\n/g);\n    return indent + lines.join('\\n' + indent);\n}\n\nconst _warned = {};\n\n/**\n * Warn about an bunyan processing error.\n *\n * @param msg {String} Message with which to warn.\n * @param dedupKey {String} Optional. A short string key for this warning to\n *      have its warning only printed once.\n */\nexport function _warn(msg, dedupKey) {\n    if (dedupKey) {\n        if (_warned[dedupKey]) {\n            return;\n        }\n        _warned[dedupKey] = true;\n    }\n    console.error(msg + '\\n');\n}\nexport function _haveWarned(dedupKey) {\n    return _warned[dedupKey];\n}\n\n// A JSON stringifier that handles cycles safely.\n// Usage: JSON.stringify(obj, safeCycles())\nexport function safeCycles() {\n    const seen = [];\n    return (key, val) => {\n        if (!val || typeof (val) !== 'object') {\n            return val;\n        }\n        if (seen.indexOf(val) !== -1) {\n            return '[Circular]';\n        }\n        seen.push(val);\n        return val;\n    };\n}","import { TRACE, DEBUG, INFO, WARN, ERROR, FATAL, nameFromLevel, resolveLevel} from '@browser-bunyan/levels';\nimport { format, _haveWarned, _warn, extractSrcFromStacktrace, _indent, objCopy, safeCycles, CALL_STACK_ERROR } from './util';\nimport { ConsoleRawStream } from '@browser-bunyan/console-raw-stream';\n\nconst LOG_VERSION = 1;\n\n//---- Logger class\n\n/**\n * Create a Logger instance.\n *\n * @param options {Object} See documentation for full details. At minimum\n *    this must include a 'name' string key. Configuration keys:\n *      - `streams`: specify the logger output streams. This is an array of\n *        objects with these fields:\n *          - `type`: The stream type. See README.md for full details.\n *            Often this is implied by the other fields. Examples are\n *            'file', 'stream' and \"raw\".\n *          - `level`: Defaults to 'info'.\n *          - `path` or `stream`: The specify the file path or writeable\n *            stream to which log records are written. E.g.\n *            `stream: process.stdout`.\n *        See README.md for full details.\n *      - `level`: set the level for a single output stream (cannot be used\n *        with `streams`)\n *      - `stream`: the output stream for a logger with just one, e.g.\n *        `process.stdout` (cannot be used with `streams`)\n *      - `serializers`: object mapping log record field names to\n *        serializing functions. See README.md for details.\n *      - `src`: Boolean (default false). Set true to enable 'src' automatic\n *        field with log call source info.\n *    All other keys are log record fields.\n *\n * An alternative *internal* call signature is used for creating a child:\n *    new Logger(<parent logger>, <child options>[, <child opts are simple>]);\n *\n * @param _childSimple (Boolean) An assertion that the given `_childOptions`\n *    (a) only add fields (no config) and (b) no serialization handling is\n *    required for them. IOW, this is a fast path for frequent child\n *    creation.\n */\nclass Logger {\n    constructor(options, _childOptions, _childSimple) {\n        if (!(this instanceof Logger)) {\n            return new Logger(options, _childOptions);\n        }\n\n        // Input arg validation.\n        let parent;\n        if (_childOptions !== undefined) {\n            parent = options;\n            options = _childOptions;\n            if (!(parent instanceof Logger)) {\n                throw new TypeError('invalid Logger creation: do not pass a second arg');\n            }\n        }\n        if (!options) {\n            throw new TypeError('options (object) is required');\n        }\n        if (!parent) {\n            if (!options.name) {\n                throw new TypeError('options.name (string) is required');\n            }\n        } else {\n            if (options.name) {\n                throw new TypeError('invalid options.name: child cannot set logger name');\n            }\n        }\n        if (options.stream && options.streams) {\n            throw new TypeError('cannot mix \"streams\" and \"stream\" options');\n        }\n        if (options.streams && !Array.isArray(options.streams)) {\n            throw new TypeError('invalid options.streams: must be an array');\n        }\n        if (options.serializers && (typeof (options.serializers) !== 'object' || Array.isArray(options.serializers))) {\n            throw new TypeError('invalid options.serializers: must be an object');\n        }\n\n        let fields, name, i;\n\n        // Fast path for simple child creation.\n        if (parent && _childSimple) {\n            this._level = parent._level;\n            this.streams = parent.streams;\n            this.serializers = parent.serializers;\n            this.src = parent.src;\n            fields = this.fields = {};\n            const parentFieldNames = Object.keys(parent.fields);\n            for (i = 0; i < parentFieldNames.length; i++) {\n                name = parentFieldNames[i];\n                fields[name] = parent.fields[name];\n            }\n            const names = Object.keys(options);\n            for (i = 0; i < names.length; i++) {\n                name = names[i];\n                fields[name] = options[name];\n            }\n            return;\n        }\n\n        // Null values.\n        if (parent) {\n            this._level = parent._level;\n            this.streams = [];\n            for (i = 0; i < parent.streams.length; i++) {\n                const s = objCopy(parent.streams[i]);\n                this.streams.push(s);\n            }\n            this.serializers = objCopy(parent.serializers);\n            this.src = parent.src;\n            this.fields = objCopy(parent.fields);\n            if (options.level) {\n                this.level(options.level);\n            }\n        } else {\n            this._level = Number.POSITIVE_INFINITY;\n            this.streams = [];\n            this.serializers = null;\n            this.src = false;\n            this.fields = {};\n        }\n\n        // Handle *config* options (i.e. options that are not just plain data\n        // for log records).\n        if (options.stream) {\n            this.addStream({\n                type: 'stream',\n                stream: options.stream,\n                level: options.level,\n            });\n        } else if (options.streams) {\n            options.streams.forEach(s => {\n                this.addStream(s, options.level);\n            });\n        } else if (parent && options.level) {\n            this.level(options.level);\n        } else if (!parent) {\n            /*\n             * In the browser we'll be emitting to console.log by default.\n             * Any console.log worth its salt these days can nicely render\n             * and introspect objects (e.g. the Firefox and Chrome console)\n             * so let's emit the raw log record. Are there browsers for which\n             * that breaks things?\n             */\n            this.addStream({\n                type: 'raw',\n                stream: new ConsoleRawStream(),\n                level: options.level,\n            });\n        }\n        if (options.serializers) {\n            this.addSerializers(options.serializers);\n        }\n        if (options.src) {\n            this.src = true;\n        }\n\n        // Fields.\n        // These are the default fields for log records (minus the attributes\n        // removed in this constructor). To allow storing raw log records\n        // (unrendered), `this.fields` must never be mutated. Create a copy for\n        // any changes.\n        fields = objCopy(options);\n        delete fields.stream;\n        delete fields.level;\n        delete fields.streams;\n        delete fields.serializers;\n        delete fields.src;\n        if (this.serializers) {\n            this._applySerializers(fields);\n        }\n        Object.keys(fields).forEach(k => {\n            this.fields[k] = fields[k];\n        });\n    }\n\n    /**\n     * Add a stream\n     *\n     * @param stream {Object}. Object with these fields:\n     *    - `type`: The stream type. See README.md for full details.\n     *      Often this is implied by the other fields. Examples are\n     *      'file', 'stream' and \"raw\".\n     *    - `path` or `stream`: The specify the file path or writeable\n     *      stream to which log records are written. E.g.\n     *      `stream: process.stdout`.\n     *    - `level`: Optional. Falls back to `defaultLevel`.\n     *    See README.md for full details.\n     * @param defaultLevel {Number|String} Optional. A level to use if\n     *      `stream.level` is not set. If neither is given, this defaults to INFO.\n     */\n    addStream(s, defaultLevel = INFO) {\n        s = objCopy(s);\n\n        //in browser bunyan, streams are always raw\n        s.type = 'raw';\n        s.level = resolveLevel(s.level || defaultLevel);\n\n        if (s.level < this._level) {\n            this._level = s.level;\n        }\n\n        this.streams.push(s);\n        delete this.haveNonRawStreams;  // reset\n    }\n\n    /**\n     * Add serializers\n     *\n     * @param serializers {Object} Optional. Object mapping log record field names\n     *    to serializing functions. See README.md for details.\n     */\n    addSerializers(serializers) {\n        if (!this.serializers) {\n            this.serializers = {};\n        }\n        Object.keys(serializers).forEach(field => {\n            const serializer = serializers[field];\n            if (typeof (serializer) !== 'function') {\n                throw new TypeError(format('invalid serializer for \"%s\" field: must be a function', field));\n            }\n            this.serializers[field] = serializer;\n        });\n    }\n\n    /**\n     * Create a child logger, typically to add a few log record fields.\n     *\n     * This can be useful when passing a logger to a sub-component, e.g. a\n     * 'wuzzle' component of your service:\n     *\n     *    const wuzzleLog = log.child({component: 'wuzzle'})\n     *    const wuzzle = new Wuzzle({..., log: wuzzleLog})\n     *\n     * Then log records from the wuzzle code will have the same structure as\n     * the app log, *plus the component='wuzzle' field*.\n     *\n     * @param options {Object} Optional. Set of options to apply to the child.\n     *    All of the same options for a new Logger apply here. Notes:\n     *      - The parent's streams are inherited and cannot be removed in this\n     *        call. Any given `streams` are *added* to the set inherited from\n     *        the parent.\n     *      - The parent's serializers are inherited, though can effectively be\n     *        overwritten by using duplicate keys.\n     *      - Can use `level` to set the level of the streams inherited from\n     *        the parent. The level for the parent is NOT affected.\n     * @param simple {Boolean} Optional. Set to true to assert that `options`\n     *    (a) only add fields (no config) and (b) no serialization handling is\n     *    required for them. IOW, this is a fast path for frequent child\n     *    creation. See 'tools/timechild.js' for numbers.\n     */\n    child(options, simple) {\n        return new (this.constructor)(this, options || {}, simple);\n    }\n\n    /**\n     * Get/set the level of all streams on this logger.\n     *\n     * Get Usage:\n     *    // Returns the current log level (lowest level of all its streams).\n     *    log.level() -> INFO\n     *\n     * Set Usage:\n     *    log.level(INFO)       // set all streams to level INFO\n     *    log.level('info')     // can use 'info' et al aliases\n     */\n    level(value) {\n        if (value === undefined) {\n            return this._level;\n        }\n        const newLevel = resolveLevel(value);\n        const len = this.streams.length;\n        for (let i = 0; i < len; i++) {\n            this.streams[i].level = newLevel;\n        }\n        this._level = newLevel;\n    }\n\n    /**\n     * Get/set the level of a particular stream on this logger.\n     *\n     * Get Usage:\n     *    // Returns an array of the levels of each stream.\n     *    log.levels() -> [TRACE, INFO]\n     *\n     *    // Returns a level of the identified stream.\n     *    log.levels(0) -> TRACE      // level of stream at index 0\n     *    log.levels('foo')           // level of stream with name 'foo'\n     *\n     * Set Usage:\n     *    log.levels(0, INFO)         // set level of stream 0 to INFO\n     *    log.levels(0, 'info')       // can use 'info' et al aliases\n     *    log.levels('foo', WARN)     // set stream named 'foo' to WARN\n     *\n     * Stream names: When streams are defined, they can optionally be given\n     * a name. For example,\n     *       log = new Logger({\n     *         streams: [\n     *           {\n     *             name: 'foo',\n     *             path: '/const/log/my-service/foo.log'\n     *             level: 'trace'\n     *           },\n     *         ...\n     *\n     * @param name {String|Number} The stream index or name.\n     * @param value {Number|String} The level value (INFO) or alias ('info').\n     *    If not given, this is a 'get' operation.\n     * @throws {Error} If there is no stream with the given name.\n     */\n    levels(name, value) {\n        if (name === undefined) {\n            return this.streams.map(s => s.level);\n        }\n        let stream;\n        if (typeof (name) === 'number') {\n            stream = this.streams[name];\n            if (stream === undefined) {\n                throw new Error('invalid stream index: ' + name);\n            }\n        } else {\n            const len = this.streams.length;\n            for (let i = 0; i < len; i++) {\n                const s = this.streams[i];\n                if (s.name === name) {\n                    stream = s;\n                    break;\n                }\n            }\n            if (!stream) {\n                throw new Error(format('no stream with name \"%s\"', name));\n            }\n        }\n        if (value === undefined) {\n            return stream.level;\n        } else {\n            const newLevel = resolveLevel(value);\n            stream.level = newLevel;\n            if (newLevel < this._level) {\n                this._level = newLevel;\n            }\n        }\n    }\n\n    /**\n     * Apply registered serializers to the appropriate keys in the given fields.\n     *\n     * Pre-condition: This is only called if there is at least one serializer.\n     *\n     * @param fields (Object) The log record fields.\n     * @param excludeFields (Object) Optional mapping of keys to `true` for\n     *    keys to NOT apply a serializer.\n     */\n    _applySerializers(fields, excludeFields) {\n        // Check each serializer against these (presuming number of serializers\n        // is typically less than number of fields).\n        Object.keys(this.serializers).forEach(name => {\n            if (fields[name] === undefined || (excludeFields && excludeFields[name])) {\n                return;\n            }\n            try {\n                fields[name] = this.serializers[name](fields[name]);\n            } catch (err) {\n                _warn(format('bunyan: ERROR: Exception thrown from the \"%s\" ' +\n                    'Bunyan serializer. This should never happen. This is a bug' +\n                    'in that serializer function.\\n%s',\n                name, err.stack || err));\n                fields[name] = format('(Error in Bunyan log \"%s\" serializer broke field. See stderr for details.)', name);\n            }\n        });\n    }\n\n    /**\n     * Emit a log record.\n     *\n     * @param rec {log record}\n     * @param noemit {Boolean} Optional. Set to true to skip emission\n     *      and just return the JSON string.\n     */\n    _emit(rec, noemit) {\n        let i;\n\n        // Lazily determine if this Logger has non-'raw' streams. If there are\n        // any, then we need to stringify the log record.\n        if (this.haveNonRawStreams === undefined) {\n            this.haveNonRawStreams = false;\n            for (i = 0; i < this.streams.length; i++) {\n                if (!this.streams[i].raw) {\n                    this.haveNonRawStreams = true;\n                    break;\n                }\n            }\n        }\n\n        // Stringify the object. Attempt to warn/recover on error.\n        let str;\n        if (noemit || this.haveNonRawStreams) {\n            try {\n                str = JSON.stringify(rec, safeCycles()) + '\\n';\n            } catch (e) {\n                const dedupKey = e.stack.split(/\\n/g, 2).join('\\n');\n                _warn('bunyan: ERROR: Exception in ' +\n                    '`JSON.stringify(rec)`. You can install the ' +\n                    '\"safe-json-stringify\" module to have Bunyan fallback ' +\n                    'to safer stringification. Record:\\n' +\n                    _indent(format('%s\\n%s', rec, e.stack)),\n                dedupKey);\n                str = format('(Exception in JSON.stringify(rec): %j. See stderr for details.)\\n', e.message);\n            }\n        }\n\n        if (noemit) {\n            return str;\n        }\n\n        const level = rec.level;\n        for (i = 0; i < this.streams.length; i++) {\n            const s = this.streams[i];\n            if (s.level <= level) {\n                s.stream.write(rec);\n            }\n        }\n\n        return str;\n    }\n}\n\n/**\n * Build a log emitter function for level minLevel. I.e. this is the\n * creator of `log.info`, `log.error`, etc.\n */\nfunction mkLogEmitter(minLevel) {\n    return function () {\n        const log = this;\n\n        function mkRecord(args) {\n            let excludeFields;\n            if (args[0] instanceof Error) {\n                // `log.<level>(err, ...)`\n                fields = {\n                    // Use this Logger's err serializer, if defined.\n                    err: (log.serializers && log.serializers.err ? log.serializers.err(args[0]) : stdSerializers.err(args[0])),\n                };\n                excludeFields = {err: true};\n                if (args.length === 1) {\n                    msgArgs = [fields.err.message];\n                } else {\n                    msgArgs = Array.prototype.slice.call(args, 1);\n                }\n            } else if (typeof (args[0]) !== 'object' && args[0] !== null || Array.isArray(args[0])) {\n                // `log.<level>(msg, ...)`\n                fields = null;\n                msgArgs = Array.prototype.slice.call(args);\n            } else {\n                // `log.<level>(fields, msg, ...)`\n                fields = args[0];\n                if (args.length === 1 && fields.err && fields.err instanceof Error) {\n                    msgArgs = [fields.err.message];\n                } else {\n                    msgArgs = Array.prototype.slice.call(args, 1);\n                }\n            }\n\n            // Build up the record object.\n            const rec = objCopy(log.fields);\n            rec.level = minLevel;\n            const recFields = (fields ? objCopy(fields) : null);\n            if (recFields) {\n                if (log.serializers) {\n                    log._applySerializers(recFields, excludeFields);\n                }\n                Object.keys(recFields).forEach(k => {\n                    rec[k] = recFields[k];\n                });\n            }\n            rec.levelName = nameFromLevel[minLevel];\n            rec.msg = msgArgs.length ? format.apply(log, msgArgs) : '';\n            if (!rec.time) {\n                rec.time = (new Date());\n            }\n            // Get call source info\n            if (log.src && !rec.src) {\n                try {\n                    //need to throw the error so there is a stack in IE\n                    throw new Error(CALL_STACK_ERROR);\n                } catch (err) {\n                    // in Safari there is missing stack trace sometimes\n                    const src = err.stack ? extractSrcFromStacktrace(err.stack, 2) : '';\n                    if (!src && !_haveWarned('src')) {\n                        _warn('Unable to determine src line info', 'src');\n                    }\n                    rec.src = src || '';\n                }\n            }\n            rec.v = LOG_VERSION;\n            return rec;\n        }\n\n        let fields = null;\n        let msgArgs = arguments;\n        let rec = null;\n        if (arguments.length === 0) {   // `log.<level>()`\n            return (this._level <= minLevel);\n        } else if (this._level > minLevel) {\n            /* pass through */\n        } else {\n            rec = mkRecord(msgArgs);\n            this._emit(rec);\n        }\n    };\n}\n\n/**\n * The functions below log a record at a specific level.\n *\n * Usages:\n *    log.<level>()  -> boolean is-trace-enabled\n *    log.<level>(<Error> err, [<string> msg, ...])\n *    log.<level>(<string> msg, ...)\n *    log.<level>(<object> fields, <string> msg, ...)\n *\n * where <level> is the lowercase version of the log level. E.g.:\n *\n *    log.info()\n *\n * @params fields {Object} Optional set of additional fields to log.\n * @params msg {String} Log message. This can be followed by additional\n *    arguments that are handled like\n *    [util.format](http://nodejs.org/docs/latest/api/all.html#util.format).\n */\nLogger.prototype.trace = mkLogEmitter(TRACE);\nLogger.prototype.debug = mkLogEmitter(DEBUG);\nLogger.prototype.info = mkLogEmitter(INFO);\nLogger.prototype.warn = mkLogEmitter(WARN);\nLogger.prototype.error = mkLogEmitter(ERROR);\nLogger.prototype.fatal = mkLogEmitter(FATAL);\n\n/*\n * This function dumps long stack traces for exceptions having a cause()\n * method. The error classes from\n * [verror](https://github.com/davepacheco/node-verror) and\n * [restify v2.0](https://github.com/mcavage/node-restify) are examples.\n *\n * Based on `dumpException` in\n * https://github.com/davepacheco/node-extsprintf/blob/master/lib/extsprintf.js\n */\nfunction getFullErrorStack(ex) {\n    let ret = ex.stack || ex.toString();\n    if (ex.cause && typeof (ex.cause) === 'function') {\n        const cex = ex.cause();\n        if (cex) {\n            ret += '\\nCaused by: ' + getFullErrorStack(cex);\n        }\n    }\n    return (ret);\n}\n\n//---- Standard serializers\n// A serializer is a function that serializes a JavaScript object to a\n// JSON representation for logging. There is a standard set of presumed\n// interesting objects in node.js-land.\nexport const stdSerializers = {\n    // Serialize an Error object\n    // (Core error properties are enumerable in node 0.4, not in 0.6).\n    err: function(err) {\n        if (!err || !err.stack) {\n            return err;\n        }\n\n        return {\n            message: err.message,\n            name: err.name,\n            stack: getFullErrorStack(err),\n            code: err.code,\n            signal: err.signal,\n        };\n    },\n};\n\nexport { Logger };\n\nexport function createLogger(...args) {\n    return new Logger(...args);\n}\n"],"names":["CALL_STACK_ERROR","objCopy","obj","Array","isArray","slice","copy","Object","keys","forEach","k","inspect","map","join","JSON","stringify","name","toString","format","f","objects","arguments","length","i","formatRegExp","args","len","str","String","replace","x","Number","_","extractSrcFromStacktrace","stack","level","stackLines","split","indexOf","shift","targetLine","lineInfo","execResult","exec","_warned","_warn","msg","dedupKey","console","error","_haveWarned","safeCycles","seen","key","val","push","Logger","options","_childOptions","_childSimple","parent","fields","this","undefined","TypeError","stream","streams","serializers","_level","src","parentFieldNames","names","s","POSITIVE_INFINITY","addStream","type","_this","ConsoleRawStream","addSerializers","_applySerializers","defaultLevel","INFO","resolveLevel","haveNonRawStreams","field","serializer","_this2","child","simple","constructor","value","newLevel","levels","Error","excludeFields","_this3","err","_emit","rec","noemit","raw","e","indent","_indent","message","write","mkLogEmitter","minLevel","log","mkRecord","stdSerializers","msgArgs","prototype","call","recFields","levelName","nameFromLevel","apply","time","Date","v","getFullErrorStack","ex","ret","cause","cex","trace","TRACE","debug","DEBUG","info","warn","WARN","ERROR","fatal","FATAL","code","signal"],"mappings":"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"}