// import { injectable, inject, postConstruct } from 'inversify';
// import { IConfigurationService } from '@vscode-alt/monaco-editor/esm/vs/platform/configuration/common/configuration';
// import { IDisposable, Disposable } from '@vscode-alt/monaco-editor/esm/vs/base/common/lifecycle';
// import * as core from '@workbench-stack/core';
// import { ApolloClient } from 'apollo-client';
// import { ClientTypes } from '@common-stack/client-core';
// import { Event, Emitter } from '@vscode-alt/monaco-editor/esm/vs/base/common/event';
// import { IConfigurationChangeEvent, ConfigurationTarget, ConfigurationChangeEvent } from '@workbench-stack/core';
// @injectable()
// export class ConfigurationRemoteService extends Disposable implements core.IClientConfigurationService, IDisposable {
//     constructor(
//         @inject(core.ClientTypes.ILifecycleService)
//         private lifecycleService: core.ILifecycleService,
//         @inject(ClientTypes.ApolloClient)
//         private apollo: ApolloClient<any>,
//         @inject(ClientTypes.UtilityClass)
//         private utility,
//     ) {
//         super();
//     }
//     private readonly _onDidChangeConfiguration: Emitter<IConfigurationChangeEvent> = this._register(new Emitter<IConfigurationChangeEvent>());
//     public readonly onDidChangeConfiguration: Event<IConfigurationChangeEvent> = this._onDidChangeConfiguration.event;
//     get configuration() {
//         const id = this.utility.getCacheKey({ __typename: core.CacheTypenames.Configuration });
//         const result = this.apollo.readFragment<core.IFinalConfigurationFragment>({
//             fragment: core.FinalConfigurationFragmentDoc,
//             fragmentName: 'FinalConfiguration',
//             id,
//         });
//         return result;
//     }
//     public getValue<T>(): T;
//     public getValue<T>(section: string): T;
//     public getValue<T>(overrides: core.IConfigurationOverrides): T;
//     public getValue<T>(section: string, overrides: core.IConfigurationOverrides): T;
//     public getValue(arg1?: any, arg2?: any): any {
//         const section = typeof arg1 === 'string' ? arg1 : undefined;
//         const overrides = core.isConfigurationOverrides(arg1) ? arg1 : core.isConfigurationOverrides(arg2) ? arg2 : {};
//         // return this.configuration.getValue(section, overrides, undefined);
//         return core.getConfigurationValue(this.configuration, section, overrides);
//     }
//     public updateValue(key: string, value: any): Promise<void>;
//     public updateValue(key: string, value: any, overrides: core.IConfigurationOverrides): Promise<void>;
//     public updateValue(key: string, value: any, target: core.ConfigurationTarget): Promise<void>;
//     public updateValue(key: string, value: any, overrides: core.IConfigurationOverrides, target: core.ConfigurationTarget): Promise<void>;
//     public updateValue(key: string, value: any, arg3?: any, arg4?: any): Promise<void> {
//         return Promise.reject(new Error('not supported'));
//     }
//     public reloadConfiguration(folder?: core.IWorkspaceFolder): Promise<void> {
//         return Promise.resolve(undefined);
//     }
//     public updateConfigurationChange(event: IConfigurationChangeEvent) {
//         const id = this.utility.getCacheKey({ __typename: core.CacheTypenames.Configuration });
//         // write to the storage
//         console.log('Add method to write to cache, received event', event);
//         this._onDidChangeConfiguration.fire(event);
//     }
// }
//# sourceMappingURL=configuration-remote-service.js.map