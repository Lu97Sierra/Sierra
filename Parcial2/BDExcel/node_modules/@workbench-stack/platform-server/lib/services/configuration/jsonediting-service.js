"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JSONEditingService = void 0;
const nls = require("@vscode-alt/monaco-editor/esm/vs/nls");
const core_1 = require("@workbench-stack/core");
const inversify_1 = require("inversify");
const core_2 = require("@files-stack/core");
// import { TYPES as fileTypes, StringSnapshot } from '@files-stack/core';
const async_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/async");
// import { JSONEditingErrorCode } from '@workbench-stack/configuration';
const jsonEdit_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/jsonEdit");
// import { Edit } from '@vscode-alt/monaco-editor/esm/vs/base/common/jsonFormatter';
const selection_1 = require("@vscode-alt/monaco-editor/esm/vs/editor/common/core/selection");
const editOperation_1 = require("@vscode-alt/monaco-editor/esm/vs/editor/common/core/editOperation");
const range_1 = require("@vscode-alt/monaco-editor/esm/vs/editor/common/core/range");
const textModel_1 = require("@vscode-alt/monaco-editor/esm/vs/editor/common/model/textModel");
const ILogger = require("bunyan");
const core_3 = require("@common-stack/core");
let JSONEditingService = class JSONEditingService {
    constructor(fileService, textFileService, logger) {
        this.fileService = fileService;
        this.textFileService = textFileService;
        this.logger = logger;
        this.queue = new async_1.Queue();
    }
    write(resource, value, save) {
        return __awaiter(this, void 0, void 0, function* () {
            // await this.fileService.updateContent(resource, JSON.stringify({[value.key]: value.value}));
            // return await this.doWriteConfiguration(resource, value, save);
            // value.value.map(el => {
            // 	const newUrl = resource.with({path: `${resource.path}/${el.path}`});
            // 	console.log('newUrl', newUrl);
            // 	this.fileService.createFolder(newUrl);
            // })
            return Promise.resolve(this.queue.queue(() => this.doWriteConfiguration(resource, value, save))); // queue up writes to prevent race conditions
        });
    }
    doWriteConfiguration(resource, value, save) {
        return __awaiter(this, void 0, void 0, function* () {
            const model = yield this.resolveAndValidate(resource, save);
            return yield this.writeToBuffer(model, value, resource);
            // return this.resolveAndValidate(resource, save)
            //     .then(reference => this.writeToBuffer(reference.object.textEditorModel, value)
            //         .then(() => reference.dispose()));
        });
    }
    writeToBuffer(model, value, resource) {
        return __awaiter(this, void 0, void 0, function* () {
            // const edit = this.getEdits(model, value)[0];
            const edit = this.getEdits(model, value)[0];
            if (this.applyEditsToBuffer(edit, model)) {
                this.logger.trace('Logging write to buffer contante [%j], [%s]', model.getValue(), resource);
                return yield this.textFileService.write(resource, model.getValue());
            }
        });
    }
    applyEditsToBuffer(edit, model) {
        const startPosition = model.getPositionAt(edit.offset);
        const endPosition = model.getPositionAt(edit.offset + edit.length);
        const range = new range_1.Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);
        let currentText = model.getValueInRange(range);
        if (edit.content !== currentText) {
            const editOperation = currentText ? editOperation_1.EditOperation.replace(range, edit.content) : editOperation_1.EditOperation.insert(startPosition, edit.content);
            model.pushEditOperations([new selection_1.Selection(startPosition.lineNumber, startPosition.column, startPosition.lineNumber, startPosition.column)], [editOperation], () => []);
            return true;
        }
        return false;
    }
    getEdits(model, configurationValue) {
        const { tabSize, insertSpaces } = model.getOptions();
        const eol = model.getEOL();
        const { key, value } = configurationValue;
        // Without key, the entire settings file is being replaced, so we just use JSON.stringify
        if (!key) {
            const content = JSON.stringify(value, null, insertSpaces ? ' '.repeat(tabSize) : '\t');
            return [{
                    content,
                    length: content.length,
                    offset: 0,
                }];
        }
        return jsonEdit_1.setProperty(model.getValue(), [key], value, { tabSize, insertSpaces, eol });
    }
    resolveModelReference(resource) {
        return __awaiter(this, void 0, void 0, function* () {
            const exists = yield this.fileService.exists(resource);
            if (!exists) {
                yield this.textFileService.write(resource, '{}', { encoding: 'utf8' });
            }
            const content = yield this.textFileService.read(resource);
            const editorModel = new textModel_1.TextModel(content.value, {}, null, resource, null); //@sri setting last argument null can break things.
            return editorModel;
            // return this.textModelResolverService.createModelReference(resource);
        });
    }
    //     // private hasParseErrors(model: editor.ITextModel): boolean {
    // 	private hasParseErrors(model): boolean {
    //         const parseErrors: json.ParseError[] = [];
    //         json.parse(model.getValue(), parseErrors);
    //         return parseErrors.length > 0;
    //     }
    resolveAndValidate(resource, checkDirty) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.resolveModelReference(resource);
            // return this.resolveModelReference(resource)
            //     .then(reference => {
            //             const model = reference.object.textEditorModel;
            //     if (this.hasParseErrors(model)) {
            //         return this.wrapError<IReference<ITextEditorModel>>(JSONEditingErrorCode.ERROR_INVALID_FILE);
            //     }
            //     // Target cannot be dirty if not writing into buffer
            //     // if (checkDirty && this.fileService.isDirty(resource)) {
            //     //     return this.wrapError<IReference<ITextEditorModel>>(JSONEditingErrorCode.ERROR_FILE_DIRTY);
            //     // }
            //     return reference;
            // });
        });
    }
    reject(code) {
        const message = this.toErrorMessage(code);
        return Promise.reject(new core_1.JSONEditingError(message, code));
    }
    toErrorMessage(error) {
        switch (error) {
            // User issues
            case core_1.JSONEditingErrorCode.ERROR_INVALID_FILE: {
                return nls.localize('errorInvalidFile', 'Unable to write into the file. Please open the file to correct errors/warnings in the file and try again.');
            }
            case core_1.JSONEditingErrorCode.ERROR_FILE_DIRTY: {
                return nls.localize('errorFileDirty', 'Unable to write into the file because the file is dirty. Please save the file and try again.');
            }
        }
    }
};
JSONEditingService = __decorate([
    inversify_1.injectable(),
    __param(0, inversify_1.inject(core_2.TYPES.IFileService)),
    __param(1, inversify_1.inject(core_2.TYPES.ITextFileService)),
    __param(2, inversify_1.inject(core_3.CommonType.LOGGER)),
    __metadata("design:paramtypes", [Object, Object, ILogger])
], JSONEditingService);
exports.JSONEditingService = JSONEditingService;
//# sourceMappingURL=jsonediting-service.js.map