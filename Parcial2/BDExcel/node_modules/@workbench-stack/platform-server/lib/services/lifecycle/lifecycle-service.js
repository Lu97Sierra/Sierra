"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var LifecycleService_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.LifecycleService = void 0;
/* tslint:disable */
const Logger = require("bunyan");
const events_1 = require("events");
const event_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/event");
const async_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/async");
const core_1 = require("@workbench-stack/core");
const utils_1 = require("./utils");
const inversify_1 = require("inversify");
const performance_1 = require("../../core/performance/performance");
// TODO use lifecycle interfaces from the `@workbench-stack/core`
let LifecycleService = LifecycleService_1 = class LifecycleService {
    constructor(notificationService, storageService, logService) {
        this.notificationService = notificationService;
        this.storageService = storageService;
        this.ipc = new events_1.EventEmitter();
        this.phaseWhen = new Map();
        this._onBeforeShutdown = new event_1.Emitter();
        this._onWillShutdown = new event_1.Emitter();
        this._onShutdown = new event_1.Emitter();
        this._phase = 1 /* Starting */;
        this.logService = logService.child({ className: 'LifecycleService' });
        this._startupKind = this.resolveStartupKind();
        this.registerListeners();
    }
    get onBeforeShutdown() { return this._onBeforeShutdown.event; }
    get onWillShutdown() { return this._onWillShutdown.event; }
    get onShutdown() { return this._onShutdown.event; }
    get startupKind() { return this._startupKind; }
    get phase() { return this._phase; }
    resolveStartupKind() {
        const lastShutdownReason = this.storageService.getInteger(LifecycleService_1.LAST_SHUTDOWN_REASON_KEY, "WORKSPACE" /* WORKSPACE */);
        this.storageService.remove(LifecycleService_1.LAST_SHUTDOWN_REASON_KEY, "WORKSPACE" /* WORKSPACE */);
        let startupKind;
        if (lastShutdownReason === 3 /* RELOAD */) {
            startupKind = 3 /* ReloadedWindow */;
        }
        else if (lastShutdownReason === 4 /* LOAD */) {
            startupKind = 4 /* ReopenedWindow */;
        }
        else {
            startupKind = 1 /* NewWindow */;
        }
        this.logService.trace(`lifecycle: starting up (startup kind: ${this._startupKind})`);
        return startupKind;
    }
    registerListeners() {
        // Main side indicates that window is about to unload, check for vetos
        this.ipc.on('vscode:onBeforeUnload', (event, reply) => {
            this.logService.trace(`lifecycle: onBeforeUnload (reason: ${reply.reason})`);
            // trigger onBeforeShutdown events and veto collecting
            this.handleBeforeShutdown(reply.reason).then(veto => {
                if (veto) {
                    this.logService.trace('lifecycle: onBeforeUnload prevented via veto');
                    this.ipc.emit(reply.cancelChannel);
                }
                else {
                    this.logService.trace('lifecycle: onBeforeUnload continues without veto');
                    this.shutdownReason = reply.reason;
                    this.ipc.emit(reply.okChannel);
                }
            });
        });
        // Main side indicates that we will indeed shutdown
        this.ipc.on('vscode:onWillUnload', (event, reply) => {
            this.logService.trace(`lifecycle: onWillUnload (reason: ${reply.reason})`);
            // trigger onWillShutdown events and joining
            return this.handleWillShutdown(reply.reason).then(() => {
                // trigger onShutdown event now that we know we will quit
                this._onShutdown.fire();
                // acknowledge to main side
                this.ipc.emit(reply.replyChannel);
            });
        });
        // Save shutdown reason to retrieve on next startup
        // this.storageService.onWillSaveState(() => {
        // 	this.storageService.store(LifecycleService.LAST_SHUTDOWN_REASON_KEY, this.shutdownReason, StorageScope.WORKSPACE);
        // });
    }
    fireWillShutdown(event) {
        this._onWillShutdown.fire(event);
    }
    handleBeforeShutdown(reason) {
        const vetos = [];
        this._onBeforeShutdown.fire({
            veto(value) {
                vetos.push(value);
            },
            reason
        });
        return utils_1.handleVetos(vetos, err => {
            console.log('handleVetos err', err);
        });
    }
    handleWillShutdown(reason) {
        const joiners = [];
        this._onWillShutdown.fire({
            join(promise) {
                if (promise) {
                    joiners.push(promise);
                }
            },
            reason
        });
        return Promise.all(joiners).then(() => undefined, err => {
            console.log('handleWillShutdown error', err);
        });
    }
    set phase(value) {
        if (value < this.phase) {
            throw new Error('Lifecycle cannot go backwards');
        }
        if (this._phase === value) {
            return;
        }
        this.logService.trace(`lifecycle: phase changed (value: ${value})`);
        this._phase = value;
        performance_1.mark(`LifecyclePhase/${utils_1.LifecyclePhaseToString(value)}`);
        const barrier = this.phaseWhen.get(this._phase);
        if (barrier) {
            barrier.open();
            this.phaseWhen.delete(this._phase);
        }
    }
    when(phase) {
        if (phase <= this._phase) {
            return Promise.resolve();
        }
        let barrier = this.phaseWhen.get(phase);
        if (!barrier) {
            barrier = new async_1.Barrier();
            this.phaseWhen.set(phase, barrier);
        }
        return barrier.wait();
    }
};
LifecycleService.LAST_SHUTDOWN_REASON_KEY = 'lifecyle.lastShutdownReason';
LifecycleService = LifecycleService_1 = __decorate([
    inversify_1.injectable(),
    __param(0, inversify_1.inject(core_1.TYPES.INotificationService)),
    __param(1, inversify_1.inject(core_1.TYPES.IStorageService)),
    __param(2, inversify_1.inject('Logger')),
    __metadata("design:paramtypes", [Object, Object, Logger])
], LifecycleService);
exports.LifecycleService = LifecycleService;
//# sourceMappingURL=lifecycle-service.js.map