"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkspaceEditingService = void 0;
/* tslint:disable */
const inversify_1 = require("inversify");
const core_1 = require("@workbench-stack/core");
const workspace_service_1 = require("./workspace-service");
const core_2 = require("@files-stack/core");
const arrays_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/arrays");
const resources_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/resources");
const nls = require("@vscode-alt/monaco-editor/esm/vs/nls");
let WorkspaceEditingService = class WorkspaceEditingService {
    constructor(jsonEditingService, contextService, configurationService, storageService, fileService, textFileService, extensionService, workspaceService, notificationService, environmentService, lifecycleService, registry) {
        this.jsonEditingService = jsonEditingService;
        this.contextService = contextService;
        this.configurationService = configurationService;
        this.storageService = storageService;
        this.fileService = fileService;
        this.textFileService = textFileService;
        this.extensionService = extensionService;
        this.workspaceService = workspaceService;
        this.notificationService = notificationService;
        this.environmentService = environmentService;
        this.lifecycleService = lifecycleService;
        this.registry = registry;
        lifecycleService.onWillShutdown((e) => __awaiter(this, void 0, void 0, function* () {
            // const saveOperation
        }));
    }
    // private async saveUntitedBeforeShutdown(reason: ShutdownReason): Promise<boolean> {
    //     if (reason !== ShutdownReason.LOAD && reason !== ShutdownReason.CLOSE) {
    //         return false; // only interested when window is closing or loading
    //     }
    //     const workspaceIdentifier = this.getCurrentWorkspaceIdentifier();
    //     if (!workspaceIdentifier || !isEqualOrParent(workspaceIdentifier.configPath, this.environmentService.untitledWorkspacesHome)) {
    //         return false; // only care about untitled workspaces to ask for saving
    //     }
    //     const windowCount = await this.windowsService.getWindowCount();
    //     if (reason === ShutdownReason.CLOSE && !isMacintosh && windowCount === 1) {
    //         return false; // Windows/Linux: quits when last window is closed, so do not ask then
    //     }
    //     enum ConfirmResult {
    //         SAVE,
    //         DONT_SAVE,
    //         CANCEL
    //     }
    //     const save = { label: mnemonicButtonLabel(nls.localize('save', "Save")), result: ConfirmResult.SAVE };
    //     const dontSave = { label: mnemonicButtonLabel(nls.localize('doNotSave', "Don't Save")), result: ConfirmResult.DONT_SAVE };
    //     const cancel = { label: nls.localize('cancel', "Cancel"), result: ConfirmResult.CANCEL };
    //     const buttons: { label: string; result: ConfirmResult; }[] = [];
    //     if (isWindows) {
    //         buttons.push(save, dontSave, cancel);
    //     } else if (isLinux) {
    //         buttons.push(dontSave, cancel, save);
    //     } else {
    //         buttons.push(save, cancel, dontSave);
    //     }
    //     const message = nls.localize('saveWorkspaceMessage', "Do you want to save your workspace configuration as a file?");
    //     const detail = nls.localize('saveWorkspaceDetail', "Save your workspace if you plan to open it again.");
    //     const cancelId = buttons.indexOf(cancel);
    //     // const res = await this.dialogService.show(Severity.Warning, message, buttons.map(button => button.label), { detail, cancelId });
    //     switch (buttons[res].result) {
    //         // Cancel: veto unload
    //         case ConfirmResult.CANCEL:
    //             return true;
    //         // Don't Save: delete workspace
    //         case ConfirmResult.DONT_SAVE:
    //             this.workspaceService.deleteUntitledWorkspace(workspaceIdentifier);
    //             return false;
    //         // Save: save workspace, but do not veto unload if path provided
    //         // case ConfirmResult.SAVE: {
    //         //     const newWorkspacePath = await this.pickNewWorkspacePath();
    //         //     if (!newWorkspacePath) {
    //         //         return true; // keep veto if no target was provided
    //         //     }
    //         //     try {
    //         //         await this.saveWorkspaceAs(workspaceIdentifier, newWorkspacePath);
    //         //         const newWorkspaceIdentifier = await this.workspaceService.getWorkspaceIdentifier(newWorkspacePath);
    //         //         const label = this.labelService.getWorkspaceLabel(newWorkspaceIdentifier, { verbose: true });
    //         //         this.windowsService.addRecentlyOpened([{ label, workspace: newWorkspaceIdentifier }]);
    //         //         this.workspaceService.deleteUntitledWorkspace(workspaceIdentifier);
    //         //     } catch (error) {
    //         //         // ignore
    //         //     }
    //         //     return false;
    //         // }
    //     }
    // }
    // pickNewWorkspacePath(): Promise<URI | undefined> {
    //     return this.fileDialogService.showSaveDialog({
    //         saveLabel: mnemonicButtonLabel(nls.localize('save', "Save")),
    //         title: nls.localize('saveWorkspace', "Save Workspace"),
    //         filters: WORKSPACE_FILTER,
    //         defaultUri: this.fileDialogService.defaultWorkspacePath()
    //     });
    // }
    updateFolders(index, deleteCount, foldersToAdd, donotNotifyError) {
        const folders = this.contextService.getWorkspace().folders;
        let foldersToDelete = [];
        if (typeof deleteCount === 'number') {
            foldersToDelete = folders.slice(index, index + deleteCount).map(f => f.uri);
        }
        const wantsToDelete = foldersToDelete.length > 0;
        const wantsToAdd = Array.isArray(foldersToAdd) && foldersToAdd.length > 0;
        if (!wantsToAdd && !wantsToDelete) {
            return Promise.resolve(); // return early if there is nothing to do
        }
        // Add Folders
        if (wantsToAdd && !wantsToDelete && Array.isArray(foldersToAdd)) {
            return this.doAddFolders(foldersToAdd, index, donotNotifyError);
        }
        // Delete Folders
        if (wantsToDelete && !wantsToAdd) {
            return this.removeFolders(foldersToDelete);
        }
        // Add & Delete Folders
        // tslint:disable-next-line:one-line
        else {
            // if we are in single-folder state and the folder is replaced with
            // other folders, we handle this specially and just enter workspace
            // mode with the folders that are being added.
            if (this.includesSingleFolderWorkspace(foldersToDelete)) {
                return this.createAndEnterWorkspace(foldersToAdd);
            }
            // if we are not in workspace-state, we just add the folders
            if (this.contextService.getWorkbenchState() !== 3 /* WORKSPACE */) {
                return this.doAddFolders(foldersToAdd, index, donotNotifyError);
            }
            // finally, update folders within the workspace
            return this.doUpdateFolders(foldersToAdd, foldersToDelete, index, donotNotifyError);
        }
    }
    doUpdateFolders(foldersToAdd, foldersToDelete, index, donotNotifyError = false) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.contextService.updateFolders(foldersToAdd, foldersToDelete, index);
            }
            catch (error) {
                if (donotNotifyError) {
                    throw error;
                }
                this.handleWorkspaceConfigurationEditingError(error);
            }
        });
    }
    addFolders(foldersToAdd, donotNotifyError = false) {
        return this.doAddFolders(foldersToAdd, undefined, donotNotifyError);
    }
    doAddFolders(foldersToAdd, index, donotNotifyError = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const state = this.contextService.getWorkbenchState();
            // If we are in no-workspace or single-folder workspace, adding folders has to
            // enter a workspace.
            if (state !== 3 /* WORKSPACE */) {
                let newWorkspaceFolders = this.contextService.getWorkspace().folders.map(folder => ({ uri: folder.uri }));
                newWorkspaceFolders.splice(typeof index === 'number' ? index : newWorkspaceFolders.length, 0, ...foldersToAdd);
                newWorkspaceFolders = arrays_1.distinct(newWorkspaceFolders, folder => resources_1.getComparisonKey(folder.uri));
                if (state === 1 /* EMPTY */ && newWorkspaceFolders.length === 0 || state === 2 /* FOLDER */ && newWorkspaceFolders.length === 1) {
                    return; // return if the operation is a no-op for the current state
                }
                return this.createAndEnterWorkspace(newWorkspaceFolders);
            }
            // Delegate addition of folders to workspace service otherwise
            try {
                yield this.contextService.addFolders(foldersToAdd, index);
            }
            catch (error) {
                if (donotNotifyError) {
                    throw error;
                }
                this.handleWorkspaceConfigurationEditingError(error);
            }
        });
    }
    removeFolders(foldersToRemove, donotNotifyError = false) {
        return __awaiter(this, void 0, void 0, function* () {
            // If we are in single-folder state and the opened folder is to be removed,
            // we create an empty workspace and enter it.
            if (this.includesSingleFolderWorkspace(foldersToRemove)) {
                return this.createAndEnterWorkspace([]);
            }
            // Delegate removal of folders to workspace service otherwise
            try {
                yield this.contextService.removeFolders(foldersToRemove);
            }
            catch (error) {
                if (donotNotifyError) {
                    throw error;
                }
                this.handleWorkspaceConfigurationEditingError(error);
            }
        });
    }
    includesSingleFolderWorkspace(folders) {
        if (this.contextService.getWorkbenchState() === 2 /* FOLDER */) {
            const workspaceFolder = this.contextService.getWorkspace().folders[0];
            return (folders.some(folder => resources_1.isEqual(folder, workspaceFolder.uri)));
        }
        return false;
    }
    createAndEnterWorkspace(folders, path) {
        return __awaiter(this, void 0, void 0, function* () {
            if (path && !(yield this.isValidTargetWorkspacePath(path))) {
                return;
            }
            const remoteAuthority = this.environmentService.configuration.remoteAuthority;
            const untitledWorkspace = yield this.workspaceService.createUntitledWorkspace(folders, remoteAuthority);
            if (path) {
                yield this.saveWorkspaceAs(untitledWorkspace, path);
            }
            else {
                path = untitledWorkspace.configPath;
            }
            return this.enterWorkspace(path);
        });
    }
    saveAndEnterWorkspace(path) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield this.isValidTargetWorkspacePath(path))) {
                return;
            }
            const workspaceIdentifier = this.getCurrentWorkspaceIdentifier();
            if (!workspaceIdentifier) {
                return;
            }
            yield this.saveWorkspaceAs(workspaceIdentifier, path);
            return this.enterWorkspace(path);
        });
    }
    isValidTargetWorkspacePath(path) {
        return __awaiter(this, void 0, void 0, function* () {
            // const windows = await this.windowsService.getWindows();
            // Prevent overwriting a workspace that is currently opened in another window
            // if (windows.some(window => !!window.workspace && isEqual(window.workspace.configPath, path))) {
            //     const options: MessageBoxOptions = {
            //         type: 'info',
            //         buttons: [nls.localize('ok', "OK")],
            //         message: nls.localize('workspaceOpenedMessage', "Unable to save workspace '{0}'", basename(path)),
            //         detail: nls.localize('workspaceOpenedDetail', "The workspace is already opened in another window. Please close that window first and then try again."),
            //         noLink: true
            //     };
            //     await this.windowService.showMessageBox(options);
            //     return false;
            // }
            return true; // OK
        });
    }
    saveWorkspaceAs(workspace, targetConfigPathURI) {
        return __awaiter(this, void 0, void 0, function* () {
            const configPathURI = workspace.configPath;
            // Return early if target is same as source
            if (resources_1.isEqual(configPathURI, targetConfigPathURI)) {
                return;
            }
            // Read the contents of the workspace file, update it to new location and save it.
            const raw = yield this.fileService.readFile(configPathURI);
            const newRawWorkspaceContents = core_1.rewriteWorkspaceFileForNewLocation(raw.value.toString(), configPathURI, targetConfigPathURI);
            yield this.textFileService.create(targetConfigPathURI, newRawWorkspaceContents, { overwrite: true });
        });
    }
    handleWorkspaceConfigurationEditingError(error) {
        switch (error.code) {
            case core_1.JSONEditingErrorCode.ERROR_INVALID_FILE:
                this.onInvalidWorkspaceConfigurationFileError();
                break;
            case core_1.JSONEditingErrorCode.ERROR_FILE_DIRTY:
                this.onWorkspaceConfigurationFileDirtyError();
                break;
            default:
                this.notificationService.error(error.message);
        }
    }
    onInvalidWorkspaceConfigurationFileError() {
        const message = nls.localize('errorInvalidTaskConfiguration', "Unable to write into workspace configuration file. Please open the file to correct errors/warnings in it and try again.");
        this.askToOpenWorkspaceConfigurationFile(message);
    }
    onWorkspaceConfigurationFileDirtyError() {
        const message = nls.localize('errorWorkspaceConfigurationFileDirty', "Unable to write into workspace configuration file because the file is dirty. Please save it and try again.");
        this.askToOpenWorkspaceConfigurationFile(message);
    }
    askToOpenWorkspaceConfigurationFile(message) {
        this.notificationService.prompt(core_1.Severity.Error, message, [{
                label: nls.localize('openWorkspaceConfigurationFile', "Open Workspace Configuration"),
            }]);
    }
    enterWorkspace(path) {
        return __awaiter(this, void 0, void 0, function* () {
            // if (!!this.environmentService.extensionTestsLocationURI) {
            //     throw new Error('Entering a new workspace is not possible in tests.');
            // }
            const workspace = yield this.workspaceService.getWorkspaceIdentifier(path);
            // Settings migration (only if we come from a folder workspace)
            if (this.contextService.getWorkbenchState() === 2 /* FOLDER */) {
                yield this.migrateWorkspaceSettings(workspace);
            }
            const workspaceImpl = this.contextService;
            yield workspaceImpl.initialize(workspace);
            // Restart extension host if first root folder changed (impact on deprecated workspace.rootPath API)
            // Stop the extension host first to give extensions most time to shutdown
            this.extensionService.stopExtensionHost();
            // const result = await this.windowService.enterWorkspace(path);
            // if (result) {
            //     await this.migrateStorage(result.workspace);
            //     // Reinitialize backup service
            //     if (this.backupFileService instanceof BackupFileService) {
            //         this.backupFileService.initialize(result.backupPath!);
            //     }
            // }
            // if (this.environmentService.configuration.remoteAuthority) {
            //     this.windowService.reloadWindow(); // TODO aeschli: workaround until restarting works
            // } else {
            //     this.extensionService.startExtensionHost();
            // }
        });
    }
    // private migrateStorage(toWorkspace: IWorkspaceIdentifier): Promise<void> {
    //     const storageImpl = this.storageService as StorageService;
    //     return storageImpl.migrate(toWorkspace);
    // }
    migrateWorkspaceSettings(toWorkspace) {
        return this.doCopyWorkspaceSettings(toWorkspace, setting => setting.scope === 3 /* WINDOW */);
    }
    copyWorkspaceSettings(toWorkspace) {
        return this.doCopyWorkspaceSettings(toWorkspace);
    }
    doCopyWorkspaceSettings(toWorkspace, filter) {
        const configurationProperties = this.registry.as(core_1.Extensions.Configuration).getConfigurationProperties();
        const targetWorkspaceConfiguration = {};
        for (const key of this.configurationService.keys().workspace) {
            if (configurationProperties[key]) {
                if (filter && !filter(configurationProperties[key])) {
                    continue;
                }
                targetWorkspaceConfiguration[key] = this.configurationService.inspect(key).workspace;
            }
        }
        return this.jsonEditingService.write(toWorkspace.configPath, { key: 'settings', value: targetWorkspaceConfiguration }, true);
    }
    getCurrentWorkspaceIdentifier() {
        const workspace = this.contextService.getWorkspace();
        if (workspace && workspace.configuration) {
            return { id: workspace.id, configPath: workspace.configuration };
        }
        return undefined;
    }
};
WorkspaceEditingService = __decorate([
    inversify_1.injectable(),
    __param(0, inversify_1.inject(core_1.TYPES.IJSONEditingService)),
    __param(1, inversify_1.inject(core_1.TYPES.IWorkspaceContextService)),
    __param(2, inversify_1.inject(core_1.TYPES.IConfigurationService)),
    __param(3, inversify_1.inject(core_1.TYPES.IStorageService)),
    __param(4, inversify_1.inject(core_2.TYPES.IFileService)),
    __param(5, inversify_1.inject(core_2.TYPES.ITextFileService)),
    __param(6, inversify_1.inject(core_1.TYPES.IExtensionService)),
    __param(7, inversify_1.inject(core_1.TYPES.IWorkspacesService)),
    __param(8, inversify_1.inject(core_1.TYPES.INotificationService)),
    __param(9, inversify_1.inject(core_1.TYPES.IWorkbenchEnvironmentService)),
    __param(10, inversify_1.inject(core_1.TYPES.ILifecycleService)),
    __param(11, inversify_1.inject(core_1.TYPES.IRegistry)),
    __metadata("design:paramtypes", [Object, workspace_service_1.WorkspaceService, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object])
], WorkspaceEditingService);
exports.WorkspaceEditingService = WorkspaceEditingService;
//# sourceMappingURL=workspace-editing-service.js.map