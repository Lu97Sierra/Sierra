"use strict";
/* tslint:disable */
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkbenchContributionsRegistry = void 0;
const async_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/async");
const inversify_1 = require("inversify");
// --- Workbench Contribution Registry
class WorkbenchContributionsRegistry {
    constructor() {
        this.toBeInstantiated = new Map();
    }
    registerWorkbenchContribution(ctor, phase = 1 /* Starting */) {
        // Instantiate directly if we are already matching the provided phase
        if (this.container && this.lifecycleService && this.lifecycleService.phase >= phase) {
            this.container.bind(ctor).to(ctor);
        }
        // Otherwise keep contributions by lifecycle phase
        else {
            let toBeInstantiated = this.toBeInstantiated.get(phase);
            if (!toBeInstantiated) {
                toBeInstantiated = [];
                this.toBeInstantiated.set(phase, toBeInstantiated);
            }
            toBeInstantiated.push(ctor);
        }
    }
    start(instantiationService, lifecycleService) {
        this.container = new inversify_1.Container();
        this.container.parent = instantiationService;
        this.lifecycleService = lifecycleService;
        [1 /* Starting */, 1 /* Starting */, 2 /* Ready */, 3 /* Restored */, 4 /* Eventually */].forEach(phase => {
            this.instantiateByPhase(instantiationService, lifecycleService, phase);
        });
    }
    instantiateByPhase(container, lifecycleService, phase) {
        // Instantiate contributions directly when phase is already reached
        if (lifecycleService.phase >= phase) {
            this.doInstantiateByPhase(container, phase);
        }
        // Otherwise wait for phase to be reached
        else {
            lifecycleService.when(phase).then(() => {
                this.doInstantiateByPhase(container, phase);
            });
        }
    }
    doInstantiateByPhase(container, phase) {
        const toBeInstantiated = this.toBeInstantiated.get(phase);
        if (toBeInstantiated) {
            this.toBeInstantiated.delete(phase);
            if (phase !== 4 /* Eventually */) {
                // instantiate everything synchronously and blocking
                for (const ctor of toBeInstantiated) {
                    container.bind(ctor).to(ctor);
                }
            }
            else {
                // for the Eventually-phase we instantiate contributions
                // only when idle. this might take a few idle-busy-cycles
                // but will finish within the timeouts
                let forcedTimeout = 3000;
                let i = 0;
                let instantiateSome = (idle) => {
                    while (i < toBeInstantiated.length) {
                        const ctor = toBeInstantiated[i++];
                        container.bind(ctor).to(ctor);
                        if (idle.timeRemaining() < 1) {
                            // time is up -> reschedule
                            async_1.runWhenIdle(instantiateSome, forcedTimeout);
                            break;
                        }
                    }
                };
                async_1.runWhenIdle(instantiateSome, forcedTimeout);
            }
        }
    }
}
exports.WorkbenchContributionsRegistry = WorkbenchContributionsRegistry;
//# sourceMappingURL=contributions.js.map