/* tslint:disable */
import { Event } from '@vscode-alt/monaco-editor/esm/vs/base/common/event';
import { URI } from '@vscode-alt/monaco-editor/esm/vs/base/common/uri';
import { IIEditorInput, IIFileEditorInput as IFileEditorInput, ITextEditorOptions, IEditorGroup, IEditorInput, IEditorIdentifier } from '../generated-model';
import { IEditorModel } from './core-editor';
import { ITextModel } from '@vscode-alt/monaco-editor/esm/vs/editor/common/model';
import { IEditorOptions_Input as IEditorOptions } from '../generated-model';
import { IEditorControl } from './editor-service';
import { interfaces } from 'inversify';

// copied from vs/workbench/common/editor.ts

/**
 * Text diff editor id.
 */
export const TEXT_DIFF_EDITOR_ID = 'workbench.editors.textDiffEditor';

/**
 * Binary diff editor id.
 */
export const BINARY_DIFF_EDITOR_ID = 'workbench.editors.binaryResourceDiffEditor';

export interface IEditor {

	/**
	 * The assigned input of this editor.
	 */
    input: IEditorInput | null;

	/**
	 * The assigned options of this editor.
	 */
    options: IEditorOptions | null;

	/**
	 * The assigned group this editor is showing in.
	 */
    group: IEditorGroup | undefined;

	/**
	 * The minimum width of this editor.
	 */
    readonly minimumWidth: number;

	/**
	 * The maximum width of this editor.
	 */
    readonly maximumWidth: number;

	/**
	 * The minimum height of this editor.
	 */
    readonly minimumHeight: number;

	/**
	 * The maximum height of this editor.
	 */
    readonly maximumHeight: number;

	/**
	 * An event to notify whenever minimum/maximum width/height changes.
	 */
    readonly onDidSizeConstraintsChange: Event<{ width: number; height: number; } | undefined>;

	/**
	 * Returns the unique identifier of this editor.
	 */
    getId(): string;

	/**
	 * Returns the underlying control of this editor.
	 */
    getControl(): IEditorControl | null;

	/**
	 * Asks the underlying control to focus.
	 */
    focus(): void;

	/**
	 * Finds out if this editor is visible or not.
	 */
    isVisible(): boolean;
}

export interface IClientEditor extends  Pick<IEditor, Exclude<keyof IEditor,
'getId' | 'getControl' | 'focus' | 'isVisible' | 'onDidSizeConstraintsChange'
 >>{
	
}

export interface ITextEditor extends IClientEditor {

	/**
	 * Returns the underlying text editor widget of this editor.
	 */
    // getControl(): ICodeEditor;
}

export interface ITextDiffEditor extends IEditor {

	/**
	 * Returns the underlying text editor widget of this editor.
	 */
    // getControl(): IDiffEditor;
}

export interface ITextSideBySideEditor extends IEditor {

	/**
	 * Returns the underlying text editor widget of the master side
	 * of this side-by-side editor.
	 */
    getMasterEditor(): ITextEditor;

	/**
	 * Returns the underlying text editor widget of the details side
	 * of this side-by-side editor.
	 */
    getDetailsEditor(): ITextEditor;
}



export const enum Verbosity {
    SHORT,
    MEDIUM,
    LONG
}

export interface IRevertOptions {

	/**
	 *  Forces to load the contents of the editor again even if the editor is not dirty.
	 */
    force?: boolean;

	/**
	 * A soft revert will clear dirty state of an editor but will not attempt to load it.
	 */
    soft?: boolean;
}

export const enum ConfirmResult {
    SAVE,
    DONT_SAVE,
    CANCEL
}

export const enum EncodingMode {

	/**
	 * Instructs the encoding support to encode the current input with the provided encoding
	 */
    Encode,

	/**
	 * Instructs the encoding support to decode the current input with the provided encoding
	 */
    Decode
}

export interface IEncodingSupport {

	/**
	 * Gets the encoding of the input if known.
	 */
    getEncoding(): string;

	/**
	 * Sets the encoding for the input for saving.
	 */
    setEncoding(encoding: string, mode: EncodingMode): void;
}

export interface ITextEditorModel extends IEditorModel {
    textEditorModel: ITextModel;
}


export interface IEditorInputWithOptions {
    editor: IEditorInput;
    options?: IEditorOptions | ITextEditorOptions;
}


export interface IEditorCloseEvent extends IEditorIdentifier {
	replaced: boolean;
	index: number;
}


// src/vs/workbench/browser/editor.ts

export interface IEditorDescriptor {
	id: string;
	name: string;
}

export type IEditorInputTypeName =  Pick<IEditorInput, '__typename' | 'typeId' | 'preferredEditorId'>
export interface IEditorRegistry {
	/**
	 * Registers an editor to the platform for the given input type. The second parameter also supports an
	 * array of input classes to be passed in. If the more than one editor is registered for the same editor
	 * input, the input itself will be asked which editor it prefers if this method is provided. Otherwise
	 * the first editor in the list will be returned.
	 *
	 * @param editorInputDescriptor a constructor function that returns an instance of EditorInput for which the
	 * registered editor should be used for.
	 */
	registerEditor(descriptor: IEditorDescriptor, editorInputDescriptor: IEditorInputTypeName): void;
	registerEditor(descriptor: IEditorDescriptor, editorInputDescriptor: IEditorInputTypeName[]): void;
	/**
	 * Returns the editor descriptor for the given input or null if none.
	 */
	getEditor(input: IEditorInputTypeName): IEditorDescriptor | null;

	/**
	 * Returns the editor descriptor for the given identifier or null if none.
	 */
	getEditorById(editorId: string): IEditorDescriptor | null;

	/**
	 * Returns an array of registered editors known to the platform.
	 */
	getEditors(): IEditorDescriptor[];	
}


export type EditorInput = Pick<IIEditorInput, 'resource' | 'fileReference' | 'label' | 'typeId'>;

export interface IFileInputFactory {

	createFileInput(resource: URI, encoding: string | undefined, mode: string | undefined, instantiationService: any): IFileEditorInput;

	isFileInput(obj: any): obj is IFileEditorInput;
}


// customized based on our need
// export interface IEditorInputFactory {

// 	/**
// 	 * Returns a string representation of the provided editor input that contains enough information
// 	 * to deserialize back to the original editor input from the deserialize() method.
// 	 */
// 	serialize(editorInput: EditorInput): string | undefined;

// 	/**
// 	 * Returns an editor input from the provided serialized form of the editor input. This form matches
// 	 * the value returned from the serialize() method.
// 	 */
// 	deserialize(instantiationService: any, serializedEditorInput: string): EditorInput | undefined;
// }


export interface IFileInputFactory {

    createFileInput(resource: URI, encoding: string | undefined, mode: string | undefined, container: interfaces.Container | undefined): IFileEditorInput & { [key: string]: any };

    isFileInput(obj: any): obj is IFileEditorInput  & { [key: string]: any };
}

export interface IEditorInputFactory {

    createInput(resource: URI, label: string | undefined, encoding: string | undefined, mode: string | undefined, container: interfaces.Container | undefined, additionalProps?: object | undefined): IIEditorInput & { [key: string]: any };

}
export interface IEditorInputFactoryRegistry {

    /**
     * Registers the file input factory to use for file inputs.
     */
    registerFileInputFactory(factory: IFileInputFactory): void;

    /**
     * Returns the file input factory to use for file inputs.
     */
    getFileInputFactory(): IFileInputFactory;

    /**
     * Registers a editor input factory for the given editor input to the regsitry. An editor input factory
     * is capable of serializing and deserialzing editor inputs from string data.
     *
     * @param {string} editorInputId the identifier of the editor input
     * @memberof IEditorInputFactoryRegistry
     */
    registerEditorInputFactory(editorInputId: string, IEditorInputFactory): void;

    /**
     * Returns the editor input factory for the given editor input.
     *
     * @param {string} editorInputId the identifier of the editor input
     * @returns {IEditorInputFactory}
     * @memberof IEditorInputFactoryRegistry
     */
    getEditorInputFactory(editorInputId: string): IEditorInputFactory;

    getEditorInput(resource: URI, label: string | undefined, encoding: string | undefined, mode: string | undefined, container: interfaces.Container | undefined, additionalProps?: object | undefined): IIEditorInput & { [key: string]: any };
	
	hasEditorInput(resource: URI): boolean;
	/**
     * Starts the registry by providing the required services.
     *
     * @memberof IEditorInputFactoryRegistry
     */
    // start(): void;
}
export interface ServiceIdentifier<T> {
	(...args: any[]): void;
	type: T;
}

// remove in future
// export interface ServicesAccessor {
// 	get<T>(id: ServiceIdentifier<T>, isOptional?: any): T;
// }

