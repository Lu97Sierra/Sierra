import { URI } from '@vscode-alt/monaco-editor/esm/vs/base/common/uri';
import { Severity as INotificationSeverity } from '../../core/severity';
import { ConfigurationScope } from '../configuration';
import { ConfigurationTarget } from '../configuration';
import { EditorOpenPositioning } from '../enum';
import { GroupDirection } from '../enum';
import { GroupLocation } from '../enum';
import { GroupOrientation } from '../enum';
import { MergeGroupMode } from '../enum';
import { CloseDirection } from '../enum';
import { GroupsOrder } from '../enum';
import { Severity } from '../../core/severity';
import NotificationSeverity = Severity;
import { EditorsOrder } from '../enum';
import { GroupsArrangement } from '../enum';
import { LableFormatType } from '../enum';
import { OpenSideBySideDirection } from '../enum';
import { OpenPositioningType } from '../enum';
import { TabSizingType } from '../enum';
import { TabCloseButtonType } from '../enum';
import { SideBySideEditor } from '../enum';
import { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';
import { ApolloContext } from '../apollo-context';
import * as ApolloReactCommon from '@apollo/react-common';
export declare type Maybe<T> = T | null;
export declare type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
export declare type RequireFields<T, K extends keyof T> = {
    [X in Exclude<keyof T, K>]?: T[X];
} & {
    [P in K]-?: NonNullable<T[P]>;
};
/** All built-in and custom scalars, mapped to their actual values */
export declare type Scalars = {
    ID: string;
    String: string;
    Boolean: boolean;
    Int: number;
    Float: number;
    AnyObject: any;
    URI: URI;
    JSON: any;
    BigInt: any;
    VSBuffer: any;
    Observable: any;
    VSBufferReadableStream: any;
    JSONObject: any;
};
export declare type IAction = {
    __typename?: 'Action';
    id?: Maybe<Scalars['String']>;
    label?: Maybe<Scalars['String']>;
    tooltip?: Maybe<Scalars['String']>;
    class?: Maybe<Scalars['String']>;
    enabled?: Maybe<Scalars['Boolean']>;
    checked?: Maybe<Scalars['Boolean']>;
    radio?: Maybe<Scalars['Boolean']>;
    run?: Maybe<IActionRun>;
};
export declare type IAction_input = {
    id?: Maybe<Scalars['String']>;
    label?: Maybe<Scalars['String']>;
    tooltip?: Maybe<Scalars['String']>;
    class?: Maybe<Scalars['String']>;
    enabled?: Maybe<Scalars['Boolean']>;
    checked?: Maybe<Scalars['Boolean']>;
    radio?: Maybe<Scalars['Boolean']>;
    run?: Maybe<IActionRun_input>;
};
export declare type IActionItem = {
    __typename?: 'ActionItem';
    label?: Maybe<Scalars['String']>;
    description?: Maybe<Scalars['String']>;
};
export declare type IActionRun = {
    __typename?: 'ActionRun';
    type?: Maybe<IGraphqlCallType>;
    document?: Maybe<Scalars['AnyObject']>;
    variables?: Maybe<Scalars['AnyObject']>;
};
export declare type IActionRun_input = {
    type?: Maybe<IGraphqlCallType>;
    document?: Maybe<Scalars['AnyObject']>;
    variables?: Maybe<Scalars['AnyObject']>;
};
export declare type IActions = {
    __typename?: 'Actions';
    id?: Maybe<Scalars['String']>;
    command?: Maybe<Scalars['String']>;
    title?: Maybe<Scalars['String']>;
    category?: Maybe<Scalars['String']>;
    actionItem?: Maybe<IActionItem>;
};
export declare type IAddEntry_input = {
    id?: Maybe<Scalars['String']>;
    name?: Maybe<Scalars['String']>;
    alignment?: Maybe<Scalars['String']>;
    entry?: Maybe<IStatusbarEntry_input>;
    priority?: Maybe<Scalars['Int']>;
    container?: Maybe<Scalars['String']>;
    labelContainer?: Maybe<Scalars['String']>;
};
export declare type IAddFoldersRequest = {
    __typename?: 'AddFoldersRequest';
    foldersToAdd?: Maybe<Array<Maybe<Scalars['URI']>>>;
};
export declare type IAddGroupOptions_Input = {
    activate?: Maybe<Scalars['Boolean']>;
};
export declare type IAnchor = {
    __typename?: 'Anchor';
    x?: Maybe<Scalars['Int']>;
    y?: Maybe<Scalars['Int']>;
    height?: Maybe<Scalars['Int']>;
    width?: Maybe<Scalars['Int']>;
};
export declare type IAnchor_input = {
    x?: Maybe<Scalars['Int']>;
    y?: Maybe<Scalars['Int']>;
    height?: Maybe<Scalars['Int']>;
    width?: Maybe<Scalars['Int']>;
};
export declare type IArg_Input = {
    id?: Maybe<Scalars['String']>;
    folderUri?: Maybe<Scalars['URI']>;
};
export declare type IArgs_input = {
    id?: Maybe<Scalars['String']>;
    folderUri?: Maybe<Scalars['URI']>;
};
export declare type IArgsType = {
    __typename?: 'ArgsType';
    name?: Maybe<Scalars['String']>;
    description?: Maybe<Scalars['String']>;
    constraint?: Maybe<Scalars['String']>;
};
export declare type IAssets = {
    __typename?: 'Assets';
    Type?: Maybe<Scalars['String']>;
    Content?: Maybe<Scalars['String']>;
};
export declare type IAuthor = {
    __typename?: 'Author';
    name?: Maybe<Scalars['String']>;
};
export declare const enum IAutoSaveConfigurationType {
    off = "off",
    afterDelay = "afterDelay",
    onFocusChange = "onFocusChange",
    onWindowChange = "onWindowChange"
}
export declare type IBaseExtension = {
    __typename?: 'BaseExtension';
    type?: Maybe<IExtensionType>;
    identifier?: Maybe<IExtensionIdentifier>;
    /** @deprecated */
    galleryIdentifier?: Maybe<IExtensionIdentifier>;
    manifest?: Maybe<IExtensionManifest>;
    location?: Maybe<Scalars['URI']>;
};
/**
 * Type of input will help to determine what type of editor to be opened in.
 * Varaious Input have following common fields.
 */
export declare type IBaseResourceInput = {
    /** Optional options to use when opening the text input. */
    options?: Maybe<ITextEditorOptions_Input>;
    /** Label to show for the diff editor */
    label?: Maybe<Scalars['String']>;
    /** Description to show for the diff editor */
    description?: Maybe<Scalars['String']>;
    /**
     * Hint to indicate that this input should be treated as a file
     * that opens in an editor capable of showing file content.
     *
     * Without this hint, the editor service will make a guess by
     * looking at the scheme of the resource(s).
     */
    forceFile?: Maybe<Scalars['Boolean']>;
    /**
     * Hint to indicate that this input should be treated as a
     * untitled file
     *
     * Without this hint, the editor service will make a guess by
     * looking at the scheme of the resource(s).
     */
    forceUntitled?: Maybe<Scalars['Boolean']>;
};
export declare type IBranchStatus = IIStatusbarItem & {
    __typename?: 'BranchStatus';
    id?: Maybe<Scalars['String']>;
    name?: Maybe<Scalars['String']>;
    alignment?: Maybe<IStatusbarAlignment>;
    entry?: Maybe<IStatusbarEntry>;
    priority?: Maybe<Scalars['Int']>;
    container?: Maybe<Scalars['String']>;
    labelContainer?: Maybe<Scalars['String']>;
    typeId?: Maybe<ISTATUSBAR_ITEM_ID>;
};
export declare type IBundles = {
    __typename?: 'Bundles';
    server?: Maybe<Scalars['String']>;
    browser?: Maybe<Scalars['String']>;
};
export declare type ICachedSearchStats = {
    __typename?: 'CachedSearchStats';
    cacheWasResolved?: Maybe<Scalars['Boolean']>;
    cacheLookupTime?: Maybe<Scalars['Int']>;
    cacheFilterTime?: Maybe<Scalars['Int']>;
    cacheEntryCount?: Maybe<Scalars['Int']>;
};
export declare type IChangeRange = {
    __typename?: 'ChangeRange';
    startLineNumber?: Maybe<Scalars['Int']>;
    startColumn?: Maybe<Scalars['Int']>;
    endLineNumber?: Maybe<Scalars['Int']>;
    endColumn?: Maybe<Scalars['Int']>;
};
export declare type IChangeRange_Input = {
    startLineNumber?: Maybe<Scalars['Int']>;
    startColumn?: Maybe<Scalars['Int']>;
    endLineNumber?: Maybe<Scalars['Int']>;
    endColumn?: Maybe<Scalars['Int']>;
};
export declare type IChangesChangesChunk_Input = {
    range?: Maybe<IChangeRange_Input>;
    rangeLength?: Maybe<Scalars['Int']>;
    text?: Maybe<Scalars['String']>;
    part?: Maybe<Scalars['Int']>;
};
export declare type IChangesChunk = {
    __typename?: 'ChangesChunk';
    range?: Maybe<IChangeRange>;
    rangeLength?: Maybe<Scalars['Int']>;
    text?: Maybe<Scalars['String']>;
    rangeOffset?: Maybe<Scalars['Int']>;
    forceMoveMarkers?: Maybe<Scalars['Boolean']>;
};
export declare type IChangesChunk_Input = {
    range?: Maybe<IChangeRange_Input>;
    rangeLength?: Maybe<Scalars['Int']>;
    text?: Maybe<Scalars['String']>;
    rangeOffset?: Maybe<Scalars['Int']>;
    forceMoveMarkers?: Maybe<Scalars['Boolean']>;
};
export declare type ICheckboxOptions = {
    __typename?: 'CheckboxOptions';
    label?: Maybe<Scalars['String']>;
    checked?: Maybe<Scalars['Boolean']>;
};
export declare type ICheckboxOptions_input = {
    label?: Maybe<Scalars['String']>;
    checked?: Maybe<Scalars['Boolean']>;
};
export declare type IChunkOptions_Input = {
    piece?: Maybe<IChangesChangesChunk_Input>;
    chunksCount?: Maybe<Scalars['Int']>;
    chunkPosition?: Maybe<Scalars['Int']>;
};
export { CloseDirection };
export declare type ICloseEditor_Input = {
    resource: Scalars['String'];
    editorId?: Maybe<Scalars['Int']>;
    name?: Maybe<Scalars['String']>;
};
export declare type ICloseEditorOptions_Input = {
    preserveFocus?: Maybe<Scalars['Boolean']>;
};
export declare type ICloseEditorsFilter = {
    __typename?: 'CloseEditorsFilter';
    except?: Maybe<IEditorInput>;
    direction?: Maybe<CloseDirection>;
    savedOnly?: Maybe<Scalars['Boolean']>;
};
/** Extension of CloseEditorOptions_Input */
export declare type ICloseOptions_Input = {
    preserveFocus?: Maybe<Scalars['Boolean']>;
    closeEmptyGroups?: Maybe<Scalars['Boolean']>;
};
export declare type ICodeEditorViewState = {
    __typename?: 'CodeEditorViewState';
    cursorState?: Maybe<Scalars['JSON']>;
    viewState?: Maybe<Scalars['JSON']>;
    contributionsState?: Maybe<Scalars['JSON']>;
};
export declare type ICodeEditorViewState_Input = {
    cursorState?: Maybe<Scalars['JSON']>;
    viewState?: Maybe<Scalars['JSON']>;
    contributionsState?: Maybe<Scalars['JSON']>;
};
export declare type ICommandHandlerDescriptionType = {
    __typename?: 'CommandHandlerDescriptionType';
    description?: Maybe<Scalars['String']>;
    args?: Maybe<Array<Maybe<IArgsType>>>;
    returns?: Maybe<Scalars['String']>;
};
export declare type ICommandsType = {
    __typename?: 'CommandsType';
    commands?: Maybe<Array<Maybe<ICommandType>>>;
};
export declare type ICommandType = {
    __typename?: 'CommandType';
    id?: Maybe<Scalars['String']>;
    handler?: Maybe<Scalars['AnyObject']>;
    description?: Maybe<ICommandHandlerDescriptionType>;
};
export declare const enum IcommentThread {
    editable = "editable"
}
export declare type IConfiguration = {
    __typename?: 'Configuration';
    defaultSetting?: Maybe<Array<Maybe<ISettingsGroup>>>;
    files?: Maybe<IFiles>;
    git?: Maybe<IGit>;
    languages?: Maybe<ILanguages>;
    output?: Maybe<IOutput>;
    search?: Maybe<ISearch>;
    terminal?: Maybe<ITerminal>;
    workspace?: Maybe<IWorkspacePreferenceWorkbench>;
};
export declare type IConfigurationData = {
    __typename?: 'ConfigurationData';
    defaults?: Maybe<IConfigurationModel>;
    user?: Maybe<IConfigurationModel>;
    workspace?: Maybe<IConfigurationModel>;
    folders?: Maybe<Array<Maybe<IFolderConfigurationModel>>>;
    isComplete?: Maybe<Scalars['Boolean']>;
};
export declare type IConfigurationExtensionInfo = {
    __typename?: 'ConfigurationExtensionInfo';
    id?: Maybe<Scalars['String']>;
};
export declare type IConfigurationModel = {
    __typename?: 'ConfigurationModel';
    contents?: Maybe<Scalars['AnyObject']>;
    keys?: Maybe<Array<Maybe<Scalars['String']>>>;
    overrides?: Maybe<Array<Maybe<IOverrides>>>;
};
export declare type IConfigurationOverrides = {
    __typename?: 'ConfigurationOverrides';
    resource?: Maybe<Scalars['URI']>;
    overrideIdentifier?: Maybe<Scalars['String']>;
};
export declare type IConfigurationOverrides_Input = {
    resource?: Maybe<Scalars['URI']>;
    overrideIdentifier?: Maybe<Scalars['String']>;
};
export { ConfigurationScope };
export declare const enum IConfigurationServiceAction {
    getConfigurationData = "getConfigurationData",
    reloadConfiguration = "reloadConfiguration",
    onDidChangeConfiguration = "onDidChangeConfiguration",
    updateValue = "updateValue"
}
export { ConfigurationTarget };
export declare type IContentChangedEvent = {
    __typename?: 'ContentChangedEvent';
    changes?: Maybe<Array<Maybe<IChangesChunk>>>;
    eol?: Maybe<Scalars['String']>;
    versionId?: Maybe<Scalars['Int']>;
    isUndoing?: Maybe<Scalars['Boolean']>;
    isRedoing?: Maybe<Scalars['Boolean']>;
    isFlush?: Maybe<Scalars['Boolean']>;
};
export declare type IContentChangedEvent_Input = {
    changes?: Maybe<Array<Maybe<IChangesChunk_Input>>>;
    eol?: Maybe<Scalars['String']>;
    versionId?: Maybe<Scalars['Int']>;
    isUndoing?: Maybe<Scalars['Boolean']>;
    isRedoing?: Maybe<Scalars['Boolean']>;
    isFlush?: Maybe<Scalars['Boolean']>;
};
export declare type IContext = {
    __typename?: 'Context';
    originalResourceScheme?: Maybe<IscmResourceGroups>;
    view?: Maybe<Scalars['String']>;
    viewItem?: Maybe<Scalars['String']>;
    gitOpenRepositoryCount?: Maybe<Scalars['Int']>;
    isInDiffEditor?: Maybe<Scalars['Boolean']>;
    isInDiffRightEditor?: Maybe<Scalars['Boolean']>;
    resourceScheme?: Maybe<Scalars['String']>;
    resourceFilename?: Maybe<Scalars['String']>;
    resourceLangId?: Maybe<Scalars['String']>;
    resource?: Maybe<Scalars['URI']>;
    resourceExtName?: Maybe<Scalars['String']>;
    resourceSet?: Maybe<Scalars['Boolean']>;
    isFileSystemResource?: Maybe<Scalars['Boolean']>;
    inputFocus?: Maybe<Scalars['Boolean']>;
    suggestWidgetVisible?: Maybe<Scalars['Boolean']>;
    suggestWidgetMultipleSuggestions?: Maybe<Scalars['Boolean']>;
    suggestionMakesTextEdit?: Maybe<Scalars['Boolean']>;
    acceptSuggestionOnEnter?: Maybe<Scalars['Boolean']>;
    hasOtherSuggestions?: Maybe<Scalars['Boolean']>;
    groupFocusedInOpenEditors?: Maybe<Scalars['Boolean']>;
    dirtyEditor?: Maybe<Scalars['Boolean']>;
    resourceSelectedForCompare?: Maybe<Scalars['Boolean']>;
    fileCopied?: Maybe<Scalars['Boolean']>;
    breadcrumbsPossible?: Maybe<Scalars['Boolean']>;
    breadcrumbsVisible?: Maybe<Scalars['Boolean']>;
    breadcrumbsActive?: Maybe<Scalars['Boolean']>;
    canNavigateBack?: Maybe<Scalars['Boolean']>;
    canNavigateForward?: Maybe<Scalars['Boolean']>;
    canNavigateToLastEditLocation?: Maybe<Scalars['Boolean']>;
    dirtyDiffVisible?: Maybe<Scalars['Boolean']>;
    cancellableOperation?: Maybe<Scalars['Boolean']>;
    parameterHintsVisible?: Maybe<Scalars['Boolean']>;
    parameterHintsMultipleSignatures?: Maybe<Scalars['Boolean']>;
    markdownPreviewFocus?: Maybe<Scalars['Boolean']>;
    isMac?: Maybe<Scalars['Boolean']>;
    isLinux?: Maybe<Scalars['Boolean']>;
    isWindows?: Maybe<Scalars['Boolean']>;
    remoteAuthority?: Maybe<Scalars['String']>;
    remoteConnectionState?: Maybe<IProvidedRemoteConnectionStates>;
    hasMacNativeTabs?: Maybe<Scalars['Boolean']>;
    supportsWorkspaces?: Maybe<Scalars['Boolean']>;
    isDevelopment?: Maybe<Scalars['Boolean']>;
    workbenchState?: Maybe<Scalars['String']>;
    workspaceFolderCount?: Maybe<Scalars['Int']>;
    remoteFileDialogVisible?: Maybe<Scalars['Boolean']>;
    isFullscreen?: Maybe<Scalars['Boolean']>;
    atEndOfWord?: Maybe<Scalars['Boolean']>;
    scmRepository?: Maybe<Scalars['String']>;
    scmProvider?: Maybe<Scalars['String']>;
    scmResourceGroup?: Maybe<IscmResourceGroups>;
    inDiffEditorKey?: Maybe<Scalars['Boolean']>;
    isDominatedByLongLines?: Maybe<Scalars['Boolean']>;
    isWordWrapMinified?: Maybe<Scalars['Boolean']>;
    commentThread?: Maybe<Scalars['String']>;
    commentThreadisEmpty?: Maybe<Scalars['Boolean']>;
    commentIsEmpty?: Maybe<Scalars['Boolean']>;
    commentEditorFocused?: Maybe<Scalars['Boolean']>;
    interfaceOverviewVisible?: Maybe<Scalars['Boolean']>;
    inReferenceSearchEditor?: Maybe<Scalars['Boolean']>;
    referenceSearchVisible?: Maybe<Scalars['Boolean']>;
    listFocus?: Maybe<Scalars['Boolean']>;
    listSupportsMultiSelect?: Maybe<Scalars['Boolean']>;
    listHasSelectionOrFocus?: Maybe<Scalars['Boolean']>;
    listDoubleSelection?: Maybe<Scalars['Boolean']>;
    listMultiSelection?: Maybe<Scalars['Boolean']>;
    listSupportsKeyboardNavigation?: Maybe<Scalars['Boolean']>;
    WorkbenchListAutomaticKeyboardNavigationKey?: Maybe<Scalars['Boolean']>;
    accessibilityHelpWidgetVisible?: Maybe<Scalars['Boolean']>;
    inQuickOpenKey?: Maybe<Scalars['Boolean']>;
    supportedCodeAction?: Maybe<Scalars['String']>;
    hasSymbols?: Maybe<Scalars['Boolean']>;
    hasSnippetCompletions?: Maybe<Scalars['Boolean']>;
    messageVisible?: Maybe<Scalars['Boolean']>;
    editorHasCallHierarchyProvider?: Maybe<Scalars['Boolean']>;
    callHierarchyVisible?: Maybe<Scalars['Boolean']>;
    searchViewletVisible?: Maybe<Scalars['Boolean']>;
    searchViewletFocus?: Maybe<Scalars['Boolean']>;
    inputBoxFocus?: Maybe<Scalars['Boolean']>;
    searchInputBoxFocus?: Maybe<Scalars['Boolean']>;
    replaceInputBoxFocus?: Maybe<Scalars['Boolean']>;
    patternIncludesInputBoxFocus?: Maybe<Scalars['Boolean']>;
    patternExcludesInputBoxFocus?: Maybe<Scalars['Boolean']>;
    replaceActive?: Maybe<Scalars['Boolean']>;
    hasSearchResult?: Maybe<Scalars['Boolean']>;
    firstMatchFocus?: Maybe<Scalars['Boolean']>;
    fileMatchOrMatchFocus?: Maybe<Scalars['Boolean']>;
    fileMatchOrFolderMatchFocus?: Maybe<Scalars['Boolean']>;
    fileMatchFocus?: Maybe<Scalars['Boolean']>;
    folderMatchFocus?: Maybe<Scalars['Boolean']>;
    matchFocus?: Maybe<Scalars['Boolean']>;
    inRecentFilesPicker?: Maybe<Scalars['Boolean']>;
    inWindowsPicker?: Maybe<Scalars['Boolean']>;
    findWidgetVisible?: Maybe<Scalars['Boolean']>;
    findInputFocussed?: Maybe<Scalars['Boolean']>;
    replaceInputFocussed?: Maybe<Scalars['Boolean']>;
    /** A context key that is set when the editor's text has focus (cursor is blinking). */
    editorTextFocus?: Maybe<Scalars['Boolean']>;
    /** A context key that is set when the editor's text or an editor's widget has focus. */
    editorFocus?: Maybe<Scalars['Boolean']>;
    /** A context key that is set when any editor input has focus (regular editor, repl input...). */
    textInputFocus?: Maybe<Scalars['Boolean']>;
    editorReadonly?: Maybe<Scalars['Boolean']>;
    editorHasSelection?: Maybe<Scalars['Boolean']>;
    editorHasMultipleSelections?: Maybe<Scalars['Boolean']>;
    editorTabMoveFocus?: Maybe<Scalars['Boolean']>;
    isInEmbeddedEditor?: Maybe<Scalars['Boolean']>;
    canUndo?: Maybe<Scalars['Boolean']>;
    canRedo?: Maybe<Scalars['Boolean']>;
    editorLangId?: Maybe<Scalars['String']>;
    editorHasCompletionItemProvider?: Maybe<Scalars['Boolean']>;
    editorHasCodeActionsProvider?: Maybe<Scalars['Boolean']>;
    editorHasDefinitionProvider?: Maybe<Scalars['Boolean']>;
    editorHasDeclarationProvider?: Maybe<Scalars['Boolean']>;
    editorHasImplementationProvider?: Maybe<Scalars['Boolean']>;
    editorHasTypeDefinitionProvider?: Maybe<Scalars['Boolean']>;
    editorHasHoverProvider?: Maybe<Scalars['Boolean']>;
    editorHadDocumentHighlightProvider?: Maybe<Scalars['Boolean']>;
    editorHasDocumentSymbolProvider?: Maybe<Scalars['Boolean']>;
    editorHasReferenceProvider?: Maybe<Scalars['Boolean']>;
    editorHasRenameProvider?: Maybe<Scalars['Boolean']>;
    editorHasSignatureHelpProvider?: Maybe<Scalars['Boolean']>;
    editorHasDocumentFormattingProvider?: Maybe<Scalars['Boolean']>;
    editorHasDocumentSelectionFormattingProvider?: Maybe<Scalars['Boolean']>;
    editorHasMultipleDocumentSelectionFormattingProvider?: Maybe<Scalars['Boolean']>;
    activeEditor?: Maybe<Scalars['String']>;
    editorIsOpen?: Maybe<Scalars['Boolean']>;
    editorPinned?: Maybe<Scalars['Boolean']>;
    groupActiveEditorDirty?: Maybe<Scalars['Boolean']>;
    groupEditorsCount?: Maybe<Scalars['Int']>;
    textCompareEditorVisible?: Maybe<Scalars['Boolean']>;
    textCompareEditorActive?: Maybe<Scalars['Boolean']>;
    activeEditorGroupEmpty?: Maybe<Scalars['Boolean']>;
    multipleEditorGroups?: Maybe<Scalars['Boolean']>;
    inZenMode?: Maybe<Scalars['Boolean']>;
    inCenteredLayout?: Maybe<Scalars['Boolean']>;
    splitEditorsVertically?: Maybe<Scalars['Boolean']>;
    sideBarVisible?: Maybe<Scalars['Boolean']>;
    sideBarFocus?: Maybe<Scalars['Boolean']>;
    activeViewlet?: Maybe<Scalars['String']>;
    activePanel?: Maybe<Scalars['String']>;
    panelFocus?: Maybe<Scalars['Boolean']>;
    panelPosition?: Maybe<Scalars['String']>;
    debugType?: Maybe<Scalars['String']>;
    debugConfigurationType?: Maybe<Scalars['String']>;
    debugState?: Maybe<Scalars['String']>;
    inDebugMode?: Maybe<Scalars['Boolean']>;
    inDebugRepl?: Maybe<Scalars['Boolean']>;
    breakpointWidgetVisible?: Maybe<Scalars['Boolean']>;
    watchExpressionsFocused?: Maybe<Scalars['Boolean']>;
    variablesFocused?: Maybe<Scalars['Boolean']>;
    expressionSelected?: Maybe<Scalars['Boolean']>;
    breakpointSelected?: Maybe<Scalars['Boolean']>;
    callStackItemType?: Maybe<Scalars['Boolean']>;
    loadedScriptsSupported?: Maybe<Scalars['Boolean']>;
    loadedScriptsItemType?: Maybe<Scalars['Boolean']>;
    focusedSessionIsAttach?: Maybe<Scalars['Boolean']>;
    stepBackSupported?: Maybe<Scalars['Boolean']>;
    restartFrameSupported?: Maybe<Scalars['Boolean']>;
    inSettingsEditor?: Maybe<Scalars['Boolean']>;
    inSettingsJSONEditor?: Maybe<Scalars['Boolean']>;
    inSettingsSearch?: Maybe<Scalars['Boolean']>;
    settingsTocRowFocus?: Maybe<Scalars['Boolean']>;
    inKeybindings?: Maybe<Scalars['Boolean']>;
    inKeybindingsSearch?: Maybe<Scalars['Boolean']>;
    keybindingFocus?: Maybe<Scalars['Boolean']>;
    explorerViewletVisible?: Maybe<Scalars['Boolean']>;
    explorerResourceIsFolder?: Maybe<Scalars['Boolean']>;
    explorerResourceReadonly?: Maybe<Scalars['Boolean']>;
    explorerResourceIsRoot?: Maybe<Scalars['Boolean']>;
    explorerResourceCut?: Maybe<Scalars['Boolean']>;
    explorerResourceMoveableToTrash?: Maybe<Scalars['Boolean']>;
    filesExplorerFocus?: Maybe<Scalars['Boolean']>;
    openEditorsVisible?: Maybe<Scalars['Boolean']>;
    openEditorsFocus?: Maybe<Scalars['Boolean']>;
    explorerViewletFocus?: Maybe<Scalars['Boolean']>;
    /** A context key that is set when there is at least one opened integrated terminal. */
    terminalIsOpen?: Maybe<Scalars['Boolean']>;
    /** A context key that is set when the integrated terminal has focus. */
    terminalFocus?: Maybe<Scalars['Boolean']>;
    /** A keybinding context key that is set when the integrated terminal has text selected. */
    terminalTextSelected?: Maybe<Scalars['Boolean']>;
    /** A context key that is set when the find widget in integrated terminal is visible. */
    terminalFindWidgetVisible?: Maybe<Scalars['Boolean']>;
    /** A context key that is set when the find widget find input in integrated terminal is focused. */
    terminalFindWidgetInputFocused?: Maybe<Scalars['Boolean']>;
    /** A context key that is set when the find widget in integrated terminal is focused. */
    terminalFindWidgetFocused?: Maybe<Scalars['Boolean']>;
    /** Set when the find widget in a webview is visible */
    webviewFindWidgetVisible?: Maybe<Scalars['Boolean']>;
    taskRunning?: Maybe<Scalars['Boolean']>;
    referenceSearchTreeFocused?: Maybe<Scalars['Boolean']>;
    interactivePlaygroundFocus?: Maybe<Scalars['Boolean']>;
    outlineFiltered?: Maybe<Scalars['Boolean']>;
    outlineFocused?: Maybe<Scalars['Boolean']>;
    problemsViewFocus?: Maybe<Scalars['Boolean']>;
    problemFocus?: Maybe<Scalars['Boolean']>;
    problemsFilterFocus?: Maybe<Scalars['Boolean']>;
    relatedInformationFocus?: Maybe<Scalars['Boolean']>;
    inOutput?: Maybe<Scalars['Boolean']>;
    activeLogOutput?: Maybe<Scalars['Boolean']>;
    multiCursorModifier?: Maybe<Scalars['String']>;
    saveConflictResolutionContext?: Maybe<Scalars['Boolean']>;
    markersNavigationVisible?: Maybe<Scalars['Boolean']>;
    hasWordHighlights?: Maybe<Scalars['Boolean']>;
    profileSessionState?: Maybe<Scalars['String']>;
    extensionHostProfileRecorded?: Maybe<Scalars['Boolean']>;
    historyNavigationEnabled?: Maybe<Scalars['Boolean']>;
    historyNavigationWidget?: Maybe<Scalars['Boolean']>;
    nonEmptyWorkspace?: Maybe<Scalars['Boolean']>;
    defaultExtensionViews?: Maybe<Scalars['Boolean']>;
    searchMarketplaceExtensions?: Maybe<Scalars['Boolean']>;
    searchInstalledExtensions?: Maybe<Scalars['Boolean']>;
    searchOutdatedExtensions?: Maybe<Scalars['Boolean']>;
    searchEnabledExtensions?: Maybe<Scalars['Boolean']>;
    searchDisabledExtensions?: Maybe<Scalars['Boolean']>;
    hasInstalledExtensions?: Maybe<Scalars['Boolean']>;
    searchBuiltInExtensions?: Maybe<Scalars['Boolean']>;
    recommendedExtensions?: Maybe<Scalars['Boolean']>;
    defaultRecommendedExtensions?: Maybe<Scalars['Boolean']>;
    workspaceRecommendations?: Maybe<Scalars['Boolean']>;
    workspaceFolderRecommendations?: Maybe<Scalars['Boolean']>;
    addToWorkspaceRecommendations?: Maybe<Scalars['Boolean']>;
    addToWorkspaceFolderRecommendations?: Maybe<Scalars['Boolean']>;
};
export declare type IContextInput = {
    folder?: Maybe<Scalars['String']>;
    originalResourceScheme?: Maybe<IscmResourceGroups>;
    view?: Maybe<Scalars['String']>;
    viewItem?: Maybe<Scalars['String']>;
    gitOpenRepositoryCount?: Maybe<Scalars['Int']>;
    isInDiffEditor?: Maybe<Scalars['Boolean']>;
    isInDiffRightEditor?: Maybe<Scalars['Boolean']>;
    resourceScheme?: Maybe<Scalars['String']>;
    resourceFilename?: Maybe<Scalars['String']>;
    resourceLangId?: Maybe<Scalars['String']>;
    resource?: Maybe<Scalars['URI']>;
    resourceExtName?: Maybe<Scalars['String']>;
    resourceSet?: Maybe<Scalars['Boolean']>;
    isFileSystemResource?: Maybe<Scalars['Boolean']>;
    inputFocus?: Maybe<Scalars['Boolean']>;
    suggestWidgetVisible?: Maybe<Scalars['Boolean']>;
    suggestWidgetMultipleSuggestions?: Maybe<Scalars['Boolean']>;
    suggestionMakesTextEdit?: Maybe<Scalars['Boolean']>;
    acceptSuggestionOnEnter?: Maybe<Scalars['Boolean']>;
    hasOtherSuggestions?: Maybe<Scalars['Boolean']>;
    groupFocusedInOpenEditors?: Maybe<Scalars['Boolean']>;
    dirtyEditor?: Maybe<Scalars['Boolean']>;
    resourceSelectedForCompare?: Maybe<Scalars['Boolean']>;
    fileCopied?: Maybe<Scalars['Boolean']>;
    breadcrumbsPossible?: Maybe<Scalars['Boolean']>;
    breadcrumbsVisible?: Maybe<Scalars['Boolean']>;
    breadcrumbsActive?: Maybe<Scalars['Boolean']>;
    canNavigateBack?: Maybe<Scalars['Boolean']>;
    canNavigateForward?: Maybe<Scalars['Boolean']>;
    canNavigateToLastEditLocation?: Maybe<Scalars['Boolean']>;
    dirtyDiffVisible?: Maybe<Scalars['Boolean']>;
    cancellableOperation?: Maybe<Scalars['Boolean']>;
    parameterHintsVisible?: Maybe<Scalars['Boolean']>;
    parameterHintsMultipleSignatures?: Maybe<Scalars['Boolean']>;
    markdownPreviewFocus?: Maybe<Scalars['Boolean']>;
    isMac?: Maybe<Scalars['Boolean']>;
    isLinux?: Maybe<Scalars['Boolean']>;
    isWindows?: Maybe<Scalars['Boolean']>;
    remoteAuthority?: Maybe<Scalars['String']>;
    remoteConnectionState?: Maybe<IProvidedRemoteConnectionStates>;
    hasMacNativeTabs?: Maybe<Scalars['Boolean']>;
    supportsWorkspaces?: Maybe<Scalars['Boolean']>;
    isDevelopment?: Maybe<Scalars['Boolean']>;
    workbenchState?: Maybe<Scalars['String']>;
    workspaceFolderCount?: Maybe<Scalars['Int']>;
    remoteFileDialogVisible?: Maybe<Scalars['Boolean']>;
    isFullscreen?: Maybe<Scalars['Boolean']>;
    atEndOfWord?: Maybe<Scalars['Boolean']>;
    scmRepository?: Maybe<Scalars['String']>;
    scmProvider?: Maybe<Scalars['String']>;
    scmResourceGroup?: Maybe<IscmResourceGroups>;
    inDiffEditorKey?: Maybe<Scalars['Boolean']>;
    isDominatedByLongLines?: Maybe<Scalars['Boolean']>;
    isWordWrapMinified?: Maybe<Scalars['Boolean']>;
    commentThread?: Maybe<Scalars['String']>;
    commentThreadisEmpty?: Maybe<Scalars['Boolean']>;
    commentIsEmpty?: Maybe<Scalars['Boolean']>;
    commentEditorFocused?: Maybe<Scalars['Boolean']>;
    interfaceOverviewVisible?: Maybe<Scalars['Boolean']>;
    inReferenceSearchEditor?: Maybe<Scalars['Boolean']>;
    referenceSearchVisible?: Maybe<Scalars['Boolean']>;
    listFocus?: Maybe<Scalars['Boolean']>;
    listSupportsMultiSelect?: Maybe<Scalars['Boolean']>;
    listHasSelectionOrFocus?: Maybe<Scalars['Boolean']>;
    listDoubleSelection?: Maybe<Scalars['Boolean']>;
    listMultiSelection?: Maybe<Scalars['Boolean']>;
    listSupportsKeyboardNavigation?: Maybe<Scalars['Boolean']>;
    WorkbenchListAutomaticKeyboardNavigationKey?: Maybe<Scalars['Boolean']>;
    accessibilityHelpWidgetVisible?: Maybe<Scalars['Boolean']>;
    inQuickOpenKey?: Maybe<Scalars['Boolean']>;
    supportedCodeAction?: Maybe<Scalars['String']>;
    renameInputVisible?: Maybe<Scalars['Boolean']>;
    hasSymbols?: Maybe<Scalars['Boolean']>;
    hasSnippetCompletions?: Maybe<Scalars['Boolean']>;
    messageVisible?: Maybe<Scalars['Boolean']>;
    editorHasCallHierarchyProvider?: Maybe<Scalars['Boolean']>;
    callHierarchyVisible?: Maybe<Scalars['Boolean']>;
    notificationCenterVisible?: Maybe<Scalars['Boolean']>;
    notificationToastsVisible?: Maybe<Scalars['Boolean']>;
    notificationFocus?: Maybe<Scalars['Boolean']>;
    searchViewletVisible?: Maybe<Scalars['Boolean']>;
    searchViewletFocus?: Maybe<Scalars['Boolean']>;
    inputBoxFocus?: Maybe<Scalars['Boolean']>;
    searchInputBoxFocus?: Maybe<Scalars['Boolean']>;
    replaceInputBoxFocus?: Maybe<Scalars['Boolean']>;
    patternIncludesInputBoxFocus?: Maybe<Scalars['Boolean']>;
    patternExcludesInputBoxFocus?: Maybe<Scalars['Boolean']>;
    replaceActive?: Maybe<Scalars['Boolean']>;
    hasSearchResult?: Maybe<Scalars['Boolean']>;
    firstMatchFocus?: Maybe<Scalars['Boolean']>;
    fileMatchOrMatchFocus?: Maybe<Scalars['Boolean']>;
    fileMatchOrFolderMatchFocus?: Maybe<Scalars['Boolean']>;
    fileMatchFocus?: Maybe<Scalars['Boolean']>;
    folderMatchFocus?: Maybe<Scalars['Boolean']>;
    matchFocus?: Maybe<Scalars['Boolean']>;
    inRecentFilesPicker?: Maybe<Scalars['Boolean']>;
    inWindowsPicker?: Maybe<Scalars['Boolean']>;
    findWidgetVisible?: Maybe<Scalars['Boolean']>;
    findInputFocussed?: Maybe<Scalars['Boolean']>;
    replaceInputFocussed?: Maybe<Scalars['Boolean']>;
    /** A context key that is set when the editor's text has focus (cursor is blinking). */
    editorTextFocus?: Maybe<Scalars['Boolean']>;
    /** A context key that is set when the editor's text or an editor's widget has focus. */
    editorFocus?: Maybe<Scalars['Boolean']>;
    /** A context key that is set when any editor input has focus (regular editor, repl input...). */
    textInputFocus?: Maybe<Scalars['Boolean']>;
    editorReadonly?: Maybe<Scalars['Boolean']>;
    editorHasSelection?: Maybe<Scalars['Boolean']>;
    editorHasMultipleSelections?: Maybe<Scalars['Boolean']>;
    editorTabMoveFocus?: Maybe<Scalars['Boolean']>;
    isInEmbeddedEditor?: Maybe<Scalars['Boolean']>;
    canUndo?: Maybe<Scalars['Boolean']>;
    canRedo?: Maybe<Scalars['Boolean']>;
    editorLangId?: Maybe<Scalars['String']>;
    editorHasCompletionItemProvider?: Maybe<Scalars['Boolean']>;
    editorHasCodeActionsProvider?: Maybe<Scalars['Boolean']>;
    editorHasDefinitionProvider?: Maybe<Scalars['Boolean']>;
    editorHasDeclarationProvider?: Maybe<Scalars['Boolean']>;
    editorHasImplementationProvider?: Maybe<Scalars['Boolean']>;
    editorHasTypeDefinitionProvider?: Maybe<Scalars['Boolean']>;
    editorHasHoverProvider?: Maybe<Scalars['Boolean']>;
    editorHadDocumentHighlightProvider?: Maybe<Scalars['Boolean']>;
    editorHasDocumentSymbolProvider?: Maybe<Scalars['Boolean']>;
    editorHasReferenceProvider?: Maybe<Scalars['Boolean']>;
    editorHasRenameProvider?: Maybe<Scalars['Boolean']>;
    editorHasSignatureHelpProvider?: Maybe<Scalars['Boolean']>;
    editorHasDocumentFormattingProvider?: Maybe<Scalars['Boolean']>;
    editorHasDocumentSelectionFormattingProvider?: Maybe<Scalars['Boolean']>;
    editorHasMultipleDocumentSelectionFormattingProvider?: Maybe<Scalars['Boolean']>;
    activeEditor?: Maybe<Scalars['String']>;
    editorIsOpen?: Maybe<Scalars['Boolean']>;
    editorPinned?: Maybe<Scalars['Boolean']>;
    groupActiveEditorDirty?: Maybe<Scalars['Boolean']>;
    groupEditorsCount?: Maybe<Scalars['Int']>;
    textCompareEditorVisible?: Maybe<Scalars['Boolean']>;
    textCompareEditorActive?: Maybe<Scalars['Boolean']>;
    activeEditorGroupEmpty?: Maybe<Scalars['Boolean']>;
    multipleEditorGroups?: Maybe<Scalars['Boolean']>;
    inZenMode?: Maybe<Scalars['Boolean']>;
    inCenteredLayout?: Maybe<Scalars['Boolean']>;
    splitEditorsVertically?: Maybe<Scalars['Boolean']>;
    sideBarVisible?: Maybe<Scalars['Boolean']>;
    sideBarFocus?: Maybe<Scalars['Boolean']>;
    activeViewlet?: Maybe<Scalars['String']>;
    activePanel?: Maybe<Scalars['String']>;
    panelFocus?: Maybe<Scalars['Boolean']>;
    panelPosition?: Maybe<Scalars['String']>;
    debugType?: Maybe<Scalars['String']>;
    debugConfigurationType?: Maybe<Scalars['String']>;
    debugState?: Maybe<Scalars['String']>;
    inDebugMode?: Maybe<Scalars['Boolean']>;
    inDebugRepl?: Maybe<Scalars['Boolean']>;
    breakpointWidgetVisible?: Maybe<Scalars['Boolean']>;
    watchExpressionsFocused?: Maybe<Scalars['Boolean']>;
    variablesFocused?: Maybe<Scalars['Boolean']>;
    expressionSelected?: Maybe<Scalars['Boolean']>;
    breakpointSelected?: Maybe<Scalars['Boolean']>;
    callStackItemType?: Maybe<Scalars['Boolean']>;
    loadedScriptsSupported?: Maybe<Scalars['Boolean']>;
    loadedScriptsItemType?: Maybe<Scalars['Boolean']>;
    focusedSessionIsAttach?: Maybe<Scalars['Boolean']>;
    stepBackSupported?: Maybe<Scalars['Boolean']>;
    restartFrameSupported?: Maybe<Scalars['Boolean']>;
    inSettingsEditor?: Maybe<Scalars['Boolean']>;
    inSettingsJSONEditor?: Maybe<Scalars['Boolean']>;
    inSettingsSearch?: Maybe<Scalars['Boolean']>;
    settingsTocRowFocus?: Maybe<Scalars['Boolean']>;
    inKeybindings?: Maybe<Scalars['Boolean']>;
    inKeybindingsSearch?: Maybe<Scalars['Boolean']>;
    keybindingFocus?: Maybe<Scalars['Boolean']>;
    explorerViewletVisible?: Maybe<Scalars['Boolean']>;
    explorerResourceIsFolder?: Maybe<Scalars['Boolean']>;
    explorerResourceReadonly?: Maybe<Scalars['Boolean']>;
    explorerResourceIsRoot?: Maybe<Scalars['Boolean']>;
    explorerResourceCut?: Maybe<Scalars['Boolean']>;
    explorerResourceMoveableToTrash?: Maybe<Scalars['Boolean']>;
    filesExplorerFocus?: Maybe<Scalars['Boolean']>;
    openEditorsVisible?: Maybe<Scalars['Boolean']>;
    openEditorsFocus?: Maybe<Scalars['Boolean']>;
    explorerViewletFocus?: Maybe<Scalars['Boolean']>;
    /** A context key that is set when there is at least one opened integrated terminal. */
    terminalIsOpen?: Maybe<Scalars['Boolean']>;
    /** A context key that is set when the integrated terminal has focus. */
    terminalFocus?: Maybe<Scalars['Boolean']>;
    /** A keybinding context key that is set when the integrated terminal has text selected. */
    terminalTextSelected?: Maybe<Scalars['Boolean']>;
    /** A context key that is set when the find widget in integrated terminal is visible. */
    terminalFindWidgetVisible?: Maybe<Scalars['Boolean']>;
    /** A context key that is set when the find widget find input in integrated terminal is focused. */
    terminalFindWidgetInputFocused?: Maybe<Scalars['Boolean']>;
    /** A context key that is set when the find widget in integrated terminal is focused. */
    terminalFindWidgetFocused?: Maybe<Scalars['Boolean']>;
    /** Set when the find widget in a webview is visible */
    webviewFindWidgetVisible?: Maybe<Scalars['Boolean']>;
    taskRunning?: Maybe<Scalars['Boolean']>;
    referenceSearchTreeFocused?: Maybe<Scalars['Boolean']>;
    interactivePlaygroundFocus?: Maybe<Scalars['Boolean']>;
    outlineFiltered?: Maybe<Scalars['Boolean']>;
    outlineFocused?: Maybe<Scalars['Boolean']>;
    problemsViewFocus?: Maybe<Scalars['Boolean']>;
    problemFocus?: Maybe<Scalars['Boolean']>;
    problemsFilterFocus?: Maybe<Scalars['Boolean']>;
    relatedInformationFocus?: Maybe<Scalars['Boolean']>;
    inOutput?: Maybe<Scalars['Boolean']>;
    activeLogOutput?: Maybe<Scalars['Boolean']>;
    multiCursorModifier?: Maybe<Scalars['String']>;
    saveConflictResolutionContext?: Maybe<Scalars['Boolean']>;
    markersNavigationVisible?: Maybe<Scalars['Boolean']>;
    hasWordHighlights?: Maybe<Scalars['Boolean']>;
    profileSessionState?: Maybe<Scalars['String']>;
    extensionHostProfileRecorded?: Maybe<Scalars['Boolean']>;
    historyNavigationEnabled?: Maybe<Scalars['Boolean']>;
    historyNavigationWidget?: Maybe<Scalars['Boolean']>;
    nonEmptyWorkspace?: Maybe<Scalars['Boolean']>;
    defaultExtensionViews?: Maybe<Scalars['Boolean']>;
    searchMarketplaceExtensions?: Maybe<Scalars['Boolean']>;
    searchInstalledExtensions?: Maybe<Scalars['Boolean']>;
    searchOutdatedExtensions?: Maybe<Scalars['Boolean']>;
    searchEnabledExtensions?: Maybe<Scalars['Boolean']>;
    searchDisabledExtensions?: Maybe<Scalars['Boolean']>;
    hasInstalledExtensions?: Maybe<Scalars['Boolean']>;
    searchBuiltInExtensions?: Maybe<Scalars['Boolean']>;
    recommendedExtensions?: Maybe<Scalars['Boolean']>;
    defaultRecommendedExtensions?: Maybe<Scalars['Boolean']>;
    workspaceRecommendations?: Maybe<Scalars['Boolean']>;
    workspaceFolderRecommendations?: Maybe<Scalars['Boolean']>;
    addToWorkspaceRecommendations?: Maybe<Scalars['Boolean']>;
    addToWorkspaceFolderRecommendations?: Maybe<Scalars['Boolean']>;
};
export declare type IContextMenu = {
    __typename?: 'ContextMenu';
    id?: Maybe<Scalars['String']>;
    isShow?: Maybe<Scalars['Boolean']>;
    anchor?: Maybe<IAnchor>;
    menuItems?: Maybe<Array<Maybe<IMenuItem>>>;
};
export declare type IContextMenu_input = {
    isShow?: Maybe<Scalars['Boolean']>;
    anchor?: Maybe<IAnchor_input>;
    menuItems?: Maybe<Array<Maybe<IMenuItem_input>>>;
};
/** @deprecated use IExtensionContributions */
export declare type IContributes = {
    __typename?: 'Contributes';
    menus?: Maybe<IMenus>;
    actions?: Maybe<Array<Maybe<IActions>>>;
};
export declare type ICopyEditorOptions_Input = {
    index?: Maybe<Scalars['Int']>;
    inactive?: Maybe<Scalars['Boolean']>;
    preserveFocus?: Maybe<Scalars['Boolean']>;
};
export declare type ICrashReporterStartOptions = {
    __typename?: 'CrashReporterStartOptions';
    companyName?: Maybe<Scalars['String']>;
    submitURL?: Maybe<Scalars['String']>;
    productName?: Maybe<Scalars['String']>;
    uploadToServer?: Maybe<Scalars['Boolean']>;
    ignoreSystemCrashHandler?: Maybe<Scalars['Boolean']>;
    extra?: Maybe<Scalars['AnyObject']>;
    crashesDirectory?: Maybe<Scalars['String']>;
};
export declare type ICreateFileOptions_Input = {
    /**
     * Overwrite the file to create if it already exists on disk. Otherwise
     * an error will be thrown (FILE_MODIFIED_SINCE).
     */
    overwrite?: Maybe<Scalars['Boolean']>;
};
export declare type ICursorState = {
    __typename?: 'CursorState';
    inSelectionMode?: Maybe<Scalars['Boolean']>;
    selectionStart?: Maybe<IPosition>;
    position?: Maybe<IPosition>;
};
export declare type ICursorState_Input = {
    inSelectionMode?: Maybe<Scalars['Boolean']>;
    selectionStart?: Maybe<IPositionInput>;
    position?: Maybe<IPositionInput>;
};
/**
 * An editor input to present data URIs in a binary editor. Data URIs have the form of:
 * data:[mime type];[meta data <key=value>;...];base64,[base64 encoded value]
 */
export declare type IDataUriEditorInput = IIEditorInput & IIEditorInputWithGroupFields & {
    __typename?: 'DataUriEditorInput';
    id?: Maybe<Scalars['String']>;
    resource?: Maybe<Scalars['String']>;
    typeId?: Maybe<IEDITOR_INPUT_ID>;
    description?: Maybe<Scalars['String']>;
    label?: Maybe<Scalars['String']>;
    fileReference?: Maybe<IFileStatWithMetadata>;
    preferredEditorId?: Maybe<Scalars['String']>;
    isSupportsSplitEditor?: Maybe<Scalars['Boolean']>;
    isActive?: Maybe<Scalars['Boolean']>;
    preview?: Maybe<Scalars['Boolean']>;
    isPinned?: Maybe<Scalars['Boolean']>;
    editorId?: Maybe<Scalars['Int']>;
    status?: Maybe<Scalars['String']>;
    closable?: Maybe<Scalars['Boolean']>;
    /** The mime of the binary resource if known. */
    mime?: Maybe<Scalars['String']>;
    /** The etag of the binary resource if known. */
    etag?: Maybe<Scalars['String']>;
    /** The size of the binary resource if known. */
    size?: Maybe<Scalars['Int']>;
};
export declare type IDebugger = {
    __typename?: 'Debugger';
    label?: Maybe<Scalars['String']>;
    type?: Maybe<Scalars['String']>;
    runtime?: Maybe<Scalars['String']>;
};
export declare type IDefaultPreferencesResponse = {
    __typename?: 'DefaultPreferencesResponse';
    preferences?: Maybe<Array<Maybe<IPreferencesType>>>;
};
export declare type IDefaultSettings = IISettingsSubject & {
    __typename?: 'DefaultSettings';
    /**  The ID.  */
    id?: Maybe<Scalars['ID']>;
    /**  The latest settings.  */
    latestSettings?: Maybe<ISettings>;
    /**  The URL to the settings.  */
    settingsURL: Scalars['URI'];
    /**  Whether the viewer can modify the subject's settings. */
    viewerCanAdminister: Scalars['Boolean'];
    /**
     * All settings for this subject, and the individual levels in the settings cascade (global > organization > user)
     * that were merged to produce the final merged settings.
     */
    settingsCascade: ISettingsCascade;
};
export declare type IDeleteFileOptions_Input = {
    useTrash?: Maybe<Scalars['Boolean']>;
    recursive?: Maybe<Scalars['Boolean']>;
};
export declare type IDetail = {
    __typename?: 'Detail';
    inputName?: Maybe<Scalars['String']>;
    inputType?: Maybe<IInputTypeDetail>;
    label?: Maybe<Scalars['String']>;
    placeholder?: Maybe<Scalars['String']>;
    defaultValue?: Maybe<Scalars['String']>;
    required?: Maybe<Scalars['Boolean']>;
};
export declare type IDetail_input = {
    inputName?: Maybe<Scalars['String']>;
    inputType?: Maybe<IInputTypeDetail_input>;
    label?: Maybe<Scalars['String']>;
    placeholder?: Maybe<Scalars['String']>;
    defaultValue?: Maybe<Scalars['String']>;
    required?: Maybe<Scalars['Boolean']>;
};
export declare type IDevToolsOptions = {
    __typename?: 'DevToolsOptions';
    mode?: Maybe<IDevToolsOptionsMode>;
};
export declare const enum IDevToolsOptionsMode {
    right = "right",
    botton = "botton",
    undocked = "undocked",
    detach = "detach"
}
export declare type IDialog = {
    __typename?: 'Dialog';
    dialogType?: Maybe<Scalars['String']>;
    detail?: Maybe<Array<Maybe<IDetail>>>;
    primaryButton?: Maybe<IPrimaryButtonAction>;
    secondaryButton?: Maybe<Scalars['String']>;
    checkbox?: Maybe<ICheckboxOptions>;
};
export declare type IDialog_input = {
    dialogType?: Maybe<Scalars['String']>;
    detail?: Maybe<Array<Maybe<IDetail_input>>>;
    primaryButton?: Maybe<IPrimaryButtonAction_input>;
    secondaryButton?: Maybe<Scalars['String']>;
    checkbox?: Maybe<ICheckboxOptions_input>;
};
export declare type IDialogResult = {
    __typename?: 'DialogResult';
    confirmed?: Maybe<Scalars['Boolean']>;
    checkboxChecked?: Maybe<Scalars['Boolean']>;
};
/**
 * The base editor input for the diff editor. It is made up of two editor inputs, the original version
 * and the modified version.
 */
export declare type IDiffEditorInput = IIEditorInput & IIEditorInputWithGroupFields & {
    __typename?: 'DiffEditorInput';
    id?: Maybe<Scalars['String']>;
    resource?: Maybe<Scalars['String']>;
    typeId?: Maybe<IEDITOR_INPUT_ID>;
    description?: Maybe<Scalars['String']>;
    label?: Maybe<Scalars['String']>;
    fileReference?: Maybe<IFileStatWithMetadata>;
    preferredEditorId?: Maybe<Scalars['String']>;
    isSupportsSplitEditor?: Maybe<Scalars['Boolean']>;
    isActive?: Maybe<Scalars['Boolean']>;
    preview?: Maybe<Scalars['Boolean']>;
    isPinned?: Maybe<Scalars['Boolean']>;
    editorId?: Maybe<Scalars['Int']>;
    status?: Maybe<Scalars['String']>;
    closable?: Maybe<Scalars['Boolean']>;
    originalInput?: Maybe<IEditorInput>;
    modifiedInput?: Maybe<IEditorInput>;
};
/** @deprecated Not sure whether it is needed. */
export declare type IDockLayout = {
    __typename?: 'DockLayout';
    id?: Maybe<Scalars['Int']>;
    size?: Maybe<Scalars['Int']>;
    activeId?: Maybe<Scalars['String']>;
    mode?: Maybe<GroupOrientation>;
    children?: Maybe<Array<Maybe<IDockLayout>>>;
    tabs?: Maybe<Array<Maybe<IEditorInput>>>;
};
/**  A CDECode product documentation page. */
export declare type IDocSitePage = {
    __typename?: 'DocSitePage';
    /**  The title of this page. */
    title: Scalars['String'];
    /**  The content, as Markdown-rendered HTML. */
    contentHTML: Scalars['String'];
    /**  The page index, as rendered HTML. */
    indexHTML: Scalars['String'];
    /**  The filename of the file containing this page's content. */
    filePath: Scalars['String'];
};
export declare type IDocumentFilter = {
    __typename?: 'DocumentFilter';
    language: Scalars['String'];
    schema?: Maybe<Scalars['String']>;
    pattern?: Maybe<Scalars['String']>;
};
export declare type IEditKeybindingItem = {
    __typename?: 'EditKeybindingItem';
    command?: Maybe<Scalars['String']>;
    key?: Maybe<Scalars['String']>;
    when?: Maybe<Scalars['String']>;
    isDefault?: Maybe<Scalars['Boolean']>;
};
export declare const enum IEDITOR_ID {
    TEXT_RESOURCE_EDITOR = "TEXT_RESOURCE_EDITOR",
    TEXT_DIFF_EDITOR = "TEXT_DIFF_EDITOR",
    BINARY_DIFF_EDITOR = "BINARY_DIFF_EDITOR",
    SIDE_BY_SIDE_EDITOR = "SIDE_BY_SIDE_EDITOR"
}
export declare const enum IEDITOR_INPUT_ID {
    DATA_URI_EDITOR_INPUT = "DATA_URI_EDITOR_INPUT",
    DEFAULT_PREFERENCES_EDITOR_INPUT = "DEFAULT_PREFERENCES_EDITOR_INPUT",
    DIFF_EDITOR_INPUT = "DIFF_EDITOR_INPUT",
    FILE_EDITOR_INPUT = "FILE_EDITOR_INPUT",
    KEYBINDINGS_EDITOR_INPUT = "KEYBINDINGS_EDITOR_INPUT",
    PREFERENCES_EDITOR_INPUT = "PREFERENCES_EDITOR_INPUT",
    RESOURCE_EDITOR_INPUT = "RESOURCE_EDITOR_INPUT",
    SETTINGS2_EDITOR_INPUT = "SETTINGS2_EDITOR_INPUT",
    SIDE_BY_SIDE_EDITOR_INPUT = "SIDE_BY_SIDE_EDITOR_INPUT",
    file = "file"
}
export declare const enum IEDITOR_INPUT_RESOURCE_TYPE_ID {
    /** If the resource is `file` */
    file = "file"
}
export declare const enum IEditorActionType {
    init = "init",
    add = "add",
    remove = "remove",
    removeAll = "removeAll",
    activateEditor = "activateEditor"
}
export declare const enum IEditorActivation {
    /**
     *    Activate the editor after it opened. This will automatically restore
     * the editor if it is minimized.
     */
    ACTIVATE = "ACTIVATE",
    /**
     *    Only restore the editor if it is minimized but do not activate it.
     *
     * Note: will only work in combination with the `preserveFocus: true` option.
     * Otherwise, if focus moves into the editor, it will activate and restore
     * automatically.
     */
    RESTORE = "RESTORE",
    /**
     *    Preserve the current active editor.
     *
     * Note: will only work in combination with the `preserveFocus: true` option.
     * Otherwise, if focus moves into the editor, it will activate and restore
     * automatically.
     */
    PRESERVE = "PRESERVE"
}
export declare type IEditorChildren = IEditorPart | IEditorGroup;
export declare type IEditorChildren_Input = {
    /**
     * A unique identifier of this group that remains identical even if the
     * group is moved to different locations.
     */
    id: Scalars['Int'];
    mode?: Maybe<GroupOrientation>;
    children?: Maybe<Array<Maybe<IEditorChildren_Input>>>;
    /**
     * Size of the editor group.
     * Width when in `orientation.HORIZONTAL` and height when in `orientation.VERTICAL`
     */
    size?: Maybe<Scalars['Int']>;
    /** the id of current tab */
    activeId?: Maybe<Scalars['String']>;
    tabs?: Maybe<Array<Maybe<IEditorInput_Input>>>;
};
export declare type IEditorGroup = IIEditorGroup & {
    __typename?: 'EditorGroup';
    id: Scalars['Int'];
    label?: Maybe<Scalars['String']>;
    /** Whether it is an active group. */
    isActive?: Maybe<Scalars['Boolean']>;
    /**
     * Size of the editor group.
     * Width when in `orientation.HORIZONTAL` and height when in `orientation.VERTICAL`
     */
    size?: Maybe<Scalars['Int']>;
    /** the id of current tab */
    activeId?: Maybe<Scalars['String']>;
    /** All the Editors that are opened undered this group. */
    tabs?: Maybe<Array<Maybe<IEditorInput>>>;
};
export declare type IEditorGroupLayout = {
    __typename?: 'EditorGroupLayout';
    orientation?: Maybe<GroupOrientation>;
    groups?: Maybe<Array<Maybe<IGroupLayoutArgument>>>;
};
export declare type IEditorIdentifier = {
    __typename?: 'EditorIdentifier';
    groupId?: Maybe<Scalars['Int']>;
    editor?: Maybe<IEditorInput>;
};
export declare type IEditorInput = IDataUriEditorInput | IDiffEditorInput | IFileEditorInput | IKeybindingEditorInput | IPreferencesEditorInput | IResourceEditorInput | ISideBySideEditorInput | IUntitledEditorInput;
export declare type IEditorInput_Input = {
    id?: Maybe<Scalars['String']>;
    resource: Scalars['String'];
    name?: Maybe<Scalars['String']>;
    label?: Maybe<Scalars['String']>;
    typeId?: Maybe<IEDITOR_INPUT_ID>;
};
export declare type IEditorLayout_Input = {
    /**
     * A unique identifier of this group that remains identical even if the
     * group is moved to different locations.
     */
    id: Scalars['Int'];
    mode?: Maybe<GroupOrientation>;
    /**
     * Size of the editor group.
     * Width when in `orientation.HORIZONTAL` and height when in `orientation.VERTICAL`
     */
    size?: Maybe<Scalars['Int']>;
    children?: Maybe<Array<Maybe<IEditorChildren_Input>>>;
};
export declare const enum IEditorOpenContext {
    /**
     * Default: the editor is opening via a programmatic call
     * to the editor service API.
     */
    API = "API",
    /**
     * Indicates that a user action triggered the opening, e.g,
     * via mouse or keyboard use.
     */
    USER = "USER"
}
export declare type IEditorOpenOptions_Input = {
    editorOpenPositioning?: Maybe<EditorOpenPositioning>;
    focusRecentEditorAfterClose?: Maybe<Scalars['Boolean']>;
    pinned?: Maybe<Scalars['Boolean']>;
    active?: Maybe<Scalars['Boolean']>;
    index?: Maybe<Scalars['Int']>;
};
export { EditorOpenPositioning };
export declare type IEditorOptions_Input = {
    /**
     * Tells the editor to not receive keyboard focus when the editor is being opened.
     *
     * Will also not activate the group the editor opens in unless the group is already
     * the active one. This behaviour can be overridden via the `activation` option.
     */
    preserveFocus?: Maybe<Scalars['Boolean']>;
    /**
     * This option is only relevant if an editor is opened into a group that is not active
     * already and allows to control if the inactive group should become active, restored
     * or preserved.
     *
     * By default, the editor group will become active unless `preserveFocus` or `inactive`
     * is specified.
     */
    activation?: Maybe<IEditorActivation>;
    /**
     * Tells the editor to reload the editor input in the editor even if it is identical to the one
     * already showing. By default, the editor will not reload the input if it is identical to the
     * one showing.
     */
    forceReload?: Maybe<Scalars['Boolean']>;
    /**
     * Will reveal the editor if it is already opened and visible in any of the opened editor groups.
     *
     * Note that this option is just a hint that might be ignored if the user wants to open an editor explicitly
     * to the side of another one or into a specific editor group.
     */
    revealIfVisible?: Maybe<Scalars['Boolean']>;
    /**
     * Will reveal the editor if it is already opened (even when not visible) in any of the opened editor groups.
     *
     * Note that this option is just a hint that might be ignored if the user wants to open an editor explicitly
     * to the side of another one or into a specific editor group.
     */
    revealIfOpened?: Maybe<Scalars['Boolean']>;
    /**
     * An editor that is pinned remains in the editor stack even when another editor is being opened.
     * An editor that is not pinned will always get replaced by another editor that is not pinned.
     */
    pinned?: Maybe<Scalars['Boolean']>;
    /**
     * An editor that is sticky moves to the beginning of the editors list within the group and will remain
     * there unless explicitly closed. Operations such as "Close All" will not close sticky editors.
     */
    sticky?: Maybe<Scalars['Boolean']>;
    /** The index in the document stack where to insert the editor into when opening. */
    index?: Maybe<Scalars['Int']>;
    /**
     * An active editor that is opened will show its contents directly. Set to true to open an editor
     * in the background.
     *
     * Will also not activate the group the editor opens in unless the group is already
     * the active one. This behaviour can be overridden via the `activation` option.
     */
    inactive?: Maybe<Scalars['Boolean']>;
    /**
     * Will not show an error in case opening the editor fails and thus allows to show a custom error
     * message as needed. By default, an error will be presented as notification if opening was not possible.
     */
    ignoreError?: Maybe<Scalars['Boolean']>;
    /**
     * Allows to override the editor that should be used to display the input:
     * - `undefined`: let the editor decide for itself
     * - `false`: disable overrides
     * - `string`: specific override by id
     */
    override?: Maybe<Scalars['AnyObject']>;
    /**
     * A optional hint to signal in which context the editor opens.
     *
     * If configured to be `EditorOpenContet.USER`, this hint can be
     * used in various places to control the experience. For example,
     * if the editor to open fails with an error, a notification could
     * inform about this in a modal dialog. If the editor opened through
     * some background task, the notification would show in the background,
     * not as a modal dialog.
     */
    context?: Maybe<IEditorOpenContext>;
};
/** Editor part is an extension with EditorGroup with Tabs */
export declare type IEditorPart = {
    __typename?: 'EditorPart';
    /**
     * A unique identifier of this group that remains identical even if the
     * group is moved to different locations.
     */
    id: Scalars['Int'];
    mode?: Maybe<GroupOrientation>;
    /** @deprecated use `size` */
    height?: Maybe<Scalars['Int']>;
    /**
     * Size of the editor group.
     * Width when in `orientation.HORIZONTAL` and height when in `orientation.VERTICAL`
     */
    size?: Maybe<Scalars['Int']>;
    children?: Maybe<Array<Maybe<IEditorChildren>>>;
};
export declare type IEditorPartConfiguration_Input = {
    /**
     * @description Controls whether opened editor should show in tabs or not.
     * @default true
     */
    showTabs?: Maybe<Scalars['Boolean']>;
    /**
     * @description Controls whether a top border is drawn on modified (dirty) editor tabs or not.
     * @default false
     */
    highlightModifiedTabs?: Maybe<Scalars['Boolean']>;
    /**
     * @description Controls the position of the editor's tabs close buttons, or disables them when set to 'off'.
     * @default 'right'
     */
    tabCloseButton?: Maybe<TabCloseButtonType>;
    /**
     * @description Controls the sizing of editor tabs.
     * @default 'fit'
     */
    tabSizing?: Maybe<TabSizingType>;
    /**
     * @description Controls whether tabs are closed in most recently used order or from left to right.
     * @default true
     */
    focusRecentEditorAfterClose?: Maybe<Scalars['Boolean']>;
    /**
     * @description Controls whether opened editors should show with an icon or not.
     * This requires an icon theme to be enabled as well.
     * @default true
     */
    showIcons?: Maybe<Scalars['Boolean']>;
    /**
     * @description Controls whether opened editors show as preview. Preview editors are reused until they are pinned
     * (e.g. via double click or editing) and show up with an italic font style.
     * @default true
     */
    enablePreview?: Maybe<Scalars['Boolean']>;
    /**
     * @description Controls whether opened editors from Quick Open show as preview.
     * Preview editors are reused until they are pinned
     * (e.g. via double click or editing)
     * @default true
     */
    enablePreviewFromQuickOpen?: Maybe<Scalars['Boolean']>;
    /**
     * @description Controls whether editors showing a file that was opened during
     * the session should close automatically when getting
     * deleted or renamed by some other process. Disabling this will keep the editor
     * open on such an event. Note that deleting from within
     * the application will always close the editor and that dirty files will never close to preserve your data.
     * @default false
     */
    closeOnFileDelete?: Maybe<Scalars['Boolean']>;
    /**
     * @description Controls where editors open. Select `left` or `right` to open
     * editors to the left or right of the currently active one.
     * Select `first` or `last` to open editors independently from the currently active one.
     * @default 'right'
     */
    openPositioning?: Maybe<OpenPositioningType>;
    /**
     * @description Controls the default direction of editors that are opened side by side (e.g. from the explorer). By default,
     * editors will open on the right hand side of the currently active one. If changed to `down`, the editors will open belwo
     * the currently active one.
     * @default 'right'
     */
    openSideBySideDirection?: Maybe<OpenSideBySideDirection>;
    /**
     * @description Controls the behavior of empty editor groups when the last tab in
     * the group is closed. When enabeld, empty groups
     * will automatically close. When disabled, empty groups will remain part of the grid.
     * @default true
     */
    closeEmptyGroup?: Maybe<Scalars['Boolean']>;
    /**
     * @description Controls whether an editor is revealed in any of the visible
     * groups if opened. If disabled, an editor will prefer to
     * open in the currently active editor group. If enabled, an already opened
     * editor will be revealed instead of opened again in the
     * currently active editor group. Note that there are some cases where this
     * setting is ignored, e.g. when forcing an editor to open in a
     * specific group or to the side of the currently active group.
     * @default false
     */
    revealIfOpen?: Maybe<Scalars['Boolean']>;
    /**
     * @description: Navigate between open files using three-finger swipe horizontally.
     * @default: false
     */
    swipeToNavigate?: Maybe<Scalars['Boolean']>;
    /**
     * @description Controls the format of the label for an editor
     * @default: true
     */
    labelFormat?: Maybe<LableFormatType>;
    /**
     * @description Restores the last view state (e.g. scroll position) when re-opening files after they have been closed.
     * @default: true
     */
    restoreViewState?: Maybe<Scalars['Boolean']>;
};
/** Extends EditorPartConfiguration */
export declare type IEditorPartOptions_Input = {
    __typename?: 'EditorPartOptions_Input';
    showTabs?: Maybe<Scalars['Boolean']>;
    highlightModifiedTabs?: Maybe<Scalars['Boolean']>;
    tabCloseButton?: Maybe<TabCloseButtonType>;
    tabSizing?: Maybe<TabSizingType>;
    focusRecentEditorAfterClose?: Maybe<Scalars['Boolean']>;
    showIcons?: Maybe<Scalars['Boolean']>;
    enablePreview?: Maybe<Scalars['Boolean']>;
    enablePreviewFromQuickOpen?: Maybe<Scalars['Boolean']>;
    closeOnFileDelete?: Maybe<Scalars['Boolean']>;
    openPositioning?: Maybe<OpenPositioningType>;
    openSideBySideDirection?: Maybe<OpenSideBySideDirection>;
    closeEmptyGroup?: Maybe<Scalars['Boolean']>;
    revealIfOpen?: Maybe<Scalars['Boolean']>;
    swipeToNavigate?: Maybe<Scalars['Boolean']>;
    labelFormat?: Maybe<LableFormatType>;
    restoreViewState?: Maybe<Scalars['Boolean']>;
    iconTheme?: Maybe<Scalars['String']>;
};
export declare type IEditorSettings = {
    __typename?: 'EditorSettings';
    editorOpenPositioning?: Maybe<EditorOpenPositioning>;
    focusRecentEditorAfterClose?: Maybe<Scalars['Boolean']>;
};
export { EditorsOrder };
export declare type IEmptyResponse = {
    __typename?: 'EmptyResponse';
    alwaysNil?: Maybe<Scalars['String']>;
};
export declare type IEncodingStatus = IIStatusbarItem & {
    __typename?: 'EncodingStatus';
    id?: Maybe<Scalars['String']>;
    name?: Maybe<Scalars['String']>;
    alignment?: Maybe<IStatusbarAlignment>;
    entry?: Maybe<IStatusbarEntry>;
    priority?: Maybe<Scalars['Int']>;
    container?: Maybe<Scalars['String']>;
    labelContainer?: Maybe<Scalars['String']>;
    typeId?: Maybe<ISTATUSBAR_ITEM_ID>;
};
export declare type IEndOfLineSequence = IIStatusbarItem & {
    __typename?: 'EndOfLineSequence';
    id?: Maybe<Scalars['String']>;
    name?: Maybe<Scalars['String']>;
    alignment?: Maybe<IStatusbarAlignment>;
    entry?: Maybe<IStatusbarEntry>;
    priority?: Maybe<Scalars['Int']>;
    container?: Maybe<Scalars['String']>;
    labelContainer?: Maybe<Scalars['String']>;
    typeId?: Maybe<ISTATUSBAR_ITEM_ID>;
};
export declare type IEngines = {
    __typename?: 'Engines';
    node?: Maybe<Scalars['String']>;
    vscode?: Maybe<Scalars['String']>;
};
export declare type IEnterWorkspaceResult = {
    __typename?: 'EnterWorkspaceResult';
    workspace: IWorkspaceIdentifier;
    backupPath?: Maybe<Scalars['String']>;
};
export declare type IEnvironment = {
    __typename?: 'Environment';
    args?: Maybe<Scalars['AnyObject']>;
    execPath?: Maybe<Scalars['String']>;
    cliPath?: Maybe<Scalars['String']>;
    appRoot?: Maybe<Scalars['String']>;
    userHome?: Maybe<Scalars['String']>;
    userDataPath?: Maybe<Scalars['String']>;
    appNameLong?: Maybe<Scalars['String']>;
    appQuality?: Maybe<Scalars['String']>;
    appSettingsHome?: Maybe<Scalars['String']>;
    appSettingsPath?: Maybe<Scalars['String']>;
    appKeybindingsPath?: Maybe<Scalars['String']>;
    settingsSearchBuildId?: Maybe<Scalars['Int']>;
    settingsSearchUrl?: Maybe<Scalars['String']>;
    globalStorageHome?: Maybe<Scalars['String']>;
    workspaceStorageHome?: Maybe<Scalars['String']>;
    backupHome?: Maybe<Scalars['String']>;
    backupWorkspacesPath?: Maybe<Scalars['String']>;
    untitledWorkspacesHome?: Maybe<Scalars['URI']>;
    workspacesHome?: Maybe<Scalars['String']>;
    /** Specific to cdecode, workspaces project */
    workspacesProjectPath?: Maybe<Scalars['String']>;
    /** Specific to cdecode, workspace settings */
    workspaceSettingsPath?: Maybe<Scalars['String']>;
    isExtensionDevelopment?: Maybe<Scalars['Boolean']>;
    disableExtensions?: Maybe<Scalars['AnyObject']>;
    builtinExtensionsPath?: Maybe<Scalars['String']>;
    extensionsPath?: Maybe<Scalars['String']>;
    /**  This seems to be single URI as array was failing  */
    extensionDevelopmentLocationURI?: Maybe<Array<Maybe<Scalars['URI']>>>;
    extensionTestsPath?: Maybe<Scalars['String']>;
    debugExtensionHost?: Maybe<IExtensionHostDebugParams>;
    debugSearch?: Maybe<IIDebugParams>;
    logExtensionHostCommunication?: Maybe<Scalars['Boolean']>;
    isBuilt?: Maybe<Scalars['Boolean']>;
    wait?: Maybe<Scalars['Boolean']>;
    status?: Maybe<Scalars['Boolean']>;
    performance?: Maybe<Scalars['Boolean']>;
    log?: Maybe<Scalars['String']>;
    logsPath?: Maybe<Scalars['String']>;
    verbose?: Maybe<Scalars['Boolean']>;
    logLevel?: Maybe<Scalars['String']>;
    skipGettingStarted?: Maybe<Scalars['Boolean']>;
    skipReleaseNotes?: Maybe<Scalars['Boolean']>;
    skipAddToRecentlyOpened?: Maybe<Scalars['Boolean']>;
    nodeCachedDataDir?: Maybe<Scalars['String']>;
    installSourcePath?: Maybe<Scalars['String']>;
    disableUpdates?: Maybe<Scalars['Boolean']>;
    disableCrashReporter?: Maybe<Scalars['Boolean']>;
    driverHandle?: Maybe<Scalars['String']>;
    driverVerbose?: Maybe<Scalars['Boolean']>;
    keyboardLayoutResource?: Maybe<Scalars['URI']>;
    keybindingsResource?: Maybe<Scalars['URI']>;
    userRoamingDataHome?: Maybe<Scalars['URI']>;
    settingsResource?: Maybe<Scalars['URI']>;
};
export declare const enum IEnvironmentServiceAction {
    environment = "environment"
}
export declare type IExtensionColor = {
    __typename?: 'ExtensionColor';
    id?: Maybe<Scalars['ID']>;
    description?: Maybe<Scalars['String']>;
    defaults?: Maybe<IExtensionColorTypes>;
};
export declare type IExtensionColorTypes = {
    __typename?: 'ExtensionColorTypes';
    light?: Maybe<Scalars['String']>;
    dark?: Maybe<Scalars['String']>;
    highContrast?: Maybe<Scalars['String']>;
};
export declare type IExtensionConfiguration = {
    __typename?: 'ExtensionConfiguration';
    properties?: Maybe<Scalars['JSON']>;
};
export declare type IExtensionConfigurationProperty = {
    __typename?: 'ExtensionConfigurationProperty';
    description?: Maybe<Scalars['String']>;
    type?: Maybe<Array<Maybe<Scalars['String']>>>;
    defaults?: Maybe<Scalars['JSON']>;
};
export declare type IExtensionContributions = {
    __typename?: 'ExtensionContributions';
    /** @deprecated use commands */
    actions?: Maybe<Array<Maybe<IActions>>>;
    /**
     * @title contributes.commands
     * @description Contribute the UI for a command consisting of a title and (optionally) an icon, category,
     * and enabled state. Enablement is expressed with `when` clauses. By default, commands show in the
     * Command Pallette but they can also show in other menus.
     *
     * Presentation of contributed commands depends on the containing menu. The Command Pallette, for instance, prefixes
     * commands with their `category`, allowing for easy grouping. However, the Command Pallette doesn't show icons nor disabled
     * commands. The editor context menu, on the other hand, show disabled items but doesn't show the category label.
     *
     * Note: When a command is invoked (from a key binding, from the Command Palette,
     * any other menu, or programmatically), VS Code will emit an activationEvent
     * onCommand:${command}.
     *
     * @example
     * ```
     *    "contributes": {
     *        "commands": [{
     *            "command": "extension.sayHello",
     *            "title": "Hello World",
     *            "category": "Hello"
     *        }]
     *    }
     * ```
     */
    commands?: Maybe<Array<Maybe<IActions>>>;
    /**
     * @title contributes.configuration
     * @description Contribute configuration keys that will be exposed to the user.
     * The user will be able to set these configuration options either from User
     * Settings or from the Workspace Settings.
     * When contributing configuration keys, a JSON schema describing these keys is
     * actually contributed. This ensures the user gets great tooling support when
     * authoring VS Code settings files.
     * You can read these values from your extension using vscode.workspace.getConfiguration('myExtension').
     *
     * Note: If you use markdownDescription instead of description, your setting
     * description will be rendered as Markdown in the settings UI.
     *
     * @example
     * ```
     * "contributes": {
     *     "configuration": {
     *         "type": "object",
     *         "title": "TypeScript configuration",
     *         "properties": {
     *             "typescript.useCodeSnippetsOnMethodSuggest": {
     *                 "type": "boolean",
     *                 "default": false,
     *                 "description": "Complete functions with their parameter signature."
     *             },
     *             "typescript.tsdk": {
     *                 "type": ["string", "null"],
     *                 "default": null,
     *                 "description": "Specifies the folder path containing the tsserver and lib*.d.ts files to use."
     *             }
     *         }
     *     }
     * }
     * ```
     */
    configuration?: Maybe<Array<Maybe<IExtensionConfiguration>>>;
    debuggers?: Maybe<Array<Maybe<IDebugger>>>;
    /**
     *      @title contributes.grammars
     *      @description Contribute a TextMate grammar to a language. You must provide
     * the language this grammar applies to, the TextMate scopeName for the grammar
     * and the file path.
     *
     *      Note: The file containing the grammar can be in JSON (filenames ending in
     * .json) or in XML plist format (all other files).
     *
     *      @example
     *         ```json
     *         "contributes": {
     *             "grammars": [{
     *                 "language": "markdown",
     *                 "scopeName": "text.html.markdown",
     *                 "path": "./syntaxes/markdown.tmLanguage.json",
     *                 "embeddedLanguages": {
     *                     "meta.embedded.block.frontmatter": "yaml",
     *                     ...
     *                 }
     *             }]
     *         }
     * ```
     */
    grammars?: Maybe<Array<Maybe<IGrammar>>>;
    /**
     * @title contributes.jsonValidation
     * @description Contribute a validation schema for a specific type of json file.
     * The url value can be either a local path to a schema file included in the
     * extension or a remote server URL such as a json schema store.
     *
     * @example
     *    "contributes": {
     *        "jsonValidation": [{
     *            "fileMatch": ".jshintrc",
     *            "url": "http://json.schemastore.org/jshintrc"
     *        }]
     *    }
     */
    jsonValidation?: Maybe<Array<Maybe<IExtensionJSONValidation>>>;
    /**
     * @title contributes.keybindings
     * @description Contribute a key binding rule defining what command should be
     * invoked when the user presses a key combination. See the Key Bindings topic
     * where key bindings are explained in detail.
     *
     * Contributing a key binding will cause the Default Keyboard Shortcuts to
     * display your rule, and every UI representation of the command will now show
     * the key binding you have added. And, of course, when the user presses the key
     * combination the command will be invoked.
     *
     * Note: Because VS Code runs on Windows, macOS and Linux, where modifiers
     * differ, you can use "key" to set the default key combination and overwrite it
     * with a specific platform.
     *
     * Note: When a command is invoked (from a key binding or from the Command
     * Palette), VS Code will emit an activationEvent onCommand:${command}.
     *
     * @example
     * Defining that Ctrl+F1 under Windows and Linux and Cmd+F1 under macOS trigger the "extension.sayHello" command:
     *
     * ```json
     * "contributes": {
     *     "keybindings": [{
     *         "command": "extension.sayHello",
     *         "key": "ctrl+f1",
     *         "mac": "cmd+f1",
     *         "when": "editorTextFocus"
     *     }]
     * }
     * ```
     */
    keybindings?: Maybe<Array<Maybe<IKeyBinding>>>;
    /**
     * @title contributes.languages
     * @description Contribute definition of a language. This will introduce a new
     * language or enrich the knowledge VS Code has about a language.
     *
     * The main effects of contributes.languages are:
     *
     * Define a languageId that can be reused in other parts of VS Code API, such as
     * vscode.TextDocument.getLanguageId() and the onLanguage Activation Events.
     * You can contribute a human-readable using the aliases field. The first item in
     * the list will be used as the human-readable label.
     * Associate file name extensions, file name patterns, files that begin with a
     * specific line (such as hashbang), mimetypes to that languageId.
     * Contribute a set of Declarative Language Features for the contributed
     * language. Learn more about the configurable editing features in the Language
     * Configuration Guide.
     *
     * @example
     * ```
     *    "contributes": {
     *        "languages": [{
     *            "id": "python",
     *            "extensions": [ ".py" ],
     *            "aliases": [ "Python", "py" ],
     *            "filenames": [ ... ],
     *            "firstLine": "^#!/.*\\bpython[0-9.-]*\\b",
     *            "configuration": "./language-configuration.json"
     *        }]
     *    }
     * ```
     */
    languages?: Maybe<Array<Maybe<IExtensionLanguage>>>;
    /**
     * @title contributes.menus
     * @description Contribute a menu item for a command to the editor or Explorer.
     * The menu item definition contains the command that should be invoked when
     * selected and the condition under which the item should show. The latter is
     * defined with the when clause, which uses the key bindings when clause contexts.
     *
     * In addition to the mandatory command property, an alternative command can be
     * defined using the alt-property. It will be shown and invoked when pressing Alt
     * while opening a menu.
     *
     * Last, a group property defines sorting and grouping of menu items. The
     * navigation group is special as it will always be sorted to the top/beginning of a menu.
     *
     * Note that when clauses apply to menus and enablement clauses to commands. The
     * enablement applies to all menus and even keybindings while the when only
     * applies to a single menu.
     *
     * Currently extension writers can contribute to:
     *
     * The global Command Palette - commandPalette
     * The Explorer context menu - explorer/context
     * The editor context menu - editor/context
     * The editor title menu bar - editor/title
     * The editor title context menu - editor/title/context
     * The debug callstack view context menu - debug/callstack/context
     * The debug toolbar - debug/toolbar
     * The SCM title menu - scm/title
     * SCM resource groups menus - scm/resourceGroup/context
     * SCM resources menus - scm/resource/context
     * SCM change title menus - scm/change/title
     * The View title menu - view/title
     * The View item menu - view/item/context
     * The macOS Touch Bar - touchBar
     * The comment thread title - comments/commentThread/title
     * The comment thread actions - comments/commentThread/context
     * The comment title - comments/comment/title
     * The comment actions - comments/comment/context
     * Note: When a command is invoked from a (context) menu, VS Code tries to infer
     * the currently selected resource and passes that as a parameter when invoking
     * the command. For instance, a menu item inside the Explorer is passed the URI
     * of the selected resource and a menu item inside an editor is passed the URI of the document.
     *
     * In addition to a title, commands can also define icons which VS Code will show in the editor title menu bar.
     *
     * @example
     * "contributes": {
     *     "menus": {
     *         "editor/title": [{
     *             "when": "resourceLangId == markdown",
     *             "command": "markdown.showPreview",
     *             "alt": "markdown.showPreviewToSide",
     *             "group": "navigation"
     *         }]
     *     }
     * }
     */
    menus?: Maybe<IMenus>;
    /**
     * @title contributes.snippets
     * @description Contribute snippets for a specific language. The language
     * attribute is the language identifier and the path is the relative path to the
     * snippet file, which defines snippets in the VS Code snippet format.
     *
     * @example
     *
     * ```json
     * "contributes": {
     *     "snippets": [{
     *         "language": "go",
     *         "path": "./snippets/go.json"
     *     }]
     * }
     * ```
     */
    snippets?: Maybe<Array<Maybe<ISnippet>>>;
    /**
     * @title contributes.themes
     * @description Contribute a TextMate theme to VS Code. You must specify a label,
     * whether the theme is a dark theme or a light theme (such that the rest of VS
     * Code changes to match your theme) and the path to the file (XML plist format).
     *
     * @example
     *    ```json
     *    "contributes": {
     *        "themes": [{
     *            "label": "Monokai",
     *            "uiTheme": "vs-dark",
     *            "path": "./themes/Monokai.tmTheme"
     *        }]
     *    }
     *    ```
     */
    themes?: Maybe<Array<Maybe<IThemeLabel>>>;
    iconThemes?: Maybe<Array<Maybe<IThemeLabel>>>;
    /**
     *  @title contributes.viewsContainers
     *  @description Contribute a view container into which Custom views can be
     * contributed. You must specify an identifier, title, and an icon for the view
     * container. At present, you can contribute them to the Activity Bar
     * (activitybar) only. Below example shows how the Package Explorer view
     * container is contributed to the Activity Bar and how views are contributed to it.
     *
     *  @example
     *     ```json
     *     "contributes": {
     *             "viewsContainers": {
     *                 "activitybar": [
     *                     {
     *                         "id": "package-explorer",
     *                         "title": "Package Explorer",
     *                         "icon": "resources/package-explorer.svg"
     *                     }
     *                 ]
     *             },
     *             "views": {
     *                 "package-explorer": [
     *                     {
     *                         "id": "package-dependencies",
     *                         "name": "Dependencies"
     *                     },
     *                     {
     *                         "id": "package-outline",
     *                         "name": "Outline"
     *                     }
     *                 ]
     *             }
     *     }
     * ```
     */
    viewsContainers?: Maybe<Scalars['JSON']>;
    /**
     * @title contributes.viewsContainers
     * @description Contribute a view container into which Custom views can be
     * contributed. You must specify an identifier, title, and an icon for the view
     * container. At present, you can contribute them to the Activity Bar
     * (activitybar) only. Below example shows how the Package Explorer view
     * container is contributed to the Activity Bar and how views are contributed to it.
     *
     * @example
     * ```json
     *    "contributes": {
     *            "viewsContainers": {
     *                "activitybar": [
     *                    {
     *                        "id": "package-explorer",
     *                        "title": "Package Explorer",
     *                        "icon": "resources/package-explorer.svg"
     *                    }
     *                ]
     *            },
     *            "views": {
     *                "package-explorer": [
     *                    {
     *                        "id": "package-dependencies",
     *                        "name": "Dependencies"
     *                    },
     *                    {
     *                        "id": "package-outline",
     *                        "name": "Outline"
     *                    }
     *                ]
     *            }
     *    }
     * ```
     */
    views?: Maybe<Scalars['JSON']>;
    /**
     * @title contributes.colors
     * @description Contributes new themable colors. These colors can be used by the
     * extension in editor decorators and in the status bar. Once defined, users can
     * customize the color in the workspace.colorCustomization setting and user
     * themes can set the color value.
     *
     * @example
     * ```json
     *    "contributes": {
     *      "colors": [{
     *          "id": "superstatus.error",
     *          "description": "Color for error message in the status bar.",
     *          "defaults": {
     *              "dark": "errorForeground",
     *              "light": "errorForeground",
     *              "highContrast": "#010203"
     *          }
     *      }]
     *    }
     * ```
     * Color default values can be defined for light, dark and high contrast theme
     * and can either be a reference to an existing color or a Color Hex Value.
     */
    colors?: Maybe<Array<Maybe<IExtensionColor>>>;
    localizations?: Maybe<Array<Maybe<ILocalization>>>;
};
export declare type IExtensionHostDebugParams = IIDebugParams & {
    __typename?: 'ExtensionHostDebugParams';
    port?: Maybe<Scalars['Int']>;
    break?: Maybe<Scalars['Boolean']>;
    debugId?: Maybe<Scalars['String']>;
};
/**
 * **!Do not construct directly!**
 * **!Only static methods because it gets serialized!**
 *
 * This represents the "canonical" version for an extension identifier. Exntension ids
 * have to be case-insensitive (due to the marketplace), but we must ensure case
 * preservation because the extension API is already public at this time.
 *
 * For example, given an extension with the publisher `"Hello` and the name `"World"`,
 * its canonical extension identifier is `"Hello.World"`. This extension could be
 * referenced in some other extension's dependencies using the string `"hello.world"`.
 *
 * To make matter more complicated, an extension can optionally have an UUID. When two
 * extensions have the same UUID, they are considered equal even if their identifier is different.
 */
export declare type IExtensionIdentifier = {
    __typename?: 'ExtensionIdentifier';
    id?: Maybe<Scalars['String']>;
    uuid?: Maybe<Scalars['String']>;
};
export declare type IExtensionInstance = {
    __typename?: 'ExtensionInstance';
    pid?: Maybe<Scalars['String']>;
    name?: Maybe<Scalars['String']>;
    path?: Maybe<Scalars['String']>;
    env?: Maybe<Array<Maybe<Scalars['String']>>>;
    status?: Maybe<Scalars['String']>;
    extensionID?: Maybe<Scalars['ID']>;
    monit?: Maybe<IProcessMonitoring>;
};
export declare type IExtensionJSONValidation = {
    __typename?: 'ExtensionJSONValidation';
    fileMatch?: Maybe<Scalars['String']>;
    url?: Maybe<Scalars['String']>;
};
export declare const enum IExtensionKind {
    ui = "ui",
    workspace = "workspace"
}
export declare type IExtensionLanguage = {
    __typename?: 'ExtensionLanguage';
    id?: Maybe<Scalars['ID']>;
    extensions?: Maybe<Array<Maybe<Scalars['String']>>>;
    aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
};
export declare type IExtensionManifest = {
    __typename?: 'ExtensionManifest';
    /**  The name of the extension - should be all lowercase with no spaces  */
    name?: Maybe<Scalars['String']>;
    /**  SemVer compatible version.  */
    version?: Maybe<Scalars['String']>;
    /**  The entry point to your extension  */
    main?: Maybe<Scalars['String']>;
    /**
     *  Array of approved badges to display in the sidebar of the Marketplace's
     * extension page. Each badge is an object containing 3 properties: url for the
     * badge's image URL, href for the link users will follow when clicking the badge
     * and description.
     */
    badges?: Maybe<Array<Maybe<Scalars['String']>>>;
    /**  Sets the extension to be flagged as a Preview in the Marketplace.  */
    preview?: Maybe<Scalars['Boolean']>;
    /**
     *  An array of keywords to make it easier to find the extension. These are
     * included with other extension Tags on the Marketplace. This list is currently
     * limited to 5 keywords.
     */
    keywords?: Maybe<Array<Maybe<Scalars['String']>>>;
    /**
     *  Refer to npm's documentation. If you do have a LICENSE file in the root of
     * your extension, the value for license should be "SEE LICENSE IN <filename>".
     */
    license?: Maybe<Scalars['String']>;
    homepage?: Maybe<Scalars['String']>;
    /**  The publisher name  */
    publisher?: Maybe<Scalars['String']>;
    /**
     *  the categories you want to use for the extensions allowed values: [Programming
     * Languages, Snippets, Linters, Themes, Debuggers, Formatters, Keymaps, SCM
     * Providers, Other, Extension Packs, Language Packs]
     */
    categories?: Maybe<Scalars['String']>;
    /**  A short description of what your extension is and does.  */
    description?: Maybe<Scalars['String']>;
    extensionID?: Maybe<Scalars['String']>;
    /**  The display name for the extension used in the Marketplace.  */
    displayName?: Maybe<Scalars['String']>;
    /**  Any runtime Node.js dependencies your extensions needs. Exactly the same as npm's dependencies.  */
    dependencies?: Maybe<Scalars['JSON']>;
    /** Any development Node.js dependencies your extension needs. Exactly the same as npm's devDependencies.  */
    devDependencies?: Maybe<Scalars['JSON']>;
    /**
     * An array with the ids of extensions bundled with this extension. These other
     * extensions will be installed when the primary extension is installed. The id
     * of an extension is always
     * `${publisher}.${name}`. For example: vscode.csharp.
     */
    extensionPack?: Maybe<Array<Maybe<Scalars['String']>>>;
    /** An extension can be of 'ui' | 'workspace' */
    extensionKind?: Maybe<IExtensionKind>;
    /**
     * An array with the ids of extensions that this extension depends on. These
     * other extensions will be installed when the primary extension is installed.
     * The id of an extension is always
     * `${publisher}.${name}`. For example: vscode.csharp.
     */
    extensionDependencies?: Maybe<Array<Maybe<Scalars['String']>>>;
    bundle?: Maybe<Scalars['String']>;
    raw?: Maybe<Scalars['String']>;
    assets?: Maybe<Array<Maybe<IAssets>>>;
    /**  Exactly the same as npm's scripts but with extra VS Code specific fields such as vscode:prepublish or vscode:uninstall.  */
    scripts?: Maybe<IScripts>;
    bundles?: Maybe<IBundles>;
    bundleURL?: Maybe<Scalars['String']>;
    extension?: Maybe<IExtensionPackageType>;
    /**
     *  An object containing at least the vscode key matching
     * the versions of VS Code that the extension
     * is compatible with. Cannot be *.
     * For example: ^0.10.5 indicates compatibility with a minimum VS Code version of 0.10.5.
     */
    engines?: Maybe<IEngines>;
    /**  Controls the Markdown rendering engine used in the Marketplace. Either github (default) or standard.  */
    makrdown?: Maybe<Scalars['String']>;
    /**
     *  Controls the Q & A link in the Marketplace. Set to marketplace to enable the
     * default Marketplace Q & A site. Set to a string to provide the URL of a custom
     * Q & A site. Set to false to disable Q & A altogether.
     */
    qna?: Maybe<Scalars['String']>;
    author?: Maybe<IAuthor>;
    /**  Helps format the Marketplace header to match your icon. See details below.  */
    galleryBanner?: Maybe<IGalleryBanner>;
    /**  An array of the activation events for this extension.  */
    activationEvents?: Maybe<Array<Maybe<Scalars['String']>>>;
    /**  An object describing the extension's contributions.  */
    contributes?: Maybe<IExtensionContributions>;
    /**  The path to the icon of at least 128x128 pixels (256x256 for Retina screens).  */
    icon?: Maybe<Scalars['String']>;
    /**
     * @description Any development Node.js bugs reporting location of your extension.
     * @example
     *    "bugs": {
     *        "url": "https://github.com/Microsoft/vscode-wordcount/issues",
     *        "email": "smcbreen@microsoft.com"
     *    },
     */
    bugs?: Maybe<IExtensionManifestBugs>;
    /**
     * Any development Node.js repository location of your extension.
     * @example
     *   "repository": {
     *        "type": "git",
     *        "url": "https://github.com/Microsoft/vscode-wordcount.git"
     *    }
     */
    repository?: Maybe<IExtensionManifestRepository>;
    /** To enable proposed Api's */
    enableProposedApi?: Maybe<Scalars['Boolean']>;
    /** Add support for api:none */
    api?: Maybe<Scalars['String']>;
};
export declare type IExtensionManifestBugs = {
    __typename?: 'ExtensionManifestBugs';
    url?: Maybe<Scalars['String']>;
    email?: Maybe<Scalars['String']>;
};
export declare type IExtensionManifestRepository = {
    __typename?: 'ExtensionManifestRepository';
    type?: Maybe<Scalars['String']>;
    url?: Maybe<Scalars['String']>;
};
export declare type IExtensionPackageType = {
    __typename?: 'ExtensionPackageType';
    type?: Maybe<Scalars['String']>;
};
export declare type IExtensionRegistry = {
    __typename?: 'ExtensionRegistry';
    /**  To find an extension by its GraphQL ID, use Query.node  */
    extension?: Maybe<IRegistryExtension>;
    /**
     * Find an extension by its extension ID (which is the concatenation of the
     * publisher naem, a slash ("/"), and the extension name).
     *
     * To find an extension by its GraphQL ID, use Query.node
     * extension(extensionID: String!): RegistryExtension
     * A list of extensions published in the extension registry.
     */
    extensions: IRegistryExtensionConnection;
    /**  List of extension releases  */
    releases?: Maybe<Array<Maybe<IExtensionRelease>>>;
    /**  A list of publishers with at least 1 extension in the registry.  */
    publishers: IRegistryPublisherConnection;
    /**  A list of publishers that the viewer may publish extensions as.  */
    viewerPublishers: Array<IRegistryPublisher>;
    /**
     * The extension ID prefix for extensions that are published in the local extension registry. This is the
     * hostname ( and port, if non-default HTTP/HTTPS) of the CDEBase "appURL" site configuration property.
     *
     * It is null if extensions published on this CDEBase site do not have an extension ID prefix.
     *
     * Examples: "cdebase.example.com/", "cdebase.example.com:1234/"
     */
    localExtensionIDPrefix?: Maybe<Scalars['String']>;
};
export declare type IExtensionRegistryextensionArgs = {
    extensionID: Scalars['String'];
};
export declare type IExtensionRegistryextensionsArgs = {
    first?: Maybe<Scalars['Int']>;
    publisher?: Maybe<Scalars['ID']>;
    query?: Maybe<Scalars['String']>;
    local?: Maybe<Scalars['Boolean']>;
    remote?: Maybe<Scalars['Boolean']>;
    prioritizeExtensionIDs?: Maybe<Array<Scalars['String']>>;
    includeWIP?: Maybe<Scalars['Boolean']>;
};
export declare type IExtensionRegistryreleasesArgs = {
    extensionID: Scalars['String'];
};
export declare type IExtensionRegistrypublishersArgs = {
    first?: Maybe<Scalars['Int']>;
};
/**  The result of Mutation.extensionRegistry.createExtension. */
export declare type IExtensionRegistryCreateExtensionResult = {
    __typename?: 'ExtensionRegistryCreateExtensionResult';
    /**  The newly created extension. */
    extension: IRegistryExtension;
};
/**  The result of Mutation.extensionRegistry.publishExtension. */
export declare type IExtensionRegistryPublishExtensionResult = {
    __typename?: 'ExtensionRegistryPublishExtensionResult';
    /**  The extension that was just published. */
    extension: IRegistryExtension;
};
/**  The result of Mutation.extensionRegistry.updateExtension. */
export declare type IExtensionRegistryUpdateExtensionResult = {
    __typename?: 'ExtensionRegistryUpdateExtensionResult';
    /**  The newly updated extension. */
    extension: IRegistryExtension;
};
export declare type IExtensionRelease = {
    __typename?: 'ExtensionRelease';
    id?: Maybe<Scalars['ID']>;
    bundle?: Maybe<Scalars['String']>;
    bundleURL?: Maybe<Scalars['String']>;
    version?: Maybe<Scalars['String']>;
    manifest: Scalars['String'];
    sourceMap?: Maybe<Scalars['String']>;
    extensionID?: Maybe<Scalars['String']>;
    creatorUserId?: Maybe<Scalars['String']>;
    releaseVersion?: Maybe<Scalars['String']>;
    activationEvents?: Maybe<Array<Maybe<Scalars['String']>>>;
};
export declare const enum IExtensionType {
    System = "System",
    User = "User"
}
export declare type IFieldError = {
    __typename?: 'FieldError';
    field: Scalars['String'];
    message: Scalars['String'];
};
export declare type IFileChange = {
    __typename?: 'FileChange';
    /** The type of change that occurred to the file */
    type?: Maybe<IFileChangeType>;
    /** The unified resource identifier of the file that changed. */
    resource?: Maybe<Scalars['URI']>;
};
/** Possible changes that can occur to a file. */
export declare const enum IFileChangeType {
    UPDATED = "UPDATED",
    ADDED = "ADDED",
    DELETED = "DELETED"
}
export declare type IFileContent = IIBaseStatWithMetadata & IIBaseStat & {
    __typename?: 'FileContent';
    resource: Scalars['URI'];
    name: Scalars['String'];
    mtime: Scalars['BigInt'];
    etag: Scalars['String'];
    size: Scalars['Int'];
    isReadonly?: Maybe<Scalars['Boolean']>;
    /**  The content of a file as buffer.  */
    value?: Maybe<Scalars['VSBuffer']>;
};
export declare const enum IFileContentStatus {
    PENDING = "PENDING",
    START = "START",
    IN_PROGRESS = "IN_PROGRESS",
    END = "END",
    ERROR = "ERROR",
    RESTORE = "RESTORE"
}
export declare type IFileDeleteOptions = {
    __typename?: 'FileDeleteOptions';
    recursive: Scalars['Boolean'];
    useTrash: Scalars['Boolean'];
};
export declare type IFileEditorInput = IIFileEditorInput & IIEditorInput & IIEditorInputWithGroupFields & IIEncodingSupport & IIModeSupport & {
    __typename?: 'FileEditorInput';
    id?: Maybe<Scalars['String']>;
    resource?: Maybe<Scalars['String']>;
    typeId?: Maybe<IEDITOR_INPUT_ID>;
    description?: Maybe<Scalars['String']>;
    label?: Maybe<Scalars['String']>;
    fileReference?: Maybe<IFileStatWithMetadata>;
    preferredEditorId?: Maybe<Scalars['String']>;
    isSupportsSplitEditor?: Maybe<Scalars['Boolean']>;
    isActive?: Maybe<Scalars['Boolean']>;
    preview?: Maybe<Scalars['Boolean']>;
    isPinned?: Maybe<Scalars['Boolean']>;
    editorId?: Maybe<Scalars['Int']>;
    status?: Maybe<Scalars['String']>;
    closable?: Maybe<Scalars['Boolean']>;
    preferredEncoding?: Maybe<Scalars['String']>;
    preferredMode?: Maybe<Scalars['String']>;
    forceOpenAsBinary?: Maybe<Scalars['Boolean']>;
    encoding?: Maybe<Scalars['String']>;
    mode?: Maybe<Scalars['String']>;
};
export declare type IFileFilter = {
    __typename?: 'FileFilter';
    extensions?: Maybe<Array<Maybe<Scalars['String']>>>;
    name?: Maybe<Scalars['String']>;
};
export declare type IFileIndexProviderStats = {
    __typename?: 'FileIndexProviderStats';
    providerTime: Scalars['Int'];
    providerResultCount: Scalars['Int'];
    fileWalkTime: Scalars['Int'];
    directoriesWalked: Scalars['Int'];
    filesWalked: Scalars['Int'];
};
export declare const enum IFileLoadReason {
    EDITOR = "EDITOR",
    REFERENCE = "REFERENCE",
    OTHER = "OTHER"
}
export declare type IFileMatch = IIFileMatch & {
    __typename?: 'FileMatch';
    resource?: Maybe<Scalars['URI']>;
    results?: Maybe<Array<Maybe<ITextSearchResult>>>;
};
/** same as ModelState as in vscode */
export declare const enum IFileModelState {
    /**  A model is saved.  */
    SAVED = "SAVED",
    /**  A model is dirty.  */
    DIRTY = "DIRTY",
    /**  A model is transitioning from dirty to saved.  */
    PENDING_SAVE = "PENDING_SAVE",
    /**
     * A model is in conflict mode when changes cannot be saved because the
     * underlying file has changed. Models in conflict mode are always dirty.
     */
    CONFLICT = "CONFLICT",
    /**  A model is in orphan state when the underlying file has been deleted.  */
    ORPHAN = "ORPHAN",
    /**
     * Any error that happens during a save that is not causing the CONFLICT state.
     * Models in error mode are always dirty.
     */
    ERROR = "ERROR",
    /**  Loading  */
    PENDING_LOAD = "PENDING_LOAD",
    /**  Unkown  */
    UNKNOWN = "UNKNOWN"
}
export declare type IFileOpenOptions = {
    __typename?: 'FileOpenOptions';
    create: Scalars['Boolean'];
};
export declare const enum IFileOperation {
    CREATE = "CREATE",
    DELETE = "DELETE",
    MOVE = "MOVE",
    COPY = "COPY"
}
export declare type IFileOperationOutput = {
    __typename?: 'FileOperationOutput';
    resource?: Maybe<Scalars['URI']>;
    target?: Maybe<IFileStatWithMetadata>;
    operation?: Maybe<IFileOperation>;
};
export declare const enum IFileOperationResult {
    FILE_IS_DIRECTORY = "FILE_IS_DIRECTORY",
    FILE_NOT_FOUND = "FILE_NOT_FOUND",
    FILE_NOT_MODIFIED_SINCE = "FILE_NOT_MODIFIED_SINCE",
    FILE_MODIFIED_SINCE = "FILE_MODIFIED_SINCE",
    FILE_MOVE_CONFLICT = "FILE_MOVE_CONFLICT",
    FILE_READ_ONLY = "FILE_READ_ONLY",
    FILE_PERMISSION_DENIED = "FILE_PERMISSION_DENIED",
    FILE_TOO_LARGE = "FILE_TOO_LARGE",
    FILE_INVALID_PATH = "FILE_INVALID_PATH",
    FILE_EXCEED_MEMORY_LIMIT = "FILE_EXCEED_MEMORY_LIMIT",
    FILE_OTHER_ERROR = "FILE_OTHER_ERROR"
}
export declare type IFileOverwriteOptions = {
    __typename?: 'FileOverwriteOptions';
    overwrite: Scalars['Boolean'];
};
export declare type IFileQueryInput = {
    _reason?: Maybe<Scalars['String']>;
    folderQueries?: Maybe<Array<Maybe<IFolderQueryInput>>>;
    includePattern?: Maybe<Scalars['AnyObject']>;
    excludePattern?: Maybe<Scalars['AnyObject']>;
    extraFileResources?: Maybe<Array<Maybe<IURIInput>>>;
    useRipgrep?: Maybe<Scalars['Boolean']>;
    maxResults?: Maybe<Scalars['Int']>;
    usingSearchPaths?: Maybe<Scalars['Boolean']>;
    type: IQueryType;
    filePattern?: Maybe<Scalars['String']>;
    disregardExcludeSettings?: Maybe<Scalars['Boolean']>;
    exists?: Maybe<Scalars['Boolean']>;
    sortByScore?: Maybe<Scalars['Boolean']>;
    cacheKey?: Maybe<Scalars['String']>;
};
export declare type IFileResult = {
    __typename?: 'FileResult';
    source?: Maybe<Scalars['URI']>;
    target?: Maybe<Scalars['URI']>;
    success?: Maybe<Scalars['Boolean']>;
};
export declare type IFiles = {
    __typename?: 'Files';
    eol?: Maybe<Scalars['String']>;
    hotExit?: Maybe<Scalars['String']>;
    encoding?: Maybe<Scalars['String']>;
    autoSave?: Maybe<IAutoSaveConfigurationType>;
    autoSaveDelay?: Maybe<Scalars['Int']>;
    defaultLanguage?: Maybe<Scalars['String']>;
    autoGuessEncoding?: Maybe<Scalars['Boolean']>;
    insertFinalNewline?: Maybe<Scalars['Boolean']>;
    trimTrailingWhitespace?: Maybe<Scalars['Boolean']>;
    useExperimentalFileWatcher?: Maybe<Scalars['Boolean']>;
    watcherExclude?: Maybe<Scalars['JSON']>;
    exclude?: Maybe<Scalars['JSON']>;
};
export declare type IFiles_Stat = {
    __typename?: 'Files_Stat';
    type?: Maybe<IFileType>;
    mtime?: Maybe<Scalars['BigInt']>;
    ctime?: Maybe<Scalars['BigInt']>;
    size?: Maybe<Scalars['Int']>;
};
export declare type IFileSearchProviderStats = {
    __typename?: 'FileSearchProviderStats';
    providerTime?: Maybe<Scalars['Int']>;
    postProcessTime?: Maybe<Scalars['Int']>;
};
export declare type IFileSearchStats = {
    __typename?: 'FileSearchStats';
    fromCache?: Maybe<Scalars['Boolean']>;
    detailStats?: Maybe<IFileSearchStatsdetailStats>;
    resultCount?: Maybe<Scalars['Int']>;
    type?: Maybe<IFileSearchStatsType>;
    sortingTime?: Maybe<Scalars['Int']>;
};
export declare type IFileSearchStatsdetailStats = ISearchEngineStats | ICachedSearchStats | IFileSearchProviderStats | IFileIndexProviderStats;
export declare const enum IFileSearchStatsType {
    fileIndexProvider = "fileIndexProvider",
    fileSearchProvider = "fileSearchProvider",
    searchProcess = "searchProcess"
}
export declare type IFileStat = IIBaseStat & {
    __typename?: 'FileStat';
    resource: Scalars['URI'];
    name: Scalars['String'];
    size?: Maybe<Scalars['Int']>;
    mtime?: Maybe<Scalars['BigInt']>;
    etag?: Maybe<Scalars['String']>;
    isReadonly?: Maybe<Scalars['Boolean']>;
    /**  The resource is a directory  */
    isDirectory?: Maybe<Scalars['Boolean']>;
    /**  The resource is a symbolic link.  */
    isSymbolicLink?: Maybe<Scalars['Boolean']>;
    /**  The children of the file stat or undefined if none.  */
    children?: Maybe<Array<Maybe<IFileStat>>>;
};
export declare const enum IFileStateChange {
    DIRTY = "DIRTY",
    SAVING = "SAVING",
    SAVE_ERROR = "SAVE_ERROR",
    SAVED = "SAVED",
    REVERTED = "REVERTED",
    ENCODING = "ENCODING",
    CONTENT_CHANGE = "CONTENT_CHANGE",
    ORPHANED_CHANGE = "ORPHANED_CHANGE"
}
/** Its extension of IFileStat and IBaseStatWithMetadata */
export declare type IFileStatWithMetadata = IIBaseStat & IIBaseStatWithMetadata & IIContentChangedEvent & IIFileClientMetadata & IITreeItem & IIUntitledFileValue & {
    __typename?: 'FileStatWithMetadata';
    active?: Maybe<Scalars['Boolean']>;
    changes?: Maybe<Scalars['JSON']>;
    /**  The children of the file stat or undefined if none.  */
    children?: Maybe<Array<Maybe<IFileStatWithMetadata>>>;
    childrenGen?: Maybe<Array<Maybe<IFileStatWithMetadata>>>;
    /** Content of the file is modified */
    dirty?: Maybe<Scalars['Boolean']>;
    /** encoding as reported from disk if the file is text */
    encoding?: Maybe<Scalars['String']>;
    eol?: Maybe<Scalars['String']>;
    etag: Scalars['String'];
    expanded?: Maybe<Scalars['Boolean']>;
    hasChildren?: Maybe<Scalars['Boolean']>;
    /** File is in conflict with storage. */
    inConflictMode?: Maybe<Scalars['Boolean']>;
    /** File is in Error */
    inErrorMode?: Maybe<Scalars['Boolean']>;
    /** File doesn't exist in the storage */
    inOrphanMode?: Maybe<Scalars['Boolean']>;
    /** Pending Save */
    inPendingSave?: Maybe<Scalars['Boolean']>;
    isDirectory?: Maybe<Scalars['Boolean']>;
    isEmpty?: Maybe<Scalars['Boolean']>;
    isFlush?: Maybe<Scalars['Boolean']>;
    isReadonly?: Maybe<Scalars['Boolean']>;
    isRedoing?: Maybe<Scalars['Boolean']>;
    /**  The resource is a symbolic link.  */
    isSymbolicLink?: Maybe<Scalars['Boolean']>;
    isUndoing?: Maybe<Scalars['Boolean']>;
    mtime: Scalars['BigInt'];
    name: Scalars['String'];
    path?: Maybe<Scalars['String']>;
    preferredEncoding?: Maybe<Scalars['String']>;
    preferredMode?: Maybe<Scalars['String']>;
    resource: Scalars['URI'];
    resourcePath?: Maybe<Scalars['String']>;
    size: Scalars['Int'];
    state?: Maybe<IFileModelState>;
    subtitle?: Maybe<Scalars['String']>;
    title?: Maybe<Scalars['String']>;
    value?: Maybe<Scalars['String']>;
    versionId?: Maybe<Scalars['Int']>;
};
export declare type IFileStreamContent = IIBaseStatWithMetadata & IIBaseStat & {
    __typename?: 'FileStreamContent';
    resource: Scalars['URI'];
    name: Scalars['String'];
    mtime: Scalars['BigInt'];
    etag: Scalars['String'];
    size: Scalars['Int'];
    isReadonly?: Maybe<Scalars['Boolean']>;
    value?: Maybe<Scalars['VSBufferReadableStream']>;
};
export declare type IFileToOpen = {
    __typename?: 'FileToOpen';
    fileUri?: Maybe<Scalars['URI']>;
    label?: Maybe<Scalars['String']>;
};
export declare const enum IFileType {
    Unknown = "Unknown",
    File = "File",
    Directory = "Directory",
    SymbolicLink = "SymbolicLink"
}
export declare type IFileWriteOptions = {
    __typename?: 'FileWriteOptions';
    overwrite: Scalars['Boolean'];
    create: Scalars['Boolean'];
};
export declare type IFolder_input = {
    uri: Scalars['URI'];
    name?: Maybe<Scalars['String']>;
};
export declare type IFolderConfigurationModel = {
    __typename?: 'FolderConfigurationModel';
    id: Scalars['String'];
    contents?: Maybe<Scalars['AnyObject']>;
    keys?: Maybe<Array<Maybe<Scalars['String']>>>;
    overrides?: Maybe<IConfigurationOverrides>;
};
export declare type IFolderQuery = {
    __typename?: 'FolderQuery';
    folder: Scalars['URI'];
    excludePattern?: Maybe<Scalars['AnyObject']>;
    includePattern?: Maybe<Scalars['AnyObject']>;
    fileEncoding?: Maybe<Scalars['String']>;
    disregardIgnoreFiles?: Maybe<Scalars['Boolean']>;
};
export declare type IFolderQueryInput = {
    folder: IURIInput;
    excludePattern?: Maybe<Scalars['AnyObject']>;
    includePattern?: Maybe<Scalars['AnyObject']>;
    fileEncoding?: Maybe<Scalars['String']>;
    disregardIgnoreFiles?: Maybe<Scalars['Boolean']>;
};
export declare type IFolderSettings = IISettingsSubject & {
    __typename?: 'FolderSettings';
    /**  The ID.  */
    id?: Maybe<Scalars['ID']>;
    /**  The latest settings.  */
    latestSettings?: Maybe<ISettings>;
    /**  The URL to the settings.  */
    settingsURL: Scalars['URI'];
    /**  Whether the viewer can modify the subject's settings. */
    viewerCanAdminister: Scalars['Boolean'];
    /**
     * All settings for this subject, and the individual levels in the settings cascade (global > organization > user)
     * that were merged to produce the final merged settings.
     */
    settingsCascade: ISettingsCascade;
};
export declare type IFoldersToAdd_Input = {
    uri: Scalars['URI'];
    name?: Maybe<Scalars['String']>;
};
export declare type IFolderToOpen = {
    __typename?: 'FolderToOpen';
    folderUri?: Maybe<Scalars['URI']>;
    label?: Maybe<Scalars['String']>;
};
export declare type IGalleryBanner = {
    __typename?: 'GalleryBanner';
    color?: Maybe<Scalars['String']>;
    theme?: Maybe<Scalars['String']>;
};
export declare type IGalleryExtension = {
    __typename?: 'GalleryExtension';
    id?: Maybe<Scalars['String']>;
    name?: Maybe<Scalars['String']>;
    identifier?: Maybe<IExtensionIdentifier>;
    version?: Maybe<Scalars['String']>;
    date?: Maybe<Scalars['String']>;
    icon?: Maybe<Scalars['String']>;
    displayName?: Maybe<Scalars['String']>;
    publisherId?: Maybe<Scalars['String']>;
    publisher?: Maybe<Scalars['String']>;
    publisherDisplayName?: Maybe<Scalars['String']>;
    description?: Maybe<Scalars['String']>;
    installCount?: Maybe<Scalars['Int']>;
    rating?: Maybe<Scalars['Float']>;
    ratingCount?: Maybe<Scalars['Float']>;
    assets?: Maybe<IGalleryExtensionAssets>;
    properties?: Maybe<IGalleryExtensionProperties>;
    preview?: Maybe<Scalars['Boolean']>;
    resources?: Maybe<IGalleryExtensionResources>;
};
export declare type IGalleryExtensionAsset = {
    __typename?: 'GalleryExtensionAsset';
    uri?: Maybe<Scalars['String']>;
    fallbackUri?: Maybe<Scalars['String']>;
};
export declare type IGalleryExtensionAssets = {
    __typename?: 'GalleryExtensionAssets';
    manifest?: Maybe<IGalleryExtensionAsset>;
    readme?: Maybe<IGalleryExtensionAsset>;
    changelog?: Maybe<IGalleryExtensionAsset>;
    download?: Maybe<IGalleryExtensionAsset>;
    icon?: Maybe<IGalleryExtensionAsset>;
    license?: Maybe<IGalleryExtensionAsset>;
    repository?: Maybe<IGalleryExtensionAsset>;
    coreTranslations?: Maybe<Scalars['JSON']>;
};
export declare type IGalleryExtensionProperties = {
    __typename?: 'GalleryExtensionProperties';
    engine?: Maybe<Scalars['String']>;
    dependencies?: Maybe<Array<Maybe<Scalars['String']>>>;
    extensionPack?: Maybe<Array<Maybe<Scalars['String']>>>;
    localizedLanguages?: Maybe<Array<Maybe<Scalars['String']>>>;
};
export declare type IGalleryExtensionResources = {
    __typename?: 'GalleryExtensionResources';
    manifest?: Maybe<Scalars['String']>;
    readme?: Maybe<Scalars['String']>;
    changelog?: Maybe<Scalars['String']>;
    download?: Maybe<Scalars['String']>;
    icon?: Maybe<Scalars['String']>;
    license?: Maybe<Scalars['String']>;
    repository?: Maybe<Scalars['String']>;
};
export declare type IGalleryFilter = {
    value?: Maybe<Scalars['String']>;
    filterType?: Maybe<Scalars['String']>;
};
export declare type IGalleryPager = {
    __typename?: 'GalleryPager';
    page?: Maybe<Scalars['Int']>;
    total?: Maybe<Scalars['Int']>;
    pageSize?: Maybe<Scalars['Int']>;
    firstPage?: Maybe<Array<Maybe<IGalleryExtension>>>;
};
export declare type IGalleryQuery = {
    text?: Maybe<Scalars['String']>;
    ids?: Maybe<Array<Maybe<Scalars['String']>>>;
    names?: Maybe<Array<Maybe<Scalars['String']>>>;
    pageSize?: Maybe<Scalars['Int']>;
    sortBy?: Maybe<Scalars['Int']>;
    sortOrder?: Maybe<Scalars['Int']>;
    source?: Maybe<Scalars['String']>;
};
export declare type IGit = {
    __typename?: 'Git';
    path?: Maybe<Scalars['String']>;
    enabled?: Maybe<Scalars['Boolean']>;
    autofetch?: Maybe<Scalars['Boolean']>;
    countBadge?: Maybe<Scalars['String']>;
    autorefresh?: Maybe<Scalars['Boolean']>;
    confirmSync?: Maybe<Scalars['Boolean']>;
    checkoutType?: Maybe<Scalars['String']>;
    inputValidation?: Maybe<Scalars['String']>;
    detectSubmodules?: Maybe<Scalars['Boolean']>;
    enableSmartCommit?: Maybe<Scalars['Boolean']>;
    ignoreLimitWarning?: Maybe<Scalars['Boolean']>;
    ignoreLegacyWarning?: Maybe<Scalars['Boolean']>;
    enableCommitSigning?: Maybe<Scalars['Boolean']>;
    defaultCloneDirectory?: Maybe<Scalars['String']>;
    autoRepositoryDetection?: Maybe<Scalars['Boolean']>;
    ignoreMissingGitWarning?: Maybe<Scalars['Boolean']>;
    showInlineOpenFileAction?: Maybe<Scalars['Boolean']>;
    promptToSaveFilesBeforeCommit?: Maybe<Scalars['Boolean']>;
    decorations?: Maybe<IGitDecorations>;
};
export declare type IGitDecorations = {
    __typename?: 'GitDecorations';
    enabled?: Maybe<Scalars['Boolean']>;
};
export declare type IGlobalSettings = IISettingsSubject & {
    __typename?: 'GlobalSettings';
    /**  The ID.  */
    id?: Maybe<Scalars['ID']>;
    /**  The latest settings.  */
    latestSettings?: Maybe<ISettings>;
    /**  The URL to the settings.  */
    settingsURL: Scalars['URI'];
    /**  Whether the viewer can modify the subject's settings.  */
    viewerCanAdminister: Scalars['Boolean'];
    /**
     * All settings for this subject, and the individual levels in the settings cascade (global > organization > user)
     * that were merged to produce the final merged settings.
     */
    settingsCascade: ISettingsCascade;
};
export declare type IGoToLineQuickAccess = {
    __typename?: 'GoToLineQuickAccess';
    range?: Maybe<ILineRange>;
    highlight?: Maybe<Scalars['Boolean']>;
    focus?: Maybe<Scalars['Boolean']>;
};
export declare type IGrammar = {
    __typename?: 'Grammar';
    language?: Maybe<Scalars['String']>;
};
export declare const enum IGraphqlCallType {
    mutation = "mutation",
    query = "query"
}
export { GroupDirection };
export declare type IGroupLayoutArgument = {
    __typename?: 'GroupLayoutArgument';
    size?: Maybe<Scalars['Int']>;
    groups?: Maybe<Array<Maybe<IGroupLayoutArgument>>>;
};
export { GroupLocation };
export { GroupOrientation };
export { GroupsArrangement };
export { GroupsOrder };
export declare const enum IHotExitConfiguration {
    OFF = "OFF",
    ON_EXIT = "ON_EXIT",
    ON_EXIT_AND_WINDOW_CLOSE = "ON_EXIT_AND_WINDOW_CLOSE"
}
export declare type IIActivationRequest = {
    env?: Maybe<Array<Maybe<Scalars['String']>>>;
    extensionID: Scalars['ID'];
};
export declare type IIBaseStat = {
    /**  The unified resource identifier of this file or folder  */
    resource: Scalars['URI'];
    /**
     * The name which is the last segement
     * of the {{path}}
     */
    name: Scalars['String'];
    /**
     * The size of the file.
     *
     * The value may or may not be resolved as
     * it is optional.
     */
    size?: Maybe<Scalars['Int']>;
    /**
     * The last modification date represented
     * as millis from unix epoch.
     *
     * The value may or may not be resolved as
     * it is optional.
     */
    mtime?: Maybe<Scalars['BigInt']>;
    /**
     * A unique identifier that represents the
     * current state of the file or directory.
     *
     * The value may or may not be resolved as
     * it is optional
     */
    etag?: Maybe<Scalars['String']>;
    /**  The resource is readonly.  */
    isReadonly?: Maybe<Scalars['Boolean']>;
};
/** Extension of IBaseStat with few more fields */
export declare type IIBaseStatWithMetadata = {
    mtime: Scalars['BigInt'];
    etag: Scalars['String'];
    size: Scalars['Int'];
};
/** # extension of IBaseStatWithMetadata */
export declare type IIBaseTextFileContent = {
    /** The encoding of the content if known. */
    encoding?: Maybe<Scalars['String']>;
};
export declare type IIBehaviorSubject = {
    __typename?: 'IBehaviorSubject';
    closed?: Maybe<Scalars['Boolean']>;
    hasError?: Maybe<Scalars['Boolean']>;
    isStopped?: Maybe<Scalars['Boolean']>;
    observers?: Maybe<Array<Maybe<Scalars['JSON']>>>;
    thrownError?: Maybe<Scalars['String']>;
    _isScalar?: Maybe<Scalars['Boolean']>;
    value?: Maybe<Array<Maybe<IIBehaviorSubjectValue>>>;
};
export declare type IIBehaviorSubjectValue = {
    __typename?: 'IBehaviorSubjectValue';
    provider?: Maybe<Scalars['String']>;
    registrationOptions?: Maybe<IIDocumentSelector>;
};
export declare type IIConfigurationChangeEvent = {
    __typename?: 'IConfigurationChangeEvent';
    source?: Maybe<ConfigurationTarget>;
    affectedKeys?: Maybe<Array<Maybe<Scalars['String']>>>;
    sourceConfig?: Maybe<Scalars['AnyObject']>;
    changedConfiguration?: Maybe<IConfigurationModel>;
    changedConfigurationByResource?: Maybe<IResourceMapConfigurationModel>;
};
export declare type IIContentChangedEvent = {
    changes?: Maybe<Scalars['JSON']>;
    eol?: Maybe<Scalars['String']>;
    versionId?: Maybe<Scalars['Int']>;
    isUndoing?: Maybe<Scalars['Boolean']>;
    isRedoing?: Maybe<Scalars['Boolean']>;
    isFlush?: Maybe<Scalars['Boolean']>;
};
export declare type IIDebugParams = {
    port?: Maybe<Scalars['Int']>;
    break?: Maybe<Scalars['Boolean']>;
};
export declare type IIDestinationAnonymousSubject = {
    __typename?: 'IDestinationAnonymousSubject';
    closed?: Maybe<Scalars['Boolean']>;
    destination?: Maybe<Scalars['String']>;
    hasError?: Maybe<Scalars['Boolean']>;
    isStopped?: Maybe<Scalars['Boolean']>;
    observers?: Maybe<Array<Maybe<Scalars['JSON']>>>;
    operator?: Maybe<IISwitchMapOperator>;
    source?: Maybe<IIBehaviorSubject>;
    thrownError?: Maybe<Scalars['String']>;
    _isScalar?: Maybe<Scalars['Boolean']>;
};
export declare type IIDocumentSelector = {
    __typename?: 'IDocumentSelector';
    documentSelector?: Maybe<Scalars['JSON']>;
};
/** EditorGroup that has fields borrowed from vscode. */
export declare type IIEditorGroup = {
    /**
     * A unique identifier of this group that remains identical even if the
     * group is moved to different locations.
     */
    id: Scalars['Int'];
    /**
     * A human readable lable for the group. This label can change depending
     * on the layout of all editor groups. Clients should listen to this event
     * to react to that.
     */
    label?: Maybe<Scalars['String']>;
};
export declare type IIEditorInput = {
    /** Returns the associated resource of this input. */
    resource?: Maybe<Scalars['String']>;
    /** Unique type identifier for this input. */
    typeId?: Maybe<IEDITOR_INPUT_ID>;
    /** Returns the display title of this input. */
    label?: Maybe<Scalars['String']>;
    /**
     * Returns the display description of this input that can be shown to the user. Examples include showing the desciption of
     * the input about the editor area to the side of the name of the input.
     */
    description?: Maybe<Scalars['String']>;
    /**
     * File referenced in the Editor Input to provide
     * `isDirty`, `name`
     */
    fileReference?: Maybe<IFileStatWithMetadata>;
    /**
     * Returns the preferred editor for this input. A list of candidate editors is passed in that we registered
     * for the input. This allows subclasses to decide later which editor to use for the input on a case by case basis.
     */
    preferredEditorId?: Maybe<Scalars['String']>;
    /** Set this to false if it does not make sense to split the editor input. */
    isSupportsSplitEditor?: Maybe<Scalars['Boolean']>;
};
/**
 * Additional details to EditorInput to help to resolve fields that
 * helps IEditorGroup
 */
export declare type IIEditorInputWithGroupFields = {
    /**
     * File is currently active.
     * Note: An editor can be opened but not actively visible.
     */
    isActive?: Maybe<Scalars['Boolean']>;
    /**
     * The editor is pinned in the group. A pinned editor is not replaced
     * when another editor opens at the same location.
     */
    isPinned?: Maybe<Scalars['Boolean']>;
    /**
     * The editor in the group that is in preview mode if any. There can
     * only ever be one editor in preview mode.
     */
    preview?: Maybe<Scalars['Boolean']>;
    /** custom id to map to the EditorGroup it belongs */
    editorId?: Maybe<Scalars['Int']>;
    /**
     * File loading status
     * @deprecated - We can use IFileStat to have it.
     */
    status?: Maybe<Scalars['String']>;
    /**
     * @docklayout
     * Whether this tab is closable
     */
    closable?: Maybe<Scalars['Boolean']>;
};
export declare type IIEncodingSupport = {
    /** encoding for the input for saving. */
    encoding?: Maybe<Scalars['String']>;
};
export declare type IIFileClientMetadata = {
    /** Content of the file is modified */
    dirty?: Maybe<Scalars['Boolean']>;
    /** File is in conflict with storage. */
    inConflictMode?: Maybe<Scalars['Boolean']>;
    /** File doesn't exist in the storage */
    inOrphanMode?: Maybe<Scalars['Boolean']>;
    /** File is in Error */
    inErrorMode?: Maybe<Scalars['Boolean']>;
    /** Pending Save */
    inPendingSave?: Maybe<Scalars['Boolean']>;
    preferredMode?: Maybe<Scalars['String']>;
    encoding?: Maybe<Scalars['String']>;
    preferredEncoding?: Maybe<Scalars['String']>;
    state?: Maybe<IFileModelState>;
};
/**
 * This is a tagging interface to declare an editor input being capable of dealing
 * with files. It is only used in the editor registry
 * to register this kind of input to the platform.
 *
 * As a workaround to https://github.com/graphql/graphql-spec/pull/373, we will be add additional interfaces as sub-fields.
 */
export declare type IIFileEditorInput = {
    /** Preferred encoding to use for this input. */
    preferredEncoding?: Maybe<Scalars['String']>;
    /** Preferred mode to use for this input. */
    preferredMode?: Maybe<Scalars['String']>;
    /** Forces the file input to open as binary instead of text. */
    forceOpenAsBinary?: Maybe<Scalars['Boolean']>;
};
export declare type IIFileMatch = {
    resource?: Maybe<Scalars['URI']>;
    results?: Maybe<Array<Maybe<ITextSearchResult>>>;
};
export declare type IIJSONValue_input = {
    key?: Maybe<Scalars['String']>;
    value?: Maybe<Scalars['AnyObject']>;
};
export declare type IIModel = {
    __typename?: 'IModel';
    roots?: Maybe<IIWorkspaceRoot>;
    visibleViewComponents?: Maybe<Array<Maybe<IIViewComponentData>>>;
};
export declare type IIModelInput = {
    roots?: Maybe<IIWorkspaceRootInput>;
    visibleViewComponents?: Maybe<Array<Maybe<IIViewComponentDataInput>>>;
};
export declare type IIModeSupport = {
    /** language mode of the input. */
    mode?: Maybe<Scalars['String']>;
};
export declare type IImportResult = {
    __typename?: 'ImportResult';
    stat?: Maybe<IFileStat>;
    isNew?: Maybe<Scalars['Boolean']>;
};
export declare type IIndentation = IIStatusbarItem & {
    __typename?: 'Indentation';
    id?: Maybe<Scalars['String']>;
    name?: Maybe<Scalars['String']>;
    alignment?: Maybe<IStatusbarAlignment>;
    entry?: Maybe<IStatusbarEntry>;
    priority?: Maybe<Scalars['Int']>;
    container?: Maybe<Scalars['String']>;
    labelContainer?: Maybe<Scalars['String']>;
    typeId?: Maybe<ISTATUSBAR_ITEM_ID>;
};
export declare type IInputOptions = {
    title?: Maybe<Scalars['String']>;
    value?: Maybe<Scalars['String']>;
    prompt?: Maybe<Scalars['String']>;
    placeHolder?: Maybe<Scalars['String']>;
    password?: Maybe<Scalars['Boolean']>;
    validationMessage?: Maybe<Scalars['String']>;
};
export declare type IInputTypeDetail = {
    __typename?: 'InputTypeDetail';
    type?: Maybe<Scalars['String']>;
    options?: Maybe<Array<Maybe<Scalars['String']>>>;
};
export declare type IInputTypeDetail_input = {
    type?: Maybe<Scalars['String']>;
    options?: Maybe<Array<Maybe<Scalars['String']>>>;
};
export declare type IInstalledExtension = {
    __typename?: 'InstalledExtension';
    extension?: Maybe<IGalleryExtension>;
    identifier?: Maybe<IExtensionIdentifier>;
    galleryIdentifier?: Maybe<IExtensionIdentifier>;
};
export declare type IIntegrated = {
    __typename?: 'Integrated';
    setLocaleVariables?: Maybe<Scalars['Boolean']>;
    shellArgs?: Maybe<IShellArgs>;
    shell?: Maybe<IShell>;
};
export declare type IIObservableResult = {
    __typename?: 'IObservableResult';
    closed?: Maybe<Scalars['Boolean']>;
    destination?: Maybe<IIDestinationAnonymousSubject>;
    hasError?: Maybe<Scalars['Boolean']>;
    isStopped?: Maybe<Scalars['Boolean']>;
    observers?: Maybe<Array<Maybe<Scalars['JSON']>>>;
    operator?: Maybe<IISwitchMapOperator>;
    source?: Maybe<IISourceAnonymousSubject>;
    thrownError?: Maybe<Scalars['String']>;
    _isScalar?: Maybe<Scalars['Boolean']>;
};
export declare type IIPathData = {
    /**  the file path to open within the instance  */
    fileUri?: Maybe<Scalars['URI']>;
    /**  the line number in the file path to open  */
    lineNumber?: Maybe<Scalars['Int']>;
    /**  the column number in the file path to open  */
    columnNumber?: Maybe<Scalars['Int']>;
    /**
     * a hint that the file exists. If true, the file exists, if false it does not. within
     * undefined the state is uknown.
     */
    exists?: Maybe<Scalars['Boolean']>;
};
export declare type IIPathsToWaitForData = {
    paths?: Maybe<Array<Maybe<IIPathData>>>;
    waitMarkerFileUri?: Maybe<Scalars['URI']>;
};
export declare type IISearchCompleteStats = {
    limitHit?: Maybe<Scalars['Boolean']>;
    stats?: Maybe<ISearchCompleteStatsStats>;
};
export declare type IISearchProgress = {
    total?: Maybe<Scalars['Int']>;
    worked?: Maybe<Scalars['Int']>;
    message?: Maybe<Scalars['String']>;
};
/**
 * ISettingsSubject is something that can have settings: a site ("global settings", which is different from "site
 * configuration"), an organization, or a user.
 */
export declare type IISettingsSubject = {
    /**  The ID.  */
    id?: Maybe<Scalars['ID']>;
    /**  The latest settings.  */
    latestSettings?: Maybe<ISettings>;
    /**  The URL to the settings.  */
    settingsURL: Scalars['URI'];
    /**  Whether the viewer can modify the subject's settings.  */
    viewerCanAdminister: Scalars['Boolean'];
    /**
     * All settings for this subject, and the individual levels in the settings cascade (global > organization > user)
     * that were merged to produce the final merged settings.
     */
    settingsCascade: ISettingsCascade;
};
export declare type IISideBySideEditorInput = {
    master?: Maybe<IEditorInput>;
    details?: Maybe<IEditorInput>;
};
export declare type IISourceAnonymousSubject = {
    __typename?: 'ISourceAnonymousSubject';
    closed?: Maybe<Scalars['Boolean']>;
    destination?: Maybe<IIDestinationAnonymousSubject>;
    hasError?: Maybe<Scalars['Boolean']>;
    isStopped?: Maybe<Scalars['Boolean']>;
    observers?: Maybe<Array<Maybe<Scalars['JSON']>>>;
    operator?: Maybe<IISwitchMapOperator>;
    source?: Maybe<IIBehaviorSubject>;
    thrownError?: Maybe<Scalars['String']>;
    _isScalar?: Maybe<Scalars['Boolean']>;
};
export declare type IIStaticWorkspaceData = {
    id: Scalars['String'];
    name?: Maybe<Scalars['String']>;
    configuration?: Maybe<Scalars['URI']>;
    isUntitled?: Maybe<Scalars['Boolean']>;
};
export declare type IIStatusbarItem = {
    id?: Maybe<Scalars['String']>;
    name?: Maybe<Scalars['String']>;
    alignment?: Maybe<IStatusbarAlignment>;
    entry?: Maybe<IStatusbarEntry>;
    priority?: Maybe<Scalars['Int']>;
    container?: Maybe<Scalars['String']>;
    labelContainer?: Maybe<Scalars['String']>;
    typeId?: Maybe<ISTATUSBAR_ITEM_ID>;
};
export declare type IISwitchMapOperator = {
    __typename?: 'ISwitchMapOperator';
    project?: Maybe<Scalars['String']>;
};
export declare type IITextDocumentIdentifier = {
    uri?: Maybe<Scalars['URI']>;
    /** just to statisfy few issues */
    languageId?: Maybe<Scalars['String']>;
};
/** Tree data that compatible with `react-sortable-tree` package */
export declare type IITreeItem = {
    path?: Maybe<Scalars['String']>;
    title?: Maybe<Scalars['String']>;
    subtitle?: Maybe<Scalars['String']>;
    isDirectory?: Maybe<Scalars['Boolean']>;
    active?: Maybe<Scalars['Boolean']>;
    expanded?: Maybe<Scalars['Boolean']>;
    hasChildren?: Maybe<Scalars['Boolean']>;
    /** Helps to populate data before the directory or file created. */
    isEmpty?: Maybe<Scalars['Boolean']>;
};
export declare type IIUntitledFileValue = {
    value?: Maybe<Scalars['String']>;
};
export declare type IIUserPreferences = {
    __typename?: 'IUserPreferences';
    content?: Maybe<Scalars['String']>;
    user?: Maybe<Scalars['String']>;
};
export declare type IIUserSettings = {
    __typename?: 'IUserSettings';
    data?: Maybe<Scalars['String']>;
};
export declare type IIViewComponentData = {
    __typename?: 'IViewComponentData';
    type?: Maybe<Scalars['String']>;
    item?: Maybe<ITextDocumentItem>;
    isActive?: Maybe<Scalars['Boolean']>;
};
export declare type IIViewComponentDataInput = {
    type?: Maybe<Scalars['String']>;
    item?: Maybe<ITextDocumentItemInput>;
    isActive?: Maybe<Scalars['Boolean']>;
};
export declare type IIViewDescriptor = {
    id: Scalars['String'];
    name?: Maybe<Scalars['String']>;
    when?: Maybe<Scalars['String']>;
    order?: Maybe<Scalars['Int']>;
    weight?: Maybe<Scalars['Int']>;
    collapsed?: Maybe<Scalars['Boolean']>;
    canToggleVisibility?: Maybe<Scalars['Boolean']>;
    hideByDefault?: Maybe<Scalars['Boolean']>;
    workspace?: Maybe<Scalars['Boolean']>;
};
export declare type IIWorkspaceRoot = {
    __typename?: 'IWorkspaceRoot';
    url?: Maybe<Scalars['String']>;
};
export declare type IIWorkspaceRootInput = {
    url?: Maybe<Scalars['String']>;
};
export declare type IKeepOpen_Input = {
    resource: Scalars['String'];
    editorId?: Maybe<Scalars['Int']>;
    name?: Maybe<Scalars['String']>;
};
export declare type IKeyBinding = {
    __typename?: 'KeyBinding';
    command?: Maybe<Scalars['String']>;
    key?: Maybe<Scalars['String']>;
    when?: Maybe<Scalars['String']>;
    mac?: Maybe<Scalars['String']>;
    linux?: Maybe<Scalars['String']>;
    win?: Maybe<Scalars['String']>;
};
export declare type IKeybinding_input = {
    command?: Maybe<Scalars['String']>;
    key?: Maybe<Scalars['String']>;
    when?: Maybe<Scalars['String']>;
    source?: Maybe<Scalars['String']>;
    run?: Maybe<IActionRun_input>;
};
export declare type IKeybindingContextMenu = {
    __typename?: 'KeybindingContextMenu';
    editItem?: Maybe<IEditKeybindingItem>;
    selectedItemIndex?: Maybe<Scalars['Int']>;
    editWhenIndex?: Maybe<Scalars['Int']>;
    newWhen?: Maybe<Scalars['String']>;
    isOpenDialog?: Maybe<Scalars['Boolean']>;
    search?: Maybe<Scalars['String']>;
};
export declare type IKeybindingEditorInput = IIEditorInput & IIEditorInputWithGroupFields & {
    __typename?: 'KeybindingEditorInput';
    id?: Maybe<Scalars['String']>;
    resource?: Maybe<Scalars['String']>;
    typeId?: Maybe<IEDITOR_INPUT_ID>;
    description?: Maybe<Scalars['String']>;
    label?: Maybe<Scalars['String']>;
    fileReference?: Maybe<IFileStatWithMetadata>;
    preferredEditorId?: Maybe<Scalars['String']>;
    isSupportsSplitEditor?: Maybe<Scalars['Boolean']>;
    isActive?: Maybe<Scalars['Boolean']>;
    preview?: Maybe<Scalars['Boolean']>;
    isPinned?: Maybe<Scalars['Boolean']>;
    editorId?: Maybe<Scalars['Int']>;
    status?: Maybe<Scalars['String']>;
    closable?: Maybe<Scalars['Boolean']>;
};
export declare type IKeybindingItem = {
    __typename?: 'KeybindingItem';
    command?: Maybe<Scalars['String']>;
    key?: Maybe<Scalars['String']>;
    when?: Maybe<Scalars['String']>;
    source?: Maybe<IKeybindingSource>;
    run?: Maybe<IActionRun>;
};
export declare type IKeybindingItem_input = {
    command: Scalars['String'];
    key: Scalars['String'];
    when?: Maybe<Scalars['String']>;
    args?: Maybe<Scalars['AnyObject']>;
    isDefault?: Maybe<Scalars['Boolean']>;
};
export declare type IKeybindings = {
    __typename?: 'Keybindings';
    items?: Maybe<Array<Maybe<IKeybindingItem>>>;
};
export declare const enum IKeybindingSource {
    Default = "Default",
    User = "User"
}
export declare type IKeyboardEvent_input = {
    ctrlKey?: Maybe<Scalars['Boolean']>;
    shiftKey?: Maybe<Scalars['Boolean']>;
    altKey?: Maybe<Scalars['Boolean']>;
    metaKey?: Maybe<Scalars['Boolean']>;
    keyCode?: Maybe<Scalars['Int']>;
    code?: Maybe<Scalars['String']>;
    browserEvent?: Maybe<Scalars['AnyObject']>;
};
export declare type IKeyboardEvent_output = {
    __typename?: 'KeyboardEvent_output';
    label?: Maybe<Scalars['String']>;
    key?: Maybe<Array<Maybe<Scalars['String']>>>;
};
/**
 * A segment of a key path that locates a nested JSON value in a root JSON value. Exactly one field in each
 * KeyPathSegment must be non-null.
 *
 * For example, in {"a": [0, {"b": 3}]}, the value 3 is located at the key path ["a", 1, "b"].
 */
export declare type IKeyPathSegment = {
    /**  The name of the property in the object at this location to descend into.  */
    property?: Maybe<Scalars['String']>;
    /**  The index of the array at this location to descend into.  */
    index?: Maybe<Scalars['Int']>;
};
export { LableFormatType };
export declare type ILanguageMode = IIStatusbarItem & {
    __typename?: 'LanguageMode';
    id?: Maybe<Scalars['String']>;
    name?: Maybe<Scalars['String']>;
    alignment?: Maybe<IStatusbarAlignment>;
    entry?: Maybe<IStatusbarEntry>;
    priority?: Maybe<Scalars['Int']>;
    container?: Maybe<Scalars['String']>;
    labelContainer?: Maybe<Scalars['String']>;
    typeId?: Maybe<ISTATUSBAR_ITEM_ID>;
};
export declare type ILanguages = {
    __typename?: 'Languages';
    go?: Maybe<Scalars['Boolean']>;
    css?: Maybe<Scalars['Boolean']>;
    html?: Maybe<Scalars['Boolean']>;
    json?: Maybe<Scalars['Boolean']>;
    yaml?: Maybe<Scalars['Boolean']>;
    typescript?: Maybe<Scalars['Boolean']>;
    javascript?: Maybe<Scalars['Boolean']>;
};
export declare type ILineMatch = {
    __typename?: 'LineMatch';
    preview?: Maybe<Scalars['String']>;
    lineNumber?: Maybe<Scalars['Int']>;
    offsetAndLengths?: Maybe<Array<Maybe<Array<Maybe<Scalars['Int']>>>>>;
    part?: Maybe<Scalars['Int']>;
};
export declare type ILineRange = {
    __typename?: 'LineRange';
    endColumn?: Maybe<Scalars['Int']>;
    endLine?: Maybe<Scalars['Int']>;
    startColumn?: Maybe<Scalars['Int']>;
    startLine?: Maybe<Scalars['Int']>;
};
export declare type ILineRange_input = {
    startLine?: Maybe<Scalars['Int']>;
    startColumn?: Maybe<Scalars['Int']>;
    endLine?: Maybe<Scalars['Int']>;
    endColumn?: Maybe<Scalars['Int']>;
};
export declare type ILoadOptions_Input = {
    /**  Go to disk bypassing any cahce of the model if any. */
    forceReadFromDisk?: Maybe<Scalars['Boolean']>;
    /**  Allow to load a model even if we think it is a binary file. */
    allowBinary?: Maybe<Scalars['Boolean']>;
    /**  Context why the model is being loaded. */
    reason?: Maybe<IFileLoadReason>;
};
export declare type ILocalization = {
    __typename?: 'Localization';
    languageId?: Maybe<Scalars['String']>;
    languageName?: Maybe<Scalars['String']>;
    localizedLanguageName?: Maybe<Scalars['String']>;
    translations?: Maybe<Array<Maybe<ILocalizationTranslation>>>;
    minimalTranslations?: Maybe<Scalars['JSON']>;
};
export declare type ILocalizationTranslation = {
    __typename?: 'LocalizationTranslation';
    id?: Maybe<Scalars['ID']>;
    path?: Maybe<Scalars['String']>;
};
export declare type ILocalUserSettings = IISettingsSubject & {
    __typename?: 'LocalUserSettings';
    /**  The ID.  */
    id?: Maybe<Scalars['ID']>;
    /**  The latest settings.  */
    latestSettings?: Maybe<ISettings>;
    /**  The URL to the settings.  */
    settingsURL: Scalars['URI'];
    /**  Whether the viewer can modify the subject's settings. */
    viewerCanAdminister: Scalars['Boolean'];
    /**
     * All settings for this subject, and the individual levels in the settings cascade (global > organization > user)
     * that were merged to produce the final merged settings.
     */
    settingsCascade: ISettingsCascade;
};
/**
 * Represents a location inside a resource, such as a line
 * inside a text file.
 */
export declare type ILocation = {
    rangeOrUri?: Maybe<IPosition>;
    uriRangeOrPosition?: Maybe<Scalars['String']>;
    range?: Maybe<IPosition>;
    uri?: Maybe<Scalars['String']>;
};
export declare const enum IMarkupKind {
    plaintext = "plaintext",
    markdown = "markdown"
}
export declare type IMatch = {
    __typename?: 'Match';
    start?: Maybe<Scalars['Int']>;
    end?: Maybe<Scalars['Int']>;
};
export declare type IMatch_input = {
    start?: Maybe<Scalars['Int']>;
    end?: Maybe<Scalars['Int']>;
};
export declare type IMemorySettings = IISettingsSubject & {
    __typename?: 'MemorySettings';
    /**  The ID.  */
    id?: Maybe<Scalars['ID']>;
    /**  The latest settings.  */
    latestSettings?: Maybe<ISettings>;
    /**  The URL to the settings.  */
    settingsURL: Scalars['URI'];
    /**  Whether the viewer can modify the subject's settings. */
    viewerCanAdminister: Scalars['Boolean'];
    /**
     * All settings for this subject, and the individual levels in the settings cascade (global > organization > user)
     * that were merged to produce the final merged settings.
     */
    settingsCascade: ISettingsCascade;
};
export declare const enum IMenuId {
    CommandPalette = "CommandPalette",
    DebugBreakpointsContext = "DebugBreakpointsContext",
    DebugCallStackContext = "DebugCallStackContext",
    DebugConsoleContext = "DebugConsoleContext",
    DebugVariablesContext = "DebugVariablesContext",
    DebugWatchContext = "DebugWatchContext",
    DebugTooBar = "DebugTooBar",
    EditorContext = "EditorContext",
    EditorTitle = "EditorTitle",
    EditorTitleContext = "EditorTitleContext",
    EmptyEditorGroupContext = "EmptyEditorGroupContext",
    ExplorerContext = "ExplorerContext",
    MenubarAppearanceMenu = "MenubarAppearanceMenu",
    MenubarDebugMenu = "MenubarDebugMenu",
    MenubarEditMenu = "MenubarEditMenu",
    MenubarFileMenu = "MenubarFileMenu",
    MenubarGoMenu = "MenubarGoMenu",
    MenubarNewBreakpointMenu = "MenubarNewBreakpointMenu",
    MenubarPreferencesMenu = "MenubarPreferencesMenu",
    MenubarRecentMenu = "MenubarRecentMenu",
    MenubarSelectionMenu = "MenubarSelectionMenu",
    MenubarSwitchEditorMenu = "MenubarSwitchEditorMenu",
    MenubarSwitchGroupMenu = "MenubarSwitchGroupMenu",
    MenubarTerminalMenu = "MenubarTerminalMenu",
    MenubarViewMenu = "MenubarViewMenu",
    OpenEditorContext = "OpenEditorContext",
    ProblemsPanelContext = "ProblemsPanelContext",
    SCMChangeContext = "SCMChangeContext",
    SCMResourceContext = "SCMResourceContext",
    SCMResourceGroupContext = "SCMResourceGroupContext",
    SCMResourceControl = "SCMResourceControl",
    SCMTitle = "SCMTitle",
    SearchContext = "SearchContext",
    StatusBarWindowIndicatorMenu = "StatusBarWindowIndicatorMenu",
    TouchBarContext = "TouchBarContext",
    ViewItemContext = "ViewItemContext",
    ViewTitle = "ViewTitle",
    CommentThreadTitle = "CommentThreadTitle",
    CommentThreadActions = "CommentThreadActions",
    CommentTitle = "CommentTitle",
    CommentActions = "CommentActions"
}
export declare type IMenuItem = {
    __typename?: 'MenuItem';
    id?: Maybe<Scalars['String']>;
    label?: Maybe<Scalars['String']>;
    enabled?: Maybe<Scalars['Boolean']>;
    run?: Maybe<IActionRun>;
};
export declare type IMenuItem_input = {
    id?: Maybe<Scalars['String']>;
    label?: Maybe<Scalars['String']>;
    enabled?: Maybe<Scalars['Boolean']>;
    run?: Maybe<IActionRun_input>;
};
export declare type IMenuItemAction = {
    __typename?: 'MenuItemAction';
    action?: Maybe<Scalars['String']>;
    when?: Maybe<Scalars['String']>;
};
export declare type IMenuItemActionContext = {
    __typename?: 'MenuItemActionContext';
    context?: Maybe<Array<Maybe<IMenuItemAction>>>;
};
export declare type IMenuItemActionDebug = {
    __typename?: 'MenuItemActionDebug';
    callstack?: Maybe<IMenuItemActionContext>;
    toolbar?: Maybe<Array<Maybe<IMenuItemAction>>>;
};
export declare type IMenuItemActionEditor = {
    __typename?: 'MenuItemActionEditor';
    context?: Maybe<Array<Maybe<IMenuItemAction>>>;
    title?: Maybe<IMenuItemActionEditorTitle>;
};
export declare type IMenuItemActionEditorTitle = {
    __typename?: 'MenuItemActionEditorTitle';
    own?: Maybe<Array<Maybe<IMenuItemAction>>>;
    context?: Maybe<Array<Maybe<IMenuItemAction>>>;
};
export declare type IMenuItemActionScm = {
    __typename?: 'MenuItemActionScm';
    /**  The Source Control title menu  */
    title?: Maybe<Array<Maybe<IMenuItemAction>>>;
    /**  The Source Control resource group context menu  */
    resourceGroup?: Maybe<IMenuItemActionContext>;
    resource?: Maybe<IMenuItemActionContext>;
    change?: Maybe<IMenuItemActionScmChange>;
};
export declare type IMenuItemActionScmChange = {
    __typename?: 'MenuItemActionScmChange';
    title?: Maybe<Array<Maybe<IMenuItemAction>>>;
};
export declare type IMenuItemActionView = {
    __typename?: 'MenuItemActionView';
    /**  The contributed view title menu  */
    title?: Maybe<Array<Maybe<IMenuItemAction>>>;
    /**  The contributed view item context menu  */
    item?: Maybe<IMenuItemActionContext>;
};
export declare type IMenus = {
    __typename?: 'Menus';
    /**  The Command Palette  */
    commandPalette?: Maybe<Array<Maybe<IMenuItemAction>>>;
    /**  The file explorer  */
    explorer?: Maybe<IMenuItemActionContext>;
    /**  The editor  */
    editor?: Maybe<IMenuItemActionEditor>;
    /**  The debug  */
    debug?: Maybe<IMenuItemActionDebug>;
    /**  The Source Control  */
    scm?: Maybe<IMenuItemActionScm>;
    /**  The contributed view  */
    view?: Maybe<IMenuItemActionView>;
    /**  The touch bar (macOS only)  */
    touchBar?: Maybe<Array<Maybe<IMenuItemAction>>>;
};
export { MergeGroupMode };
export declare type IMergeGroupOptions_Input = {
    mode?: Maybe<MergeGroupMode>;
    index?: Maybe<Scalars['Int']>;
};
export declare type IMessageBoxOptions = {
    __typename?: 'MessageBoxOptions';
    type?: Maybe<Scalars['String']>;
    buttons?: Maybe<Array<Maybe<Scalars['String']>>>;
    defaultId?: Maybe<Scalars['Int']>;
    title?: Maybe<Scalars['String']>;
    message?: Maybe<Scalars['String']>;
    detail?: Maybe<Scalars['String']>;
    checkboxLabel?: Maybe<Scalars['String']>;
    checkboxChecked?: Maybe<Scalars['Boolean']>;
    cancelId?: Maybe<Scalars['Int']>;
    noLink?: Maybe<Scalars['Boolean']>;
    normalizeAccessKeys?: Maybe<Scalars['Boolean']>;
};
export declare type IMessageBoxResult = {
    __typename?: 'MessageBoxResult';
    button?: Maybe<Scalars['Int']>;
    checkboxChecked?: Maybe<Scalars['Boolean']>;
};
export declare type IMessageLink = {
    __typename?: 'MessageLink';
    name?: Maybe<Scalars['String']>;
    href?: Maybe<Scalars['String']>;
    offset?: Maybe<Scalars['Int']>;
    length?: Maybe<Scalars['Int']>;
};
export declare type IMessageLink_input = {
    name?: Maybe<Scalars['String']>;
    href?: Maybe<Scalars['String']>;
    offset?: Maybe<Scalars['Int']>;
    length?: Maybe<Scalars['Int']>;
};
export declare type IModelLoadOrCreateOptions_Input = {
    /**  Context why the model is being loaded or created. */
    reason?: Maybe<IFileLoadReason>;
    /**  The language mode to use for the model text content. */
    mode?: Maybe<Scalars['String']>;
    /**  The encoding to use when resolving the model text content. */
    encoding?: Maybe<Scalars['String']>;
    /**
     * If the model was already loaded before, allows to trigger
     * a reload of it to fetch the latest contents:
     * - async: loadOrCreate() will return immediately and trigger
     * a reload that will run in the background.
     * - sync: loadOrCreate() will only return resolved when the
     * model was finished reloading.
     */
    reload?: Maybe<IModelLoadOrCreateOptions_Input_reload>;
    /**  Allow to load a model even if we think it is a binary file. */
    allowBinary?: Maybe<Scalars['Boolean']>;
};
export declare type IModelLoadOrCreateOptions_Input_reload = {
    async?: Maybe<Scalars['Boolean']>;
};
/**  All Moleculer Topic names are extended from this. */
export declare const enum IMoleculerServiceName {
    ConfigurationClientService = "ConfigurationClientService",
    ConfigurationService = "ConfigurationService",
    EnvironmentService = "EnvironmentService",
    LifecycleService = "LifecycleService",
    WorkbenchLifecycleEmitter = "WorkbenchLifecycleEmitter",
    WorkbenchLifecycleListener = "WorkbenchLifecycleListener",
    WorkspaceClientContextService = "WorkspaceClientContextService",
    WorkspaceContextService = "WorkspaceContextService",
    WorkspaceEventually = "WorkspaceEventually",
    /**  Following services will help to wait other services  */
    WorkspaceReady = "WorkspaceReady",
    WorkspaceRestore = "WorkspaceRestore",
    WorkspaceStarted = "WorkspaceStarted",
    dummy = "dummy"
}
export declare type IMoveEditor_Input = {
    resource: Scalars['String'];
    editorId?: Maybe<Scalars['Int']>;
    name?: Maybe<Scalars['String']>;
};
export declare type IMoveEditorOptions_Input = {
    index?: Maybe<Scalars['Int']>;
    inactive?: Maybe<Scalars['Boolean']>;
    preserveFocus?: Maybe<Scalars['Boolean']>;
};
export declare type IMutation = {
    __typename?: 'Mutation';
    activate?: Maybe<Scalars['Boolean']>;
    activateEditor?: Maybe<Scalars['Boolean']>;
    addEntry?: Maybe<Scalars['Boolean']>;
    addFolders?: Maybe<Scalars['Boolean']>;
    addNotification?: Maybe<Scalars['Boolean']>;
    canHandleResource?: Maybe<Scalars['Boolean']>;
    changeEdit?: Maybe<Scalars['Boolean']>;
    changeKeybinding?: Maybe<Scalars['Boolean']>;
    changeWhenExpression?: Maybe<Scalars['Boolean']>;
    changeWorkspace?: Maybe<Scalars['Boolean']>;
    clearSearchCache?: Maybe<Scalars['Boolean']>;
    closeAllEditors?: Maybe<Scalars['Boolean']>;
    closeDialog?: Maybe<Scalars['Boolean']>;
    closeEditor?: Maybe<Scalars['Boolean']>;
    closeEditors?: Maybe<Scalars['Boolean']>;
    closeNotification?: Maybe<Scalars['Boolean']>;
    codeLenseProviderDefinition?: Maybe<Scalars['Observable']>;
    completionProviderDefinition?: Maybe<Scalars['Observable']>;
    copy?: Maybe<Scalars['Boolean']>;
    copyFile?: Maybe<IFileStatWithMetadata>;
    /**  Create a new extension in the extension registry. */
    createExtension: IRegistryExtension;
    createFile?: Maybe<IFileStatWithMetadata>;
    createFolder?: Maybe<IFileStatWithMetadata>;
    /**
     * Create a file. If the file exists it will be overwritten with the contents if
     * the options enable to overwrite.
     */
    createTextFile?: Maybe<IFileStatWithMetadata>;
    createUntitledFile?: Maybe<IFileStatWithMetadata>;
    definitionDefinition?: Maybe<Scalars['Observable']>;
    del?: Maybe<Scalars['Boolean']>;
    /**
     * Delete an extension from the extension registry.
     *
     * Only authorized extension publishers may perform this mutation.
     */
    deleteExtension: IEmptyResponse;
    /** Delete a file. If the file is dirty, it will get reverted and then deleted from disk. */
    deleteTextFile?: Maybe<Scalars['Boolean']>;
    documentFormattingProviderDefinition?: Maybe<Scalars['Observable']>;
    documentHighLightProviderDefinition?: Maybe<Scalars['Observable']>;
    documentSymbolDefinition?: Maybe<Scalars['Observable']>;
    dummy?: Maybe<Scalars['Int']>;
    editKeybinding?: Maybe<Scalars['Boolean']>;
    findFileStat?: Maybe<IFileStatWithMetadata>;
    getConfigurationTarget?: Maybe<Scalars['Int']>;
    getEditorState?: Maybe<ICodeEditorViewState>;
    getFilesTreeData?: Maybe<Array<Maybe<IFileStatWithMetadata>>>;
    gotoLine?: Maybe<Scalars['Boolean']>;
    handler?: Maybe<Scalars['Boolean']>;
    hideContextMenu?: Maybe<Scalars['Boolean']>;
    hideInputModel?: Maybe<Scalars['Boolean']>;
    hideKeybindingDialog?: Maybe<Scalars['Boolean']>;
    highlightLine?: Maybe<Scalars['Boolean']>;
    hoverProviderDefinition?: Maybe<Scalars['Observable']>;
    install?: Maybe<IExtensionIdentifier>;
    jsonWrite?: Maybe<Scalars['Boolean']>;
    keepOpen?: Maybe<Scalars['Boolean']>;
    loadFile?: Maybe<IFileStatWithMetadata>;
    loadFileContent?: Maybe<IFileContent>;
    loadFileWithContent?: Maybe<ITextFileContent>;
    loadFilesTreeData?: Maybe<Array<Maybe<IFileStatWithMetadata>>>;
    lookupKeybinding?: Maybe<Scalars['String']>;
    makePinEditor?: Maybe<Scalars['Boolean']>;
    moveEditorInsideGroup?: Maybe<Scalars['Boolean']>;
    moveFile?: Maybe<IFileStatWithMetadata>;
    /** Move a file. If the file is dirty, its contents will be preserved and restored. */
    moveTextFile?: Maybe<IFileStatWithMetadata>;
    notify?: Maybe<Scalars['Boolean']>;
    notifyError?: Maybe<Scalars['Boolean']>;
    notifyInfo?: Maybe<Scalars['Boolean']>;
    notifyPrompt?: Maybe<Scalars['Boolean']>;
    notifyWarn?: Maybe<Scalars['Boolean']>;
    /**
     * Open an editor or file in an EditorGroup.
     * If no EditorGroup exist, it creates one.
     */
    openEditor?: Maybe<Scalars['Boolean']>;
    /**
     * Open an editor in an editor group.
     *
     * @param editor the editor to open
     * @param group the target group. If unspecified, the editor will open in the currently
     * active group. Use `SIDE_GROUP_TYPE` to open the editor in a new editor group to the side
     * of the currently active group.
     */
    openEditorWithResourceDiffInput?: Maybe<Scalars['Boolean']>;
    /**
     * Open an editor in an editor group.
     *
     * @param editor the editor to open
     * @param group the target group. If unspecified, the editor will open in the currently
     * active group. Use `SIDE_GROUP_TYPE` to open the editor in a new editor group to the side
     * of the currently active group.
     */
    openEditorWithResourceInput?: Maybe<Scalars['Boolean']>;
    /**
     * Open an editor in an editor group.
     *
     * @param editor the editor to open
     * @param group the target group. If unspecified, the editor will open in the currently
     * active group. Use `SIDE_GROUP_TYPE` to open the editor in a new editor group to the side
     * of the currently active group.
     */
    openEditorWithResourceSideBySideInput?: Maybe<Scalars['Boolean']>;
    /**
     * Open an editor in an editor group.
     *
     * @param editor the editor to open
     * @param group the target group. If unspecified, the editor will open in the currently
     * active group. Use `SIDE_GROUP_TYPE` to open the editor in a new editor group to the side
     * of the currently active group.
     */
    openEditorWithUntitledResourceInput?: Maybe<Scalars['Boolean']>;
    /** @deprecated use openEditor */
    openFile?: Maybe<Scalars['Boolean']>;
    openGlobalKeybindingSettings?: Maybe<Scalars['Boolean']>;
    openLanguageDocument?: Maybe<Scalars['Observable']>;
    openPreferenceSettings?: Maybe<Scalars['Boolean']>;
    /**
     * Publish an extension in the extension registry, creating it (if it doesn't yet exist) or updating it (if it
     * does).
     *
     * This is a helper that wraps multiple other GraphQL mutations to expose a single API for publishing an
     * extension.
     */
    publishExtension: IExtensionRegistryPublishExtensionResult;
    /**
     * Read the contents of a file identified by the resource.
     *
     * Added inaddition to the query as we want to manipulate the cache with `update` option available in `mutation`.
     * However, with apollo-client v3.0 we can start using it as `Query` as they support custom `merge`.
     */
    readTextFile?: Maybe<ITextFileContent>;
    referenceProviderDefinition?: Maybe<Scalars['Observable']>;
    registerKeybinding?: Maybe<Scalars['Boolean']>;
    removeChangedContent?: Maybe<Scalars['Boolean']>;
    removeEdit?: Maybe<Scalars['Boolean']>;
    removeExtension?: Maybe<Scalars['Boolean']>;
    removeFolders?: Maybe<Scalars['Boolean']>;
    removeKeybinding?: Maybe<Scalars['Boolean']>;
    removeStatusbarEntry?: Maybe<Scalars['Boolean']>;
    rename?: Maybe<IFileStatWithMetadata>;
    renameDefinition?: Maybe<Scalars['Observable']>;
    replaceContent?: Maybe<IReplaceContentResult>;
    resetKeybinding?: Maybe<Scalars['Boolean']>;
    resetSetting?: Maybe<Scalars['Boolean']>;
    resolveKeyboardEvent?: Maybe<IKeyboardEvent_output>;
    runMenuAction?: Maybe<Scalars['Boolean']>;
    saveAllEditor?: Maybe<Scalars['Boolean']>;
    saveFile?: Maybe<IFileStat>;
    saveFileAs?: Maybe<Scalars['URI']>;
    saveUserSettings?: Maybe<ISaveWorkspaceRes>;
    saveWorkspaceSettings?: Maybe<ISaveWorkspaceRes>;
    searchKeybinding?: Maybe<Scalars['Boolean']>;
    selectEdit?: Maybe<Scalars['Boolean']>;
    setEncoding?: Maybe<Scalars['Boolean']>;
    setFilesTreeData?: Maybe<Scalars['Boolean']>;
    setSelected?: Maybe<Scalars['Boolean']>;
    setSelectedKeybindingIndex?: Maybe<Scalars['Boolean']>;
    setStatusMessage?: Maybe<Scalars['String']>;
    show?: Maybe<Scalars['Boolean']>;
    showContextMenu?: Maybe<Scalars['Boolean']>;
    showInput?: Maybe<Scalars['Boolean']>;
    showPickInput?: Maybe<Scalars['Boolean']>;
    startExtensionHost?: Maybe<Scalars['Boolean']>;
    stopEditWhenExpression?: Maybe<Scalars['Boolean']>;
    switchSettings?: Maybe<Scalars['Boolean']>;
    testNotification?: Maybe<Scalars['Boolean']>;
    textSearch_?: Maybe<ISearchComplete>;
    unwatch?: Maybe<Scalars['Boolean']>;
    unwatchFileChanges?: Maybe<Scalars['Boolean']>;
    updateChangedContent?: Maybe<Scalars['Boolean']>;
    updateConfigurationValue?: Maybe<Scalars['Boolean']>;
    updateContent?: Maybe<IFileStatWithMetadata>;
    updateContext?: Maybe<Scalars['Boolean']>;
    updateEditorState?: Maybe<Scalars['Boolean']>;
    /**
     * Update an extension in the extension registry.
     *
     * Only authorized extension publishers may perform this mutation.
     */
    updateExtension: IRegistryExtension;
    updateFileDirtyState?: Maybe<Scalars['Boolean']>;
    updateFolders?: Maybe<Scalars['Boolean']>;
    updateLayout?: Maybe<Scalars['Boolean']>;
    /** @deprecated need to remove */
    updateModel?: Maybe<Scalars['Boolean']>;
    updateSelectedResource?: Maybe<Scalars['Boolean']>;
    updateStatusbarEntry?: Maybe<Scalars['Boolean']>;
    updateWorkspaceContextAddFolders?: Maybe<Array<Maybe<IWorkspaceFolderData>>>;
    updateWorkspaceContextRemoveFolders?: Maybe<Array<Maybe<IWorkspaceFolderData>>>;
    updateWorkspaceContextUpdateFolders?: Maybe<Array<Maybe<IWorkspaceFolderData>>>;
    watchFile?: Maybe<Scalars['String']>;
    /**
     * Allows to start a watcher that reports file change events on the provided resource.
     *
     * Note: watching a folder does not report events recursively for child folders yet.
     */
    watchFileChanges?: Maybe<Scalars['Boolean']>;
    writeChunk?: Maybe<IUpdatedResource>;
    writeChunkWithDelay?: Maybe<IUpdateDelayedResource>;
    writeContent?: Maybe<Scalars['Boolean']>;
    /** Update a file with given contents. */
    writeTextFile?: Maybe<IFileStatWithMetadata>;
};
export declare type IMutationactivateArgs = {
    request: IIActivationRequest;
};
export declare type IMutationactivateEditorArgs = {
    editorId?: Maybe<Scalars['Int']>;
};
export declare type IMutationaddEntryArgs = {
    arg?: Maybe<IAddEntry_input>;
};
export declare type IMutationaddFoldersArgs = {
    folders?: Maybe<Array<Maybe<IFolder_input>>>;
    index?: Maybe<Scalars['Int']>;
};
export declare type IMutationaddNotificationArgs = {
    notification?: Maybe<INotification_input>;
};
export declare type IMutationcanHandleResourceArgs = {
    resource: Scalars['URI'];
};
export declare type IMutationchangeEditArgs = {
    changed?: Maybe<Scalars['Boolean']>;
    resource?: Maybe<Scalars['String']>;
};
export declare type IMutationchangeKeybindingArgs = {
    editItem?: Maybe<IKeybindingItem_input>;
    selectedIndex?: Maybe<Scalars['Int']>;
    isOpenDialog?: Maybe<Scalars['Boolean']>;
};
export declare type IMutationchangeWhenExpressionArgs = {
    editItem?: Maybe<IKeybindingItem_input>;
    editWhenIndex?: Maybe<Scalars['Int']>;
    newWhen?: Maybe<Scalars['String']>;
};
export declare type IMutationchangeWorkspaceArgs = {
    args?: Maybe<IArgs_input>;
};
export declare type IMutationclearSearchCacheArgs = {
    cacheKey?: Maybe<Scalars['String']>;
};
export declare type IMutationcloseEditorArgs = {
    content?: Maybe<ICloseEditor_Input>;
    layoutId?: Maybe<Scalars['String']>;
};
export declare type IMutationcloseEditorsArgs = {
    editors?: Maybe<Array<Maybe<ICloseEditor_Input>>>;
    editorGroupId?: Maybe<Scalars['Int']>;
    options?: Maybe<ICloseEditorOptions_Input>;
};
export declare type IMutationcloseNotificationArgs = {
    index?: Maybe<Scalars['Int']>;
};
export declare type IMutationcodeLenseProviderDefinitionArgs = {
    params?: Maybe<ITextDocumentPositionParamsInput>;
};
export declare type IMutationcompletionProviderDefinitionArgs = {
    params?: Maybe<ITextDocumentPositionParamsInput>;
};
export declare type IMutationcopyArgs = {
    value?: Maybe<Scalars['String']>;
};
export declare type IMutationcopyFileArgs = {
    source: Scalars['URI'];
    target: Scalars['URI'];
    overwrite?: Maybe<Scalars['Boolean']>;
};
export declare type IMutationcreateExtensionArgs = {
    publisher: Scalars['ID'];
    name: Scalars['String'];
};
export declare type IMutationcreateFileArgs = {
    resource: Scalars['URI'];
    bufferOrReadable?: Maybe<Scalars['VSBuffer']>;
    options?: Maybe<ICreateFileOptions_Input>;
};
export declare type IMutationcreateFolderArgs = {
    resource: Scalars['URI'];
};
export declare type IMutationcreateTextFileArgs = {
    resource: Scalars['URI'];
    content?: Maybe<Scalars['String']>;
    overwrite?: Maybe<Scalars['Boolean']>;
};
export declare type IMutationcreateUntitledFileArgs = {
    resource?: Maybe<Scalars['URI']>;
    mode?: Maybe<Scalars['String']>;
    initialValue?: Maybe<Scalars['String']>;
    encoding?: Maybe<Scalars['String']>;
    hasAssociatedFilePath?: Maybe<Scalars['Boolean']>;
};
export declare type IMutationdefinitionDefinitionArgs = {
    params?: Maybe<ITextDocumentPositionParamsInput>;
};
export declare type IMutationdelArgs = {
    resource: Scalars['URI'];
    options?: Maybe<IDeleteFileOptions_Input>;
};
export declare type IMutationdeleteExtensionArgs = {
    extension: Scalars['ID'];
};
export declare type IMutationdeleteTextFileArgs = {
    resource: Scalars['URI'];
    useTrash?: Maybe<Scalars['Boolean']>;
};
export declare type IMutationdocumentFormattingProviderDefinitionArgs = {
    params?: Maybe<ITextDocumentPositionParamsInput>;
};
export declare type IMutationdocumentHighLightProviderDefinitionArgs = {
    params?: Maybe<ITextDocumentPositionParamsInput>;
};
export declare type IMutationdocumentSymbolDefinitionArgs = {
    params?: Maybe<ITextDocumentPositionParamsInput>;
};
export declare type IMutationeditKeybindingArgs = {
    keybindingItem?: Maybe<IKeybindingItem_input>;
    key?: Maybe<Scalars['String']>;
    when?: Maybe<Scalars['String']>;
};
export declare type IMutationfindFileStatArgs = {
    resource: Scalars['URI'];
};
export declare type IMutationgetConfigurationTargetArgs = {
    resource?: Maybe<Scalars['URI']>;
};
export declare type IMutationgetEditorStateArgs = {
    editorId: Scalars['String'];
    resource: Scalars['URI'];
};
export declare type IMutationgetFilesTreeDataArgs = {
    resource: Scalars['URI'];
};
export declare type IMutationgotoLineArgs = {
    range?: Maybe<ILineRange_input>;
};
export declare type IMutationhandlerArgs = {
    arg?: Maybe<IActionRun_input>;
};
export declare type IMutationhighlightLineArgs = {
    range?: Maybe<ILineRange_input>;
};
export declare type IMutationhoverProviderDefinitionArgs = {
    params?: Maybe<ITextDocumentPositionParamsInput>;
};
export declare type IMutationinstallArgs = {
    vsix: Scalars['String'];
};
export declare type IMutationjsonWriteArgs = {
    resource?: Maybe<Scalars['URI']>;
    value?: Maybe<IIJSONValue_input>;
    save?: Maybe<Scalars['Boolean']>;
};
export declare type IMutationkeepOpenArgs = {
    content?: Maybe<IKeepOpen_Input>;
};
export declare type IMutationloadFileArgs = {
    resource: Scalars['URI'];
    options?: Maybe<IResolveMetadataFileOptions_Input>;
};
export declare type IMutationloadFileContentArgs = {
    resource: Scalars['URI'];
    options?: Maybe<IReadFileOptions_Input>;
};
export declare type IMutationloadFileWithContentArgs = {
    resource: Scalars['URI'];
    options?: Maybe<ILoadOptions_Input>;
};
export declare type IMutationloadFilesTreeDataArgs = {
    resource: Scalars['URI'];
};
export declare type IMutationlookupKeybindingArgs = {
    commandId?: Maybe<Scalars['String']>;
};
export declare type IMutationmakePinEditorArgs = {
    tabId?: Maybe<Scalars['String']>;
    editorId?: Maybe<Scalars['Int']>;
};
export declare type IMutationmoveEditorInsideGroupArgs = {
    content?: Maybe<IMoveEditor_Input>;
    moveOptions?: Maybe<IMoveEditorOptions_Input>;
};
export declare type IMutationmoveFileArgs = {
    source: Scalars['URI'];
    target: Scalars['URI'];
    overwrite?: Maybe<Scalars['Boolean']>;
};
export declare type IMutationmoveTextFileArgs = {
    source: Scalars['URI'];
    target: Scalars['URI'];
    overwrite?: Maybe<Scalars['Boolean']>;
};
export declare type IMutationnotifyArgs = {
    notification?: Maybe<INotification_input>;
};
export declare type IMutationnotifyErrorArgs = {
    message?: Maybe<Array<Maybe<INotificationMessage_input>>>;
};
export declare type IMutationnotifyInfoArgs = {
    message?: Maybe<Array<Maybe<INotificationMessage_input>>>;
};
export declare type IMutationnotifyPromptArgs = {
    severity?: Maybe<NotificationSeverity>;
    message?: Maybe<Scalars['String']>;
    choices?: Maybe<Array<Maybe<IPromptChoice_input>>>;
    options?: Maybe<IPromptOptions_input>;
};
export declare type IMutationnotifyWarnArgs = {
    message?: Maybe<Array<Maybe<INotificationMessage_input>>>;
};
export declare type IMutationopenEditorArgs = {
    content: IOpenEditor_Input;
    options?: Maybe<IEditorOpenOptions_Input>;
};
export declare type IMutationopenEditorWithResourceDiffInputArgs = {
    editor: IResourceDiff_Input;
    group?: Maybe<Scalars['Int']>;
};
export declare type IMutationopenEditorWithResourceInputArgs = {
    editor: IResource_Input;
    group?: Maybe<Scalars['Int']>;
};
export declare type IMutationopenEditorWithResourceSideBySideInputArgs = {
    editor: IResourceSideBySide_Input;
    group?: Maybe<Scalars['Int']>;
};
export declare type IMutationopenEditorWithUntitledResourceInputArgs = {
    editor: IUntitledResource_Input;
    group?: Maybe<Scalars['Int']>;
};
export declare type IMutationopenFileArgs = {
    content: IOpenEditor_Input;
    options?: Maybe<IEditorOpenOptions_Input>;
};
export declare type IMutationopenGlobalKeybindingSettingsArgs = {
    textual?: Maybe<Scalars['Boolean']>;
};
export declare type IMutationopenLanguageDocumentArgs = {
    params?: Maybe<IOpenDocumentParamsInput>;
};
export declare type IMutationopenPreferenceSettingsArgs = {
    jsonEditor?: Maybe<Scalars['Boolean']>;
    query?: Maybe<Scalars['String']>;
};
export declare type IMutationpublishExtensionArgs = {
    name?: Maybe<Scalars['String']>;
    version?: Maybe<Scalars['String']>;
    extensionID: Scalars['String'];
    manifest: Scalars['String'];
    bundle?: Maybe<Scalars['String']>;
    sourceMap?: Maybe<Scalars['String']>;
    force?: Maybe<Scalars['Boolean']>;
};
export declare type IMutationreadTextFileArgs = {
    resource: Scalars['URI'];
    options?: Maybe<IReadTextFileOptions_Input>;
};
export declare type IMutationreferenceProviderDefinitionArgs = {
    params?: Maybe<ITextDocumentPositionParamsInput>;
};
export declare type IMutationregisterKeybindingArgs = {
    keybinding?: Maybe<IKeybinding_input>;
};
export declare type IMutationremoveChangedContentArgs = {
    resource: Scalars['URI'];
    reset?: Maybe<Scalars['Boolean']>;
};
export declare type IMutationremoveEditArgs = {
    content?: Maybe<IRemoveEditor_Input>;
};
export declare type IMutationremoveExtensionArgs = {
    id: Scalars['String'];
};
export declare type IMutationremoveFoldersArgs = {
    folders?: Maybe<Array<Maybe<Scalars['URI']>>>;
};
export declare type IMutationremoveKeybindingArgs = {
    keybindingItem?: Maybe<IKeybindingItem_input>;
};
export declare type IMutationremoveStatusbarEntryArgs = {
    id: Scalars['ID'];
};
export declare type IMutationrenameArgs = {
    resource: Scalars['URI'];
    target: Scalars['URI'];
    overwrite?: Maybe<Scalars['Boolean']>;
};
export declare type IMutationrenameDefinitionArgs = {
    params?: Maybe<ITextDocumentPositionParamsInput>;
};
export declare type IMutationreplaceContentArgs = {
    resource?: Maybe<Scalars['String']>;
    oldText?: Maybe<Scalars['String']>;
    newText?: Maybe<Scalars['String']>;
};
export declare type IMutationresetKeybindingArgs = {
    keybindingItem?: Maybe<IKeybindingItem_input>;
};
export declare type IMutationresetSettingArgs = {
    resource?: Maybe<Scalars['URI']>;
    settingKey?: Maybe<Scalars['String']>;
};
export declare type IMutationresolveKeyboardEventArgs = {
    keyboardEvent?: Maybe<IKeyboardEvent_input>;
};
export declare type IMutationrunMenuActionArgs = {
    argument?: Maybe<IActionRun_input>;
};
export declare type IMutationsaveAllEditorArgs = {
    allSave?: Maybe<Scalars['Boolean']>;
};
export declare type IMutationsaveFileArgs = {
    resource: Scalars['URI'];
    versionId?: Maybe<Scalars['Int']>;
    options: ISaveOptions_Input;
};
export declare type IMutationsaveFileAsArgs = {
    resource: Scalars['String'];
    versionId?: Maybe<Scalars['Int']>;
    options: ISaveOptions_Input;
    target?: Maybe<Scalars['String']>;
};
export declare type IMutationsaveUserSettingsArgs = {
    content?: Maybe<Scalars['String']>;
};
export declare type IMutationsearchKeybindingArgs = {
    value?: Maybe<Scalars['String']>;
};
export declare type IMutationselectEditArgs = {
    content?: Maybe<ISelectEditor_Input>;
};
export declare type IMutationsetEncodingArgs = {
    resource: Scalars['URI'];
    encoding?: Maybe<Scalars['String']>;
};
export declare type IMutationsetFilesTreeDataArgs = {
    treeData?: Maybe<Array<Maybe<ITreeData_Input>>>;
    originalData?: Maybe<ITreeData_Input>;
};
export declare type IMutationsetSelectedArgs = {
    selectedValue?: Maybe<Array<Maybe<IPickItem>>>;
    inputValue?: Maybe<Scalars['String']>;
};
export declare type IMutationsetSelectedKeybindingIndexArgs = {
    index?: Maybe<Scalars['Int']>;
};
export declare type IMutationsetStatusMessageArgs = {
    arg?: Maybe<ISetStatusMsg_input>;
};
export declare type IMutationshowArgs = {
    dialog?: Maybe<IDialog_input>;
};
export declare type IMutationshowContextMenuArgs = {
    delegate?: Maybe<IContextMenu_input>;
};
export declare type IMutationshowInputArgs = {
    options?: Maybe<IInputOptions>;
};
export declare type IMutationshowPickInputArgs = {
    items?: Maybe<Array<Maybe<IPickItem>>>;
    options?: Maybe<IPickInputOptions>;
};
export declare type IMutationstartExtensionHostArgs = {
    request?: Maybe<Scalars['String']>;
};
export declare type IMutationswitchSettingsArgs = {
    target?: Maybe<Scalars['Int']>;
    editorId?: Maybe<Scalars['Int']>;
    resource?: Maybe<Scalars['URI']>;
    jsonEditor?: Maybe<Scalars['Boolean']>;
};
export declare type IMutationtextSearch_Args = {
    query?: Maybe<ITextQueryInput>;
};
export declare type IMutationunwatchArgs = {
    resource: Scalars['URI'];
    session: Scalars['String'];
};
export declare type IMutationunwatchFileChangesArgs = {
    resource: Scalars['URI'];
    session: Scalars['String'];
};
export declare type IMutationupdateChangedContentArgs = {
    resource: Scalars['URI'];
    changedEvent: IContentChangedEvent_Input;
};
export declare type IMutationupdateConfigurationValueArgs = {
    key: Scalars['String'];
    value: Scalars['AnyObject'];
    overrides?: Maybe<IConfigurationOverrides_Input>;
    target?: Maybe<Scalars['Int']>;
    donotNotifyError?: Maybe<Scalars['Boolean']>;
};
export declare type IMutationupdateContentArgs = {
    resource: Scalars['URI'];
    value: Scalars['VSBuffer'];
    options: IWriteFileOptions_Input;
};
export declare type IMutationupdateContextArgs = {
    key?: Maybe<Scalars['String']>;
    value?: Maybe<Scalars['AnyObject']>;
};
export declare type IMutationupdateEditorStateArgs = {
    editorId: Scalars['String'];
    resource: Scalars['URI'];
    state: ICodeEditorViewState_Input;
};
export declare type IMutationupdateExtensionArgs = {
    extension: Scalars['ID'];
    name?: Maybe<Scalars['String']>;
};
export declare type IMutationupdateFileDirtyStateArgs = {
    resource: Scalars['URI'];
    isFileDirty: Scalars['Boolean'];
};
export declare type IMutationupdateFoldersArgs = {
    foldersToAdd?: Maybe<Array<Maybe<IFolder_input>>>;
    foldersToRemove?: Maybe<Array<Maybe<Scalars['URI']>>>;
    index?: Maybe<Scalars['Int']>;
};
export declare type IMutationupdateLayoutArgs = {
    changedLayout?: Maybe<IEditorLayout_Input>;
};
export declare type IMutationupdateModelArgs = {
    model?: Maybe<IIModelInput>;
};
export declare type IMutationupdateSelectedResourceArgs = {
    resource: Scalars['URI'];
};
export declare type IMutationupdateStatusbarEntryArgs = {
    arg?: Maybe<IUpdateEntry_input>;
};
export declare type IMutationupdateWorkspaceContextAddFoldersArgs = {
    foldersToAdd?: Maybe<Array<Maybe<IFoldersToAdd_Input>>>;
    index?: Maybe<Scalars['Int']>;
};
export declare type IMutationupdateWorkspaceContextRemoveFoldersArgs = {
    foldersToRemove?: Maybe<Array<Maybe<Scalars['URI']>>>;
};
export declare type IMutationupdateWorkspaceContextUpdateFoldersArgs = {
    foldersToAdd?: Maybe<Array<Maybe<IFoldersToAdd_Input>>>;
    foldersToRemove?: Maybe<Array<Maybe<Scalars['URI']>>>;
    index?: Maybe<Scalars['Int']>;
};
export declare type IMutationwatchFileArgs = {
    resource: Scalars['URI'];
};
export declare type IMutationwatchFileChangesArgs = {
    resource: Scalars['URI'];
    options: IWatchOptions_Input;
};
export declare type IMutationwriteChunkArgs = {
    resource: Scalars['URI'];
    changes: Array<Maybe<IChangesChunk_Input>>;
    options: IWriteTextFileOptions_Input;
};
export declare type IMutationwriteChunkWithDelayArgs = {
    resource: Scalars['URI'];
    changes: Array<Maybe<IChangesChunk_Input>>;
    options: IWriteTextFileOptions_Input;
};
export declare type IMutationwriteTextFileArgs = {
    resource: Scalars['URI'];
    value: Scalars['String'];
    options: IWriteTextFileOptions_Input;
};
export declare type INativeOpenDialogOptions = {
    __typename?: 'NativeOpenDialogOptions';
    windowId?: Maybe<Scalars['Int']>;
    forceNewWindow?: Maybe<Scalars['Boolean']>;
    defaultPath?: Maybe<Scalars['String']>;
    telemetryEventName?: Maybe<Scalars['String']>;
};
export declare type INewWindowOptions = {
    __typename?: 'NewWindowOptions';
    remoteAuthority?: Maybe<Scalars['String']>;
    reuseWindow?: Maybe<Scalars['Boolean']>;
};
export declare type INode = {
    id: Scalars['ID'];
};
export declare type INotification = {
    __typename?: 'Notification';
    index?: Maybe<Scalars['Boolean']>;
    /** The severity of the notification. Either `Info`, `Warning` or `Error`. */
    severity?: Maybe<NotificationSeverity>;
    /**
     * The message of the notification. This can either be a `string` or `Error`. Messages
     * can optionally include links in the format: `[text](link)`
     */
    message?: Maybe<Scalars['String']>;
    /** The source of the notification appears as additional information. */
    source?: Maybe<Scalars['String']>;
    /**
     * Actions to show as part of the notification. Primary actions show up as
     * buttons as part of the message and will clost the notification once clicked.
     *
     * Secondary actions are meant to provide additional configuration or context
     * for the notification and will show up less prominent. A notification does not
     * close automatically when invoking a secondary action.
     *
     * **Note:** If you intent is to show a message with actions to the user, consider
     * the `INotificationService.prompt()` method instead which are optimized for
     * this usecase and much easier to use!
     */
    actions?: Maybe<INotificationActions>;
    /**
     * Sticky notifications are not automatically removed after a certain timeout. By
     * default, notifications with primary actions and severity error are always sticky.
     */
    sticky?: Maybe<Scalars['Boolean']>;
};
export declare type INotification_input = {
    severity?: Maybe<NotificationSeverity>;
    message?: Maybe<INotificationMessage_input>;
    source?: Maybe<Scalars['String']>;
    actions?: Maybe<INotificationActions_input>;
    sticky?: Maybe<Scalars['Boolean']>;
};
export declare type INotificationActions = {
    __typename?: 'NotificationActions';
    /**
     * Primary actions show up as buttons as part of the message and will close
     * the notification once clicked.
     */
    primary?: Maybe<Array<Maybe<IAction>>>;
    /**
     * Secondary actions are meant to provide additional configuration or context
     * for the notification and will show up less prominent. A notification does not
     * close automatically when invoking a secondary action.
     */
    secondary?: Maybe<Array<Maybe<IAction>>>;
};
export declare type INotificationActions_input = {
    primary?: Maybe<Array<Maybe<IAction_input>>>;
    secondary?: Maybe<Array<Maybe<IAction_input>>>;
};
export declare type INotificationChangeEvent = {
    __typename?: 'NotificationChangeEvent';
    /** The index this notification has in the list of notifications. */
    index?: Maybe<Scalars['Int']>;
    /** The notification this change is about. */
    item?: Maybe<INotificationViewItem>;
    /** The kind of notification change. */
    kind?: Maybe<INotificationChangeType>;
};
export declare const enum INotificationChangeType {
    ADD = "ADD",
    CHANGE = "CHANGE",
    REMOVE = "REMOVE"
}
export declare type INotificationMessage = {
    __typename?: 'NotificationMessage';
    raw?: Maybe<Scalars['String']>;
    original?: Maybe<INotificationMessage>;
    value?: Maybe<Scalars['String']>;
    links?: Maybe<Array<Maybe<IMessageLink>>>;
};
export declare type INotificationMessage_input = {
    raw?: Maybe<Scalars['String']>;
    original?: Maybe<INotificationMessage_input>;
    value?: Maybe<Scalars['String']>;
    links?: Maybe<Array<Maybe<IMessageLink_input>>>;
};
export declare type INotifications = {
    __typename?: 'Notifications';
    notifications?: Maybe<Array<Maybe<INotification>>>;
};
export { NotificationSeverity };
export declare type INotificationViewItem = {
    __typename?: 'NotificationViewItem';
    severity?: Maybe<NotificationSeverity>;
    sticky?: Maybe<Scalars['Boolean']>;
    silent?: Maybe<Scalars['Boolean']>;
    message?: Maybe<INotificationMessage>;
    source?: Maybe<Scalars['String']>;
    action?: Maybe<INotificationActions>;
    progress?: Maybe<INotificationViewItemProgress>;
    expanded?: Maybe<Scalars['Boolean']>;
    canCollapse?: Maybe<Scalars['Boolean']>;
};
export declare const enum INotificationViewItemLabelKind {
    SEVERITY = "SEVERITY",
    MESSAGE = "MESSAGE",
    ACTIONS = "ACTIONS",
    PROGRESS = "PROGRESS"
}
export declare type INotificationViewItemProgress = {
    __typename?: 'NotificationViewItemProgress';
    state?: Maybe<INotificationViewItemProgressState>;
};
export declare type INotificationViewItemProgressState = {
    __typename?: 'NotificationViewItemProgressState';
    /** Causes the progress bar to spin infinitely. */
    infinite?: Maybe<Scalars['Boolean']>;
    /** Indicate the total amount of work. */
    total?: Maybe<Scalars['Int']>;
    /** Indicate that a specific chunk of work is done. */
    worked?: Maybe<Scalars['Int']>;
    /** Indicate that the long running operation is done. */
    done?: Maybe<Scalars['Boolean']>;
};
/** One folder to search and a glob expression that should be applied. */
export declare type IOneSearchPathPattern = {
    __typename?: 'OneSearchPathPattern';
    searchPath?: Maybe<Scalars['URI']>;
    pattern?: Maybe<Scalars['String']>;
};
export declare type IOpenConfiguration = {
    __typename?: 'OpenConfiguration';
    context?: Maybe<IOpenContext>;
    contextWindowId?: Maybe<Scalars['Int']>;
    cli?: Maybe<Scalars['AnyObject']>;
    userEnv?: Maybe<Scalars['AnyObject']>;
    urisToOpen?: Maybe<Array<Maybe<IURIToOpen>>>;
    waitMarkerFileURI?: Maybe<Scalars['URI']>;
    preferNewWindow?: Maybe<Scalars['Boolean']>;
    forceNewWindow?: Maybe<Scalars['Boolean']>;
    forceNewTabbedWindow?: Maybe<Scalars['Boolean']>;
    forceReuseWindow?: Maybe<Scalars['Boolean']>;
    forceEmpty?: Maybe<Scalars['Boolean']>;
    diffMode?: Maybe<Scalars['Boolean']>;
    addMode?: Maybe<Scalars['Boolean']>;
    initialStartup?: Maybe<Scalars['Boolean']>;
    noRecentEntry?: Maybe<Scalars['Boolean']>;
};
export declare const enum IOpenContext {
    /** opening when running from the command line */
    CLI = "CLI",
    /** macOS only: opening from the dock (also when opening files to a running instance from desktop) */
    DOCK = "DOCK",
    /** opening from the main application window */
    MENU = "MENU",
    /** opening from a file or folder dialog */
    DIALOG = "DIALOG",
    /** opening from the OS's UI  */
    DESKTOP = "DESKTOP",
    /** opening through the API */
    API = "API"
}
export declare type IOpenDialogOptions = {
    __typename?: 'OpenDialogOptions';
    title?: Maybe<Scalars['String']>;
    defaultPath?: Maybe<Scalars['String']>;
    buttonLabel?: Maybe<Scalars['String']>;
    filters?: Maybe<Array<Maybe<IFileFilter>>>;
    properties?: Maybe<Array<Maybe<IOpenDialogOptionsProperties>>>;
    message?: Maybe<Scalars['String']>;
};
export declare const enum IOpenDialogOptionsProperties {
    openFile = "openFile",
    openDirectory = "openDirectory",
    multiSelections = "multiSelections",
    showHiddenFiles = "showHiddenFiles",
    createDirectory = "createDirectory",
    promptToCreate = "promptToCreate",
    noResolveAliases = "noResolveAliases",
    treatPackageAsDirectory = "treatPackageAsDirectory"
}
export declare type IOpenDiff_Input = {
    resource?: Maybe<Scalars['String']>;
    editorId?: Maybe<Scalars['Int']>;
    name?: Maybe<Scalars['String']>;
};
export declare type IOpenDocumentParamsInput = {
    textDocument?: Maybe<IOpenDocumentTextParamsInput>;
};
export declare type IOpenDocumentTextParamsInput = {
    uri?: Maybe<Scalars['String']>;
    languageId?: Maybe<Scalars['String']>;
    version?: Maybe<Scalars['Int']>;
    text?: Maybe<Scalars['String']>;
};
export declare type IOpenEditor_Input = {
    resource: Scalars['String'];
    name: Scalars['String'];
    editorId?: Maybe<Scalars['Int']>;
    isPinned?: Maybe<Scalars['Boolean']>;
    size?: Maybe<Scalars['Int']>;
    deleted?: Maybe<Scalars['Boolean']>;
};
export declare type IOpenFileRequest = {
    __typename?: 'OpenFileRequest';
    filesToOpenOrCreate?: Maybe<Array<Maybe<IIPathData>>>;
    filesToDiff?: Maybe<Array<Maybe<IIPathData>>>;
    filesToWait?: Maybe<IIPathsToWaitForData>;
    termProgram?: Maybe<Scalars['String']>;
};
export { OpenPositioningType };
export declare type IOpenSettings = {
    __typename?: 'OpenSettings';
    forceNewWindow?: Maybe<Scalars['Boolean']>;
    forceReuseWindow?: Maybe<Scalars['Boolean']>;
    diffMode?: Maybe<Scalars['Boolean']>;
    addMode?: Maybe<Scalars['Boolean']>;
    noRecentEntry?: Maybe<Scalars['Boolean']>;
    waitMarkerFileURI?: Maybe<Scalars['URI']>;
    args?: Maybe<Scalars['AnyObject']>;
};
export { OpenSideBySideDirection };
export declare type IOutput = {
    __typename?: 'Output';
    maxChannelHistory?: Maybe<Scalars['Int']>;
};
export declare type IOverrides = {
    __typename?: 'Overrides';
    contents?: Maybe<Scalars['AnyObject']>;
    identifiers?: Maybe<Array<Maybe<Scalars['String']>>>;
};
export declare type IPageInfo = {
    __typename?: 'PageInfo';
    hasNextPage: Scalars['Boolean'];
};
export declare type IPath = IIPathData & {
    __typename?: 'Path';
    lineNumber?: Maybe<Scalars['Int']>;
    columnNumber?: Maybe<Scalars['Int']>;
    exists?: Maybe<Scalars['Boolean']>;
    /**  the file path to open within the instance  */
    fileUri?: Maybe<Scalars['URI']>;
};
export declare type IPathsToWaitFor = IIPathsToWaitForData & {
    __typename?: 'PathsToWaitFor';
    paths?: Maybe<Array<Maybe<IPath>>>;
    waitMarkerFileUri?: Maybe<Scalars['URI']>;
};
export declare type IPatternInfo = {
    __typename?: 'PatternInfo';
    pattern: Scalars['String'];
    isRegExp?: Maybe<Scalars['Boolean']>;
    isWordMatch?: Maybe<Scalars['Boolean']>;
    wordSeparators?: Maybe<Scalars['String']>;
    isMultiline?: Maybe<Scalars['Boolean']>;
    isCaseSensitive?: Maybe<Scalars['Boolean']>;
    isSmartCase?: Maybe<Scalars['Boolean']>;
};
export declare type IPatternInfoInput = {
    pattern: Scalars['String'];
    isRegExp?: Maybe<Scalars['Boolean']>;
    isWordMatch?: Maybe<Scalars['Boolean']>;
    wordSeparators?: Maybe<Scalars['String']>;
    isMultiline?: Maybe<Scalars['Boolean']>;
    isCaseSensitive?: Maybe<Scalars['Boolean']>;
    isSmartCase?: Maybe<Scalars['Boolean']>;
};
export declare type IPendingStatusbarEntry = {
    __typename?: 'PendingStatusbarEntry';
    id?: Maybe<Scalars['String']>;
    name?: Maybe<Scalars['String']>;
    alignment?: Maybe<IStatusbarAlignment>;
    priority?: Maybe<Scalars['Int']>;
};
export declare type IPickInputOptions = {
    title?: Maybe<Scalars['String']>;
    placeHolder?: Maybe<Scalars['String']>;
    matchOnDescription?: Maybe<Scalars['Boolean']>;
    matchOnDetail?: Maybe<Scalars['Boolean']>;
    matchOnLabel?: Maybe<Scalars['Boolean']>;
    canPickMany?: Maybe<Scalars['Boolean']>;
    activeItem?: Maybe<IPickItem>;
};
export declare type IPickItem = {
    id?: Maybe<Scalars['String']>;
    label?: Maybe<Scalars['String']>;
    description?: Maybe<Scalars['String']>;
    detail?: Maybe<Scalars['String']>;
    keybinding?: Maybe<IKeybindingItem_input>;
    italic?: Maybe<Scalars['Boolean']>;
    highlights?: Maybe<IQuickPickItemHighlights_input>;
    picked?: Maybe<Scalars['Boolean']>;
    alwaysShow?: Maybe<Scalars['Boolean']>;
};
/**
 * @lsp - Position in a text document expressed as zero-based line and character offset.
 * The offsets are based on UTF-16 string representation. So a string of the form
 * `a𐐀b` the character offset of b is 3 since `𐐀` is represented using two code
 * untis in UTF-16.
 *
 * Positions are line end character agnostic. So you can not specify a position that
 * denotes `\r|\n` or `\n"` where `|` represents the character offset.
 *
 *
 * @editor - A position in the editor.
 */
export declare type IPosition = {
    __typename?: 'Position';
    /** @editor - line number (starts at 1) */
    lineNumber?: Maybe<Scalars['Int']>;
    /** @editor - column (the first character in a line is between column 1 and column 2) */
    column?: Maybe<Scalars['Int']>;
    /**
     * @lsp - Line position in a document (zero-based).
     * If a line number is greater than the number of lines in a document, it
     * defaults back to the number of lines in the document.
     * If a line number is negative, it defaults to 0.
     */
    line?: Maybe<Scalars['Int']>;
    /**
     * @lsp - Character offset on a line in a document (zer-based). Assuming that the line is represented as a string, the
     * `character` value represents the gap between the `character` and `character+1`.
     *
     * If the character value is greater than the line length it defaults back to the
     * line length.
     * If a line number is negative, it defaults to 0.
     */
    character?: Maybe<Scalars['Int']>;
};
export declare type IPositionInput = {
    line?: Maybe<Scalars['Int']>;
    character?: Maybe<Scalars['Int']>;
    lineNumber?: Maybe<Scalars['Int']>;
    column?: Maybe<Scalars['Int']>;
};
export declare type IPreferenceItem = {
    __typename?: 'PreferenceItem';
    name?: Maybe<Scalars['String']>;
    type?: Maybe<Scalars['String']>;
    default?: Maybe<Scalars['String']>;
    description?: Maybe<Scalars['String']>;
    categoryType?: Maybe<Scalars['String']>;
    settings?: Maybe<Scalars['String']>;
    enum?: Maybe<Array<Maybe<Scalars['String']>>>;
    enumDescriptions?: Maybe<Array<Maybe<Scalars['String']>>>;
};
/** Is a extension of SideBySideEditorInput */
export declare type IPreferencesEditorInput = IIEditorInput & IIEditorInputWithGroupFields & IISideBySideEditorInput & {
    __typename?: 'PreferencesEditorInput';
    id?: Maybe<Scalars['String']>;
    resource?: Maybe<Scalars['String']>;
    typeId?: Maybe<IEDITOR_INPUT_ID>;
    description?: Maybe<Scalars['String']>;
    label?: Maybe<Scalars['String']>;
    fileReference?: Maybe<IFileStatWithMetadata>;
    preferredEditorId?: Maybe<Scalars['String']>;
    isSupportsSplitEditor?: Maybe<Scalars['Boolean']>;
    isActive?: Maybe<Scalars['Boolean']>;
    preview?: Maybe<Scalars['Boolean']>;
    isPinned?: Maybe<Scalars['Boolean']>;
    editorId?: Maybe<Scalars['Int']>;
    status?: Maybe<Scalars['String']>;
    closable?: Maybe<Scalars['Boolean']>;
    master?: Maybe<IEditorInput>;
    details?: Maybe<IEditorInput>;
};
export declare type IPreferencesType = {
    __typename?: 'PreferencesType';
    type?: Maybe<Scalars['String']>;
    data?: Maybe<Array<Maybe<ISetting>>>;
};
export declare type IPrimaryButtonAction = {
    __typename?: 'PrimaryButtonAction';
    label?: Maybe<Scalars['String']>;
    run?: Maybe<IActionRun>;
};
export declare type IPrimaryButtonAction_input = {
    label?: Maybe<Scalars['String']>;
    run?: Maybe<IActionRun_input>;
};
export declare type IProcessMonitoring = {
    __typename?: 'ProcessMonitoring';
    cpu?: Maybe<Scalars['Float']>;
    memory?: Maybe<Scalars['Float']>;
};
export declare type IProgress = {
    __typename?: 'Progress';
    total?: Maybe<Scalars['Int']>;
    worked?: Maybe<Scalars['Int']>;
};
export declare type IPromptChoice_input = {
    /** Label to show for the choice to the user. */
    label?: Maybe<Scalars['String']>;
    /**
     * Primary choices show up as buttons in the notification below the message.
     * Secondary choices show up under the gear icon in the header of the notification.
     */
    isSecondary?: Maybe<Scalars['Boolean']>;
    /**
     * Whether to keep the notification open after the choice was selected
     * by the user. By default, will close the notification upon click.
     */
    keepOpen?: Maybe<Scalars['Boolean']>;
    /** Triggered when the user selects the choice. */
    run?: Maybe<IPromptChoiceRun>;
};
export declare type IPromptChoiceRun = {
    type?: Maybe<IGraphqlCallType>;
    document?: Maybe<Scalars['AnyObject']>;
    variables?: Maybe<Scalars['AnyObject']>;
};
export declare type IPromptOptions_input = {
    /**
     * Sticky prompts are not automatically removed after a certain timeout.
     *
     * Note: Prompts of severity ERROR are always sticky.
     */
    sticky?: Maybe<Scalars['Boolean']>;
    /**
     * Silent notifications are not shown to the user unless the notification center is opened.
     * The status bar will still indicate all number of notifications to
     * catch some attention.
     */
    silent?: Maybe<Scalars['Boolean']>;
    /**
     * Will be called if the user closed the notification without picking
     * any  of the provided choices.
     */
    onCancel?: Maybe<IPromptOptionsCancel>;
};
export declare type IPromptOptionsCancel = {
    type?: Maybe<IGraphqlCallType>;
    document?: Maybe<Scalars['AnyObject']>;
    variables?: Maybe<Scalars['AnyObject']>;
};
export declare const enum IProvidedRemoteConnectionStates {
    initializing = "initializing",
    disconnected = "disconnected",
    connected = "connected"
}
export declare type IProvideTextDocumentLocationSignature = ITextDocumentPositionParams & ILocation & {
    __typename?: 'ProvideTextDocumentLocationSignature';
    textDocument?: Maybe<ITextDocumentIdentifier>;
    position?: Maybe<IPosition>;
    rangeOrUri?: Maybe<IPosition>;
    uriRangeOrPosition?: Maybe<Scalars['String']>;
    range?: Maybe<IPosition>;
    uri?: Maybe<Scalars['String']>;
};
export declare type IProvideTextDocumentLocationSignatureInput = {
    textDocument?: Maybe<ITextDocumentIdentifierInput>;
    position?: Maybe<IPositionInput>;
    rangeOrUri?: Maybe<IPositionInput>;
    uriRangeOrPosition?: Maybe<Scalars['String']>;
    range?: Maybe<IPositionInput>;
    uri?: Maybe<Scalars['String']>;
};
export declare type IQuery = {
    __typename?: 'Query';
    contextMenu?: Maybe<IContextMenu>;
    /**  Default Preferences  */
    defaultPreferences?: Maybe<IDefaultPreferencesResponse>;
    defaultSetting?: Maybe<ISetting>;
    /**
     * The default settings for the requested ConfigurationTarget
     * Note: Due to bug in graphql we using  `target: Int` argument instead of  `target:ConfigurationTarget`
     * https://github.com/apollographql/apollo-server/issues/2556
     */
    defaultViewerSettingsSubject: IDefaultSettings;
    dialog?: Maybe<IDialog>;
    /**
     * The CDECode documentation page for the given path, used to serve the content for help
     * pages under the URL path /help on the CDECode instance. If no page exists at the path,
     * null is returned.
     */
    docSitePage?: Maybe<IDocSitePage>;
    dummy?: Maybe<Scalars['Int']>;
    editorPart?: Maybe<IEditorPart>;
    editorState?: Maybe<ICodeEditorViewState>;
    existsFile?: Maybe<Scalars['Boolean']>;
    extension?: Maybe<IRegistryExtension>;
    /**  The extension registry.  */
    extensionRegistry: IExtensionRegistry;
    extensions: IRegistryExtensionConnection;
    fileSearch?: Maybe<ISearchComplete>;
    gallery?: Maybe<IGalleryPager>;
    galleryExtension?: Maybe<IGalleryExtension>;
    getChangedEvent?: Maybe<IIContentChangedEvent>;
    getConfigurationData?: Maybe<IConfigurationData>;
    getConfigurationTarget?: Maybe<ConfigurationScope>;
    getContextData?: Maybe<IContext>;
    getContextProperty?: Maybe<IContext>;
    /**  Default settings  */
    getDefaultSettings?: Maybe<Scalars['String']>;
    /**  Default Settings Resources  */
    getDefaultSettingsResource?: Maybe<Scalars['URI']>;
    getEnvironment?: Maybe<IEnvironment>;
    getKeybindings?: Maybe<IKeybindings>;
    getMostCommonlyUsedSettings?: Maybe<Array<Maybe<Scalars['String']>>>;
    getSelectedValue?: Maybe<ISelectedOutput>;
    getViews?: Maybe<Array<Maybe<IViewDescriptor>>>;
    getWorkspace?: Maybe<IWorkspaceData>;
    getWorkspaceFolderContext?: Maybe<IWorkspaceData>;
    getWorkspaceValue?: Maybe<Scalars['AnyObject']>;
    gotoLineQuickAccess?: Maybe<IGoToLineQuickAccess>;
    installed?: Maybe<Array<Maybe<IInstalledExtension>>>;
    instances?: Maybe<Array<Maybe<IExtensionInstance>>>;
    keybindingContextMenu?: Maybe<IKeybindingContextMenu>;
    keybindings?: Maybe<IKeybindings>;
    notifications?: Maybe<INotifications>;
    quickInputModel?: Maybe<IQuickInputModel>;
    /** Read the contents of a file identified by the resource as stream. */
    readStreamTextFile?: Maybe<ITextFileStreamContent>;
    readStringStreamTextFile?: Maybe<ITextFilePublishContent>;
    /** Read the contents of a file identified by the resource. */
    readTextFile?: Maybe<ITextFileContent>;
    registerProvider?: Maybe<Scalars['Boolean']>;
    releases?: Maybe<Array<Maybe<IExtensionRelease>>>;
    resolveContent?: Maybe<IFileContent>;
    resolveContents?: Maybe<Array<Maybe<IResolveFileResultWithMetadata>>>;
    resolveFile?: Maybe<IFileStatWithMetadata>;
    resolveFileContent?: Maybe<ITextFileContent>;
    resolveUntitledFileContent?: Maybe<ITextFileContent>;
    selectedResource?: Maybe<IContext>;
    /**
     * Looks up an instance of a type that implements ISettingsSubject (i.e., something that has settings). This can
     * can be a site (which has global settings), an organization, or a user
     */
    settingsSubject?: Maybe<IISettingsSubject>;
    showDialog?: Maybe<IDialogResult>;
    showNotification?: Maybe<Scalars['Boolean']>;
    statusbar?: Maybe<IStatusbar>;
    statusbarItem?: Maybe<IStatusbarItem>;
    textSearch?: Maybe<ISearchComplete>;
    treeViewData?: Maybe<Array<Maybe<ITreeItem>>>;
    untitledResources?: Maybe<Array<Maybe<Scalars['String']>>>;
    userPreferences?: Maybe<IUserPreferencesRes>;
    /**
     * The settings for the viewer. The viewer is either an anonymous visitor (in which case viewer settings is
     * global settings) or an authenticated user (in which case viewer settings are the user's settings).
     */
    viewerSettings: ISettingsCascade;
    workspaces?: Maybe<Array<Maybe<IWorkspaceRes>>>;
};
export declare type IQuerydefaultViewerSettingsSubjectArgs = {
    target?: Maybe<Scalars['Int']>;
};
export declare type IQuerydocSitePageArgs = {
    path: Scalars['String'];
};
export declare type IQueryeditorStateArgs = {
    editorId: Scalars['String'];
    resource: Scalars['URI'];
};
export declare type IQueryexistsFileArgs = {
    resource: Scalars['URI'];
};
export declare type IQueryextensionArgs = {
    extensionID: Scalars['String'];
};
export declare type IQueryextensionsArgs = {
    first?: Maybe<Scalars['Int']>;
    query?: Maybe<Scalars['String']>;
    local?: Maybe<Scalars['Boolean']>;
    remote?: Maybe<Scalars['Boolean']>;
    prioritizeExtensionIDs?: Maybe<Array<Scalars['String']>>;
    includeWIP?: Maybe<Scalars['Boolean']>;
};
export declare type IQueryfileSearchArgs = {
    query?: Maybe<IFileQueryInput>;
};
export declare type IQuerygalleryArgs = {
    query?: Maybe<IGalleryQuery>;
};
export declare type IQuerygalleryExtensionArgs = {
    extensionID: Scalars['String'];
};
export declare type IQuerygetChangedEventArgs = {
    resource: Scalars['URI'];
};
export declare type IQuerygetContextPropertyArgs = {
    keys?: Maybe<Array<Maybe<Scalars['String']>>>;
};
export declare type IQuerygetDefaultSettingsArgs = {
    target?: Maybe<ConfigurationTarget>;
};
export declare type IQuerygetDefaultSettingsResourceArgs = {
    configurationTarget?: Maybe<ConfigurationTarget>;
};
export declare type IQuerygetViewsArgs = {
    containerId: Scalars['String'];
};
export declare type IQuerygetWorkspaceFolderContextArgs = {
    arg?: Maybe<IArg_Input>;
};
export declare type IQuerygetWorkspaceValueArgs = {
    value?: Maybe<IWorkspaceValue_Input>;
};
export declare type IQueryreadStreamTextFileArgs = {
    resource: Scalars['URI'];
    options?: Maybe<IReadTextFileOptions_Input>;
};
export declare type IQueryreadStringStreamTextFileArgs = {
    resource: Scalars['URI'];
    options?: Maybe<IReadTextFileOptions_Input>;
};
export declare type IQueryreadTextFileArgs = {
    resource: Scalars['URI'];
    options?: Maybe<IReadTextFileOptions_Input>;
};
export declare type IQueryregisterProviderArgs = {
    registrationOptions?: Maybe<ITextDocumentRegistrationOptionsInput>;
    provider?: Maybe<IProvideTextDocumentLocationSignatureInput>;
};
export declare type IQueryreleasesArgs = {
    extensionID: Scalars['String'];
};
export declare type IQueryresolveContentArgs = {
    resource: Scalars['URI'];
    options?: Maybe<IReadFileOptions_Input>;
};
export declare type IQueryresolveContentsArgs = {
    toResolve?: Maybe<Array<Maybe<IResolveAll_toResolveWithMetadata_Input>>>;
};
export declare type IQueryresolveFileArgs = {
    resource: Scalars['URI'];
    options?: Maybe<IResolveMetadataFileOptions_Input>;
};
export declare type IQueryresolveFileContentArgs = {
    resource: Scalars['URI'];
    options?: Maybe<ILoadOptions_Input>;
};
export declare type IQueryresolveUntitledFileContentArgs = {
    resource: Scalars['URI'];
};
export declare type IQuerysettingsSubjectArgs = {
    id: Scalars['ID'];
};
export declare type IQueryshowDialogArgs = {
    dialog?: Maybe<IDialog_input>;
};
export declare type IQueryshowNotificationArgs = {
    notification?: Maybe<INotification_input>;
};
export declare type IQuerystatusbarItemArgs = {
    id?: Maybe<Scalars['String']>;
};
export declare type IQuerytextSearchArgs = {
    query?: Maybe<ITextQueryInput>;
};
export declare type IQueryuserPreferencesArgs = {
    user?: Maybe<Scalars['String']>;
};
export declare const enum IQueryType {
    File = "File",
    Text = "Text"
}
export declare type IQuickInput = {
    __typename?: 'QuickInput';
    title?: Maybe<Scalars['String']>;
    description?: Maybe<Scalars['String']>;
    step?: Maybe<Scalars['Int']>;
    totalSteps?: Maybe<Scalars['Int']>;
    enabled?: Maybe<Scalars['Boolean']>;
    ignoreFocusOut?: Maybe<Scalars['Boolean']>;
    value?: Maybe<Scalars['String']>;
    placeholder?: Maybe<Scalars['String']>;
    prompt?: Maybe<Scalars['String']>;
    validationMessage?: Maybe<Scalars['String']>;
};
export declare type IQuickInputModel = {
    __typename?: 'QuickInputModel';
    show?: Maybe<Scalars['Boolean']>;
    title?: Maybe<Scalars['String']>;
    input?: Maybe<IQuickInput>;
    quickPick?: Maybe<IQuickPick>;
    inputValue?: Maybe<Scalars['String']>;
    selectedValue?: Maybe<Array<Maybe<IQuickPickItem>>>;
};
export declare type IQuickPick = {
    __typename?: 'QuickPick';
    placeholder?: Maybe<Scalars['String']>;
    canSelectMany?: Maybe<Scalars['Boolean']>;
    autoFocusOnList?: Maybe<Scalars['Boolean']>;
    items?: Maybe<Array<Maybe<IQuickPickItem>>>;
    activeItem?: Maybe<IQuickPickItem>;
    selectedItems?: Maybe<Array<Maybe<IQuickPickItem>>>;
};
export declare type IQuickPickItem = {
    __typename?: 'QuickPickItem';
    id?: Maybe<Scalars['String']>;
    label?: Maybe<Scalars['String']>;
    description?: Maybe<Scalars['String']>;
    detail?: Maybe<Scalars['String']>;
    keybinding?: Maybe<IKeybindingItem>;
    italic?: Maybe<Scalars['Boolean']>;
    highlights?: Maybe<IQuickPickItemHighlights>;
    picked?: Maybe<Scalars['Boolean']>;
    alwaysShow?: Maybe<Scalars['Boolean']>;
};
export declare type IQuickPickItemHighlights = {
    __typename?: 'QuickPickItemHighlights';
    label?: Maybe<Array<Maybe<IMatch>>>;
    description?: Maybe<Array<Maybe<IMatch>>>;
    detail?: Maybe<Array<Maybe<IMatch>>>;
};
export declare type IQuickPickItemHighlights_input = {
    label?: Maybe<Array<Maybe<IMatch_input>>>;
    description?: Maybe<Array<Maybe<IMatch_input>>>;
    detail?: Maybe<Array<Maybe<IMatch_input>>>;
};
/**
 * @lsp - A range in a text document expressed as (zero-based) start and end positions. A range is comparable to a
 * section in an editor. Therefore the end position is exclusive. If you want to specify a range that contains a line
 * including the line ending character(s) then use an end pisition denoting the start of the next line. For example:
 * ```
 * {
 *    start: { line: 5, character: 23 },
 *    end : { line 6, character : 0 }
 * }
 * ```
 *
 * @editor - A range in the editor. This interface is suitable for serialization.
 */
export declare type IRange = {
    __typename?: 'Range';
    /**
     * @lsp
     * The range's start position.
     */
    start?: Maybe<IPosition>;
    /**
     * @lsp
     * The range's end position.
     */
    end?: Maybe<IPosition>;
    /** @editor - Line number on which the range starts (starts at 1). */
    startLineNumber?: Maybe<Scalars['Int']>;
    /** @editor - Column on which the range starts in the line `startLineNumber` (starts at 1). */
    startColumn?: Maybe<Scalars['Int']>;
    /** @editor - Line number on which the range ends. */
    endLineNumber?: Maybe<Scalars['Int']>;
    /** @editor - Column on which the range ends in the line `endLineNumber` */
    endColumn?: Maybe<Scalars['Int']>;
};
export declare type IRangeInput = {
    endColumn?: Maybe<Scalars['Int']>;
    endLineNumber?: Maybe<Scalars['Int']>;
    startColumn?: Maybe<Scalars['Int']>;
    startLineNumber?: Maybe<Scalars['Int']>;
};
export declare type IReadFileOptions_Input = {
    /**
     * The optional etag parameter allows to return early from resolving the resource if
     * the contents on disk match the etag. This prevents accumulated reading of resources
     * that have been read already with the same etag.
     * It is the task of the caller to makes sure to handle this error case from the promise.
     */
    etag?: Maybe<Scalars['String']>;
    /**
     * Is an integer specifying where to begin reading from in the file. If position is null,
     * data will be read from the current file position.
     */
    position?: Maybe<Scalars['Int']>;
    /**
     * Is an integer specifying how many bytes to read from the file. By default, all bytes
     * will be read.
     */
    length?: Maybe<Scalars['Int']>;
    /** If provided, the size of the file will be checked agains the limits. */
    limits?: Maybe<IReadFileOptions_Input_limits>;
};
export declare type IReadFileOptions_Input_limits = {
    size?: Maybe<Scalars['Int']>;
    memory?: Maybe<Scalars['Int']>;
};
/** It is a extension to ReadFileOptions_Input with few more options. */
export declare type IReadTextFileOptions_Input = {
    etag?: Maybe<Scalars['String']>;
    Position?: Maybe<Scalars['Int']>;
    length?: Maybe<Scalars['Int']>;
    limits?: Maybe<IReadFileOptions_Input_limits>;
    /**
     * The optional acceptTextOnly parameters allows to fail this request early if the file
     * contents are not textual.
     */
    acceptTextOnly?: Maybe<Scalars['Boolean']>;
    /**
     * The optional encoding parameter allows to specify the desired encoding when resolving
     * the contents of the file.
     */
    encoding?: Maybe<Scalars['String']>;
    /** The ioptional guessEncoding parameter allows to guess encoding from content of the file. */
    autoGuessEncoding?: Maybe<Scalars['Boolean']>;
};
export declare const enum IReadyState {
    /** This window has  not loaded any HTML yet */
    NONE = "NONE",
    /** This window is loading HTML */
    LOADING = "LOADING",
    /** This window is navigating to another HTML */
    NAVIGATING = "NAVIGATING",
    /** This window is done loading HTML */
    READY = "READY"
}
export declare type IRegistryEntry = {
    __typename?: 'RegistryEntry';
    registrationOptions?: Maybe<ITextDocumentRegistrationOptions>;
    provider?: Maybe<Scalars['String']>;
};
/**  An extenion's listing in the extension registry. */
export declare type IRegistryExtension = INode & {
    __typename?: 'RegistryExtension';
    /**
     *  The unique, opaque, permanent ID of the extension. Do not display this ID to the user; display
     * RegistryExtension.extensionID instead (it is friendlier and still unique, but it can be renamed).
     */
    id: Scalars['ID'];
    /**
     * The UUID of the extension. This identifies the extension externally (along with the origin). The UUID maps
     * 1-t0-1 to RegistryExtension.id.
     */
    uuid: Scalars['String'];
    /**  The publisher of the extension. If this extension is from a remote registry, the publisher may be null. */
    publisher?: Maybe<IRegistryPublisher>;
    /**
     *  The qualified, unique name that refers to this extension, consisting of the registry name (if non-default),
     * publisher's name, and the extension's name, all joined by "/" (for example, "cdecode/my-extension-name").
     */
    extensionID?: Maybe<Scalars['String']>;
    /**  The extension ID without the registry name. */
    extensionIDWithoutRegistry?: Maybe<Scalars['String']>;
    /**  The name of the extension (not including the publisher's name). */
    name: Scalars['String'];
    /**  Latest Published version  */
    version?: Maybe<Scalars['String']>;
    activationEvents?: Maybe<Array<Maybe<Scalars['String']>>>;
    /**  The extension manifest, or null if none is set. */
    manifest?: Maybe<IExtensionManifest>;
    /**  The date when this extension was last updated on the registry. */
    updatedAt?: Maybe<Scalars['String']>;
    /**  The URL to the extension on this CDECode site. */
    url?: Maybe<Scalars['String']>;
    /**
     *  The URL to the extension on the extension registry where it lives (if this is a remote
     * extension). If this extension is local, then this field's value is null.
     */
    remoteURL?: Maybe<Scalars['String']>;
    /**  Whether the registry extension is published on this CDECode site. */
    isLocal?: Maybe<Scalars['Boolean']>;
    /**  Whether the viewer has admin privileges on this registry extension. */
    viewerCanAdminister?: Maybe<Scalars['Boolean']>;
    /**  Extension Releases  */
    releases?: Maybe<Array<Maybe<IExtensionRelease>>>;
};
/**  A list of registry extensions. */
export declare type IRegistryExtensionConnection = {
    __typename?: 'RegistryExtensionConnection';
    /**  A list of registry extensions. */
    nodes: Array<IRegistryExtension>;
    /**
     * The total count of registry extensions in the connection. This total cound may be larger than the number of
     * nodes in this object when the result is paginated.
     */
    totalCount: Scalars['Int'];
    /**  Pagination information  */
    pageInfo: IPageInfo;
    /**  location of the extension path for example: /extensions/<extension_user>/<extension_name>  */
    url?: Maybe<Scalars['String']>;
    /**
     * Errors that occured while communicating with remote registries to obtain the list of extensions.
     *
     * In order to be able to return local extensions even when the remote registry is unreachable, errors are
     * recorded here instead of in the top-level GraphQL errors list.
     */
    error?: Maybe<Scalars['String']>;
};
/**  A publisher of a registry extension. */
export declare type IRegistryPublisher = {
    __typename?: 'RegistryPublisher';
    UserId?: Maybe<Scalars['String']>;
};
/**  A list of publishers of extensions in the registry. */
export declare type IRegistryPublisherConnection = {
    __typename?: 'RegistryPublisherConnection';
    /**  A list of publishers. */
    nodes: Array<IRegistryPublisher>;
    /**
     * The total count of publishers in the connection. This total count may be larger than the number of
     * nodes in the object when result is paginated.
     */
    totalCount: Scalars['Int'];
    /**  Pagination information. */
    pageInfo: IPageInfo;
};
export declare type IRemoteUserSettings = IISettingsSubject & {
    __typename?: 'RemoteUserSettings';
    /**  The ID.  */
    id?: Maybe<Scalars['ID']>;
    /**  The latest settings.  */
    latestSettings?: Maybe<ISettings>;
    /**  The URL to the settings.  */
    settingsURL: Scalars['URI'];
    /**  Whether the viewer can modify the subject's settings. */
    viewerCanAdminister: Scalars['Boolean'];
    /**
     * All settings for this subject, and the individual levels in the settings cascade (global > organization > user)
     * that were merged to produce the final merged settings.
     */
    settingsCascade: ISettingsCascade;
};
export declare type IRemoveEditor_Input = {
    editorId?: Maybe<Scalars['Int']>;
    resource?: Maybe<Scalars['String']>;
    name?: Maybe<Scalars['String']>;
};
export declare type IReplaceContentResult = {
    __typename?: 'ReplaceContentResult';
    resource?: Maybe<Scalars['String']>;
    oldText?: Maybe<Scalars['String']>;
    newText?: Maybe<Scalars['String']>;
};
export declare type IResolveAll_toResolve_Input = {
    resource?: Maybe<Scalars['URI']>;
    options?: Maybe<IResolveFileOptions_Input>;
};
export declare type IResolveAll_toResolveWithMetadata_Input = {
    resource?: Maybe<Scalars['URI']>;
    options?: Maybe<IResolveMetadataFileOptions_Input>;
};
export declare type IResolveFileOptions_Input = {
    /**
     * Automatically continue resolving children of a directory until the provided resources
     * are found.
     */
    resolveTo?: Maybe<Array<Maybe<Scalars['URI']>>>;
    /** Automatically continue resolving children of a directory if the number of children as 1. */
    resolveSingleChildDescendants?: Maybe<Scalars['Boolean']>;
    /**
     * Will resolve mtime, size and etag of files if enabled. Ths can have a negative impact
     * on performance and thus should only be used when these values are required.
     */
    resolveMetadata?: Maybe<Scalars['Boolean']>;
};
export declare type IResolveFileResult = {
    __typename?: 'ResolveFileResult';
    stat?: Maybe<IFileStat>;
    success: Scalars['Boolean'];
    /**  The content of a file as stream  */
    value?: Maybe<Scalars['VSBufferReadableStream']>;
};
export declare type IResolveFileResultWithMetadata = {
    __typename?: 'ResolveFileResultWithMetadata';
    stat?: Maybe<IFileStatWithMetadata>;
    success: Scalars['Boolean'];
};
/** Extension of `ResolveFileOptions_Input` with defined `resolveMedata` */
export declare type IResolveMetadataFileOptions_Input = {
    resolveTo?: Maybe<Array<Maybe<Scalars['URI']>>>;
    resolveSingleChildDescendants?: Maybe<Scalars['Boolean']>;
    resolveMetadata?: Maybe<Scalars['Boolean']>;
};
/** Resource_Input is extension of BaseResourceInput */
export declare type IResource_Input = {
    options?: Maybe<ITextEditorOptions_Input>;
    label?: Maybe<Scalars['String']>;
    description?: Maybe<Scalars['String']>;
    forceFile?: Maybe<Scalars['Boolean']>;
    forceUntitled?: Maybe<Scalars['Boolean']>;
    /** The resource URL of the resource to open. */
    resource: Scalars['URI'];
    /** The encoding of the text input if known. */
    encoding?: Maybe<Scalars['String']>;
    /**
     * The identifier of the language mode of the text input
     * if known to use when displaying the contents.
     */
    mode?: Maybe<Scalars['String']>;
};
/** Extends BaseResource_Input */
export declare type IResourceDiff_Input = {
    options?: Maybe<ITextEditorOptions_Input>;
    label?: Maybe<Scalars['String']>;
    description?: Maybe<Scalars['String']>;
    forceFile?: Maybe<Scalars['Boolean']>;
    forceUntitled?: Maybe<Scalars['Boolean']>;
    /** The left hand side URI to open inside a diff editor. */
    leftResource: Scalars['URI'];
    /** The right hand side URI to open inside a diff editor. */
    rightResource: Scalars['URI'];
};
/**
 * A read-only text editor input whoes content are made of the provided resource that points to an existing
 * code editor model.
 */
export declare type IResourceEditorInput = IIEditorInput & IIEditorInputWithGroupFields & {
    __typename?: 'ResourceEditorInput';
    id?: Maybe<Scalars['String']>;
    resource?: Maybe<Scalars['String']>;
    typeId?: Maybe<IEDITOR_INPUT_ID>;
    description?: Maybe<Scalars['String']>;
    label?: Maybe<Scalars['String']>;
    fileReference?: Maybe<IFileStatWithMetadata>;
    preferredEditorId?: Maybe<Scalars['String']>;
    isSupportsSplitEditor?: Maybe<Scalars['Boolean']>;
    isActive?: Maybe<Scalars['Boolean']>;
    preview?: Maybe<Scalars['Boolean']>;
    isPinned?: Maybe<Scalars['Boolean']>;
    editorId?: Maybe<Scalars['Int']>;
    status?: Maybe<Scalars['String']>;
    closable?: Maybe<Scalars['Boolean']>;
    mode?: Maybe<Scalars['String']>;
    preferredMode?: Maybe<Scalars['String']>;
};
export declare type IResourceEncoding = {
    __typename?: 'ResourceEncoding';
    encoding?: Maybe<Scalars['String']>;
    hasBOM?: Maybe<Scalars['Boolean']>;
};
export declare type IResourceMapConfigurationModel = {
    __typename?: 'ResourceMapConfigurationModel';
    resource?: Maybe<Scalars['URI']>;
    contents?: Maybe<Scalars['AnyObject']>;
    keys?: Maybe<Array<Maybe<Scalars['String']>>>;
    overrides?: Maybe<IConfigurationOverrides>;
};
/** Extends BaseResource_Input */
export declare type IResourceSideBySide_Input = {
    options?: Maybe<ITextEditorOptions_Input>;
    label?: Maybe<Scalars['String']>;
    description?: Maybe<Scalars['String']>;
    forceFile?: Maybe<Scalars['Boolean']>;
    forceUntitled?: Maybe<Scalars['Boolean']>;
    /** The right hand side URI to open inside a side by side editor. */
    masterResource: Scalars['URI'];
    /** The left hand side URI to open inside a side by side editor. */
    detailResource: Scalars['URI'];
};
export declare type IRevealOptions = {
    __typename?: 'RevealOptions';
    select?: Maybe<Scalars['Boolean']>;
    focus?: Maybe<Scalars['Boolean']>;
    expand?: Maybe<Scalars['Boolean']>;
};
export declare type IRunActionInWindowRequest = {
    __typename?: 'RunActionInWindowRequest';
    id: Scalars['String'];
    from?: Maybe<IRunActionInWindowRequestFrom>;
    args?: Maybe<Array<Maybe<Scalars['AnyObject']>>>;
};
export declare const enum IRunActionInWindowRequestFrom {
    menu = "menu",
    touchbar = "touchbar",
    mouse = "mouse"
}
export declare type IRunKeybindingInWindowRequest = {
    __typename?: 'RunKeybindingInWindowRequest';
    userSettingsLabel?: Maybe<Scalars['String']>;
};
export declare type ISaveDialogOptions = {
    __typename?: 'SaveDialogOptions';
    title?: Maybe<Scalars['String']>;
    defaultPath?: Maybe<Scalars['String']>;
    buttonLabel?: Maybe<Scalars['String']>;
    filters?: Maybe<Array<Maybe<IFileFilter>>>;
    message?: Maybe<Scalars['String']>;
    nameFieldLabel?: Maybe<Scalars['String']>;
    showTagField?: Maybe<Scalars['Boolean']>;
};
export declare type ISaveOptions_Input = {
    force?: Maybe<Scalars['Boolean']>;
    reason?: Maybe<ISaveReason>;
    overwriteReadonly?: Maybe<Scalars['Boolean']>;
    overwriteEncoding?: Maybe<Scalars['Boolean']>;
    skipSaveParticipants?: Maybe<Scalars['Boolean']>;
    writeElevated?: Maybe<Scalars['Boolean']>;
};
export declare const enum ISaveReason {
    EXPLICIT = "EXPLICIT",
    AUTO = "AUTO",
    FOCUS_CHANGE = "FOCUS_CHANGE",
    WINDOW_CHANGE = "WINDOW_CHANGE"
}
export declare type ISaveWorkspaceRes = {
    __typename?: 'SaveWorkspaceRes';
    updated?: Maybe<Scalars['Boolean']>;
    id?: Maybe<Scalars['String']>;
};
export declare const enum IscmProviders {
    git = "git"
}
export declare const enum IscmResourceGroups {
    workingTree = "workingTree",
    merge = "merge",
    index = "index"
}
export declare type IScripts = {
    __typename?: 'Scripts';
    cdebasebuild?: Maybe<Scalars['String']>;
    cdebasepublish?: Maybe<Scalars['String']>;
};
export declare type ISearch = {
    __typename?: 'Search';
    location?: Maybe<Scalars['String']>;
    smartCase?: Maybe<Scalars['Boolean']>;
    useRipgrep?: Maybe<Scalars['Boolean']>;
    useIgnoreFiles?: Maybe<Scalars['Boolean']>;
    followSymlinks?: Maybe<Scalars['Boolean']>;
    globalFindClipboard?: Maybe<Scalars['Boolean']>;
    quickOpen?: Maybe<ISearchQuickOpen>;
    exclude?: Maybe<Scalars['JSON']>;
};
export declare type ISearchComplete = IISearchCompleteStats & {
    __typename?: 'SearchComplete';
    limitHit?: Maybe<Scalars['Boolean']>;
    stats: ISearchCompleteStatsStats;
    results?: Maybe<Array<Maybe<IFileMatch>>>;
};
export declare type ISearchCompleteStatsStats = IFileSearchStats | ITextSearchStats;
export declare type ISearchCompleteStream = {
    __typename?: 'SearchCompleteStream';
    isEnd?: Maybe<Scalars['Boolean']>;
    limitHit?: Maybe<Scalars['Boolean']>;
    results?: Maybe<Array<Maybe<IFileMatch>>>;
    stats: ISearchCompleteStatsStats;
    part?: Maybe<Scalars['Int']>;
    size?: Maybe<Scalars['Int']>;
};
export declare type ISearchEngineStats = {
    __typename?: 'SearchEngineStats';
    traversal: Scalars['String'];
    fileWalkTime: Scalars['Int'];
    directoriesWalked: Scalars['Int'];
    filesWalked: Scalars['Int'];
    cmdTime: Scalars['Int'];
    cmdResultCount?: Maybe<Scalars['Int']>;
};
export declare type ISearchLog = {
    __typename?: 'SearchLog';
    message?: Maybe<Scalars['String']>;
};
/** One folder to search and a set of glob expressions that should be applied. */
export declare type ISearchPathPattern = {
    __typename?: 'SearchPathPattern';
    searchPath?: Maybe<Scalars['URI']>;
    pattern?: Maybe<Scalars['String']>;
};
export declare type ISearchProgressItem = IIFileMatch & IISearchProgress & {
    __typename?: 'SearchProgressItem';
    resource?: Maybe<Scalars['URI']>;
    results?: Maybe<Array<Maybe<ITextSearchResult>>>;
    total?: Maybe<Scalars['Int']>;
    worked?: Maybe<Scalars['Int']>;
    message?: Maybe<Scalars['String']>;
};
export declare type ISearchQuickOpen = {
    __typename?: 'SearchQuickOpen';
    includeSymbols?: Maybe<Scalars['Boolean']>;
};
export declare type ISearchRange = {
    __typename?: 'SearchRange';
    startLineNumber?: Maybe<Scalars['Int']>;
    startColumn?: Maybe<Scalars['Int']>;
    endLineNumber?: Maybe<Scalars['Int']>;
    endColumn?: Maybe<Scalars['Int']>;
};
export declare type ISearchStreamInput = {
    _reason?: Maybe<Scalars['String']>;
    folderQueries?: Maybe<Array<Maybe<IFolderQueryInput>>>;
    includePattern?: Maybe<Scalars['AnyObject']>;
    excludePattern?: Maybe<Scalars['AnyObject']>;
    extraFileResources?: Maybe<Array<Maybe<IURIInput>>>;
    useRipgrep?: Maybe<Scalars['Boolean']>;
    maxResults?: Maybe<Scalars['Int']>;
    usingSearchPaths?: Maybe<Scalars['Boolean']>;
    filePattern?: Maybe<Scalars['String']>;
    disregardExcludeSettings?: Maybe<Scalars['Boolean']>;
    exists?: Maybe<Scalars['Boolean']>;
    sortByScore?: Maybe<Scalars['Boolean']>;
    cacheKey?: Maybe<Scalars['String']>;
};
export declare type ISelectEditor_Input = {
    resource: Scalars['String'];
    editorId?: Maybe<Scalars['Int']>;
    name?: Maybe<Scalars['String']>;
};
export declare type ISelectedOutput = {
    __typename?: 'SelectedOutput';
    title?: Maybe<Scalars['String']>;
    inputValue?: Maybe<Scalars['String']>;
    selectedValue?: Maybe<Array<Maybe<IQuickPickItem>>>;
};
export declare type ISelectionStatus = IIStatusbarItem & {
    __typename?: 'SelectionStatus';
    id?: Maybe<Scalars['String']>;
    name?: Maybe<Scalars['String']>;
    alignment?: Maybe<IStatusbarAlignment>;
    entry?: Maybe<IStatusbarEntry>;
    priority?: Maybe<Scalars['Int']>;
    container?: Maybe<Scalars['String']>;
    labelContainer?: Maybe<Scalars['String']>;
    typeId?: Maybe<ISTATUSBAR_ITEM_ID>;
};
export declare type ISetStatusMsg_input = {
    id: Scalars['String'];
    message: Scalars['String'];
};
export declare type ISetting = {
    __typename?: 'Setting';
    /**  name of the settings */
    name?: Maybe<Scalars['String']>;
    range?: Maybe<IRange>;
    key?: Maybe<Scalars['String']>;
    keyRange?: Maybe<IRange>;
    /**  @deprecated  */
    default?: Maybe<Scalars['String']>;
    value?: Maybe<Scalars['AnyObject']>;
    valueRange?: Maybe<IRange>;
    description?: Maybe<Array<Maybe<Scalars['String']>>>;
    descriptionIsMarkdown?: Maybe<Scalars['Boolean']>;
    descriptionRanges?: Maybe<Array<Maybe<IRange>>>;
    overrides?: Maybe<Array<Maybe<ISetting>>>;
    overrideOf?: Maybe<ISetting>;
    deprecationMessage?: Maybe<Scalars['String']>;
    scope?: Maybe<ConfigurationScope>;
    type?: Maybe<Array<Maybe<Scalars['String']>>>;
    enum?: Maybe<Array<Maybe<Scalars['String']>>>;
    enumDescriptions?: Maybe<Array<Maybe<Scalars['String']>>>;
    enumDescriptionsAreMarkdown?: Maybe<Scalars['Boolean']>;
    tags?: Maybe<Array<Maybe<Scalars['String']>>>;
    extensionInfo?: Maybe<IConfigurationExtensionInfo>;
};
/** Settings is a version of a configuration settings file. */
export declare type ISettings = {
    __typename?: 'Settings';
    /** The time when this was created.  */
    createdAt?: Maybe<Scalars['String']>;
    /**
     * The stringified JSON contents of the settings. The contents may include "//"-style comments and trailing
     * commas in the JSON.
     */
    contents: Scalars['String'];
};
/** The configuration for all of the relevant settings subjects, plus the merged settings. */
export declare type ISettingsCascade = {
    __typename?: 'SettingsCascade';
    /**
     * The other settings subjects that are applied with lower precedence that this subject to
     * form the final merged settings. For example, a user in 2 organizations would have the following
     * settings subjects: site (global settings), org 1, org 2 and the user.
     */
    subjects?: Maybe<Array<Maybe<ISettingsSubject>>>;
    /** The effective final merged settings as (stringified) JSON, merged from all of the subjects. */
    final?: Maybe<Scalars['String']>;
    /** The effective final merged settings as Object, merged from all of the subjects. */
    finalConfiguration?: Maybe<IConfiguration>;
};
export declare type ISettingsGroup = {
    __typename?: 'SettingsGroup';
    id?: Maybe<Scalars['String']>;
    range?: Maybe<IRange>;
    title?: Maybe<Scalars['String']>;
    titleRange?: Maybe<IRange>;
    sections?: Maybe<Array<Maybe<ISettingsSection>>>;
    contributedByExtension?: Maybe<Scalars['Boolean']>;
};
export declare type ISettingsSection = {
    __typename?: 'SettingsSection';
    titleRange?: Maybe<IRange>;
    title?: Maybe<Scalars['String']>;
    settings?: Maybe<Array<Maybe<ISetting>>>;
};
export declare type ISettingsSubject = IUserSettings | ILocalUserSettings | IRemoteUserSettings | IFolderSettings | IGlobalSettings | IWorkspaceSettings | IMemorySettings | IDefaultSettings;
export declare const enum ISettingValueType {
    Null = "Null",
    Enum = "Enum",
    String = "String",
    Integer = "Integer",
    Number = "Number",
    Boolean = "Boolean",
    Exclude = "Exclude",
    Complex = "Complex",
    NullableInteger = "NullableInteger",
    NullableNumber = "NullableNumber"
}
export declare type IShell = {
    __typename?: 'Shell';
    osx?: Maybe<Scalars['String']>;
    linux?: Maybe<Scalars['String']>;
    windows?: Maybe<Scalars['String']>;
    container?: Maybe<Scalars['String']>;
};
export declare type IShellArgs = {
    __typename?: 'ShellArgs';
    container?: Maybe<Array<Maybe<Scalars['String']>>>;
    windows?: Maybe<Array<Maybe<Scalars['String']>>>;
    linux?: Maybe<Array<Maybe<Scalars['String']>>>;
    osx?: Maybe<Array<Maybe<Scalars['String']>>>;
};
export { SideBySideEditor };
/** Side by side editor inputs that have a master and details side. */
export declare type ISideBySideEditorInput = IIEditorInput & IIEditorInputWithGroupFields & IISideBySideEditorInput & {
    __typename?: 'SideBySideEditorInput';
    id?: Maybe<Scalars['String']>;
    resource?: Maybe<Scalars['String']>;
    typeId?: Maybe<IEDITOR_INPUT_ID>;
    description?: Maybe<Scalars['String']>;
    label?: Maybe<Scalars['String']>;
    fileReference?: Maybe<IFileStatWithMetadata>;
    preferredEditorId?: Maybe<Scalars['String']>;
    isSupportsSplitEditor?: Maybe<Scalars['Boolean']>;
    isActive?: Maybe<Scalars['Boolean']>;
    preview?: Maybe<Scalars['Boolean']>;
    isPinned?: Maybe<Scalars['Boolean']>;
    editorId?: Maybe<Scalars['Int']>;
    status?: Maybe<Scalars['String']>;
    closable?: Maybe<Scalars['Boolean']>;
    master?: Maybe<IEditorInput>;
    details?: Maybe<IEditorInput>;
};
export declare type ISnippet = {
    __typename?: 'Snippet';
    language?: Maybe<Scalars['String']>;
};
export declare type IStatusbar = {
    __typename?: 'Statusbar';
    items?: Maybe<Array<Maybe<IStatusbarItem>>>;
};
export declare const enum ISTATUSBAR_ITEM_ID {
    TERMINAL = "TERMINAL",
    SELECTION_STATUS = "SELECTION_STATUS",
    INDENTATION_STATUS = "INDENTATION_STATUS",
    ENCODING_STATUS = "ENCODING_STATUS",
    EOL_STATUS = "EOL_STATUS",
    LANGUAGE_MODE_STATUS = "LANGUAGE_MODE_STATUS",
    SYNC_STATUS = "SYNC_STATUS",
    BRANCH_STATUS = "BRANCH_STATUS"
}
export declare const enum IStatusbarAlignment {
    LEFT = "LEFT",
    RIGHT = "RIGHT"
}
export declare type IStatusbarEntry = {
    __typename?: 'StatusbarEntry';
    showTabsButtons?: Maybe<Scalars['Boolean']>;
    showIcons?: Maybe<Scalars['Boolean']>;
    showStatusbar?: Maybe<Scalars['Boolean']>;
    text: Scalars['String'];
    ariaLabel?: Maybe<Scalars['String']>;
    tooltip?: Maybe<Scalars['String']>;
    color?: Maybe<Scalars['String']>;
    backgroundColor?: Maybe<Scalars['String']>;
    command?: Maybe<Scalars['String']>;
    arguments?: Maybe<Array<Maybe<Scalars['String']>>>;
    showBeak?: Maybe<Scalars['Boolean']>;
};
export declare type IStatusbarEntry_input = {
    showTabsButtons?: Maybe<Scalars['Boolean']>;
    showIcons?: Maybe<Scalars['Boolean']>;
    showStatusbar?: Maybe<Scalars['Boolean']>;
    text: Scalars['String'];
    ariaLabel?: Maybe<Scalars['String']>;
    tooltip?: Maybe<Scalars['String']>;
    color?: Maybe<Scalars['String']>;
    backgroundColor?: Maybe<Scalars['String']>;
    command?: Maybe<Scalars['String']>;
    arguments?: Maybe<Array<Maybe<Scalars['String']>>>;
    showBeak?: Maybe<Scalars['Boolean']>;
};
export declare type IStatusbarItem = ITerminal | ISelectionStatus | IIndentation | IEncodingStatus | IEndOfLineSequence | ILanguageMode | ISyncStatus | IBranchStatus;
export declare const enum IStorageScope {
    /** The stored data will be scoped to all workspaces of this domain. */
    GLOBAL = "GLOBAL",
    /** The stored data will be scoped to the current workspace. */
    WORKSPACE = "WORKSPACE"
}
export declare type IStreamContent = {
    __typename?: 'StreamContent';
    resource?: Maybe<Scalars['String']>;
    name?: Maybe<Scalars['String']>;
    mtime?: Maybe<Scalars['BigInt']>;
    etag?: Maybe<Scalars['String']>;
    value?: Maybe<Scalars['String']>;
    status?: Maybe<Scalars['String']>;
    encoding?: Maybe<Scalars['String']>;
    linesRange?: Maybe<ILineRange>;
};
export declare type ISubscription = {
    __typename?: 'Subscription';
    dummy?: Maybe<Scalars['Int']>;
    fileData?: Maybe<Array<Maybe<IFileChange>>>;
    fileOperation?: Maybe<IFileOperationOutput>;
    onDidChangeConfiguration?: Maybe<IIConfigurationChangeEvent>;
    /** Doesn't work yet */
    readStreamTextFile?: Maybe<ITextFileStreamContent>;
    /** Streams content in string chunks */
    readStreamTextString?: Maybe<ITextFilePublishContent>;
    searchStreamContent?: Maybe<ISearchCompleteStream>;
};
export declare type ISubscriptionfileDataArgs = {
    resource: Scalars['URI'];
};
export declare type ISubscriptionfileOperationArgs = {
    resource: Scalars['URI'];
};
export declare type ISubscriptionreadStreamTextFileArgs = {
    resource: Scalars['URI'];
};
export declare type ISubscriptionreadStreamTextStringArgs = {
    resource: Scalars['URI'];
};
export declare type ISubscriptionsearchStreamContentArgs = {
    input?: Maybe<Scalars['AnyObject']>;
};
export declare type ISyncStatus = IIStatusbarItem & {
    __typename?: 'SyncStatus';
    id?: Maybe<Scalars['String']>;
    name?: Maybe<Scalars['String']>;
    alignment?: Maybe<IStatusbarAlignment>;
    entry?: Maybe<IStatusbarEntry>;
    priority?: Maybe<Scalars['Int']>;
    container?: Maybe<Scalars['String']>;
    labelContainer?: Maybe<Scalars['String']>;
    typeId?: Maybe<ISTATUSBAR_ITEM_ID>;
};
export { TabCloseButtonType };
export { TabSizingType };
export declare type ITerminal = IIStatusbarItem & {
    __typename?: 'Terminal';
    alignment?: Maybe<IStatusbarAlignment>;
    container?: Maybe<Scalars['String']>;
    entry?: Maybe<IStatusbarEntry>;
    id?: Maybe<Scalars['String']>;
    integrated?: Maybe<IIntegrated>;
    labelContainer?: Maybe<Scalars['String']>;
    name?: Maybe<Scalars['String']>;
    priority?: Maybe<Scalars['Int']>;
    typeId?: Maybe<ISTATUSBAR_ITEM_ID>;
};
export declare type ITextBufferData = {
    __typename?: 'TextBufferData';
    EOL?: Maybe<Scalars['String']>;
    lines?: Maybe<Array<Maybe<Scalars['String']>>>;
    containsRTL?: Maybe<Scalars['Boolean']>;
    isBasicASCII?: Maybe<Scalars['Boolean']>;
};
export declare type ITextDocumentIdentifier = IITextDocumentIdentifier & {
    __typename?: 'TextDocumentIdentifier';
    uri?: Maybe<Scalars['URI']>;
    languageId?: Maybe<Scalars['String']>;
};
export declare type ITextDocumentIdentifierInput = {
    uri?: Maybe<Scalars['URI']>;
};
/** An item to transfer a text document from the client to the server. */
export declare type ITextDocumentItem = IITextDocumentIdentifier & {
    __typename?: 'TextDocumentItem';
    uri?: Maybe<Scalars['URI']>;
    /** The ID of the document's language. This is a well-defined string identifier such as "phython". */
    languageId?: Maybe<Scalars['String']>;
    /** The document's text content. */
    text?: Maybe<Scalars['String']>;
};
export declare type ITextDocumentItemInput = {
    uri?: Maybe<Scalars['String']>;
    languageId?: Maybe<Scalars['String']>;
    text?: Maybe<Scalars['String']>;
};
export declare type ITextDocumentPositionParams = {
    textDocument?: Maybe<ITextDocumentIdentifier>;
    position?: Maybe<IPosition>;
};
export declare type ITextDocumentPositionParamsInput = {
    textDocument?: Maybe<ITextDocumentIdentifierInput>;
    position?: Maybe<IPositionInput>;
};
export declare type ITextDocumentRegistrationOptions = {
    __typename?: 'TextDocumentRegistrationOptions';
    documentSelector?: Maybe<Array<Maybe<Scalars['String']>>>;
};
export declare type ITextDocumentRegistrationOptionsInput = {
    documentSelector?: Maybe<Array<Maybe<Scalars['String']>>>;
};
/** Extension of EditorOptions_Input */
export declare type ITextEditorOptions_Input = {
    /**
     * Tells the editor to not receive keyboard focus when the editor is being opened.
     *
     * Will also not activate the group the editor opens in unless the group is already
     * the active one. This behaviour can be overridden via the `activation` option.
     */
    preserveFocus?: Maybe<Scalars['Boolean']>;
    /**
     * This option is only relevant if an editor is opened into a group that is not active
     * already and allows to control if the inactive group should become active, restored
     * or preserved.
     *
     * By default, the editor group will become active unless `preserveFocus` or `inactive`
     * is specified.
     */
    activation?: Maybe<IEditorActivation>;
    /**
     * Tells the editor to reload the editor input in the editor even if it is identical to the one
     * already showing. By default, the editor will not reload the input if it is identical to the
     * one showing.
     */
    forceReload?: Maybe<Scalars['Boolean']>;
    /**
     * Will reveal the editor if it is already opened and visible in any of the opened editor groups.
     *
     * Note that this option is just a hint that might be ignored if the user wants to open an editor explicitly
     * to the side of another one or into a specific editor group.
     */
    revealIfVisible?: Maybe<Scalars['Boolean']>;
    /**
     * Will reveal the editor if it is already opened (even when not visible) in any of the opened editor groups.
     *
     * Note that this option is just a hint that might be ignored if the user wants to open an editor explicitly
     * to the side of another one or into a specific editor group.
     */
    revealIfOpened?: Maybe<Scalars['Boolean']>;
    /**
     * An editor that is pinned remains in the editor stack even when another editor is being opened.
     * An editor that is not pinned will always get replaced by another editor that is not pinned.
     */
    pinned?: Maybe<Scalars['Boolean']>;
    /**
     * An editor that is sticky moves to the beginning of the editors list within the group and will remain
     * there unless explicitly closed. Operations such as "Close All" will not close sticky editors.
     */
    sticky?: Maybe<Scalars['Boolean']>;
    /** The index in the document stack where to insert the editor into when opening. */
    index?: Maybe<Scalars['Int']>;
    /**
     * An active editor that is opened will show its contents directly. Set to true to open an editor
     * in the background.
     *
     * Will also not activate the group the editor opens in unless the group is already
     * the active one. This behaviour can be overridden via the `activation` option.
     */
    inactive?: Maybe<Scalars['Boolean']>;
    /**
     * Will not show an error in case opening the editor fails and thus allows to show a custom error
     * message as needed. By default, an error will be presented as notification if opening was not possible.
     */
    ignoreError?: Maybe<Scalars['Boolean']>;
    /**
     * Allows to override the editor that should be used to display the input:
     * - `undefined`: let the editor decide for itself
     * - `false`: disable overrides
     * - `string`: specific override by id
     */
    override?: Maybe<Scalars['AnyObject']>;
    /**
     * A optional hint to signal in which context the editor opens.
     *
     * If configured to be `EditorOpenContet.USER`, this hint can be
     * used in various places to control the experience. For example,
     * if the editor to open fails with an error, a notification could
     * inform about this in a modal dialog. If the editor opened through
     * some background task, the notification would show in the background,
     * not as a modal dialog.
     */
    context?: Maybe<IEditorOpenContext>;
    /** Text editor selection. */
    selection?: Maybe<ITextEditorSelection_Input>;
    /** Text editor view state. */
    viewState?: Maybe<Scalars['AnyObject']>;
    /**
     * Options to control the text editor selection reveal type.
     * Defaults to TextEditoSelectionRevewalType.Center
     */
    selectionRevealType?: Maybe<ITextEditorSelectionRevealType>;
};
export declare type ITextEditorSelection_Input = {
    startLineNumber: Scalars['Int'];
    startColumn: Scalars['Int'];
    endLineNumber?: Maybe<Scalars['Int']>;
    endColumn?: Maybe<Scalars['Int']>;
};
export declare const enum ITextEditorSelectionRevealType {
    /** Option to scroll vertically or horizontally as necessary and reveal a range centered vertically. */
    Center = "Center",
    /**
     * Option to scroll vertically or horizontally as necessary and reveal a range
     * centered vertically only if it lies outside the viewport.
     */
    CenterIfOutsideViewport = "CenterIfOutsideViewport",
    /**
     * Option to scroll vertically or horizontally as necessary and reveal a range
     * close to the top of the viewport, but not quite at the top.
     */
    NearTop = "NearTop",
    /**
     * Option to scroll vertically or horizontally as necessary and reveal a range
     * close to the top of the viewport, but not quite at the top.
     * Only if it lies outside the viewport
     */
    NearTopIfOutsideViewport = "NearTopIfOutsideViewport"
}
export declare type ITextFileContent = IIBaseStat & IIBaseStatWithMetadata & IIBaseTextFileContent & IIFileClientMetadata & {
    __typename?: 'TextFileContent';
    /** Content of the file is modified */
    dirty?: Maybe<Scalars['Boolean']>;
    /** Encoding as reported from disk */
    encoding?: Maybe<Scalars['String']>;
    etag: Scalars['String'];
    /** File is in conflict with storage. */
    inConflictMode?: Maybe<Scalars['Boolean']>;
    /** File is in Error */
    inErrorMode?: Maybe<Scalars['Boolean']>;
    /** File doesn't exist in the storage */
    inOrphanMode?: Maybe<Scalars['Boolean']>;
    /** Pending Save */
    inPendingSave?: Maybe<Scalars['Boolean']>;
    isReadonly?: Maybe<Scalars['Boolean']>;
    mtime: Scalars['BigInt'];
    name: Scalars['String'];
    /** Encoding as chosen by the user */
    preferredEncoding?: Maybe<Scalars['String']>;
    preferredMode?: Maybe<Scalars['String']>;
    resource: Scalars['URI'];
    size: Scalars['Int'];
    /** States the text file editor model can be in. */
    state?: Maybe<IFileModelState>;
    /** The content of a text file. */
    value?: Maybe<Scalars['String']>;
};
export declare const enum ITextFileOperationResult {
    FILE_IS_BINARY = "FILE_IS_BINARY"
}
export declare type ITextFilePublishContent = IIBaseTextFileContent & IIBaseStat & {
    __typename?: 'TextFilePublishContent';
    resource: Scalars['URI'];
    name: Scalars['String'];
    mtime?: Maybe<Scalars['BigInt']>;
    etag?: Maybe<Scalars['String']>;
    size?: Maybe<Scalars['Int']>;
    isReadonly?: Maybe<Scalars['Boolean']>;
    streamSeq?: Maybe<Scalars['Int']>;
    encoding?: Maybe<Scalars['String']>;
    /** The content of the file in parts */
    value?: Maybe<Scalars['String']>;
    status?: Maybe<IFileContentStatus>;
};
export declare type ITextFileStreamContent = IIBaseTextFileContent & IIBaseStatWithMetadata & IIBaseStat & {
    __typename?: 'TextFileStreamContent';
    resource: Scalars['URI'];
    name: Scalars['String'];
    size: Scalars['Int'];
    mtime: Scalars['BigInt'];
    etag: Scalars['String'];
    isReadonly?: Maybe<Scalars['Boolean']>;
    encoding?: Maybe<Scalars['String']>;
    /** The line grouped content of a text file. */
    value?: Maybe<ITextBufferData>;
};
export declare type ITextQueryInput = {
    _reason?: Maybe<Scalars['String']>;
    folderQueries?: Maybe<Array<Maybe<IFolderQueryInput>>>;
    includePattern?: Maybe<Scalars['AnyObject']>;
    excludePattern?: Maybe<Scalars['AnyObject']>;
    extraFileResources?: Maybe<Array<Maybe<IURIInput>>>;
    useRipgrep?: Maybe<Scalars['Boolean']>;
    maxResults?: Maybe<Scalars['Int']>;
    usingSearchPaths?: Maybe<Scalars['Boolean']>;
    type: IQueryType;
    contentPattern: IPatternInfoInput;
    previewOptions?: Maybe<ITextSearchPreviewOptionsInput>;
    maxFileSize?: Maybe<Scalars['Int']>;
    usePCRE2?: Maybe<Scalars['Boolean']>;
    afterContext?: Maybe<Scalars['Int']>;
    beforeContext?: Maybe<Scalars['Int']>;
};
export declare type ITextSearchContext = {
    __typename?: 'TextSearchContext';
    uri?: Maybe<Scalars['URI']>;
    text: Scalars['String'];
    lineNumber: Scalars['Int'];
};
export declare type ITextSearchMatch = {
    __typename?: 'TextSearchMatch';
    uri?: Maybe<Scalars['URI']>;
    ranges?: Maybe<Array<Maybe<ISearchRange>>>;
    preview?: Maybe<ITextSearchResultPreview>;
};
export declare type ITextSearchPreviewOptions = {
    __typename?: 'TextSearchPreviewOptions';
    matchLines: Scalars['Int'];
    charsPerLine: Scalars['Int'];
};
export declare type ITextSearchPreviewOptionsInput = {
    matchLines: Scalars['Int'];
    charsPerLine: Scalars['Int'];
};
export declare type ITextSearchResult = ITextSearchMatch | ITextSearchContext;
export declare type ITextSearchResultPreview = {
    __typename?: 'TextSearchResultPreview';
    text?: Maybe<Scalars['String']>;
    matches?: Maybe<Array<Maybe<ISearchRange>>>;
};
export declare type ITextSearchStats = {
    __typename?: 'TextSearchStats';
    type?: Maybe<ITextSearchStatsType>;
};
export declare const enum ITextSearchStatsType {
    textSearchProvider = "textSearchProvider",
    searchProcess = "searchProcess"
}
export declare type IThemeLabel = {
    __typename?: 'ThemeLabel';
    label?: Maybe<Scalars['String']>;
    uiTheme?: Maybe<Scalars['String']>;
    path?: Maybe<Scalars['String']>;
};
export declare type ITreeData_Input = {
    path?: Maybe<Scalars['String']>;
    title?: Maybe<Scalars['String']>;
    subtitle?: Maybe<Scalars['String']>;
    isDirectory?: Maybe<Scalars['Boolean']>;
    active?: Maybe<Scalars['Boolean']>;
    expanded?: Maybe<Scalars['Boolean']>;
    hasChildren?: Maybe<Scalars['Boolean']>;
    childrenGen?: Maybe<Scalars['JSON']>;
};
export declare type ITreeItem = {
    __typename?: 'TreeItem';
    handle?: Maybe<Scalars['String']>;
    parentHandle?: Maybe<Scalars['String']>;
    collapsibleState?: Maybe<ITreeItemCollapsibleState>;
    label?: Maybe<Scalars['String']>;
    description?: Maybe<Scalars['String']>;
    icon?: Maybe<Scalars['URI']>;
    iconDark?: Maybe<Scalars['URI']>;
    themeIcon?: Maybe<Scalars['String']>;
    resourceUri?: Maybe<Scalars['URI']>;
    tooltip?: Maybe<Scalars['String']>;
    contextValue?: Maybe<Scalars['String']>;
    children?: Maybe<Array<Maybe<ITreeItem>>>;
};
export declare const enum ITreeItemCollapsibleState {
    None = "None",
    Collapsed = "Collapsed",
    Expanded = "Expanded"
}
export declare type ITreeViewDescriptor = IIViewDescriptor & {
    __typename?: 'TreeViewDescriptor';
    id: Scalars['String'];
    name?: Maybe<Scalars['String']>;
    when?: Maybe<Scalars['String']>;
    order?: Maybe<Scalars['Int']>;
    weight?: Maybe<Scalars['Int']>;
    collapsed?: Maybe<Scalars['Boolean']>;
    canToggleVisibility?: Maybe<Scalars['Boolean']>;
    hideByDefault?: Maybe<Scalars['Boolean']>;
    workspace?: Maybe<Scalars['Boolean']>;
};
/** An editor input to be used for untitled text buffers. */
export declare type IUntitledEditorInput = IIEditorInput & IIEditorInputWithGroupFields & {
    __typename?: 'UntitledEditorInput';
    id?: Maybe<Scalars['String']>;
    resource?: Maybe<Scalars['String']>;
    typeId?: Maybe<IEDITOR_INPUT_ID>;
    description?: Maybe<Scalars['String']>;
    label?: Maybe<Scalars['String']>;
    fileReference?: Maybe<IFileStatWithMetadata>;
    preferredEditorId?: Maybe<Scalars['String']>;
    isSupportsSplitEditor?: Maybe<Scalars['Boolean']>;
    isActive?: Maybe<Scalars['Boolean']>;
    preview?: Maybe<Scalars['Boolean']>;
    isPinned?: Maybe<Scalars['Boolean']>;
    editorId?: Maybe<Scalars['Int']>;
    status?: Maybe<Scalars['String']>;
    closable?: Maybe<Scalars['Boolean']>;
    hasAssociatedFilePath?: Maybe<Scalars['Boolean']>;
    shortDescription?: Maybe<Scalars['String']>;
    mediumDescription?: Maybe<Scalars['String']>;
    longDescription?: Maybe<Scalars['String']>;
    shortTitle?: Maybe<Scalars['String']>;
    mediumTitle?: Maybe<Scalars['String']>;
    longTitle?: Maybe<Scalars['String']>;
    suggestFileName?: Maybe<Scalars['String']>;
    enconding?: Maybe<Scalars['String']>;
    mode?: Maybe<Scalars['String']>;
};
/** Extension of BaseResource_Input */
export declare type IUntitledResource_Input = {
    options?: Maybe<ITextEditorOptions_Input>;
    label?: Maybe<Scalars['String']>;
    description?: Maybe<Scalars['String']>;
    forceFile?: Maybe<Scalars['Boolean']>;
    forceUntitled?: Maybe<Scalars['Boolean']>;
    /**
     * Optional resource. If the resource is not provided a new untitled file is created (e.g. Untitled-1).
     * Otherwise the untitled editor will have an associated path and use that when saving.
     */
    resource?: Maybe<Scalars['URI']>;
    /**
     * Optional file path. Using the file resource will associate the file to the untitled resource.
     *    @deprecated
     */
    filePath?: Maybe<Scalars['String']>;
    /** Optional language of the untitled resource. */
    mode?: Maybe<Scalars['String']>;
    /** Optional contents of the untitled resource. */
    contents?: Maybe<Scalars['String']>;
    /** Optional encoding of the untitled resource. */
    encoding?: Maybe<Scalars['String']>;
};
export declare type IUpdateDelayedResource = {
    __typename?: 'UpdateDelayedResource';
    resource?: Maybe<Scalars['URI']>;
};
export declare type IUpdatedResource = {
    __typename?: 'UpdatedResource';
    resource?: Maybe<Scalars['URI']>;
    etag?: Maybe<Scalars['String']>;
};
export declare type IUpdateEntry_input = {
    id?: Maybe<Scalars['String']>;
    alignment?: Maybe<Scalars['String']>;
    entry?: Maybe<IStatusbarEntry_input>;
    priority?: Maybe<Scalars['Int']>;
    container?: Maybe<Scalars['String']>;
    labelContainer?: Maybe<Scalars['String']>;
};
export declare type IURIInput = {
    path?: Maybe<Scalars['String']>;
    scheme?: Maybe<Scalars['String']>;
    authority?: Maybe<Scalars['String']>;
    query?: Maybe<Scalars['String']>;
    fragment?: Maybe<Scalars['String']>;
    fsPath?: Maybe<Scalars['String']>;
};
export declare type IURIToOpen = IWorkspaceToOpen | IFolderToOpen | IFileToOpen;
export declare type IUser = {
    __typename?: 'User';
    username?: Maybe<Scalars['String']>;
};
export declare type IUserPreferencesRes = {
    __typename?: 'UserPreferencesRes';
    prefs?: Maybe<IIUserPreferences>;
};
/** UserSettings is a combination of LocalUserSettings and RemoteUserSettings */
export declare type IUserSettings = IISettingsSubject & {
    __typename?: 'UserSettings';
    /**  The ID.  */
    id?: Maybe<Scalars['ID']>;
    /**
     * The latest settings for the user.
     *
     * Only the user and site admins can access this field.
     */
    latestSettings?: Maybe<ISettings>;
    /** The URL to the user's settings. */
    settingsURL: Scalars['URI'];
    /**
     * Whether the viewer has admin privileges on this user. The user has admin privileges on their own user, and
     * site admins have admin privileges on all users.
     */
    viewerCanAdminister: Scalars['Boolean'];
    /**
     * All settings for this user, and the individual levels in the settings cascade (global > organization > user)
     * that were merged to produce the final merged settings.
     *
     * Only the user and site admins can access this field.
     */
    settingsCascade: ISettingsCascade;
};
export declare type IView = {
    __typename?: 'View';
    id?: Maybe<Scalars['ID']>;
    name?: Maybe<Scalars['String']>;
};
export declare type IViewContainer = {
    __typename?: 'ViewContainer';
    id?: Maybe<Scalars['ID']>;
    title?: Maybe<Scalars['String']>;
};
export declare type IViewDescriptor = IIViewDescriptor & {
    __typename?: 'ViewDescriptor';
    id: Scalars['String'];
    name?: Maybe<Scalars['String']>;
    when?: Maybe<Scalars['String']>;
    order?: Maybe<Scalars['Int']>;
    weight?: Maybe<Scalars['Int']>;
    collapsed?: Maybe<Scalars['Boolean']>;
    canToggleVisibility?: Maybe<Scalars['Boolean']>;
    hideByDefault?: Maybe<Scalars['Boolean']>;
    workspace?: Maybe<Scalars['Boolean']>;
};
export declare type IViewState = {
    __typename?: 'ViewState';
    scrollTop?: Maybe<Scalars['Int']>;
    scrollTopWithoutViewZones?: Maybe<Scalars['Int']>;
    scrollLeft?: Maybe<Scalars['Int']>;
    firstPosition?: Maybe<IPosition>;
    firstPositionDeltaTop?: Maybe<Scalars['Int']>;
};
export declare type IViewState_Input = {
    scrollTop?: Maybe<Scalars['Int']>;
    scrollTopWithoutViewZones?: Maybe<Scalars['Int']>;
    scrollLeft?: Maybe<Scalars['Int']>;
    firstPosition?: Maybe<IPositionInput>;
    firstPositionDeltaTop?: Maybe<Scalars['Int']>;
};
export declare type IWatchOptions_Input = {
    recursive?: Maybe<Scalars['Boolean']>;
    excludes?: Maybe<Array<Maybe<Scalars['String']>>>;
    session?: Maybe<Scalars['String']>;
};
export declare type IWindowConfiguration = {
    __typename?: 'WindowConfiguration';
    machineId?: Maybe<Scalars['String']>;
    windowId?: Maybe<Scalars['Int']>;
    logLevel?: Maybe<Scalars['String']>;
    mainPid?: Maybe<Scalars['String']>;
    appRoot?: Maybe<Scalars['String']>;
    execPath?: Maybe<Scalars['String']>;
    isInitialStartup?: Maybe<Scalars['Boolean']>;
    nodeCacheDataDir?: Maybe<Scalars['String']>;
    backupPath?: Maybe<Scalars['String']>;
    workspace?: Maybe<IWorkspaceIdentifier>;
    /** A single folder workspace identifier is just the path to the folder. */
    folderUri?: Maybe<Scalars['URI']>;
    remoteAuthority?: Maybe<Scalars['String']>;
    zoomLevel?: Maybe<Scalars['Int']>;
    fullscreen?: Maybe<Scalars['Boolean']>;
    maximized?: Maybe<Scalars['Boolean']>;
    highContrast?: Maybe<Scalars['Boolean']>;
    frameless?: Maybe<Scalars['Boolean']>;
    accessibilitySupport?: Maybe<Scalars['Boolean']>;
    partsSplashPath?: Maybe<Scalars['String']>;
    perfStartTime?: Maybe<Scalars['Int']>;
    perfAppReady?: Maybe<Scalars['Int']>;
    perfWindowLoadTime?: Maybe<Scalars['Int']>;
    perfEntries?: Maybe<Scalars['AnyObject']>;
    filesToOpenOrCreate?: Maybe<Array<Maybe<IPath>>>;
    filesToDiff?: Maybe<Array<Maybe<IPath>>>;
    filesToWait?: Maybe<IPathsToWaitFor>;
    termProgram?: Maybe<Scalars['String']>;
};
export declare const enum IWorkspaceContextServiceAction {
    getWorkspace = "getWorkspace",
    onDidChangeWorkbenchState = "onDidChangeWorkbenchState",
    onDidChangeWorkspaceName = "onDidChangeWorkspaceName",
    onDidChangeWorkspaceFolders = "onDidChangeWorkspaceFolders",
    addFolders = "addFolders",
    removeFolders = "removeFolders",
    updateFolders = "updateFolders"
}
export declare type IWorkspaceData = IIStaticWorkspaceData & {
    __typename?: 'WorkspaceData';
    /** The unique identifier of the workspace. */
    id: Scalars['String'];
    /** Folders in the workspace. */
    folders: Array<Maybe<IWorkspaceFolderData>>;
    /** The location of the workspace configuration */
    configuration?: Maybe<Scalars['URI']>;
    name?: Maybe<Scalars['String']>;
    isUntitled?: Maybe<Scalars['Boolean']>;
};
export declare type IWorkspaceFolderData = {
    __typename?: 'WorkspaceFolderData';
    /** The associated URI for this workspace folder. */
    uri?: Maybe<Scalars['URI']>;
    /** The name of this workspace folder. Defaults to the basename its [uri-path](#Uri.path) */
    name: Scalars['String'];
    /** The ordinal number of this workspace folder. */
    index: Scalars['Int'];
};
export declare type IWorkspaceIdentifier = {
    __typename?: 'WorkspaceIdentifier';
    id?: Maybe<Scalars['String']>;
    configPath?: Maybe<Scalars['URI']>;
};
export declare type IWorkspacePreferenceActivityBar = {
    __typename?: 'WorkspacePreferenceActivityBar';
    visible?: Maybe<Scalars['Boolean']>;
};
export declare type IWorkspacePreferenceCommandPalette = {
    __typename?: 'WorkspacePreferenceCommandPalette';
    history?: Maybe<Scalars['Int']>;
    preserveInput?: Maybe<Scalars['Boolean']>;
};
export declare type IWorkspacePreferenceEditor = {
    __typename?: 'WorkspacePreferenceEditor';
    centeredLayoutAutoResize?: Maybe<Scalars['Boolean']>;
    closeEmptyGroups?: Maybe<Scalars['Boolean']>;
    closeOnFileDelete?: Maybe<Scalars['Boolean']>;
    enablePreview?: Maybe<Scalars['Boolean']>;
    enablePreviewFromQuickOpen?: Maybe<Scalars['Boolean']>;
    focusRecentEditorAfterClose?: Maybe<Scalars['Boolean']>;
    highlightModifiedTabs?: Maybe<Scalars['Boolean']>;
    labelFormat?: Maybe<Scalars['String']>;
    openPositioning?: Maybe<Scalars['String']>;
    openSideBySideDirection?: Maybe<Scalars['String']>;
    restoreViewState?: Maybe<Scalars['Boolean']>;
    revealIfOpen?: Maybe<Scalars['Boolean']>;
    showIcons?: Maybe<Scalars['Boolean']>;
    showTabs?: Maybe<Scalars['Boolean']>;
    splitSizing?: Maybe<Scalars['String']>;
    tabCloseButton?: Maybe<Scalars['String']>;
    tabSizing?: Maybe<Scalars['String']>;
};
export declare type IWorkspacePreferenceExperimental = {
    __typename?: 'WorkspacePreferenceExperimental';
    editorAssociations?: Maybe<Array<Maybe<Scalars['String']>>>;
};
export declare type IWorkspacePreferenceList = {
    __typename?: 'WorkspacePreferenceList';
    automaticKeyboardNavigation?: Maybe<Scalars['Boolean']>;
    horizontalScrolling?: Maybe<Scalars['Boolean']>;
    keyboardNavigation?: Maybe<Scalars['String']>;
    multiSelectModifier?: Maybe<Scalars['String']>;
    openMode?: Maybe<Scalars['String']>;
};
export declare type IWorkspacePreferencePanel = {
    __typename?: 'WorkspacePreferencePanel';
    defaultLocation?: Maybe<Scalars['String']>;
};
export declare type IWorkspacePreferenceQuickOpen = {
    __typename?: 'WorkspacePreferenceQuickOpen';
    closeOnFocusLost?: Maybe<Scalars['Boolean']>;
    preserveInput?: Maybe<Scalars['Boolean']>;
};
export declare type IWorkspacePreferenceSettings = {
    __typename?: 'WorkspacePreferenceSettings';
    editor?: Maybe<Scalars['String']>;
    enableNaturalLanguageSearch?: Maybe<Scalars['Boolean']>;
    openDefaultKeybindings?: Maybe<Scalars['Boolean']>;
    settingsSearchTocBehavior?: Maybe<Scalars['String']>;
    useSplitJSON?: Maybe<Scalars['Boolean']>;
};
export declare type IWorkspacePreferenceSideBar = {
    __typename?: 'WorkspacePreferenceSideBar';
    location?: Maybe<Scalars['String']>;
};
export declare type IWorkspacePreferenceStatusBar = {
    __typename?: 'WorkspacePreferenceStatusBar';
    visible?: Maybe<Scalars['Boolean']>;
};
export declare type IWorkspacePreferenceTips = {
    __typename?: 'WorkspacePreferenceTips';
    enabled?: Maybe<Scalars['Boolean']>;
    horizontalScrolling?: Maybe<Scalars['Boolean']>;
    indent?: Maybe<Scalars['Int']>;
    renderIndentGuides?: Maybe<Scalars['String']>;
};
export declare type IWorkspacePreferenceView = {
    __typename?: 'WorkspacePreferenceView';
    alwaysShowHeaderActions?: Maybe<Scalars['Boolean']>;
};
export declare type IWorkspacePreferenceWorkbench = {
    __typename?: 'WorkspacePreferenceWorkbench';
    colorTheme?: Maybe<Scalars['String']>;
    enableExperiments?: Maybe<Scalars['Boolean']>;
    fontAliasing?: Maybe<Scalars['String']>;
    iconTheme?: Maybe<Scalars['String']>;
    startupEditor?: Maybe<Scalars['String']>;
    view?: Maybe<IWorkspacePreferenceView>;
    tips?: Maybe<IWorkspacePreferenceTips>;
    statusBar?: Maybe<IWorkspacePreferenceStatusBar>;
    sideBar?: Maybe<IWorkspacePreferenceSideBar>;
    settings?: Maybe<IWorkspacePreferenceSettings>;
    quickOpen?: Maybe<IWorkspacePreferenceQuickOpen>;
    panel?: Maybe<IWorkspacePreferencePanel>;
    list?: Maybe<IWorkspacePreferenceList>;
    experimental?: Maybe<IWorkspacePreferenceExperimental>;
    editor?: Maybe<IWorkspacePreferenceEditor>;
    commandPalette?: Maybe<IWorkspacePreferenceCommandPalette>;
    activityBar?: Maybe<IWorkspacePreferenceActivityBar>;
};
export declare type IWorkspaceRes = {
    __typename?: 'WorkspaceRes';
    uri?: Maybe<Scalars['String']>;
};
export declare type IWorkspaceSettings = IISettingsSubject & {
    __typename?: 'WorkspaceSettings';
    /**  The ID.  */
    id?: Maybe<Scalars['ID']>;
    /**  The latest settings.  */
    latestSettings?: Maybe<ISettings>;
    /**  The URL to the settings.  */
    settingsURL: Scalars['URI'];
    /**  Whether the viewer can modify the subject's settings. */
    viewerCanAdminister: Scalars['Boolean'];
    /**
     * All settings for this subject, and the individual levels in the settings cascade (global > organization > user)
     * that were merged to produce the final merged settings.
     */
    settingsCascade: ISettingsCascade;
};
export declare type IWorkspaceStackSettings = {
    __typename?: 'WorkspaceStackSettings';
    dummy?: Maybe<Scalars['Int']>;
};
export declare type IWorkspaceToOpen = {
    __typename?: 'WorkspaceToOpen';
    workspaceUri: Scalars['URI'];
    label?: Maybe<Scalars['String']>;
};
export declare type IWorkspaceValue_Input = {
    section?: Maybe<Scalars['String']>;
    overrides?: Maybe<IConfigurationOverrides_Input>;
};
export declare type IWriteFileOptions_Input = {
    /** The last known modification time of the file. This can be used to prevent dirty writes. */
    mtime?: Maybe<Scalars['BigInt']>;
    /** The etag of the file. This can be used to prevent dirty writes. */
    etag?: Maybe<Scalars['String']>;
};
/** It is an extension to WriteFileOptions_Input with few more options. */
export declare type IWriteTextFileOptions_Input = {
    mtime?: Maybe<Scalars['BigInt']>;
    etag?: Maybe<Scalars['String']>;
    /** The encoding to use when updating a file. */
    encoding?: Maybe<Scalars['String']>;
    /** If set to true, will enforce the selected encoding and not perform any detection using BOM's. */
    overwriteEncoding?: Maybe<Scalars['Boolean']>;
    /** Whether to overwrite a file even if is readonly. */
    overwriteReadonly?: Maybe<Scalars['Boolean']>;
    /**
     * Whether to write to the file as elevated (admin) user. When setting this option a prompt will
     * ask the user to authenticate as super user.
     */
    writeElevated?: Maybe<Scalars['Boolean']>;
};
export declare type IinstallMutationVariables = {
    vsix: Scalars['String'];
};
export declare type IinstallMutation = ({
    __typename?: 'Mutation';
} & {
    install?: Maybe<({
        __typename?: 'ExtensionIdentifier';
    } & Pick<IExtensionIdentifier, 'id' | 'uuid'>)>;
});
export declare type IproviderDefinitionMutationVariables = {
    params?: Maybe<ITextDocumentPositionParamsInput>;
};
export declare type IproviderDefinitionMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'hoverProviderDefinition'>);
export declare type IremoveMutationVariables = {
    id: Scalars['String'];
};
export declare type IremoveMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'removeExtension'>);
export declare type IExtensionsByLimitQueryVariables = {
    first: Scalars['Int'];
    prioritizeExtensionIDs: Array<Scalars['String']>;
};
export declare type IExtensionsByLimitQuery = ({
    __typename?: 'Query';
} & {
    extensionRegistry: ({
        __typename?: 'ExtensionRegistry';
    } & {
        extensions: ({
            __typename?: 'RegistryExtensionConnection';
        } & {
            nodes: Array<({
                __typename?: 'RegistryExtension';
            } & Pick<IRegistryExtension, 'id' | 'url' | 'extensionID' | 'viewerCanAdminister'> & {
                manifest?: Maybe<({
                    __typename?: 'ExtensionManifest';
                } & Pick<IExtensionManifest, 'raw' | 'name' | 'activationEvents'>)>;
            })>;
        });
    });
});
export declare type IExtensionsQueryVariables = {};
export declare type IExtensionsQuery = ({
    __typename?: 'Query';
} & {
    extensions: ({
        __typename?: 'RegistryExtensionConnection';
    } & {
        nodes: Array<({
            __typename?: 'RegistryExtension';
        } & Pick<IRegistryExtension, 'id' | 'url' | 'activationEvents' | 'viewerCanAdminister' | 'extensionID'> & {
            releases?: Maybe<Array<Maybe<({
                __typename?: 'ExtensionRelease';
            } & Pick<IExtensionRelease, 'version' | 'bundleURL' | 'extensionID'>)>>>;
            manifest?: Maybe<({
                __typename?: 'ExtensionManifest';
            } & Pick<IExtensionManifest, 'bundleURL' | 'raw' | 'name' | 'main' | 'badges' | 'preview' | 'version' | 'keywords' | 'license' | 'homepage' | 'publisher' | 'categories' | 'description' | 'extensionID' | 'displayName' | 'dependencies' | 'extensionDependencies' | 'bundle' | 'activationEvents'> & {
                assets?: Maybe<Array<Maybe<({
                    __typename?: 'Assets';
                } & Pick<IAssets, 'Type' | 'Content'>)>>>;
                scripts?: Maybe<({
                    __typename?: 'Scripts';
                } & Pick<IScripts, 'cdebasebuild' | 'cdebasepublish'>)>;
                bundles?: Maybe<({
                    __typename?: 'Bundles';
                } & Pick<IBundles, 'server' | 'browser'>)>;
                extension?: Maybe<({
                    __typename?: 'ExtensionPackageType';
                } & Pick<IExtensionPackageType, 'type'>)>;
                engines?: Maybe<({
                    __typename?: 'Engines';
                } & Pick<IEngines, 'node' | 'vscode'>)>;
                author?: Maybe<({
                    __typename?: 'Author';
                } & Pick<IAuthor, 'name'>)>;
                galleryBanner?: Maybe<({
                    __typename?: 'GalleryBanner';
                } & Pick<IGalleryBanner, 'color' | 'theme'>)>;
                contributes?: Maybe<({
                    __typename?: 'ExtensionContributions';
                } & {
                    menus?: Maybe<({
                        __typename?: 'Menus';
                    } & {
                        commandPalette?: Maybe<Array<Maybe<({
                            __typename?: 'MenuItemAction';
                        } & Pick<IMenuItemAction, 'action' | 'when'>)>>>;
                        explorer?: Maybe<({
                            __typename?: 'MenuItemActionContext';
                        } & {
                            context?: Maybe<Array<Maybe<({
                                __typename?: 'MenuItemAction';
                            } & Pick<IMenuItemAction, 'action' | 'when'>)>>>;
                        })>;
                        editor?: Maybe<({
                            __typename?: 'MenuItemActionEditor';
                        } & {
                            context?: Maybe<Array<Maybe<({
                                __typename?: 'MenuItemAction';
                            } & Pick<IMenuItemAction, 'action' | 'when'>)>>>;
                            title?: Maybe<({
                                __typename?: 'MenuItemActionEditorTitle';
                            } & {
                                own?: Maybe<Array<Maybe<({
                                    __typename?: 'MenuItemAction';
                                } & Pick<IMenuItemAction, 'action' | 'when'>)>>>;
                                context?: Maybe<Array<Maybe<({
                                    __typename?: 'MenuItemAction';
                                } & Pick<IMenuItemAction, 'action' | 'when'>)>>>;
                            })>;
                        })>;
                    })>;
                    actions?: Maybe<Array<Maybe<({
                        __typename?: 'Actions';
                    } & Pick<IActions, 'id' | 'command' | 'title' | 'category'> & {
                        actionItem?: Maybe<({
                            __typename?: 'ActionItem';
                        } & Pick<IActionItem, 'label' | 'description'>)>;
                    })>>>;
                })>;
            })>;
        })>;
    });
});
export declare type IgalleryExtensionQueryVariables = {
    extensionID: Scalars['String'];
};
export declare type IgalleryExtensionQuery = ({
    __typename?: 'Query';
} & {
    galleryExtension?: Maybe<({
        __typename?: 'GalleryExtension';
    } & Pick<IGalleryExtension, 'id' | 'name' | 'icon' | 'version' | 'description' | 'publisher' | 'installCount' | 'publisherDisplayName' | 'rating' | 'ratingCount' | 'displayName'> & {
        assets?: Maybe<({
            __typename?: 'GalleryExtensionAssets';
        } & {
            download?: Maybe<({
                __typename?: 'GalleryExtensionAsset';
            } & Pick<IGalleryExtensionAsset, 'uri' | 'fallbackUri'>)>;
        })>;
        resources?: Maybe<({
            __typename?: 'GalleryExtensionResources';
        } & Pick<IGalleryExtensionResources, 'icon' | 'readme' | 'manifest' | 'changelog'>)>;
    })>;
});
export declare type IgalleryQueryVariables = {
    query?: Maybe<IGalleryQuery>;
};
export declare type IgalleryQuery = ({
    __typename?: 'Query';
} & {
    gallery?: Maybe<({
        __typename?: 'GalleryPager';
    } & Pick<IGalleryPager, 'page'> & {
        firstPage?: Maybe<Array<Maybe<({
            __typename?: 'GalleryExtension';
        } & Pick<IGalleryExtension, 'id' | 'name' | 'icon' | 'version' | 'description' | 'publisher' | 'installCount' | 'publisherDisplayName' | 'rating' | 'ratingCount' | 'displayName'> & {
            assets?: Maybe<({
                __typename?: 'GalleryExtensionAssets';
            } & {
                download?: Maybe<({
                    __typename?: 'GalleryExtensionAsset';
                } & Pick<IGalleryExtensionAsset, 'uri' | 'fallbackUri'>)>;
            })>;
        })>>>;
    })>;
});
export declare type IinstalledExtensionsQueryVariables = {};
export declare type IinstalledExtensionsQuery = ({
    __typename?: 'Query';
} & {
    installed?: Maybe<Array<Maybe<({
        __typename?: 'InstalledExtension';
    } & {
        identifier?: Maybe<({
            __typename?: 'ExtensionIdentifier';
        } & Pick<IExtensionIdentifier, 'id' | 'uuid'>)>;
        galleryIdentifier?: Maybe<({
            __typename?: 'ExtensionIdentifier';
        } & Pick<IExtensionIdentifier, 'id' | 'uuid'>)>;
        extension?: Maybe<({
            __typename?: 'GalleryExtension';
        } & Pick<IGalleryExtension, 'name' | 'id' | 'icon' | 'displayName' | 'installCount' | 'description' | 'version' | 'publisherDisplayName'> & {
            identifier?: Maybe<({
                __typename?: 'ExtensionIdentifier';
            } & Pick<IExtensionIdentifier, 'id' | 'uuid'>)>;
        })>;
    })>>>;
});
export declare type IViewerSettingsQueryVariables = {};
export declare type IViewerSettingsQuery = ({
    __typename?: 'Query';
} & {
    viewerSettings: ({
        __typename?: 'SettingsCascade';
    } & Pick<ISettingsCascade, 'final'>);
});
export declare type IDefaultSettingFragment = ({
    __typename?: 'Setting';
} & Pick<ISetting, 'key' | 'value' | 'description' | 'descriptionIsMarkdown' | 'deprecationMessage' | 'type' | 'enum' | 'enumDescriptions' | 'enumDescriptionsAreMarkdown' | 'tags'>);
export declare type IFilesConfigurationFragment = ({
    __typename?: 'Files';
} & Pick<IFiles, 'eol' | 'hotExit' | 'encoding' | 'autoSave' | 'autoSaveDelay' | 'defaultLanguage' | 'autoGuessEncoding' | 'insertFinalNewline' | 'trimTrailingWhitespace' | 'useExperimentalFileWatcher' | 'watcherExclude' | 'exclude'>);
export declare type IGitConfigurationFragment = ({
    __typename?: 'Git';
} & Pick<IGit, 'path' | 'enabled' | 'autofetch' | 'countBadge' | 'autorefresh' | 'confirmSync' | 'checkoutType' | 'inputValidation' | 'detectSubmodules' | 'enableSmartCommit' | 'ignoreLimitWarning' | 'ignoreLegacyWarning' | 'enableCommitSigning' | 'defaultCloneDirectory' | 'autoRepositoryDetection' | 'ignoreMissingGitWarning' | 'showInlineOpenFileAction' | 'promptToSaveFilesBeforeCommit'> & {
    decorations?: Maybe<({
        __typename?: 'GitDecorations';
    } & Pick<IGitDecorations, 'enabled'>)>;
});
export declare type ILanguagesConfigurationFragment = ({
    __typename?: 'Languages';
} & Pick<ILanguages, 'go' | 'css' | 'html' | 'json' | 'yaml' | 'typescript' | 'javascript'>);
export declare type ISearchConfigurationFragment = ({
    __typename?: 'Search';
} & Pick<ISearch, 'location' | 'smartCase' | 'useRipgrep' | 'useIgnoreFiles' | 'followSymlinks' | 'globalFindClipboard' | 'exclude'> & {
    quickOpen?: Maybe<({
        __typename?: 'SearchQuickOpen';
    } & Pick<ISearchQuickOpen, 'includeSymbols'>)>;
});
export declare type ISettingRangeFragment = ({
    __typename?: 'Range';
} & Pick<IRange, 'startLineNumber' | 'startColumn' | 'endLineNumber' | 'endColumn'> & {
    start?: Maybe<({
        __typename?: 'Position';
    } & Pick<IPosition, 'line' | 'lineNumber' | 'column' | 'character'>)>;
    end?: Maybe<({
        __typename?: 'Position';
    } & Pick<IPosition, 'line' | 'lineNumber' | 'column' | 'character'>)>;
});
export declare type ITerminalConfigurationFragment = ({
    __typename?: 'Terminal';
} & {
    integrated?: Maybe<({
        __typename?: 'Integrated';
    } & Pick<IIntegrated, 'setLocaleVariables'> & {
        shell?: Maybe<({
            __typename?: 'Shell';
        } & Pick<IShell, 'osx' | 'linux' | 'windows' | 'container'>)>;
        shellArgs?: Maybe<({
            __typename?: 'ShellArgs';
        } & Pick<IShellArgs, 'container' | 'windows' | 'osx' | 'linux'>)>;
    })>;
});
export declare type IViewerSettingsFragment = ({
    __typename?: 'SettingsCascade';
} & Pick<ISettingsCascade, 'final'> & {
    subjects?: Maybe<Array<Maybe<({
        __typename?: 'UserSettings';
    } & Pick<IUserSettings, 'id' | 'settingsURL'> & {
        latestSettings?: Maybe<({
            __typename?: 'Settings';
        } & Pick<ISettings, 'contents' | 'createdAt'>)>;
        settingsCascade: ({
            __typename?: 'SettingsCascade';
        } & {
            finalConfiguration?: Maybe<({
                __typename?: 'Configuration';
            } & {
                terminal?: Maybe<({
                    __typename?: 'Terminal';
                } & ITerminalConfigurationFragment)>;
                search?: Maybe<({
                    __typename?: 'Search';
                } & ISearchConfigurationFragment)>;
                languages?: Maybe<({
                    __typename?: 'Languages';
                } & ILanguagesConfigurationFragment)>;
                output?: Maybe<({
                    __typename?: 'Output';
                } & Pick<IOutput, 'maxChannelHistory'>)>;
                files?: Maybe<({
                    __typename?: 'Files';
                } & IFilesConfigurationFragment)>;
                git?: Maybe<({
                    __typename?: 'Git';
                } & IGitConfigurationFragment)>;
                workspace?: Maybe<({
                    __typename?: 'WorkspacePreferenceWorkbench';
                } & IWorkspaceConfigurationFragment)>;
            })>;
        });
    }) | {
        __typename?: 'LocalUserSettings';
    } | {
        __typename?: 'RemoteUserSettings';
    } | ({
        __typename?: 'FolderSettings';
    } & Pick<IFolderSettings, 'id' | 'settingsURL'> & {
        latestSettings?: Maybe<({
            __typename?: 'Settings';
        } & Pick<ISettings, 'contents' | 'createdAt'>)>;
        settingsCascade: ({
            __typename?: 'SettingsCascade';
        } & {
            finalConfiguration?: Maybe<({
                __typename?: 'Configuration';
            } & {
                terminal?: Maybe<({
                    __typename?: 'Terminal';
                } & ITerminalConfigurationFragment)>;
                search?: Maybe<({
                    __typename?: 'Search';
                } & ISearchConfigurationFragment)>;
                languages?: Maybe<({
                    __typename?: 'Languages';
                } & ILanguagesConfigurationFragment)>;
                output?: Maybe<({
                    __typename?: 'Output';
                } & Pick<IOutput, 'maxChannelHistory'>)>;
                files?: Maybe<({
                    __typename?: 'Files';
                } & IFilesConfigurationFragment)>;
                git?: Maybe<({
                    __typename?: 'Git';
                } & IGitConfigurationFragment)>;
                workspace?: Maybe<({
                    __typename?: 'WorkspacePreferenceWorkbench';
                } & IWorkspaceConfigurationFragment)>;
            })>;
        });
    }) | ({
        __typename?: 'GlobalSettings';
    } & Pick<IGlobalSettings, 'id' | 'settingsURL'> & {
        latestSettings?: Maybe<({
            __typename?: 'Settings';
        } & Pick<ISettings, 'contents' | 'createdAt'>)>;
        settingsCascade: ({
            __typename?: 'SettingsCascade';
        } & {
            finalConfiguration?: Maybe<({
                __typename?: 'Configuration';
            } & {
                terminal?: Maybe<({
                    __typename?: 'Terminal';
                } & ITerminalConfigurationFragment)>;
                search?: Maybe<({
                    __typename?: 'Search';
                } & ISearchConfigurationFragment)>;
                languages?: Maybe<({
                    __typename?: 'Languages';
                } & ILanguagesConfigurationFragment)>;
                output?: Maybe<({
                    __typename?: 'Output';
                } & Pick<IOutput, 'maxChannelHistory'>)>;
                files?: Maybe<({
                    __typename?: 'Files';
                } & IFilesConfigurationFragment)>;
                git?: Maybe<({
                    __typename?: 'Git';
                } & IGitConfigurationFragment)>;
                workspace?: Maybe<({
                    __typename?: 'WorkspacePreferenceWorkbench';
                } & IWorkspaceConfigurationFragment)>;
            })>;
        });
    }) | {
        __typename?: 'WorkspaceSettings';
    } | {
        __typename?: 'MemorySettings';
    } | {
        __typename?: 'DefaultSettings';
    }>>>;
});
export declare type IWorkspaceConfigurationFragment = ({
    __typename?: 'WorkspacePreferenceWorkbench';
} & Pick<IWorkspacePreferenceWorkbench, 'colorTheme' | 'enableExperiments' | 'fontAliasing' | 'iconTheme' | 'startupEditor'> & {
    view?: Maybe<({
        __typename?: 'WorkspacePreferenceView';
    } & Pick<IWorkspacePreferenceView, 'alwaysShowHeaderActions'>)>;
    tips?: Maybe<({
        __typename?: 'WorkspacePreferenceTips';
    } & Pick<IWorkspacePreferenceTips, 'enabled' | 'horizontalScrolling' | 'indent' | 'renderIndentGuides'>)>;
    statusBar?: Maybe<({
        __typename?: 'WorkspacePreferenceStatusBar';
    } & Pick<IWorkspacePreferenceStatusBar, 'visible'>)>;
    settings?: Maybe<({
        __typename?: 'WorkspacePreferenceSettings';
    } & Pick<IWorkspacePreferenceSettings, 'editor' | 'enableNaturalLanguageSearch' | 'openDefaultKeybindings' | 'settingsSearchTocBehavior' | 'useSplitJSON'>)>;
    quickOpen?: Maybe<({
        __typename?: 'WorkspacePreferenceQuickOpen';
    } & Pick<IWorkspacePreferenceQuickOpen, 'closeOnFocusLost' | 'preserveInput'>)>;
    panel?: Maybe<({
        __typename?: 'WorkspacePreferencePanel';
    } & Pick<IWorkspacePreferencePanel, 'defaultLocation'>)>;
    list?: Maybe<({
        __typename?: 'WorkspacePreferenceList';
    } & Pick<IWorkspacePreferenceList, 'automaticKeyboardNavigation' | 'horizontalScrolling' | 'keyboardNavigation' | 'multiSelectModifier' | 'openMode'>)>;
    experimental?: Maybe<({
        __typename?: 'WorkspacePreferenceExperimental';
    } & Pick<IWorkspacePreferenceExperimental, 'editorAssociations'>)>;
    editor?: Maybe<({
        __typename?: 'WorkspacePreferenceEditor';
    } & Pick<IWorkspacePreferenceEditor, 'centeredLayoutAutoResize' | 'closeEmptyGroups' | 'closeOnFileDelete' | 'enablePreview' | 'enablePreviewFromQuickOpen' | 'focusRecentEditorAfterClose' | 'highlightModifiedTabs' | 'labelFormat' | 'openPositioning' | 'openSideBySideDirection' | 'restoreViewState' | 'revealIfOpen' | 'showIcons' | 'showTabs' | 'splitSizing' | 'tabCloseButton' | 'tabSizing'>)>;
    commandPalette?: Maybe<({
        __typename?: 'WorkspacePreferenceCommandPalette';
    } & Pick<IWorkspacePreferenceCommandPalette, 'history' | 'preserveInput'>)>;
    activityBar?: Maybe<({
        __typename?: 'WorkspacePreferenceActivityBar';
    } & Pick<IWorkspacePreferenceActivityBar, 'visible'>)>;
});
export declare type IGetConfigurationTargetMutationVariables = {
    resource?: Maybe<Scalars['URI']>;
};
export declare type IGetConfigurationTargetMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'getConfigurationTarget'>);
export declare type IOpenGlobalKeybindingsSettingsMutationVariables = {
    textual?: Maybe<Scalars['Boolean']>;
};
export declare type IOpenGlobalKeybindingsSettingsMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'openGlobalKeybindingSettings'>);
export declare type IOpenPreferenceSettingsMutationVariables = {
    jsonEditor?: Maybe<Scalars['Boolean']>;
    query?: Maybe<Scalars['String']>;
};
export declare type IOpenPreferenceSettingsMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'openPreferenceSettings'>);
export declare type IResetSettingMutationVariables = {
    resource?: Maybe<Scalars['URI']>;
    settingKey?: Maybe<Scalars['String']>;
};
export declare type IResetSettingMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'resetSetting'>);
export declare type IsaveUserSettingsMutationVariables = {
    content?: Maybe<Scalars['String']>;
};
export declare type IsaveUserSettingsMutation = ({
    __typename?: 'Mutation';
} & {
    saveUserSettings?: Maybe<({
        __typename?: 'SaveWorkspaceRes';
    } & Pick<ISaveWorkspaceRes, 'id'>)>;
});
export declare type IsaveWorkspaceSettingsMutationVariables = {};
export declare type IsaveWorkspaceSettingsMutation = ({
    __typename?: 'Mutation';
} & {
    saveWorkspaceSettings?: Maybe<({
        __typename?: 'SaveWorkspaceRes';
    } & Pick<ISaveWorkspaceRes, 'updated'>)>;
});
export declare type ISwitchSettingsMutationVariables = {
    target?: Maybe<Scalars['Int']>;
    editorId?: Maybe<Scalars['Int']>;
    resource?: Maybe<Scalars['URI']>;
    jsonEditor?: Maybe<Scalars['Boolean']>;
};
export declare type ISwitchSettingsMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'switchSettings'>);
export declare type IDefaultPreferencesQueryVariables = {};
export declare type IDefaultPreferencesQuery = ({
    __typename?: 'Query';
} & {
    defaultPreferences?: Maybe<({
        __typename?: 'DefaultPreferencesResponse';
    } & {
        preferences?: Maybe<Array<Maybe<({
            __typename?: 'PreferencesType';
        } & Pick<IPreferencesType, 'type'> & {
            data?: Maybe<Array<Maybe<({
                __typename?: 'Setting';
            } & Pick<ISetting, 'name' | 'type' | 'default' | 'description' | 'enum' | 'enumDescriptions'>)>>>;
        })>>>;
    })>;
});
export declare type IDefaultSettingsQueryVariables = {
    target?: Maybe<Scalars['Int']>;
};
export declare type IDefaultSettingsQuery = ({
    __typename?: 'Query';
} & {
    defaultViewerSettingsSubject: ({
        __typename?: 'DefaultSettings';
    } & {
        settingsCascade: ({
            __typename?: 'SettingsCascade';
        } & Pick<ISettingsCascade, 'final'> & {
            finalConfiguration?: Maybe<({
                __typename?: 'Configuration';
            } & {
                defaultSetting?: Maybe<Array<Maybe<({
                    __typename?: 'SettingsGroup';
                } & Pick<ISettingsGroup, 'title' | 'id'> & {
                    sections?: Maybe<Array<Maybe<({
                        __typename?: 'SettingsSection';
                    } & {
                        settings?: Maybe<Array<Maybe<({
                            __typename?: 'Setting';
                        } & IDefaultSettingFragment)>>>;
                    })>>>;
                })>>>;
            })>;
        });
    });
});
export declare type IFullConfigurationQueryVariables = {};
export declare type IFullConfigurationQuery = ({
    __typename?: 'Query';
} & {
    viewerSettings: ({
        __typename?: 'SettingsCascade';
    } & Pick<ISettingsCascade, 'final'> & {
        subjects?: Maybe<Array<Maybe<({
            __typename?: 'UserSettings';
        } & Pick<IUserSettings, 'id' | 'settingsURL'> & {
            latestSettings?: Maybe<({
                __typename?: 'Settings';
            } & Pick<ISettings, 'contents' | 'createdAt'>)>;
            settingsCascade: ({
                __typename?: 'SettingsCascade';
            } & {
                finalConfiguration?: Maybe<({
                    __typename?: 'Configuration';
                } & {
                    terminal?: Maybe<({
                        __typename?: 'Terminal';
                    } & ITerminalConfigurationFragment)>;
                    search?: Maybe<({
                        __typename?: 'Search';
                    } & ISearchConfigurationFragment)>;
                    languages?: Maybe<({
                        __typename?: 'Languages';
                    } & ILanguagesConfigurationFragment)>;
                    output?: Maybe<({
                        __typename?: 'Output';
                    } & Pick<IOutput, 'maxChannelHistory'>)>;
                    files?: Maybe<({
                        __typename?: 'Files';
                    } & IFilesConfigurationFragment)>;
                    git?: Maybe<({
                        __typename?: 'Git';
                    } & IGitConfigurationFragment)>;
                    workspace?: Maybe<({
                        __typename?: 'WorkspacePreferenceWorkbench';
                    } & IWorkspaceConfigurationFragment)>;
                })>;
            });
        }) | {
            __typename?: 'LocalUserSettings';
        } | {
            __typename?: 'RemoteUserSettings';
        } | ({
            __typename?: 'FolderSettings';
        } & Pick<IFolderSettings, 'id' | 'settingsURL'> & {
            latestSettings?: Maybe<({
                __typename?: 'Settings';
            } & Pick<ISettings, 'contents' | 'createdAt'>)>;
            settingsCascade: ({
                __typename?: 'SettingsCascade';
            } & {
                finalConfiguration?: Maybe<({
                    __typename?: 'Configuration';
                } & {
                    terminal?: Maybe<({
                        __typename?: 'Terminal';
                    } & ITerminalConfigurationFragment)>;
                    search?: Maybe<({
                        __typename?: 'Search';
                    } & ISearchConfigurationFragment)>;
                    languages?: Maybe<({
                        __typename?: 'Languages';
                    } & ILanguagesConfigurationFragment)>;
                    output?: Maybe<({
                        __typename?: 'Output';
                    } & Pick<IOutput, 'maxChannelHistory'>)>;
                    files?: Maybe<({
                        __typename?: 'Files';
                    } & IFilesConfigurationFragment)>;
                    git?: Maybe<({
                        __typename?: 'Git';
                    } & IGitConfigurationFragment)>;
                    workspace?: Maybe<({
                        __typename?: 'WorkspacePreferenceWorkbench';
                    } & IWorkspaceConfigurationFragment)>;
                })>;
            });
        }) | ({
            __typename?: 'GlobalSettings';
        } & Pick<IGlobalSettings, 'id' | 'settingsURL'> & {
            latestSettings?: Maybe<({
                __typename?: 'Settings';
            } & Pick<ISettings, 'contents' | 'createdAt'>)>;
            settingsCascade: ({
                __typename?: 'SettingsCascade';
            } & {
                finalConfiguration?: Maybe<({
                    __typename?: 'Configuration';
                } & {
                    terminal?: Maybe<({
                        __typename?: 'Terminal';
                    } & ITerminalConfigurationFragment)>;
                    search?: Maybe<({
                        __typename?: 'Search';
                    } & ISearchConfigurationFragment)>;
                    languages?: Maybe<({
                        __typename?: 'Languages';
                    } & ILanguagesConfigurationFragment)>;
                    output?: Maybe<({
                        __typename?: 'Output';
                    } & Pick<IOutput, 'maxChannelHistory'>)>;
                    files?: Maybe<({
                        __typename?: 'Files';
                    } & IFilesConfigurationFragment)>;
                    git?: Maybe<({
                        __typename?: 'Git';
                    } & IGitConfigurationFragment)>;
                    workspace?: Maybe<({
                        __typename?: 'WorkspacePreferenceWorkbench';
                    } & IWorkspaceConfigurationFragment)>;
                })>;
            });
        }) | ({
            __typename?: 'WorkspaceSettings';
        } & Pick<IWorkspaceSettings, 'id' | 'settingsURL'> & {
            latestSettings?: Maybe<({
                __typename?: 'Settings';
            } & Pick<ISettings, 'contents' | 'createdAt'>)>;
            settingsCascade: ({
                __typename?: 'SettingsCascade';
            } & {
                finalConfiguration?: Maybe<({
                    __typename?: 'Configuration';
                } & {
                    terminal?: Maybe<({
                        __typename?: 'Terminal';
                    } & ITerminalConfigurationFragment)>;
                    search?: Maybe<({
                        __typename?: 'Search';
                    } & ISearchConfigurationFragment)>;
                    languages?: Maybe<({
                        __typename?: 'Languages';
                    } & ILanguagesConfigurationFragment)>;
                    output?: Maybe<({
                        __typename?: 'Output';
                    } & Pick<IOutput, 'maxChannelHistory'>)>;
                    files?: Maybe<({
                        __typename?: 'Files';
                    } & IFilesConfigurationFragment)>;
                    git?: Maybe<({
                        __typename?: 'Git';
                    } & IGitConfigurationFragment)>;
                    workspace?: Maybe<({
                        __typename?: 'WorkspacePreferenceWorkbench';
                    } & IWorkspaceConfigurationFragment)>;
                })>;
            });
        }) | {
            __typename?: 'MemorySettings';
        } | {
            __typename?: 'DefaultSettings';
        }>>>;
    });
});
export declare type IGetMostCommonlyUsedSettingsQueryVariables = {};
export declare type IGetMostCommonlyUsedSettingsQuery = ({
    __typename?: 'Query';
} & Pick<IQuery, 'getMostCommonlyUsedSettings'>);
export declare type IWorkspacesQueryVariables = {};
export declare type IWorkspacesQuery = ({
    __typename?: 'Query';
} & {
    workspaces?: Maybe<Array<Maybe<({
        __typename?: 'WorkspaceRes';
    } & Pick<IWorkspaceRes, 'uri'>)>>>;
});
export declare type IAllContextFragment = ({
    __typename?: 'Context';
} & Pick<IContext, 'originalResourceScheme' | 'view' | 'viewItem' | 'gitOpenRepositoryCount' | 'isInDiffEditor' | 'isInDiffRightEditor' | 'resourceScheme' | 'resourceFilename' | 'resourceLangId' | 'resource' | 'resourceExtName' | 'resourceSet' | 'isFileSystemResource' | 'inputFocus' | 'suggestWidgetVisible' | 'suggestWidgetMultipleSuggestions' | 'suggestionMakesTextEdit' | 'acceptSuggestionOnEnter' | 'hasOtherSuggestions' | 'groupFocusedInOpenEditors' | 'dirtyEditor' | 'resourceSelectedForCompare' | 'fileCopied' | 'breadcrumbsPossible' | 'breadcrumbsVisible' | 'breadcrumbsActive' | 'canNavigateBack' | 'canNavigateForward' | 'canNavigateToLastEditLocation' | 'dirtyDiffVisible' | 'cancellableOperation' | 'parameterHintsVisible' | 'parameterHintsMultipleSignatures' | 'markdownPreviewFocus' | 'isMac' | 'isLinux' | 'isWindows' | 'remoteAuthority' | 'remoteConnectionState' | 'hasMacNativeTabs' | 'supportsWorkspaces' | 'isDevelopment' | 'workbenchState' | 'workspaceFolderCount' | 'remoteFileDialogVisible' | 'isFullscreen' | 'atEndOfWord' | 'scmRepository' | 'scmProvider' | 'scmResourceGroup' | 'inDiffEditorKey' | 'isDominatedByLongLines' | 'isWordWrapMinified' | 'commentThread' | 'commentThreadisEmpty' | 'commentIsEmpty' | 'commentEditorFocused' | 'interfaceOverviewVisible' | 'inReferenceSearchEditor' | 'referenceSearchVisible' | 'listFocus' | 'listSupportsMultiSelect' | 'listHasSelectionOrFocus' | 'listDoubleSelection' | 'listMultiSelection' | 'listSupportsKeyboardNavigation' | 'WorkbenchListAutomaticKeyboardNavigationKey' | 'accessibilityHelpWidgetVisible' | 'inQuickOpenKey' | 'supportedCodeAction' | 'hasSymbols' | 'hasSnippetCompletions' | 'messageVisible' | 'editorHasCallHierarchyProvider' | 'callHierarchyVisible' | 'searchViewletVisible' | 'searchViewletFocus' | 'inputBoxFocus' | 'searchInputBoxFocus' | 'replaceInputBoxFocus' | 'patternIncludesInputBoxFocus' | 'patternExcludesInputBoxFocus' | 'replaceActive' | 'hasSearchResult' | 'firstMatchFocus' | 'fileMatchOrMatchFocus' | 'fileMatchOrFolderMatchFocus' | 'fileMatchFocus' | 'folderMatchFocus' | 'matchFocus' | 'inRecentFilesPicker' | 'inWindowsPicker' | 'findWidgetVisible' | 'findInputFocussed' | 'replaceInputFocussed' | 'editorTextFocus' | 'editorFocus' | 'textInputFocus' | 'editorReadonly' | 'editorHasSelection' | 'editorHasMultipleSelections' | 'editorTabMoveFocus' | 'isInEmbeddedEditor' | 'canUndo' | 'canRedo' | 'editorLangId' | 'editorHasCompletionItemProvider' | 'editorHasCodeActionsProvider' | 'editorHasDefinitionProvider' | 'editorHasDeclarationProvider' | 'editorHasImplementationProvider' | 'editorHasTypeDefinitionProvider' | 'editorHasHoverProvider' | 'editorHadDocumentHighlightProvider' | 'editorHasDocumentSymbolProvider' | 'editorHasReferenceProvider' | 'editorHasRenameProvider' | 'editorHasSignatureHelpProvider' | 'editorHasDocumentFormattingProvider' | 'editorHasDocumentSelectionFormattingProvider' | 'editorHasMultipleDocumentSelectionFormattingProvider' | 'activeEditor' | 'editorIsOpen' | 'editorPinned' | 'groupActiveEditorDirty' | 'groupEditorsCount' | 'textCompareEditorVisible' | 'textCompareEditorActive' | 'activeEditorGroupEmpty' | 'multipleEditorGroups' | 'inZenMode' | 'inCenteredLayout' | 'splitEditorsVertically' | 'sideBarVisible' | 'sideBarFocus' | 'activeViewlet' | 'activePanel' | 'panelFocus' | 'panelPosition' | 'debugType' | 'debugConfigurationType' | 'debugState' | 'inDebugMode' | 'inDebugRepl' | 'breakpointWidgetVisible' | 'watchExpressionsFocused' | 'variablesFocused' | 'expressionSelected' | 'breakpointSelected' | 'callStackItemType' | 'loadedScriptsSupported' | 'loadedScriptsItemType' | 'focusedSessionIsAttach' | 'stepBackSupported' | 'restartFrameSupported' | 'inSettingsEditor' | 'inSettingsJSONEditor' | 'inSettingsSearch' | 'settingsTocRowFocus' | 'inKeybindings' | 'inKeybindingsSearch' | 'keybindingFocus' | 'explorerViewletVisible' | 'explorerResourceIsFolder' | 'explorerResourceReadonly' | 'explorerResourceIsRoot' | 'explorerResourceCut' | 'explorerResourceMoveableToTrash' | 'filesExplorerFocus' | 'openEditorsVisible' | 'openEditorsFocus' | 'explorerViewletFocus' | 'terminalIsOpen' | 'terminalFocus' | 'terminalTextSelected' | 'terminalFindWidgetVisible' | 'terminalFindWidgetInputFocused' | 'terminalFindWidgetFocused' | 'webviewFindWidgetVisible' | 'taskRunning' | 'referenceSearchTreeFocused' | 'interactivePlaygroundFocus' | 'outlineFiltered' | 'outlineFocused' | 'problemsViewFocus' | 'problemFocus' | 'problemsFilterFocus' | 'relatedInformationFocus' | 'inOutput' | 'activeLogOutput' | 'multiCursorModifier' | 'saveConflictResolutionContext' | 'markersNavigationVisible' | 'hasWordHighlights' | 'profileSessionState' | 'extensionHostProfileRecorded' | 'historyNavigationEnabled' | 'historyNavigationWidget' | 'nonEmptyWorkspace' | 'defaultExtensionViews' | 'searchMarketplaceExtensions' | 'searchInstalledExtensions' | 'searchOutdatedExtensions' | 'searchEnabledExtensions' | 'searchDisabledExtensions' | 'hasInstalledExtensions' | 'searchBuiltInExtensions' | 'recommendedExtensions' | 'defaultRecommendedExtensions' | 'workspaceRecommendations' | 'workspaceFolderRecommendations' | 'addToWorkspaceRecommendations' | 'addToWorkspaceFolderRecommendations'>);
export declare type IFinalConfigurationFragment = ({
    __typename?: 'Configuration';
} & {
    terminal?: Maybe<({
        __typename?: 'Terminal';
    } & ITerminalConfigurationFragment)>;
    search?: Maybe<({
        __typename?: 'Search';
    } & ISearchConfigurationFragment)>;
    languages?: Maybe<({
        __typename?: 'Languages';
    } & ILanguagesConfigurationFragment)>;
    output?: Maybe<({
        __typename?: 'Output';
    } & Pick<IOutput, 'maxChannelHistory'>)>;
    files?: Maybe<({
        __typename?: 'Files';
    } & IFilesConfigurationFragment)>;
    git?: Maybe<({
        __typename?: 'Git';
    } & IGitConfigurationFragment)>;
    workspace?: Maybe<({
        __typename?: 'WorkspacePreferenceWorkbench';
    } & IWorkspaceConfigurationFragment)>;
});
export declare type IKeybindingItemFragment = ({
    __typename?: 'KeybindingItem';
} & Pick<IKeybindingItem, 'command' | 'key' | 'when' | 'source'>);
export declare type IKeybindingsFragment = ({
    __typename?: 'Keybindings';
} & {
    items?: Maybe<Array<Maybe<({
        __typename?: 'KeybindingItem';
    } & Pick<IKeybindingItem, 'command' | 'key' | 'when' | 'source'>)>>>;
});
export declare type IpickItemFragment = ({
    __typename?: 'QuickPickItem';
} & Pick<IQuickPickItem, 'id' | 'label' | 'description' | 'detail' | 'italic' | 'picked' | 'alwaysShow'> & {
    keybinding?: Maybe<({
        __typename?: 'KeybindingItem';
    } & Pick<IKeybindingItem, 'command' | 'key' | 'when' | 'source'>)>;
    highlights?: Maybe<({
        __typename?: 'QuickPickItemHighlights';
    } & {
        label?: Maybe<Array<Maybe<({
            __typename?: 'Match';
        } & Pick<IMatch, 'start' | 'end'>)>>>;
        description?: Maybe<Array<Maybe<({
            __typename?: 'Match';
        } & Pick<IMatch, 'start' | 'end'>)>>>;
        detail?: Maybe<Array<Maybe<({
            __typename?: 'Match';
        } & Pick<IMatch, 'start' | 'end'>)>>>;
    })>;
});
export declare type IselectedFragment = ({
    __typename?: 'QuickInputModel';
} & Pick<IQuickInputModel, 'title' | 'inputValue'> & {
    selectedValue?: Maybe<Array<Maybe<({
        __typename?: 'QuickPickItem';
    } & IpickItemFragment)>>>;
});
export declare type IResourceContextFragment = ({
    __typename?: 'Context';
} & Pick<IContext, 'resourceScheme' | 'resourceFilename' | 'resource' | 'resourceExtName' | 'resourceSet' | 'isFileSystemResource'>);
declare type IstatusbarItem_Terminal_Fragment = ({
    __typename?: 'Terminal';
} & Pick<ITerminal, 'name' | 'alignment' | 'priority'> & {
    entry?: Maybe<({
        __typename?: 'StatusbarEntry';
    } & Pick<IStatusbarEntry, 'showTabsButtons' | 'showIcons' | 'showStatusbar' | 'text' | 'ariaLabel' | 'tooltip' | 'color' | 'backgroundColor' | 'command' | 'arguments' | 'showBeak'>)>;
});
declare type IstatusbarItem_SelectionStatus_Fragment = ({
    __typename?: 'SelectionStatus';
} & Pick<ISelectionStatus, 'name' | 'alignment' | 'priority'> & {
    entry?: Maybe<({
        __typename?: 'StatusbarEntry';
    } & Pick<IStatusbarEntry, 'showTabsButtons' | 'showIcons' | 'showStatusbar' | 'text' | 'ariaLabel' | 'tooltip' | 'color' | 'backgroundColor' | 'command' | 'arguments' | 'showBeak'>)>;
});
declare type IstatusbarItem_Indentation_Fragment = ({
    __typename?: 'Indentation';
} & Pick<IIndentation, 'name' | 'alignment' | 'priority'> & {
    entry?: Maybe<({
        __typename?: 'StatusbarEntry';
    } & Pick<IStatusbarEntry, 'showTabsButtons' | 'showIcons' | 'showStatusbar' | 'text' | 'ariaLabel' | 'tooltip' | 'color' | 'backgroundColor' | 'command' | 'arguments' | 'showBeak'>)>;
});
declare type IstatusbarItem_EncodingStatus_Fragment = ({
    __typename?: 'EncodingStatus';
} & Pick<IEncodingStatus, 'name' | 'alignment' | 'priority'> & {
    entry?: Maybe<({
        __typename?: 'StatusbarEntry';
    } & Pick<IStatusbarEntry, 'showTabsButtons' | 'showIcons' | 'showStatusbar' | 'text' | 'ariaLabel' | 'tooltip' | 'color' | 'backgroundColor' | 'command' | 'arguments' | 'showBeak'>)>;
});
declare type IstatusbarItem_EndOfLineSequence_Fragment = ({
    __typename?: 'EndOfLineSequence';
} & Pick<IEndOfLineSequence, 'name' | 'alignment' | 'priority'> & {
    entry?: Maybe<({
        __typename?: 'StatusbarEntry';
    } & Pick<IStatusbarEntry, 'showTabsButtons' | 'showIcons' | 'showStatusbar' | 'text' | 'ariaLabel' | 'tooltip' | 'color' | 'backgroundColor' | 'command' | 'arguments' | 'showBeak'>)>;
});
declare type IstatusbarItem_LanguageMode_Fragment = ({
    __typename?: 'LanguageMode';
} & Pick<ILanguageMode, 'name' | 'alignment' | 'priority'> & {
    entry?: Maybe<({
        __typename?: 'StatusbarEntry';
    } & Pick<IStatusbarEntry, 'showTabsButtons' | 'showIcons' | 'showStatusbar' | 'text' | 'ariaLabel' | 'tooltip' | 'color' | 'backgroundColor' | 'command' | 'arguments' | 'showBeak'>)>;
});
declare type IstatusbarItem_SyncStatus_Fragment = {
    __typename?: 'SyncStatus';
};
declare type IstatusbarItem_BranchStatus_Fragment = {
    __typename?: 'BranchStatus';
};
export declare type IstatusbarItemFragment = IstatusbarItem_Terminal_Fragment | IstatusbarItem_SelectionStatus_Fragment | IstatusbarItem_Indentation_Fragment | IstatusbarItem_EncodingStatus_Fragment | IstatusbarItem_EndOfLineSequence_Fragment | IstatusbarItem_LanguageMode_Fragment | IstatusbarItem_SyncStatus_Fragment | IstatusbarItem_BranchStatus_Fragment;
export declare type IUpdateConfigurationValueMutationVariables = {
    key: Scalars['String'];
    value: Scalars['AnyObject'];
    overrides: IConfigurationOverrides_Input;
    target?: Maybe<Scalars['Int']>;
    donotNotifyError?: Maybe<Scalars['Boolean']>;
};
export declare type IUpdateConfigurationValueMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'updateConfigurationValue'>);
export declare type ICopyMutationVariables = {
    value?: Maybe<Scalars['String']>;
};
export declare type ICopyMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'copy'>);
export declare type IRunMenuActionMutationVariables = {
    argument?: Maybe<IActionRun_input>;
};
export declare type IRunMenuActionMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'runMenuAction'>);
export declare type IHideContextMenuMutationVariables = {};
export declare type IHideContextMenuMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'hideContextMenu'>);
export declare type IShowContextMenuMutationVariables = {
    delegate?: Maybe<IContextMenu_input>;
};
export declare type IShowContextMenuMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'showContextMenu'>);
export declare type ICloseDialogMutationVariables = {};
export declare type ICloseDialogMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'closeDialog'>);
export declare type IShowMutationVariables = {
    dialog?: Maybe<IDialog_input>;
};
export declare type IShowMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'show'>);
export declare type IOpenEditorResourceInputMutationVariables = {
    editor: IResource_Input;
    group?: Maybe<Scalars['Int']>;
};
export declare type IOpenEditorResourceInputMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'openEditorWithResourceInput'>);
export declare type IOpenEditorMutationVariables = {
    content: IOpenEditor_Input;
    options?: Maybe<IEditorOpenOptions_Input>;
};
export declare type IOpenEditorMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'openEditor'>);
export declare type IGoToLineMutationVariables = {
    range?: Maybe<ILineRange_input>;
};
export declare type IGoToLineMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'gotoLine'>);
export declare type IHighlightLineMutationVariables = {
    range?: Maybe<ILineRange_input>;
};
export declare type IHighlightLineMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'highlightLine'>);
export declare type IJsonEditingWriteMutationVariables = {
    resource?: Maybe<Scalars['URI']>;
    value?: Maybe<IIJSONValue_input>;
    save?: Maybe<Scalars['Boolean']>;
};
export declare type IJsonEditingWriteMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'jsonWrite'>);
export declare type IChangeKeybindingMutationVariables = {
    editItem?: Maybe<IKeybindingItem_input>;
    selectedIndex?: Maybe<Scalars['Int']>;
    isOpenDialog?: Maybe<Scalars['Boolean']>;
};
export declare type IChangeKeybindingMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'changeKeybinding'>);
export declare type IChangeWhenExpressionMutationVariables = {
    editItem?: Maybe<IKeybindingItem_input>;
    editWhenIndex?: Maybe<Scalars['Int']>;
    newWhen?: Maybe<Scalars['String']>;
};
export declare type IChangeWhenExpressionMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'changeWhenExpression'>);
export declare type IEditKeybindingMutationVariables = {
    keybindingItem?: Maybe<IKeybindingItem_input>;
    key?: Maybe<Scalars['String']>;
    when?: Maybe<Scalars['String']>;
};
export declare type IEditKeybindingMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'editKeybinding'>);
export declare type IHideKeybindingDialogMutationVariables = {};
export declare type IHideKeybindingDialogMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'hideKeybindingDialog'>);
export declare type ILookupKeybindingMutationVariables = {
    commandId?: Maybe<Scalars['String']>;
};
export declare type ILookupKeybindingMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'lookupKeybinding'>);
export declare type IregisterKeybindingMutationVariables = {
    keybinding?: Maybe<IKeybinding_input>;
};
export declare type IregisterKeybindingMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'registerKeybinding'>);
export declare type IRemoveKeybindingMutationVariables = {
    keybindingItem?: Maybe<IKeybindingItem_input>;
};
export declare type IRemoveKeybindingMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'removeKeybinding'>);
export declare type IResetKeybindingMutationVariables = {
    keybindingItem?: Maybe<IKeybindingItem_input>;
};
export declare type IResetKeybindingMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'resetKeybinding'>);
export declare type IResolveKeyboardEventMutationVariables = {
    keyboardEvent?: Maybe<IKeyboardEvent_input>;
};
export declare type IResolveKeyboardEventMutation = ({
    __typename?: 'Mutation';
} & {
    resolveKeyboardEvent?: Maybe<({
        __typename?: 'KeyboardEvent_output';
    } & Pick<IKeyboardEvent_output, 'label' | 'key'>)>;
});
export declare type ISearchKeybindingMutationVariables = {
    value?: Maybe<Scalars['String']>;
};
export declare type ISearchKeybindingMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'searchKeybinding'>);
export declare type ISetSelectedKeybindingIndexMutationVariables = {
    index?: Maybe<Scalars['Int']>;
};
export declare type ISetSelectedKeybindingIndexMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'setSelectedKeybindingIndex'>);
export declare type IStopEditWhenExpressionMutationVariables = {};
export declare type IStopEditWhenExpressionMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'stopEditWhenExpression'>);
export declare type IAddNotificationMutationVariables = {
    notification?: Maybe<INotification_input>;
};
export declare type IAddNotificationMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'addNotification'>);
export declare type ICloseNotificationMutationVariables = {
    index?: Maybe<Scalars['Int']>;
};
export declare type ICloseNotificationMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'closeNotification'>);
export declare type IHandlerMutationVariables = {
    arg?: Maybe<IActionRun_input>;
};
export declare type IHandlerMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'handler'>);
export declare type IOpenEditorFileMutationVariables = {
    content: IOpenEditor_Input;
    options?: Maybe<IEditorOpenOptions_Input>;
};
export declare type IOpenEditorFileMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'openFile'>);
export declare type IHideInputModelMutationVariables = {};
export declare type IHideInputModelMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'hideInputModel'>);
export declare type ISetSelectedMutationVariables = {
    selectedValue?: Maybe<Array<Maybe<IPickItem>>>;
    inputValue?: Maybe<Scalars['String']>;
};
export declare type ISetSelectedMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'setSelected'>);
export declare type IShowInputMutationVariables = {
    options?: Maybe<IInputOptions>;
};
export declare type IShowInputMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'showInput'>);
export declare type IShowPickInputMutationVariables = {
    items?: Maybe<Array<Maybe<IPickItem>>>;
    options?: Maybe<IPickInputOptions>;
};
export declare type IShowPickInputMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'showPickInput'>);
export declare type IAddEntryMutationVariables = {
    arg?: Maybe<IAddEntry_input>;
};
export declare type IAddEntryMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'addEntry'>);
export declare type IRemoveStatusbarEntryMutationVariables = {
    id: Scalars['ID'];
};
export declare type IRemoveStatusbarEntryMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'removeStatusbarEntry'>);
export declare type ISetStatusMessageMutationVariables = {
    arg?: Maybe<ISetStatusMsg_input>;
};
export declare type ISetStatusMessageMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'setStatusMessage'>);
export declare type IUpdateStatusbarEntryMutationVariables = {
    arg?: Maybe<IUpdateEntry_input>;
};
export declare type IUpdateStatusbarEntryMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'updateStatusbarEntry'>);
export declare type IAddFoldersMutationVariables = {
    folders?: Maybe<Array<Maybe<IFolder_input>>>;
    index?: Maybe<Scalars['Int']>;
};
export declare type IAddFoldersMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'addFolders'>);
export declare type IChangeWorkspaceMutationVariables = {
    args?: Maybe<IArgs_input>;
};
export declare type IChangeWorkspaceMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'changeWorkspace'>);
export declare type IRemoveFoldersMutationVariables = {
    folders?: Maybe<Array<Maybe<Scalars['URI']>>>;
};
export declare type IRemoveFoldersMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'removeFolders'>);
export declare type IUpdateFoldersMutationVariables = {
    foldersToAdd?: Maybe<Array<Maybe<IFolder_input>>>;
    foldersToRemove?: Maybe<Array<Maybe<Scalars['URI']>>>;
    index?: Maybe<Scalars['Int']>;
};
export declare type IUpdateFoldersMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'updateFolders'>);
export declare type IFinalConfiguration_WSQueryVariables = {};
export declare type IFinalConfiguration_WSQuery = ({
    __typename?: 'Query';
} & {
    viewerSettings: ({
        __typename?: 'SettingsCascade';
    } & {
        finalConfiguration?: Maybe<({
            __typename?: 'Configuration';
        } & IFinalConfigurationFragment)>;
    });
});
export declare type IGetContextQueryVariables = {};
export declare type IGetContextQuery = ({
    __typename?: 'Query';
} & {
    getContextData?: Maybe<({
        __typename?: 'Context';
    } & IAllContextFragment)>;
});
export declare type IContextMenuQueryVariables = {};
export declare type IContextMenuQuery = ({
    __typename?: 'Query';
} & {
    contextMenu?: Maybe<({
        __typename?: 'ContextMenu';
    } & Pick<IContextMenu, 'id' | 'isShow'> & {
        anchor?: Maybe<({
            __typename?: 'Anchor';
        } & Pick<IAnchor, 'x' | 'y' | 'height' | 'width'>)>;
        menuItems?: Maybe<Array<Maybe<({
            __typename?: 'MenuItem';
        } & Pick<IMenuItem, 'id' | 'label' | 'enabled'> & {
            run?: Maybe<({
                __typename?: 'ActionRun';
            } & Pick<IActionRun, 'type' | 'document' | 'variables'>)>;
        })>>>;
    })>;
});
export declare type IDialogQueryVariables = {};
export declare type IDialogQuery = ({
    __typename?: 'Query';
} & {
    dialog?: Maybe<({
        __typename?: 'Dialog';
    } & Pick<IDialog, 'dialogType' | 'secondaryButton'> & {
        detail?: Maybe<Array<Maybe<({
            __typename?: 'Detail';
        } & Pick<IDetail, 'inputName' | 'label' | 'placeholder' | 'defaultValue' | 'required'> & {
            inputType?: Maybe<({
                __typename?: 'InputTypeDetail';
            } & Pick<IInputTypeDetail, 'type' | 'options'>)>;
        })>>>;
        primaryButton?: Maybe<({
            __typename?: 'PrimaryButtonAction';
        } & Pick<IPrimaryButtonAction, 'label'> & {
            run?: Maybe<({
                __typename?: 'ActionRun';
            } & Pick<IActionRun, 'type' | 'document' | 'variables'>)>;
        })>;
        checkbox?: Maybe<({
            __typename?: 'CheckboxOptions';
        } & Pick<ICheckboxOptions, 'label' | 'checked'>)>;
    })>;
});
export declare type IshowDialogQueryVariables = {
    dialog?: Maybe<IDialog_input>;
};
export declare type IshowDialogQuery = ({
    __typename?: 'Query';
} & {
    showDialog?: Maybe<({
        __typename?: 'DialogResult';
    } & Pick<IDialogResult, 'confirmed' | 'checkboxChecked'>)>;
});
export declare type IGoToLineQuickAccessQueryVariables = {};
export declare type IGoToLineQuickAccessQuery = ({
    __typename?: 'Query';
} & {
    gotoLineQuickAccess?: Maybe<({
        __typename?: 'GoToLineQuickAccess';
    } & Pick<IGoToLineQuickAccess, 'highlight' | 'focus'> & {
        range?: Maybe<({
            __typename?: 'LineRange';
        } & Pick<ILineRange, 'startLine' | 'startColumn' | 'endLine' | 'endColumn'>)>;
    })>;
});
export declare type IGetKeybindingsQueryVariables = {};
export declare type IGetKeybindingsQuery = ({
    __typename?: 'Query';
} & {
    getKeybindings?: Maybe<({
        __typename?: 'Keybindings';
    } & {
        items?: Maybe<Array<Maybe<({
            __typename?: 'KeybindingItem';
        } & Pick<IKeybindingItem, 'command' | 'key' | 'when' | 'source'>)>>>;
    })>;
});
export declare type IKeybindingContextMenuQueryVariables = {};
export declare type IKeybindingContextMenuQuery = ({
    __typename?: 'Query';
} & {
    keybindingContextMenu?: Maybe<({
        __typename?: 'KeybindingContextMenu';
    } & Pick<IKeybindingContextMenu, 'selectedItemIndex' | 'editWhenIndex' | 'newWhen' | 'isOpenDialog' | 'search'> & {
        editItem?: Maybe<({
            __typename?: 'EditKeybindingItem';
        } & Pick<IEditKeybindingItem, 'command' | 'key' | 'when' | 'isDefault'>)>;
    })>;
});
export declare type IKeybindingsQueryVariables = {};
export declare type IKeybindingsQuery = ({
    __typename?: 'Query';
} & {
    keybindings?: Maybe<({
        __typename?: 'Keybindings';
    } & {
        items?: Maybe<Array<Maybe<({
            __typename?: 'KeybindingItem';
        } & Pick<IKeybindingItem, 'command' | 'key' | 'when' | 'source'>)>>>;
    })>;
});
export declare type INotificationsQueryVariables = {};
export declare type INotificationsQuery = ({
    __typename?: 'Query';
} & {
    notifications?: Maybe<({
        __typename?: 'Notifications';
    } & {
        notifications?: Maybe<Array<Maybe<({
            __typename?: 'Notification';
        } & Pick<INotification, 'index' | 'severity' | 'message' | 'sticky'> & {
            actions?: Maybe<({
                __typename?: 'NotificationActions';
            } & {
                primary?: Maybe<Array<Maybe<({
                    __typename?: 'Action';
                } & Pick<IAction, 'id' | 'label' | 'tooltip' | 'class' | 'enabled' | 'checked' | 'radio'> & {
                    run?: Maybe<({
                        __typename?: 'ActionRun';
                    } & Pick<IActionRun, 'type' | 'document' | 'variables'>)>;
                })>>>;
                secondary?: Maybe<Array<Maybe<({
                    __typename?: 'Action';
                } & Pick<IAction, 'id' | 'label' | 'tooltip' | 'class' | 'enabled' | 'checked' | 'radio'> & {
                    run?: Maybe<({
                        __typename?: 'ActionRun';
                    } & Pick<IActionRun, 'type' | 'document' | 'variables'>)>;
                })>>>;
            })>;
        })>>>;
    })>;
});
export declare type IshowNotificationQueryVariables = {
    notification?: Maybe<INotification_input>;
};
export declare type IshowNotificationQuery = ({
    __typename?: 'Query';
} & Pick<IQuery, 'showNotification'>);
export declare type IGetSelectedValueQueryVariables = {};
export declare type IGetSelectedValueQuery = ({
    __typename?: 'Query';
} & {
    quickInputModel?: Maybe<({
        __typename?: 'QuickInputModel';
    } & Pick<IQuickInputModel, 'title' | 'inputValue'> & {
        selectedValue?: Maybe<Array<Maybe<({
            __typename?: 'QuickPickItem';
        } & IpickItemFragment)>>>;
    })>;
});
export declare type IQuickInputModelQueryVariables = {};
export declare type IQuickInputModelQuery = ({
    __typename?: 'Query';
} & {
    quickInputModel?: Maybe<({
        __typename?: 'QuickInputModel';
    } & Pick<IQuickInputModel, 'show'> & {
        input?: Maybe<({
            __typename?: 'QuickInput';
        } & Pick<IQuickInput, 'title' | 'description' | 'enabled' | 'ignoreFocusOut' | 'value' | 'placeholder' | 'prompt' | 'validationMessage'>)>;
        quickPick?: Maybe<({
            __typename?: 'QuickPick';
        } & Pick<IQuickPick, 'placeholder' | 'canSelectMany' | 'autoFocusOnList'> & {
            items?: Maybe<Array<Maybe<({
                __typename?: 'QuickPickItem';
            } & IpickItemFragment)>>>;
            activeItem?: Maybe<({
                __typename?: 'QuickPickItem';
            } & IpickItemFragment)>;
            selectedItems?: Maybe<Array<Maybe<({
                __typename?: 'QuickPickItem';
            } & IpickItemFragment)>>>;
        })>;
    })>;
});
export declare type IStatusbarQueryVariables = {};
export declare type IStatusbarQuery = ({
    __typename?: 'Query';
} & {
    statusbar?: Maybe<({
        __typename?: 'Statusbar';
    } & {
        items?: Maybe<Array<Maybe<({
            __typename?: 'Terminal';
        } & Pick<ITerminal, 'id' | 'name' | 'alignment' | 'priority' | 'typeId'> & {
            entry?: Maybe<({
                __typename?: 'StatusbarEntry';
            } & Pick<IStatusbarEntry, 'showTabsButtons' | 'showIcons' | 'showStatusbar' | 'text' | 'ariaLabel' | 'tooltip' | 'color' | 'backgroundColor' | 'command' | 'arguments' | 'showBeak'>)>;
        }) | ({
            __typename?: 'SelectionStatus';
        } & Pick<ISelectionStatus, 'id' | 'name' | 'alignment' | 'priority' | 'typeId'> & {
            entry?: Maybe<({
                __typename?: 'StatusbarEntry';
            } & Pick<IStatusbarEntry, 'showTabsButtons' | 'showIcons' | 'showStatusbar' | 'text' | 'ariaLabel' | 'tooltip' | 'color' | 'backgroundColor' | 'command' | 'arguments' | 'showBeak'>)>;
        }) | ({
            __typename?: 'Indentation';
        } & Pick<IIndentation, 'id' | 'name' | 'alignment' | 'priority' | 'typeId'> & {
            entry?: Maybe<({
                __typename?: 'StatusbarEntry';
            } & Pick<IStatusbarEntry, 'showTabsButtons' | 'showIcons' | 'showStatusbar' | 'text' | 'ariaLabel' | 'tooltip' | 'color' | 'backgroundColor' | 'command' | 'arguments' | 'showBeak'>)>;
        }) | ({
            __typename?: 'EncodingStatus';
        } & Pick<IEncodingStatus, 'id' | 'name' | 'alignment' | 'priority' | 'typeId'> & {
            entry?: Maybe<({
                __typename?: 'StatusbarEntry';
            } & Pick<IStatusbarEntry, 'showTabsButtons' | 'showIcons' | 'showStatusbar' | 'text' | 'ariaLabel' | 'tooltip' | 'color' | 'backgroundColor' | 'command' | 'arguments' | 'showBeak'>)>;
        }) | ({
            __typename?: 'EndOfLineSequence';
        } & Pick<IEndOfLineSequence, 'id' | 'name' | 'alignment' | 'priority' | 'typeId'> & {
            entry?: Maybe<({
                __typename?: 'StatusbarEntry';
            } & Pick<IStatusbarEntry, 'showTabsButtons' | 'showIcons' | 'showStatusbar' | 'text' | 'ariaLabel' | 'tooltip' | 'color' | 'backgroundColor' | 'command' | 'arguments' | 'showBeak'>)>;
        }) | ({
            __typename?: 'LanguageMode';
        } & Pick<ILanguageMode, 'id' | 'name' | 'alignment' | 'priority' | 'typeId'> & {
            entry?: Maybe<({
                __typename?: 'StatusbarEntry';
            } & Pick<IStatusbarEntry, 'showTabsButtons' | 'showIcons' | 'showStatusbar' | 'text' | 'ariaLabel' | 'tooltip' | 'color' | 'backgroundColor' | 'command' | 'arguments' | 'showBeak'>)>;
        }) | ({
            __typename?: 'SyncStatus';
        } & Pick<ISyncStatus, 'id' | 'name' | 'alignment' | 'priority' | 'typeId'> & {
            entry?: Maybe<({
                __typename?: 'StatusbarEntry';
            } & Pick<IStatusbarEntry, 'showTabsButtons' | 'showIcons' | 'showStatusbar' | 'text' | 'ariaLabel' | 'tooltip' | 'color' | 'backgroundColor' | 'command' | 'arguments' | 'showBeak'>)>;
        }) | ({
            __typename?: 'BranchStatus';
        } & Pick<IBranchStatus, 'id' | 'name' | 'alignment' | 'priority' | 'typeId'> & {
            entry?: Maybe<({
                __typename?: 'StatusbarEntry';
            } & Pick<IStatusbarEntry, 'showTabsButtons' | 'showIcons' | 'showStatusbar' | 'text' | 'ariaLabel' | 'tooltip' | 'color' | 'backgroundColor' | 'command' | 'arguments' | 'showBeak'>)>;
        })>>>;
    })>;
});
export declare type IStatusbarItemQueryVariables = {
    id?: Maybe<Scalars['String']>;
};
export declare type IStatusbarItemQuery = ({
    __typename?: 'Query';
} & {
    statusbarItem?: Maybe<({
        __typename?: 'Terminal';
    } & Pick<ITerminal, 'id' | 'name' | 'alignment' | 'priority' | 'typeId'> & {
        entry?: Maybe<({
            __typename?: 'StatusbarEntry';
        } & Pick<IStatusbarEntry, 'showTabsButtons' | 'showIcons' | 'showStatusbar' | 'text' | 'ariaLabel' | 'tooltip' | 'color' | 'backgroundColor' | 'command' | 'arguments' | 'showBeak'>)>;
    }) | ({
        __typename?: 'SelectionStatus';
    } & Pick<ISelectionStatus, 'id' | 'name' | 'alignment' | 'priority' | 'typeId'> & {
        entry?: Maybe<({
            __typename?: 'StatusbarEntry';
        } & Pick<IStatusbarEntry, 'showTabsButtons' | 'showIcons' | 'showStatusbar' | 'text' | 'ariaLabel' | 'tooltip' | 'color' | 'backgroundColor' | 'command' | 'arguments' | 'showBeak'>)>;
    }) | ({
        __typename?: 'Indentation';
    } & Pick<IIndentation, 'id' | 'name' | 'alignment' | 'priority' | 'typeId'> & {
        entry?: Maybe<({
            __typename?: 'StatusbarEntry';
        } & Pick<IStatusbarEntry, 'showTabsButtons' | 'showIcons' | 'showStatusbar' | 'text' | 'ariaLabel' | 'tooltip' | 'color' | 'backgroundColor' | 'command' | 'arguments' | 'showBeak'>)>;
    }) | ({
        __typename?: 'EncodingStatus';
    } & Pick<IEncodingStatus, 'id' | 'name' | 'alignment' | 'priority' | 'typeId'> & {
        entry?: Maybe<({
            __typename?: 'StatusbarEntry';
        } & Pick<IStatusbarEntry, 'showTabsButtons' | 'showIcons' | 'showStatusbar' | 'text' | 'ariaLabel' | 'tooltip' | 'color' | 'backgroundColor' | 'command' | 'arguments' | 'showBeak'>)>;
    }) | ({
        __typename?: 'EndOfLineSequence';
    } & Pick<IEndOfLineSequence, 'id' | 'name' | 'alignment' | 'priority' | 'typeId'> & {
        entry?: Maybe<({
            __typename?: 'StatusbarEntry';
        } & Pick<IStatusbarEntry, 'showTabsButtons' | 'showIcons' | 'showStatusbar' | 'text' | 'ariaLabel' | 'tooltip' | 'color' | 'backgroundColor' | 'command' | 'arguments' | 'showBeak'>)>;
    }) | ({
        __typename?: 'LanguageMode';
    } & Pick<ILanguageMode, 'id' | 'name' | 'alignment' | 'priority' | 'typeId'> & {
        entry?: Maybe<({
            __typename?: 'StatusbarEntry';
        } & Pick<IStatusbarEntry, 'showTabsButtons' | 'showIcons' | 'showStatusbar' | 'text' | 'ariaLabel' | 'tooltip' | 'color' | 'backgroundColor' | 'command' | 'arguments' | 'showBeak'>)>;
    }) | ({
        __typename?: 'SyncStatus';
    } & Pick<ISyncStatus, 'id' | 'name' | 'alignment' | 'priority' | 'typeId'> & {
        entry?: Maybe<({
            __typename?: 'StatusbarEntry';
        } & Pick<IStatusbarEntry, 'showTabsButtons' | 'showIcons' | 'showStatusbar' | 'text' | 'ariaLabel' | 'tooltip' | 'color' | 'backgroundColor' | 'command' | 'arguments' | 'showBeak'>)>;
    }) | ({
        __typename?: 'BranchStatus';
    } & Pick<IBranchStatus, 'id' | 'name' | 'alignment' | 'priority' | 'typeId'> & {
        entry?: Maybe<({
            __typename?: 'StatusbarEntry';
        } & Pick<IStatusbarEntry, 'showTabsButtons' | 'showIcons' | 'showStatusbar' | 'text' | 'ariaLabel' | 'tooltip' | 'color' | 'backgroundColor' | 'command' | 'arguments' | 'showBeak'>)>;
    })>;
});
export declare type IGetViewsQueryVariables = {
    containerId: Scalars['String'];
};
export declare type IGetViewsQuery = ({
    __typename?: 'Query';
} & {
    getViews?: Maybe<Array<Maybe<({
        __typename?: 'ViewDescriptor';
    } & Pick<IViewDescriptor, 'id' | 'name'>)>>>;
});
export declare type IGetWorkspaceQueryVariables = {};
export declare type IGetWorkspaceQuery = ({
    __typename?: 'Query';
} & {
    getWorkspace?: Maybe<({
        __typename?: 'WorkspaceData';
    } & Pick<IWorkspaceData, 'id' | 'name' | 'configuration'> & {
        folders: Array<Maybe<({
            __typename?: 'WorkspaceFolderData';
        } & Pick<IWorkspaceFolderData, 'uri' | 'name' | 'index'>)>>;
    })>;
});
export declare type IGetConfigurationDataFragment = ({
    __typename?: 'ConfigurationData';
} & {
    defaults?: Maybe<({
        __typename?: 'ConfigurationModel';
    } & Pick<IConfigurationModel, 'contents' | 'keys'> & {
        overrides?: Maybe<Array<Maybe<({
            __typename?: 'Overrides';
        } & Pick<IOverrides, 'contents' | 'identifiers'>)>>>;
    })>;
    user?: Maybe<({
        __typename?: 'ConfigurationModel';
    } & Pick<IConfigurationModel, 'contents' | 'keys'> & {
        overrides?: Maybe<Array<Maybe<({
            __typename?: 'Overrides';
        } & Pick<IOverrides, 'contents' | 'identifiers'>)>>>;
    })>;
    workspace?: Maybe<({
        __typename?: 'ConfigurationModel';
    } & Pick<IConfigurationModel, 'contents' | 'keys'> & {
        overrides?: Maybe<Array<Maybe<({
            __typename?: 'Overrides';
        } & Pick<IOverrides, 'contents' | 'identifiers'>)>>>;
    })>;
    folders?: Maybe<Array<Maybe<({
        __typename?: 'FolderConfigurationModel';
    } & Pick<IFolderConfigurationModel, 'id' | 'keys' | 'contents'> & {
        overrides?: Maybe<({
            __typename?: 'ConfigurationOverrides';
        } & Pick<IConfigurationOverrides, 'overrideIdentifier' | 'resource'>)>;
    })>>>;
});
export declare type IINotificationMessageFragment = ({
    __typename?: 'NotificationMessage';
} & Pick<INotificationMessage, 'raw' | 'value'> & {
    links?: Maybe<Array<Maybe<({
        __typename?: 'MessageLink';
    } & Pick<IMessageLink, 'name' | 'href' | 'offset' | 'length'>)>>>;
});
export declare type INotificationMessageFragment = ({
    __typename?: 'NotificationMessage';
} & {
    original?: Maybe<({
        __typename?: 'NotificationMessage';
    } & IINotificationMessageFragment)>;
} & IINotificationMessageFragment);
export declare type INotificationFragment = ({
    __typename?: 'Notification';
} & Pick<INotification, 'index' | 'severity' | 'source' | 'sticky'> & {
    actions?: Maybe<({
        __typename?: 'NotificationActions';
    } & {
        primary?: Maybe<Array<Maybe<({
            __typename?: 'Action';
        } & INotifyActionFragment)>>>;
        secondary?: Maybe<Array<Maybe<({
            __typename?: 'Action';
        } & INotifyActionFragment)>>>;
    })>;
});
export declare type INotifyActionFragment = ({
    __typename?: 'Action';
} & Pick<IAction, 'id' | 'label' | 'tooltip' | 'class' | 'enabled' | 'checked' | 'radio'>);
export declare type IWorkspaceFolderFragment = ({
    __typename?: 'WorkspaceFolderData';
} & Pick<IWorkspaceFolderData, 'uri' | 'name' | 'index'>);
export declare type INotifyErrorMutationVariables = {
    message?: Maybe<Array<Maybe<INotificationMessage_input>>>;
};
export declare type INotifyErrorMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'notifyError'>);
export declare type INotifyInfoMutationVariables = {
    message?: Maybe<Array<Maybe<INotificationMessage_input>>>;
};
export declare type INotifyInfoMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'notifyInfo'>);
export declare type INotifyPromptMutationVariables = {
    severity?: Maybe<INotificationSeverity>;
    message?: Maybe<Scalars['String']>;
    choices?: Maybe<Array<Maybe<IPromptChoice_input>>>;
    options?: Maybe<IPromptOptions_input>;
};
export declare type INotifyPromptMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'notifyPrompt'>);
export declare type INotifyWarnMutationVariables = {
    message?: Maybe<Array<Maybe<INotificationMessage_input>>>;
};
export declare type INotifyWarnMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'notifyWarn'>);
export declare type INotifyMutationVariables = {
    notification?: Maybe<INotification_input>;
};
export declare type INotifyMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'notify'>);
export declare type IUpdateWorkspaceContextAddFoldersMutationVariables = {
    foldersToAdd?: Maybe<Array<Maybe<IFoldersToAdd_Input>>>;
    index?: Maybe<Scalars['Int']>;
};
export declare type IUpdateWorkspaceContextAddFoldersMutation = ({
    __typename?: 'Mutation';
} & {
    updateWorkspaceContextAddFolders?: Maybe<Array<Maybe<({
        __typename?: 'WorkspaceFolderData';
    } & Pick<IWorkspaceFolderData, 'uri' | 'name' | 'index'>)>>>;
});
export declare type IUpdateWorkspaceContextRemoveFoldersMutationVariables = {
    foldersToRemove?: Maybe<Array<Maybe<Scalars['URI']>>>;
};
export declare type IUpdateWorkspaceContextRemoveFoldersMutation = ({
    __typename?: 'Mutation';
} & {
    updateWorkspaceContextRemoveFolders?: Maybe<Array<Maybe<({
        __typename?: 'WorkspaceFolderData';
    } & Pick<IWorkspaceFolderData, 'uri' | 'name' | 'index'>)>>>;
});
export declare type IUpdateWorkspaceContextUpdateFoldersMutationVariables = {
    foldersToAdd?: Maybe<Array<Maybe<IFoldersToAdd_Input>>>;
    foldersToRemove?: Maybe<Array<Maybe<Scalars['URI']>>>;
    index?: Maybe<Scalars['Int']>;
};
export declare type IUpdateWorkspaceContextUpdateFoldersMutation = ({
    __typename?: 'Mutation';
} & {
    updateWorkspaceContextUpdateFolders?: Maybe<Array<Maybe<({
        __typename?: 'WorkspaceFolderData';
    } & Pick<IWorkspaceFolderData, 'uri' | 'name' | 'index'>)>>>;
});
export declare type IGetConfiguration_WSQueryVariables = {};
export declare type IGetConfiguration_WSQuery = ({
    __typename?: 'Query';
} & {
    getConfigurationData?: Maybe<({
        __typename?: 'ConfigurationData';
    } & IGetConfigurationDataFragment)>;
});
export declare type IGetEnvironment_WSQueryVariables = {};
export declare type IGetEnvironment_WSQuery = ({
    __typename?: 'Query';
} & {
    getEnvironment?: Maybe<({
        __typename?: 'Environment';
    } & Pick<IEnvironment, 'execPath' | 'cliPath' | 'appRoot' | 'userHome' | 'userDataPath' | 'appNameLong' | 'appQuality' | 'appSettingsHome' | 'appSettingsPath' | 'appKeybindingsPath' | 'settingsSearchBuildId' | 'settingsSearchUrl' | 'globalStorageHome' | 'workspaceStorageHome' | 'backupHome' | 'backupWorkspacesPath' | 'workspacesHome' | 'workspaceSettingsPath' | 'isExtensionDevelopment' | 'disableExtensions' | 'builtinExtensionsPath' | 'extensionsPath' | 'extensionDevelopmentLocationURI' | 'extensionTestsPath' | 'logExtensionHostCommunication' | 'isBuilt' | 'wait' | 'status' | 'performance' | 'logsPath' | 'log' | 'verbose' | 'logLevel' | 'skipGettingStarted' | 'skipReleaseNotes' | 'skipAddToRecentlyOpened' | 'nodeCachedDataDir' | 'installSourcePath' | 'disableUpdates' | 'disableCrashReporter' | 'driverHandle' | 'driverVerbose'> & {
        debugExtensionHost?: Maybe<({
            __typename?: 'ExtensionHostDebugParams';
        } & Pick<IExtensionHostDebugParams, 'port' | 'break' | 'debugId'>)>;
    })>;
});
export declare type IGetWorkspace_WSQueryVariables = {};
export declare type IGetWorkspace_WSQuery = ({
    __typename?: 'Query';
} & {
    getWorkspace?: Maybe<({
        __typename?: 'WorkspaceData';
    } & Pick<IWorkspaceData, 'id' | 'name' | 'configuration'> & {
        folders: Array<Maybe<({
            __typename?: 'WorkspaceFolderData';
        } & IWorkspaceFolderFragment)>>;
    })>;
});
export declare type IGetWorkspaceValue_WSQueryVariables = {
    value?: Maybe<IWorkspaceValue_Input>;
};
export declare type IGetWorkspaceValue_WSQuery = ({
    __typename?: 'Query';
} & Pick<IQuery, 'getWorkspaceValue'>);
export declare type IAddServerNotificationMutationVariables = {
    notification?: Maybe<INotification_input>;
};
export declare type IAddServerNotificationMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'addNotification'>);
export declare type IGetWorkspaceFolderContextQueryVariables = {
    arg?: Maybe<IArg_Input>;
};
export declare type IGetWorkspaceFolderContextQuery = ({
    __typename?: 'Query';
} & {
    getWorkspaceFolderContext?: Maybe<({
        __typename?: 'WorkspaceData';
    } & Pick<IWorkspaceData, 'id' | 'configuration'> & {
        folders: Array<Maybe<({
            __typename?: 'WorkspaceFolderData';
        } & IWorkspaceFolderFragment)>>;
    })>;
});
export declare type ICodeLenseProviderDefinitionMutationVariables = {
    params?: Maybe<ITextDocumentPositionParamsInput>;
};
export declare type ICodeLenseProviderDefinitionMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'codeLenseProviderDefinition'>);
export declare type ICompletionProviderDefinitionMutationVariables = {
    params?: Maybe<ITextDocumentPositionParamsInput>;
};
export declare type ICompletionProviderDefinitionMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'completionProviderDefinition'>);
export declare type IDefinitionDefinitionMutationVariables = {
    params?: Maybe<ITextDocumentPositionParamsInput>;
};
export declare type IDefinitionDefinitionMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'definitionDefinition'>);
export declare type IDocumentHighLightProviderDefinitionMutationVariables = {
    params?: Maybe<ITextDocumentPositionParamsInput>;
};
export declare type IDocumentHighLightProviderDefinitionMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'documentHighLightProviderDefinition'>);
export declare type IDocumentFormattingProviderDefinitionMutationVariables = {
    params?: Maybe<ITextDocumentPositionParamsInput>;
};
export declare type IDocumentFormattingProviderDefinitionMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'documentFormattingProviderDefinition'>);
export declare type IHoverProviderDefinitionMutationVariables = {
    params?: Maybe<ITextDocumentPositionParamsInput>;
};
export declare type IHoverProviderDefinitionMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'hoverProviderDefinition'>);
export declare type IOpenLanguageDocumentMutationVariables = {
    document?: Maybe<IOpenDocumentParamsInput>;
};
export declare type IOpenLanguageDocumentMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'openLanguageDocument'>);
export declare type IReferenceProviderDefinitionMutationVariables = {
    params?: Maybe<ITextDocumentPositionParamsInput>;
};
export declare type IReferenceProviderDefinitionMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'referenceProviderDefinition'>);
export declare type IRenameDefinitionMutationVariables = {
    params?: Maybe<ITextDocumentPositionParamsInput>;
};
export declare type IRenameDefinitionMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'renameDefinition'>);
export declare type IDocumentSymbolDefinitionMutationVariables = {
    params?: Maybe<ITextDocumentPositionParamsInput>;
};
export declare type IDocumentSymbolDefinitionMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'documentSymbolDefinition'>);
export declare type IUpdateModelMutationVariables = {
    model?: Maybe<IIModelInput>;
};
export declare type IUpdateModelMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'updateModel'>);
export declare type ResolverTypeWrapper<T> = Promise<T> | T;
export declare type StitchingResolver<TResult, TParent, TContext, TArgs> = {
    fragment: string;
    resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export declare type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> = ResolverFn<TResult, TParent, TContext, TArgs> | StitchingResolver<TResult, TParent, TContext, TArgs>;
export declare type ResolverFn<TResult, TParent, TContext, TArgs> = (parent: TParent, args: TArgs, context: TContext, info: GraphQLResolveInfo) => Promise<TResult> | TResult;
export declare type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (parent: TParent, args: TArgs, context: TContext, info: GraphQLResolveInfo) => AsyncIterator<TResult> | Promise<AsyncIterator<TResult>>;
export declare type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (parent: TParent, args: TArgs, context: TContext, info: GraphQLResolveInfo) => TResult | Promise<TResult>;
export interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {
    subscribe: SubscriptionSubscribeFn<{
        [key in TKey]: TResult;
    }, TParent, TContext, TArgs>;
    resolve?: SubscriptionResolveFn<TResult, {
        [key in TKey]: TResult;
    }, TContext, TArgs>;
}
export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
    subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
    resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}
export declare type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> = SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs> | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;
export declare type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> = ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>) | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;
export declare type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (parent: TParent, context: TContext, info: GraphQLResolveInfo) => Maybe<TTypes> | Promise<Maybe<TTypes>>;
export declare type isTypeOfResolverFn<T = {}> = (obj: T, info: GraphQLResolveInfo) => boolean | Promise<boolean>;
export declare type NextResolverFn<T> = () => Promise<T>;
export declare type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (next: NextResolverFn<TResult>, parent: TParent, args: TArgs, context: TContext, info: GraphQLResolveInfo) => TResult | Promise<TResult>;
/** Mapping between all available schema types and the resolvers types */
export declare type IResolversTypes = {
    Query: ResolverTypeWrapper<{}>;
    ContextMenu: ResolverTypeWrapper<IContextMenu>;
    String: ResolverTypeWrapper<Scalars['String']>;
    Boolean: ResolverTypeWrapper<Scalars['Boolean']>;
    Anchor: ResolverTypeWrapper<IAnchor>;
    Int: ResolverTypeWrapper<Scalars['Int']>;
    MenuItem: ResolverTypeWrapper<IMenuItem>;
    ActionRun: ResolverTypeWrapper<IActionRun>;
    GraphqlCallType: IGraphqlCallType;
    AnyObject: ResolverTypeWrapper<Scalars['AnyObject']>;
    DefaultPreferencesResponse: ResolverTypeWrapper<IDefaultPreferencesResponse>;
    PreferencesType: ResolverTypeWrapper<IPreferencesType>;
    Setting: ResolverTypeWrapper<ISetting>;
    Range: ResolverTypeWrapper<IRange>;
    Position: ResolverTypeWrapper<IPosition>;
    ConfigurationScope: ConfigurationScope;
    ConfigurationExtensionInfo: ResolverTypeWrapper<IConfigurationExtensionInfo>;
    DefaultSettings: ResolverTypeWrapper<IDefaultSettings>;
    ISettingsSubject: IResolversTypes['DefaultSettings'] | IResolversTypes['UserSettings'] | IResolversTypes['LocalUserSettings'] | IResolversTypes['RemoteUserSettings'] | IResolversTypes['FolderSettings'] | IResolversTypes['GlobalSettings'] | IResolversTypes['WorkspaceSettings'] | IResolversTypes['MemorySettings'];
    ID: ResolverTypeWrapper<Scalars['ID']>;
    Settings: ResolverTypeWrapper<ISettings>;
    URI: ResolverTypeWrapper<Scalars['URI']>;
    SettingsCascade: ResolverTypeWrapper<Omit<ISettingsCascade, 'subjects'> & {
        subjects?: Maybe<Array<Maybe<IResolversTypes['SettingsSubject']>>>;
    }>;
    SettingsSubject: IResolversTypes['UserSettings'] | IResolversTypes['LocalUserSettings'] | IResolversTypes['RemoteUserSettings'] | IResolversTypes['FolderSettings'] | IResolversTypes['GlobalSettings'] | IResolversTypes['WorkspaceSettings'] | IResolversTypes['MemorySettings'] | IResolversTypes['DefaultSettings'];
    UserSettings: ResolverTypeWrapper<IUserSettings>;
    LocalUserSettings: ResolverTypeWrapper<ILocalUserSettings>;
    RemoteUserSettings: ResolverTypeWrapper<IRemoteUserSettings>;
    FolderSettings: ResolverTypeWrapper<IFolderSettings>;
    GlobalSettings: ResolverTypeWrapper<IGlobalSettings>;
    WorkspaceSettings: ResolverTypeWrapper<IWorkspaceSettings>;
    MemorySettings: ResolverTypeWrapper<IMemorySettings>;
    Configuration: ResolverTypeWrapper<IConfiguration>;
    SettingsGroup: ResolverTypeWrapper<ISettingsGroup>;
    SettingsSection: ResolverTypeWrapper<ISettingsSection>;
    Files: ResolverTypeWrapper<IFiles>;
    AutoSaveConfigurationType: IAutoSaveConfigurationType;
    JSON: ResolverTypeWrapper<Scalars['JSON']>;
    Git: ResolverTypeWrapper<IGit>;
    GitDecorations: ResolverTypeWrapper<IGitDecorations>;
    Languages: ResolverTypeWrapper<ILanguages>;
    Output: ResolverTypeWrapper<IOutput>;
    Search: ResolverTypeWrapper<ISearch>;
    SearchQuickOpen: ResolverTypeWrapper<ISearchQuickOpen>;
    Terminal: ResolverTypeWrapper<ITerminal>;
    IStatusbarItem: IResolversTypes['Terminal'] | IResolversTypes['SelectionStatus'] | IResolversTypes['Indentation'] | IResolversTypes['EncodingStatus'] | IResolversTypes['EndOfLineSequence'] | IResolversTypes['LanguageMode'] | IResolversTypes['SyncStatus'] | IResolversTypes['BranchStatus'];
    StatusbarAlignment: IStatusbarAlignment;
    StatusbarEntry: ResolverTypeWrapper<IStatusbarEntry>;
    STATUSBAR_ITEM_ID: ISTATUSBAR_ITEM_ID;
    Integrated: ResolverTypeWrapper<IIntegrated>;
    ShellArgs: ResolverTypeWrapper<IShellArgs>;
    Shell: ResolverTypeWrapper<IShell>;
    WorkspacePreferenceWorkbench: ResolverTypeWrapper<IWorkspacePreferenceWorkbench>;
    WorkspacePreferenceView: ResolverTypeWrapper<IWorkspacePreferenceView>;
    WorkspacePreferenceTips: ResolverTypeWrapper<IWorkspacePreferenceTips>;
    WorkspacePreferenceStatusBar: ResolverTypeWrapper<IWorkspacePreferenceStatusBar>;
    WorkspacePreferenceSideBar: ResolverTypeWrapper<IWorkspacePreferenceSideBar>;
    WorkspacePreferenceSettings: ResolverTypeWrapper<IWorkspacePreferenceSettings>;
    WorkspacePreferenceQuickOpen: ResolverTypeWrapper<IWorkspacePreferenceQuickOpen>;
    WorkspacePreferencePanel: ResolverTypeWrapper<IWorkspacePreferencePanel>;
    WorkspacePreferenceList: ResolverTypeWrapper<IWorkspacePreferenceList>;
    WorkspacePreferenceExperimental: ResolverTypeWrapper<IWorkspacePreferenceExperimental>;
    WorkspacePreferenceEditor: ResolverTypeWrapper<IWorkspacePreferenceEditor>;
    WorkspacePreferenceCommandPalette: ResolverTypeWrapper<IWorkspacePreferenceCommandPalette>;
    WorkspacePreferenceActivityBar: ResolverTypeWrapper<IWorkspacePreferenceActivityBar>;
    Dialog: ResolverTypeWrapper<IDialog>;
    Detail: ResolverTypeWrapper<IDetail>;
    InputTypeDetail: ResolverTypeWrapper<IInputTypeDetail>;
    PrimaryButtonAction: ResolverTypeWrapper<IPrimaryButtonAction>;
    CheckboxOptions: ResolverTypeWrapper<ICheckboxOptions>;
    DocSitePage: ResolverTypeWrapper<IDocSitePage>;
    EditorPart: ResolverTypeWrapper<Omit<IEditorPart, 'children'> & {
        children?: Maybe<Array<Maybe<IResolversTypes['EditorChildren']>>>;
    }>;
    GroupOrientation: GroupOrientation;
    EditorChildren: IResolversTypes['EditorPart'] | IResolversTypes['EditorGroup'];
    EditorGroup: ResolverTypeWrapper<Omit<IEditorGroup, 'tabs'> & {
        tabs?: Maybe<Array<Maybe<IResolversTypes['EditorInput']>>>;
    }>;
    IEditorGroup: IResolversTypes['EditorGroup'];
    EditorInput: IResolversTypes['DataUriEditorInput'] | IResolversTypes['DiffEditorInput'] | IResolversTypes['FileEditorInput'] | IResolversTypes['KeybindingEditorInput'] | IResolversTypes['PreferencesEditorInput'] | IResolversTypes['ResourceEditorInput'] | IResolversTypes['SideBySideEditorInput'] | IResolversTypes['UntitledEditorInput'];
    DataUriEditorInput: ResolverTypeWrapper<IDataUriEditorInput>;
    IEditorInput: IResolversTypes['DataUriEditorInput'] | IResolversTypes['DiffEditorInput'] | IResolversTypes['FileEditorInput'] | IResolversTypes['KeybindingEditorInput'] | IResolversTypes['PreferencesEditorInput'] | IResolversTypes['ResourceEditorInput'] | IResolversTypes['SideBySideEditorInput'] | IResolversTypes['UntitledEditorInput'];
    EDITOR_INPUT_ID: IEDITOR_INPUT_ID;
    FileStatWithMetadata: ResolverTypeWrapper<IFileStatWithMetadata>;
    IBaseStat: IResolversTypes['FileStatWithMetadata'] | IResolversTypes['TextFileStreamContent'] | IResolversTypes['TextFilePublishContent'] | IResolversTypes['TextFileContent'] | IResolversTypes['FileContent'] | IResolversTypes['FileStat'] | IResolversTypes['FileStreamContent'];
    BigInt: ResolverTypeWrapper<Scalars['BigInt']>;
    IBaseStatWithMetadata: IResolversTypes['FileStatWithMetadata'] | IResolversTypes['TextFileStreamContent'] | IResolversTypes['TextFileContent'] | IResolversTypes['FileContent'] | IResolversTypes['FileStreamContent'];
    IContentChangedEvent: IResolversTypes['FileStatWithMetadata'];
    IFileClientMetadata: IResolversTypes['FileStatWithMetadata'] | IResolversTypes['TextFileContent'];
    FileModelState: IFileModelState;
    ITreeItem: IResolversTypes['FileStatWithMetadata'];
    IUntitledFileValue: IResolversTypes['FileStatWithMetadata'];
    IEditorInputWithGroupFields: IResolversTypes['DataUriEditorInput'] | IResolversTypes['DiffEditorInput'] | IResolversTypes['FileEditorInput'] | IResolversTypes['KeybindingEditorInput'] | IResolversTypes['PreferencesEditorInput'] | IResolversTypes['ResourceEditorInput'] | IResolversTypes['SideBySideEditorInput'] | IResolversTypes['UntitledEditorInput'];
    DiffEditorInput: ResolverTypeWrapper<Omit<IDiffEditorInput, 'originalInput' | 'modifiedInput'> & {
        originalInput?: Maybe<IResolversTypes['EditorInput']>;
        modifiedInput?: Maybe<IResolversTypes['EditorInput']>;
    }>;
    FileEditorInput: ResolverTypeWrapper<IFileEditorInput>;
    IFileEditorInput: IResolversTypes['FileEditorInput'];
    IEncodingSupport: IResolversTypes['FileEditorInput'];
    IModeSupport: IResolversTypes['FileEditorInput'];
    KeybindingEditorInput: ResolverTypeWrapper<IKeybindingEditorInput>;
    PreferencesEditorInput: ResolverTypeWrapper<Omit<IPreferencesEditorInput, 'master' | 'details'> & {
        master?: Maybe<IResolversTypes['EditorInput']>;
        details?: Maybe<IResolversTypes['EditorInput']>;
    }>;
    ISideBySideEditorInput: IResolversTypes['PreferencesEditorInput'] | IResolversTypes['SideBySideEditorInput'];
    ResourceEditorInput: ResolverTypeWrapper<IResourceEditorInput>;
    SideBySideEditorInput: ResolverTypeWrapper<Omit<ISideBySideEditorInput, 'master' | 'details'> & {
        master?: Maybe<IResolversTypes['EditorInput']>;
        details?: Maybe<IResolversTypes['EditorInput']>;
    }>;
    UntitledEditorInput: ResolverTypeWrapper<IUntitledEditorInput>;
    CodeEditorViewState: ResolverTypeWrapper<ICodeEditorViewState>;
    RegistryExtension: ResolverTypeWrapper<IRegistryExtension>;
    Node: IResolversTypes['RegistryExtension'];
    RegistryPublisher: ResolverTypeWrapper<IRegistryPublisher>;
    ExtensionManifest: ResolverTypeWrapper<IExtensionManifest>;
    ExtensionKind: IExtensionKind;
    Assets: ResolverTypeWrapper<IAssets>;
    Scripts: ResolverTypeWrapper<IScripts>;
    Bundles: ResolverTypeWrapper<IBundles>;
    ExtensionPackageType: ResolverTypeWrapper<IExtensionPackageType>;
    Engines: ResolverTypeWrapper<IEngines>;
    Author: ResolverTypeWrapper<IAuthor>;
    GalleryBanner: ResolverTypeWrapper<IGalleryBanner>;
    ExtensionContributions: ResolverTypeWrapper<IExtensionContributions>;
    Actions: ResolverTypeWrapper<IActions>;
    ActionItem: ResolverTypeWrapper<IActionItem>;
    ExtensionConfiguration: ResolverTypeWrapper<IExtensionConfiguration>;
    Debugger: ResolverTypeWrapper<IDebugger>;
    Grammar: ResolverTypeWrapper<IGrammar>;
    ExtensionJSONValidation: ResolverTypeWrapper<IExtensionJSONValidation>;
    KeyBinding: ResolverTypeWrapper<IKeyBinding>;
    ExtensionLanguage: ResolverTypeWrapper<IExtensionLanguage>;
    Menus: ResolverTypeWrapper<IMenus>;
    MenuItemAction: ResolverTypeWrapper<IMenuItemAction>;
    MenuItemActionContext: ResolverTypeWrapper<IMenuItemActionContext>;
    MenuItemActionEditor: ResolverTypeWrapper<IMenuItemActionEditor>;
    MenuItemActionEditorTitle: ResolverTypeWrapper<IMenuItemActionEditorTitle>;
    MenuItemActionDebug: ResolverTypeWrapper<IMenuItemActionDebug>;
    MenuItemActionScm: ResolverTypeWrapper<IMenuItemActionScm>;
    MenuItemActionScmChange: ResolverTypeWrapper<IMenuItemActionScmChange>;
    MenuItemActionView: ResolverTypeWrapper<IMenuItemActionView>;
    Snippet: ResolverTypeWrapper<ISnippet>;
    ThemeLabel: ResolverTypeWrapper<IThemeLabel>;
    ExtensionColor: ResolverTypeWrapper<IExtensionColor>;
    ExtensionColorTypes: ResolverTypeWrapper<IExtensionColorTypes>;
    Localization: ResolverTypeWrapper<ILocalization>;
    LocalizationTranslation: ResolverTypeWrapper<ILocalizationTranslation>;
    ExtensionManifestBugs: ResolverTypeWrapper<IExtensionManifestBugs>;
    ExtensionManifestRepository: ResolverTypeWrapper<IExtensionManifestRepository>;
    ExtensionRelease: ResolverTypeWrapper<IExtensionRelease>;
    ExtensionRegistry: ResolverTypeWrapper<IExtensionRegistry>;
    RegistryExtensionConnection: ResolverTypeWrapper<IRegistryExtensionConnection>;
    PageInfo: ResolverTypeWrapper<IPageInfo>;
    RegistryPublisherConnection: ResolverTypeWrapper<IRegistryPublisherConnection>;
    FileQueryInput: IFileQueryInput;
    FolderQueryInput: IFolderQueryInput;
    URIInput: IURIInput;
    QueryType: IQueryType;
    SearchComplete: ResolverTypeWrapper<Omit<ISearchComplete, 'stats'> & {
        stats: IResolversTypes['SearchCompleteStatsStats'];
    }>;
    ISearchCompleteStats: IResolversTypes['SearchComplete'];
    SearchCompleteStatsStats: IResolversTypes['FileSearchStats'] | IResolversTypes['TextSearchStats'];
    FileSearchStats: ResolverTypeWrapper<Omit<IFileSearchStats, 'detailStats'> & {
        detailStats?: Maybe<IResolversTypes['FileSearchStatsdetailStats']>;
    }>;
    FileSearchStatsdetailStats: IResolversTypes['SearchEngineStats'] | IResolversTypes['CachedSearchStats'] | IResolversTypes['FileSearchProviderStats'] | IResolversTypes['FileIndexProviderStats'];
    SearchEngineStats: ResolverTypeWrapper<ISearchEngineStats>;
    CachedSearchStats: ResolverTypeWrapper<ICachedSearchStats>;
    FileSearchProviderStats: ResolverTypeWrapper<IFileSearchProviderStats>;
    FileIndexProviderStats: ResolverTypeWrapper<IFileIndexProviderStats>;
    FileSearchStatsType: IFileSearchStatsType;
    TextSearchStats: ResolverTypeWrapper<ITextSearchStats>;
    TextSearchStatsType: ITextSearchStatsType;
    FileMatch: ResolverTypeWrapper<Omit<IFileMatch, 'results'> & {
        results?: Maybe<Array<Maybe<IResolversTypes['TextSearchResult']>>>;
    }>;
    IFileMatch: IResolversTypes['FileMatch'] | IResolversTypes['SearchProgressItem'];
    TextSearchResult: IResolversTypes['TextSearchMatch'] | IResolversTypes['TextSearchContext'];
    TextSearchMatch: ResolverTypeWrapper<ITextSearchMatch>;
    SearchRange: ResolverTypeWrapper<ISearchRange>;
    TextSearchResultPreview: ResolverTypeWrapper<ITextSearchResultPreview>;
    TextSearchContext: ResolverTypeWrapper<ITextSearchContext>;
    GalleryQuery: IGalleryQuery;
    GalleryPager: ResolverTypeWrapper<IGalleryPager>;
    GalleryExtension: ResolverTypeWrapper<IGalleryExtension>;
    ExtensionIdentifier: ResolverTypeWrapper<IExtensionIdentifier>;
    Float: ResolverTypeWrapper<Scalars['Float']>;
    GalleryExtensionAssets: ResolverTypeWrapper<IGalleryExtensionAssets>;
    GalleryExtensionAsset: ResolverTypeWrapper<IGalleryExtensionAsset>;
    GalleryExtensionProperties: ResolverTypeWrapper<IGalleryExtensionProperties>;
    GalleryExtensionResources: ResolverTypeWrapper<IGalleryExtensionResources>;
    ConfigurationData: ResolverTypeWrapper<IConfigurationData>;
    ConfigurationModel: ResolverTypeWrapper<IConfigurationModel>;
    Overrides: ResolverTypeWrapper<IOverrides>;
    FolderConfigurationModel: ResolverTypeWrapper<IFolderConfigurationModel>;
    ConfigurationOverrides: ResolverTypeWrapper<IConfigurationOverrides>;
    Context: ResolverTypeWrapper<IContext>;
    scmResourceGroups: IscmResourceGroups;
    ProvidedRemoteConnectionStates: IProvidedRemoteConnectionStates;
    ConfigurationTarget: ConfigurationTarget;
    Environment: ResolverTypeWrapper<IEnvironment>;
    ExtensionHostDebugParams: ResolverTypeWrapper<IExtensionHostDebugParams>;
    IDebugParams: IResolversTypes['ExtensionHostDebugParams'];
    Keybindings: ResolverTypeWrapper<IKeybindings>;
    KeybindingItem: ResolverTypeWrapper<IKeybindingItem>;
    KeybindingSource: IKeybindingSource;
    SelectedOutput: ResolverTypeWrapper<ISelectedOutput>;
    QuickPickItem: ResolverTypeWrapper<IQuickPickItem>;
    QuickPickItemHighlights: ResolverTypeWrapper<IQuickPickItemHighlights>;
    Match: ResolverTypeWrapper<IMatch>;
    ViewDescriptor: ResolverTypeWrapper<IViewDescriptor>;
    IViewDescriptor: IResolversTypes['ViewDescriptor'] | IResolversTypes['TreeViewDescriptor'];
    WorkspaceData: ResolverTypeWrapper<IWorkspaceData>;
    IStaticWorkspaceData: IResolversTypes['WorkspaceData'];
    WorkspaceFolderData: ResolverTypeWrapper<IWorkspaceFolderData>;
    Arg_Input: IArg_Input;
    WorkspaceValue_Input: IWorkspaceValue_Input;
    ConfigurationOverrides_Input: IConfigurationOverrides_Input;
    GoToLineQuickAccess: ResolverTypeWrapper<IGoToLineQuickAccess>;
    LineRange: ResolverTypeWrapper<ILineRange>;
    InstalledExtension: ResolverTypeWrapper<IInstalledExtension>;
    ExtensionInstance: ResolverTypeWrapper<IExtensionInstance>;
    ProcessMonitoring: ResolverTypeWrapper<IProcessMonitoring>;
    KeybindingContextMenu: ResolverTypeWrapper<IKeybindingContextMenu>;
    EditKeybindingItem: ResolverTypeWrapper<IEditKeybindingItem>;
    Notifications: ResolverTypeWrapper<INotifications>;
    Notification: ResolverTypeWrapper<INotification>;
    NotificationSeverity: NotificationSeverity;
    NotificationActions: ResolverTypeWrapper<INotificationActions>;
    Action: ResolverTypeWrapper<IAction>;
    QuickInputModel: ResolverTypeWrapper<IQuickInputModel>;
    QuickInput: ResolverTypeWrapper<IQuickInput>;
    QuickPick: ResolverTypeWrapper<IQuickPick>;
    ReadTextFileOptions_Input: IReadTextFileOptions_Input;
    ReadFileOptions_Input_limits: IReadFileOptions_Input_limits;
    TextFileStreamContent: ResolverTypeWrapper<ITextFileStreamContent>;
    IBaseTextFileContent: IResolversTypes['TextFileStreamContent'] | IResolversTypes['TextFilePublishContent'] | IResolversTypes['TextFileContent'];
    TextBufferData: ResolverTypeWrapper<ITextBufferData>;
    TextFilePublishContent: ResolverTypeWrapper<ITextFilePublishContent>;
    FileContentStatus: IFileContentStatus;
    TextFileContent: ResolverTypeWrapper<ITextFileContent>;
    TextDocumentRegistrationOptionsInput: ITextDocumentRegistrationOptionsInput;
    ProvideTextDocumentLocationSignatureInput: IProvideTextDocumentLocationSignatureInput;
    TextDocumentIdentifierInput: ITextDocumentIdentifierInput;
    PositionInput: IPositionInput;
    ReadFileOptions_Input: IReadFileOptions_Input;
    FileContent: ResolverTypeWrapper<IFileContent>;
    VSBuffer: ResolverTypeWrapper<Scalars['VSBuffer']>;
    ResolveAll_toResolveWithMetadata_Input: IResolveAll_toResolveWithMetadata_Input;
    ResolveMetadataFileOptions_Input: IResolveMetadataFileOptions_Input;
    ResolveFileResultWithMetadata: ResolverTypeWrapper<IResolveFileResultWithMetadata>;
    LoadOptions_Input: ILoadOptions_Input;
    FileLoadReason: IFileLoadReason;
    Dialog_input: IDialog_input;
    Detail_input: IDetail_input;
    InputTypeDetail_input: IInputTypeDetail_input;
    PrimaryButtonAction_input: IPrimaryButtonAction_input;
    ActionRun_input: IActionRun_input;
    CheckboxOptions_input: ICheckboxOptions_input;
    DialogResult: ResolverTypeWrapper<IDialogResult>;
    Notification_input: INotification_input;
    NotificationMessage_input: INotificationMessage_input;
    MessageLink_input: IMessageLink_input;
    NotificationActions_input: INotificationActions_input;
    Action_input: IAction_input;
    Statusbar: ResolverTypeWrapper<Omit<IStatusbar, 'items'> & {
        items?: Maybe<Array<Maybe<IResolversTypes['StatusbarItem']>>>;
    }>;
    StatusbarItem: IResolversTypes['Terminal'] | IResolversTypes['SelectionStatus'] | IResolversTypes['Indentation'] | IResolversTypes['EncodingStatus'] | IResolversTypes['EndOfLineSequence'] | IResolversTypes['LanguageMode'] | IResolversTypes['SyncStatus'] | IResolversTypes['BranchStatus'];
    SelectionStatus: ResolverTypeWrapper<ISelectionStatus>;
    Indentation: ResolverTypeWrapper<IIndentation>;
    EncodingStatus: ResolverTypeWrapper<IEncodingStatus>;
    EndOfLineSequence: ResolverTypeWrapper<IEndOfLineSequence>;
    LanguageMode: ResolverTypeWrapper<ILanguageMode>;
    SyncStatus: ResolverTypeWrapper<ISyncStatus>;
    BranchStatus: ResolverTypeWrapper<IBranchStatus>;
    TextQueryInput: ITextQueryInput;
    PatternInfoInput: IPatternInfoInput;
    TextSearchPreviewOptionsInput: ITextSearchPreviewOptionsInput;
    TreeItem: ResolverTypeWrapper<ITreeItem>;
    TreeItemCollapsibleState: ITreeItemCollapsibleState;
    UserPreferencesRes: ResolverTypeWrapper<IUserPreferencesRes>;
    IUserPreferences: ResolverTypeWrapper<IIUserPreferences>;
    WorkspaceRes: ResolverTypeWrapper<IWorkspaceRes>;
    Mutation: ResolverTypeWrapper<{}>;
    IActivationRequest: IIActivationRequest;
    AddEntry_input: IAddEntry_input;
    StatusbarEntry_input: IStatusbarEntry_input;
    Folder_input: IFolder_input;
    KeybindingItem_input: IKeybindingItem_input;
    Args_input: IArgs_input;
    CloseEditor_Input: ICloseEditor_Input;
    CloseEditorOptions_Input: ICloseEditorOptions_Input;
    TextDocumentPositionParamsInput: ITextDocumentPositionParamsInput;
    Observable: ResolverTypeWrapper<Scalars['Observable']>;
    CreateFileOptions_Input: ICreateFileOptions_Input;
    DeleteFileOptions_Input: IDeleteFileOptions_Input;
    EmptyResponse: ResolverTypeWrapper<IEmptyResponse>;
    LineRange_input: ILineRange_input;
    IJSONValue_input: IIJSONValue_input;
    KeepOpen_Input: IKeepOpen_Input;
    MoveEditor_Input: IMoveEditor_Input;
    MoveEditorOptions_Input: IMoveEditorOptions_Input;
    PromptChoice_input: IPromptChoice_input;
    PromptChoiceRun: IPromptChoiceRun;
    PromptOptions_input: IPromptOptions_input;
    PromptOptionsCancel: IPromptOptionsCancel;
    OpenEditor_Input: IOpenEditor_Input;
    EditorOpenOptions_Input: IEditorOpenOptions_Input;
    EditorOpenPositioning: EditorOpenPositioning;
    ResourceDiff_Input: IResourceDiff_Input;
    TextEditorOptions_Input: ITextEditorOptions_Input;
    EditorActivation: IEditorActivation;
    EditorOpenContext: IEditorOpenContext;
    TextEditorSelection_Input: ITextEditorSelection_Input;
    TextEditorSelectionRevealType: ITextEditorSelectionRevealType;
    Resource_Input: IResource_Input;
    ResourceSideBySide_Input: IResourceSideBySide_Input;
    UntitledResource_Input: IUntitledResource_Input;
    OpenDocumentParamsInput: IOpenDocumentParamsInput;
    OpenDocumentTextParamsInput: IOpenDocumentTextParamsInput;
    ExtensionRegistryPublishExtensionResult: ResolverTypeWrapper<IExtensionRegistryPublishExtensionResult>;
    Keybinding_input: IKeybinding_input;
    RemoveEditor_Input: IRemoveEditor_Input;
    ReplaceContentResult: ResolverTypeWrapper<IReplaceContentResult>;
    KeyboardEvent_input: IKeyboardEvent_input;
    KeyboardEvent_output: ResolverTypeWrapper<IKeyboardEvent_output>;
    SaveOptions_Input: ISaveOptions_Input;
    SaveReason: ISaveReason;
    FileStat: ResolverTypeWrapper<IFileStat>;
    SaveWorkspaceRes: ResolverTypeWrapper<ISaveWorkspaceRes>;
    SelectEditor_Input: ISelectEditor_Input;
    TreeData_Input: ITreeData_Input;
    PickItem: IPickItem;
    QuickPickItemHighlights_input: IQuickPickItemHighlights_input;
    Match_input: IMatch_input;
    SetStatusMsg_input: ISetStatusMsg_input;
    ContextMenu_input: IContextMenu_input;
    Anchor_input: IAnchor_input;
    MenuItem_input: IMenuItem_input;
    InputOptions: IInputOptions;
    PickInputOptions: IPickInputOptions;
    ContentChangedEvent_Input: IContentChangedEvent_Input;
    ChangesChunk_Input: IChangesChunk_Input;
    ChangeRange_Input: IChangeRange_Input;
    WriteFileOptions_Input: IWriteFileOptions_Input;
    CodeEditorViewState_Input: ICodeEditorViewState_Input;
    EditorLayout_Input: IEditorLayout_Input;
    EditorChildren_Input: IEditorChildren_Input;
    EditorInput_Input: IEditorInput_Input;
    IModelInput: IIModelInput;
    IWorkspaceRootInput: IIWorkspaceRootInput;
    IViewComponentDataInput: IIViewComponentDataInput;
    TextDocumentItemInput: ITextDocumentItemInput;
    UpdateEntry_input: IUpdateEntry_input;
    FoldersToAdd_Input: IFoldersToAdd_Input;
    WatchOptions_Input: IWatchOptions_Input;
    WriteTextFileOptions_Input: IWriteTextFileOptions_Input;
    UpdatedResource: ResolverTypeWrapper<IUpdatedResource>;
    UpdateDelayedResource: ResolverTypeWrapper<IUpdateDelayedResource>;
    Subscription: ResolverTypeWrapper<{}>;
    FileChange: ResolverTypeWrapper<IFileChange>;
    FileChangeType: IFileChangeType;
    FileOperationOutput: ResolverTypeWrapper<IFileOperationOutput>;
    FileOperation: IFileOperation;
    IConfigurationChangeEvent: ResolverTypeWrapper<IIConfigurationChangeEvent>;
    ResourceMapConfigurationModel: ResolverTypeWrapper<IResourceMapConfigurationModel>;
    SearchCompleteStream: ResolverTypeWrapper<Omit<ISearchCompleteStream, 'stats'> & {
        stats: IResolversTypes['SearchCompleteStatsStats'];
    }>;
    RegistryEntry: ResolverTypeWrapper<IRegistryEntry>;
    TextDocumentRegistrationOptions: ResolverTypeWrapper<ITextDocumentRegistrationOptions>;
    DocumentFilter: ResolverTypeWrapper<IDocumentFilter>;
    ITextDocumentIdentifier: IResolversTypes['TextDocumentIdentifier'] | IResolversTypes['TextDocumentItem'];
    TextDocumentIdentifier: ResolverTypeWrapper<ITextDocumentIdentifier>;
    ProvideTextDocumentLocationSignature: ResolverTypeWrapper<IProvideTextDocumentLocationSignature>;
    TextDocumentPositionParams: IResolversTypes['ProvideTextDocumentLocationSignature'];
    Location: IResolversTypes['ProvideTextDocumentLocationSignature'];
    MarkupKind: IMarkupKind;
    IViewComponentData: ResolverTypeWrapper<IIViewComponentData>;
    TextDocumentItem: ResolverTypeWrapper<ITextDocumentItem>;
    IWorkspaceRoot: ResolverTypeWrapper<IIWorkspaceRoot>;
    IModel: ResolverTypeWrapper<IIModel>;
    ISwitchMapOperator: ResolverTypeWrapper<IISwitchMapOperator>;
    IDocumentSelector: ResolverTypeWrapper<IIDocumentSelector>;
    IBehaviorSubjectValue: ResolverTypeWrapper<IIBehaviorSubjectValue>;
    IBehaviorSubject: ResolverTypeWrapper<IIBehaviorSubject>;
    IDestinationAnonymousSubject: ResolverTypeWrapper<IIDestinationAnonymousSubject>;
    ISourceAnonymousSubject: ResolverTypeWrapper<IISourceAnonymousSubject>;
    IObservableResult: ResolverTypeWrapper<IIObservableResult>;
    GalleryFilter: IGalleryFilter;
    ExtensionRegistryCreateExtensionResult: ResolverTypeWrapper<IExtensionRegistryCreateExtensionResult>;
    ExtensionRegistryUpdateExtensionResult: ResolverTypeWrapper<IExtensionRegistryUpdateExtensionResult>;
    SettingValueType: ISettingValueType;
    KeyPathSegment: IKeyPathSegment;
    IUserSettings: ResolverTypeWrapper<IIUserSettings>;
    PreferenceItem: ResolverTypeWrapper<IPreferenceItem>;
    CommandType: ResolverTypeWrapper<ICommandType>;
    CommandHandlerDescriptionType: ResolverTypeWrapper<ICommandHandlerDescriptionType>;
    ArgsType: ResolverTypeWrapper<IArgsType>;
    CommandsType: ResolverTypeWrapper<ICommandsType>;
    ContextInput: IContextInput;
    scmProviders: IscmProviders;
    commentThread: IcommentThread;
    EditorOptions_Input: IEditorOptions_Input;
    SideBySideEditor: SideBySideEditor;
    EditorPartConfiguration_Input: IEditorPartConfiguration_Input;
    TabCloseButtonType: TabCloseButtonType;
    TabSizingType: TabSizingType;
    OpenPositioningType: OpenPositioningType;
    OpenSideBySideDirection: OpenSideBySideDirection;
    LableFormatType: LableFormatType;
    EditorPartOptions_Input: ResolverTypeWrapper<IEditorPartOptions_Input>;
    GroupDirection: GroupDirection;
    GroupLocation: GroupLocation;
    GroupsArrangement: GroupsArrangement;
    GroupLayoutArgument: ResolverTypeWrapper<IGroupLayoutArgument>;
    EditorGroupLayout: ResolverTypeWrapper<IEditorGroupLayout>;
    CopyEditorOptions_Input: ICopyEditorOptions_Input;
    AddGroupOptions_Input: IAddGroupOptions_Input;
    MergeGroupMode: MergeGroupMode;
    MergeGroupOptions_Input: IMergeGroupOptions_Input;
    CloseDirection: CloseDirection;
    CloseEditorsFilter: ResolverTypeWrapper<Omit<ICloseEditorsFilter, 'except'> & {
        except?: Maybe<IResolversTypes['EditorInput']>;
    }>;
    GroupsOrder: GroupsOrder;
    EditorsOrder: EditorsOrder;
    BaseResourceInput: IBaseResourceInput;
    CloseOptions_Input: ICloseOptions_Input;
    EditorActionType: IEditorActionType;
    EditorIdentifier: ResolverTypeWrapper<Omit<IEditorIdentifier, 'editor'> & {
        editor?: Maybe<IResolversTypes['EditorInput']>;
    }>;
    EditorSettings: ResolverTypeWrapper<IEditorSettings>;
    OpenDiff_Input: IOpenDiff_Input;
    DockLayout: ResolverTypeWrapper<Omit<IDockLayout, 'tabs'> & {
        tabs?: Maybe<Array<Maybe<IResolversTypes['EditorInput']>>>;
    }>;
    EDITOR_ID: IEDITOR_ID;
    PendingStatusbarEntry: ResolverTypeWrapper<IPendingStatusbarEntry>;
    TreeViewDescriptor: ResolverTypeWrapper<ITreeViewDescriptor>;
    RevealOptions: ResolverTypeWrapper<IRevealOptions>;
    RangeInput: IRangeInput;
    ExtensionType: IExtensionType;
    BaseExtension: ResolverTypeWrapper<IBaseExtension>;
    ExtensionConfigurationProperty: ResolverTypeWrapper<IExtensionConfigurationProperty>;
    Contributes: ResolverTypeWrapper<IContributes>;
    MessageLink: ResolverTypeWrapper<IMessageLink>;
    NotificationChangeType: INotificationChangeType;
    NotificationChangeEvent: ResolverTypeWrapper<INotificationChangeEvent>;
    NotificationViewItem: ResolverTypeWrapper<INotificationViewItem>;
    NotificationMessage: ResolverTypeWrapper<INotificationMessage>;
    NotificationViewItemProgress: ResolverTypeWrapper<INotificationViewItemProgress>;
    NotificationViewItemProgressState: ResolverTypeWrapper<INotificationViewItemProgressState>;
    NotificationViewItemLabelKind: INotificationViewItemLabelKind;
    ViewContainer: ResolverTypeWrapper<IViewContainer>;
    View: ResolverTypeWrapper<IView>;
    MenuId: IMenuId;
    MoleculerServiceName: IMoleculerServiceName;
    ConfigurationServiceAction: IConfigurationServiceAction;
    WorkspaceContextServiceAction: IWorkspaceContextServiceAction;
    EnvironmentServiceAction: IEnvironmentServiceAction;
    StorageScope: IStorageScope;
    NativeOpenDialogOptions: ResolverTypeWrapper<INativeOpenDialogOptions>;
    EnterWorkspaceResult: ResolverTypeWrapper<IEnterWorkspaceResult>;
    WorkspaceIdentifier: ResolverTypeWrapper<IWorkspaceIdentifier>;
    CrashReporterStartOptions: ResolverTypeWrapper<ICrashReporterStartOptions>;
    OpenDialogOptions: ResolverTypeWrapper<IOpenDialogOptions>;
    FileFilter: ResolverTypeWrapper<IFileFilter>;
    OpenDialogOptionsProperties: IOpenDialogOptionsProperties;
    MessageBoxResult: ResolverTypeWrapper<IMessageBoxResult>;
    OpenSettings: ResolverTypeWrapper<IOpenSettings>;
    URIToOpen: IResolversTypes['WorkspaceToOpen'] | IResolversTypes['FolderToOpen'] | IResolversTypes['FileToOpen'];
    WorkspaceToOpen: ResolverTypeWrapper<IWorkspaceToOpen>;
    FolderToOpen: ResolverTypeWrapper<IFolderToOpen>;
    FileToOpen: ResolverTypeWrapper<IFileToOpen>;
    MessageBoxOptions: ResolverTypeWrapper<IMessageBoxOptions>;
    SaveDialogOptions: ResolverTypeWrapper<ISaveDialogOptions>;
    NewWindowOptions: ResolverTypeWrapper<INewWindowOptions>;
    DevToolsOptionsMode: IDevToolsOptionsMode;
    DevToolsOptions: ResolverTypeWrapper<IDevToolsOptions>;
    OpenContext: IOpenContext;
    ReadyState: IReadyState;
    IPathData: IResolversTypes['Path'];
    Path: ResolverTypeWrapper<IPath>;
    IPathsToWaitForData: IResolversTypes['PathsToWaitFor'];
    PathsToWaitFor: ResolverTypeWrapper<IPathsToWaitFor>;
    WindowConfiguration: ResolverTypeWrapper<IWindowConfiguration>;
    OpenFileRequest: ResolverTypeWrapper<IOpenFileRequest>;
    AddFoldersRequest: ResolverTypeWrapper<IAddFoldersRequest>;
    RunActionInWindowRequestFrom: IRunActionInWindowRequestFrom;
    RunActionInWindowRequest: ResolverTypeWrapper<IRunActionInWindowRequest>;
    RunKeybindingInWindowRequest: ResolverTypeWrapper<IRunKeybindingInWindowRequest>;
    OpenConfiguration: ResolverTypeWrapper<Omit<IOpenConfiguration, 'urisToOpen'> & {
        urisToOpen?: Maybe<Array<Maybe<IResolversTypes['URIToOpen']>>>;
    }>;
    OneSearchPathPattern: ResolverTypeWrapper<IOneSearchPathPattern>;
    SearchPathPattern: ResolverTypeWrapper<ISearchPathPattern>;
    FolderQuery: ResolverTypeWrapper<IFolderQuery>;
    TextSearchPreviewOptions: ResolverTypeWrapper<ITextSearchPreviewOptions>;
    SearchStreamInput: ISearchStreamInput;
    Progress: ResolverTypeWrapper<IProgress>;
    SearchLog: ResolverTypeWrapper<ISearchLog>;
    LineMatch: ResolverTypeWrapper<ILineMatch>;
    ISearchProgress: IResolversTypes['SearchProgressItem'];
    SearchProgressItem: ResolverTypeWrapper<Omit<ISearchProgressItem, 'results'> & {
        results?: Maybe<Array<Maybe<IResolversTypes['TextSearchResult']>>>;
    }>;
    PatternInfo: ResolverTypeWrapper<IPatternInfo>;
    FileOverwriteOptions: ResolverTypeWrapper<IFileOverwriteOptions>;
    FileWriteOptions: ResolverTypeWrapper<IFileWriteOptions>;
    FileOpenOptions: ResolverTypeWrapper<IFileOpenOptions>;
    FileDeleteOptions: ResolverTypeWrapper<IFileDeleteOptions>;
    FileType: IFileType;
    Files_Stat: ResolverTypeWrapper<IFiles_Stat>;
    ResolveFileResult: ResolverTypeWrapper<IResolveFileResult>;
    VSBufferReadableStream: ResolverTypeWrapper<Scalars['VSBufferReadableStream']>;
    FileStreamContent: ResolverTypeWrapper<IFileStreamContent>;
    StreamContent: ResolverTypeWrapper<IStreamContent>;
    ResolveFileOptions_Input: IResolveFileOptions_Input;
    FileOperationResult: IFileOperationResult;
    HotExitConfiguration: IHotExitConfiguration;
    ImportResult: ResolverTypeWrapper<IImportResult>;
    ChangesChangesChunk_Input: IChangesChangesChunk_Input;
    ChunkOptions_Input: IChunkOptions_Input;
    ChangeRange: ResolverTypeWrapper<IChangeRange>;
    ContentChangedEvent: ResolverTypeWrapper<IContentChangedEvent>;
    ChangesChunk: ResolverTypeWrapper<IChangesChunk>;
    ResolveAll_toResolve_Input: IResolveAll_toResolve_Input;
    TextFileOperationResult: ITextFileOperationResult;
    ResourceEncoding: ResolverTypeWrapper<IResourceEncoding>;
    FileStateChange: IFileStateChange;
    FileResult: ResolverTypeWrapper<IFileResult>;
    ModelLoadOrCreateOptions_Input_reload: IModelLoadOrCreateOptions_Input_reload;
    ModelLoadOrCreateOptions_Input: IModelLoadOrCreateOptions_Input;
    CursorState: ResolverTypeWrapper<ICursorState>;
    ViewState: ResolverTypeWrapper<IViewState>;
    CursorState_Input: ICursorState_Input;
    ViewState_Input: IViewState_Input;
    EDITOR_INPUT_RESOURCE_TYPE_ID: IEDITOR_INPUT_RESOURCE_TYPE_ID;
    JSONObject: ResolverTypeWrapper<Scalars['JSONObject']>;
    User: ResolverTypeWrapper<IUser>;
    FieldError: ResolverTypeWrapper<IFieldError>;
    WorkspaceStackSettings: ResolverTypeWrapper<IWorkspaceStackSettings>;
};
/** Mapping between all available schema types and the resolvers parents */
export declare type IResolversParentTypes = {
    Query: {};
    ContextMenu: IContextMenu;
    String: Scalars['String'];
    Boolean: Scalars['Boolean'];
    Anchor: IAnchor;
    Int: Scalars['Int'];
    MenuItem: IMenuItem;
    ActionRun: IActionRun;
    GraphqlCallType: IGraphqlCallType;
    AnyObject: Scalars['AnyObject'];
    DefaultPreferencesResponse: IDefaultPreferencesResponse;
    PreferencesType: IPreferencesType;
    Setting: ISetting;
    Range: IRange;
    Position: IPosition;
    ConfigurationScope: ConfigurationScope;
    ConfigurationExtensionInfo: IConfigurationExtensionInfo;
    DefaultSettings: IDefaultSettings;
    ISettingsSubject: IResolversParentTypes['DefaultSettings'] | IResolversParentTypes['UserSettings'] | IResolversParentTypes['LocalUserSettings'] | IResolversParentTypes['RemoteUserSettings'] | IResolversParentTypes['FolderSettings'] | IResolversParentTypes['GlobalSettings'] | IResolversParentTypes['WorkspaceSettings'] | IResolversParentTypes['MemorySettings'];
    ID: Scalars['ID'];
    Settings: ISettings;
    URI: Scalars['URI'];
    SettingsCascade: Omit<ISettingsCascade, 'subjects'> & {
        subjects?: Maybe<Array<Maybe<IResolversParentTypes['SettingsSubject']>>>;
    };
    SettingsSubject: IResolversParentTypes['UserSettings'] | IResolversParentTypes['LocalUserSettings'] | IResolversParentTypes['RemoteUserSettings'] | IResolversParentTypes['FolderSettings'] | IResolversParentTypes['GlobalSettings'] | IResolversParentTypes['WorkspaceSettings'] | IResolversParentTypes['MemorySettings'] | IResolversParentTypes['DefaultSettings'];
    UserSettings: IUserSettings;
    LocalUserSettings: ILocalUserSettings;
    RemoteUserSettings: IRemoteUserSettings;
    FolderSettings: IFolderSettings;
    GlobalSettings: IGlobalSettings;
    WorkspaceSettings: IWorkspaceSettings;
    MemorySettings: IMemorySettings;
    Configuration: IConfiguration;
    SettingsGroup: ISettingsGroup;
    SettingsSection: ISettingsSection;
    Files: IFiles;
    AutoSaveConfigurationType: IAutoSaveConfigurationType;
    JSON: Scalars['JSON'];
    Git: IGit;
    GitDecorations: IGitDecorations;
    Languages: ILanguages;
    Output: IOutput;
    Search: ISearch;
    SearchQuickOpen: ISearchQuickOpen;
    Terminal: ITerminal;
    IStatusbarItem: IResolversParentTypes['Terminal'] | IResolversParentTypes['SelectionStatus'] | IResolversParentTypes['Indentation'] | IResolversParentTypes['EncodingStatus'] | IResolversParentTypes['EndOfLineSequence'] | IResolversParentTypes['LanguageMode'] | IResolversParentTypes['SyncStatus'] | IResolversParentTypes['BranchStatus'];
    StatusbarAlignment: IStatusbarAlignment;
    StatusbarEntry: IStatusbarEntry;
    STATUSBAR_ITEM_ID: ISTATUSBAR_ITEM_ID;
    Integrated: IIntegrated;
    ShellArgs: IShellArgs;
    Shell: IShell;
    WorkspacePreferenceWorkbench: IWorkspacePreferenceWorkbench;
    WorkspacePreferenceView: IWorkspacePreferenceView;
    WorkspacePreferenceTips: IWorkspacePreferenceTips;
    WorkspacePreferenceStatusBar: IWorkspacePreferenceStatusBar;
    WorkspacePreferenceSideBar: IWorkspacePreferenceSideBar;
    WorkspacePreferenceSettings: IWorkspacePreferenceSettings;
    WorkspacePreferenceQuickOpen: IWorkspacePreferenceQuickOpen;
    WorkspacePreferencePanel: IWorkspacePreferencePanel;
    WorkspacePreferenceList: IWorkspacePreferenceList;
    WorkspacePreferenceExperimental: IWorkspacePreferenceExperimental;
    WorkspacePreferenceEditor: IWorkspacePreferenceEditor;
    WorkspacePreferenceCommandPalette: IWorkspacePreferenceCommandPalette;
    WorkspacePreferenceActivityBar: IWorkspacePreferenceActivityBar;
    Dialog: IDialog;
    Detail: IDetail;
    InputTypeDetail: IInputTypeDetail;
    PrimaryButtonAction: IPrimaryButtonAction;
    CheckboxOptions: ICheckboxOptions;
    DocSitePage: IDocSitePage;
    EditorPart: Omit<IEditorPart, 'children'> & {
        children?: Maybe<Array<Maybe<IResolversParentTypes['EditorChildren']>>>;
    };
    GroupOrientation: GroupOrientation;
    EditorChildren: IResolversParentTypes['EditorPart'] | IResolversParentTypes['EditorGroup'];
    EditorGroup: Omit<IEditorGroup, 'tabs'> & {
        tabs?: Maybe<Array<Maybe<IResolversParentTypes['EditorInput']>>>;
    };
    IEditorGroup: IResolversParentTypes['EditorGroup'];
    EditorInput: IResolversParentTypes['DataUriEditorInput'] | IResolversParentTypes['DiffEditorInput'] | IResolversParentTypes['FileEditorInput'] | IResolversParentTypes['KeybindingEditorInput'] | IResolversParentTypes['PreferencesEditorInput'] | IResolversParentTypes['ResourceEditorInput'] | IResolversParentTypes['SideBySideEditorInput'] | IResolversParentTypes['UntitledEditorInput'];
    DataUriEditorInput: IDataUriEditorInput;
    IEditorInput: IResolversParentTypes['DataUriEditorInput'] | IResolversParentTypes['DiffEditorInput'] | IResolversParentTypes['FileEditorInput'] | IResolversParentTypes['KeybindingEditorInput'] | IResolversParentTypes['PreferencesEditorInput'] | IResolversParentTypes['ResourceEditorInput'] | IResolversParentTypes['SideBySideEditorInput'] | IResolversParentTypes['UntitledEditorInput'];
    EDITOR_INPUT_ID: IEDITOR_INPUT_ID;
    FileStatWithMetadata: IFileStatWithMetadata;
    IBaseStat: IResolversParentTypes['FileStatWithMetadata'] | IResolversParentTypes['TextFileStreamContent'] | IResolversParentTypes['TextFilePublishContent'] | IResolversParentTypes['TextFileContent'] | IResolversParentTypes['FileContent'] | IResolversParentTypes['FileStat'] | IResolversParentTypes['FileStreamContent'];
    BigInt: Scalars['BigInt'];
    IBaseStatWithMetadata: IResolversParentTypes['FileStatWithMetadata'] | IResolversParentTypes['TextFileStreamContent'] | IResolversParentTypes['TextFileContent'] | IResolversParentTypes['FileContent'] | IResolversParentTypes['FileStreamContent'];
    IContentChangedEvent: IResolversParentTypes['FileStatWithMetadata'];
    IFileClientMetadata: IResolversParentTypes['FileStatWithMetadata'] | IResolversParentTypes['TextFileContent'];
    FileModelState: IFileModelState;
    ITreeItem: IResolversParentTypes['FileStatWithMetadata'];
    IUntitledFileValue: IResolversParentTypes['FileStatWithMetadata'];
    IEditorInputWithGroupFields: IResolversParentTypes['DataUriEditorInput'] | IResolversParentTypes['DiffEditorInput'] | IResolversParentTypes['FileEditorInput'] | IResolversParentTypes['KeybindingEditorInput'] | IResolversParentTypes['PreferencesEditorInput'] | IResolversParentTypes['ResourceEditorInput'] | IResolversParentTypes['SideBySideEditorInput'] | IResolversParentTypes['UntitledEditorInput'];
    DiffEditorInput: Omit<IDiffEditorInput, 'originalInput' | 'modifiedInput'> & {
        originalInput?: Maybe<IResolversParentTypes['EditorInput']>;
        modifiedInput?: Maybe<IResolversParentTypes['EditorInput']>;
    };
    FileEditorInput: IFileEditorInput;
    IFileEditorInput: IResolversParentTypes['FileEditorInput'];
    IEncodingSupport: IResolversParentTypes['FileEditorInput'];
    IModeSupport: IResolversParentTypes['FileEditorInput'];
    KeybindingEditorInput: IKeybindingEditorInput;
    PreferencesEditorInput: Omit<IPreferencesEditorInput, 'master' | 'details'> & {
        master?: Maybe<IResolversParentTypes['EditorInput']>;
        details?: Maybe<IResolversParentTypes['EditorInput']>;
    };
    ISideBySideEditorInput: IResolversParentTypes['PreferencesEditorInput'] | IResolversParentTypes['SideBySideEditorInput'];
    ResourceEditorInput: IResourceEditorInput;
    SideBySideEditorInput: Omit<ISideBySideEditorInput, 'master' | 'details'> & {
        master?: Maybe<IResolversParentTypes['EditorInput']>;
        details?: Maybe<IResolversParentTypes['EditorInput']>;
    };
    UntitledEditorInput: IUntitledEditorInput;
    CodeEditorViewState: ICodeEditorViewState;
    RegistryExtension: IRegistryExtension;
    Node: IResolversParentTypes['RegistryExtension'];
    RegistryPublisher: IRegistryPublisher;
    ExtensionManifest: IExtensionManifest;
    ExtensionKind: IExtensionKind;
    Assets: IAssets;
    Scripts: IScripts;
    Bundles: IBundles;
    ExtensionPackageType: IExtensionPackageType;
    Engines: IEngines;
    Author: IAuthor;
    GalleryBanner: IGalleryBanner;
    ExtensionContributions: IExtensionContributions;
    Actions: IActions;
    ActionItem: IActionItem;
    ExtensionConfiguration: IExtensionConfiguration;
    Debugger: IDebugger;
    Grammar: IGrammar;
    ExtensionJSONValidation: IExtensionJSONValidation;
    KeyBinding: IKeyBinding;
    ExtensionLanguage: IExtensionLanguage;
    Menus: IMenus;
    MenuItemAction: IMenuItemAction;
    MenuItemActionContext: IMenuItemActionContext;
    MenuItemActionEditor: IMenuItemActionEditor;
    MenuItemActionEditorTitle: IMenuItemActionEditorTitle;
    MenuItemActionDebug: IMenuItemActionDebug;
    MenuItemActionScm: IMenuItemActionScm;
    MenuItemActionScmChange: IMenuItemActionScmChange;
    MenuItemActionView: IMenuItemActionView;
    Snippet: ISnippet;
    ThemeLabel: IThemeLabel;
    ExtensionColor: IExtensionColor;
    ExtensionColorTypes: IExtensionColorTypes;
    Localization: ILocalization;
    LocalizationTranslation: ILocalizationTranslation;
    ExtensionManifestBugs: IExtensionManifestBugs;
    ExtensionManifestRepository: IExtensionManifestRepository;
    ExtensionRelease: IExtensionRelease;
    ExtensionRegistry: IExtensionRegistry;
    RegistryExtensionConnection: IRegistryExtensionConnection;
    PageInfo: IPageInfo;
    RegistryPublisherConnection: IRegistryPublisherConnection;
    FileQueryInput: IFileQueryInput;
    FolderQueryInput: IFolderQueryInput;
    URIInput: IURIInput;
    QueryType: IQueryType;
    SearchComplete: Omit<ISearchComplete, 'stats'> & {
        stats: IResolversParentTypes['SearchCompleteStatsStats'];
    };
    ISearchCompleteStats: IResolversParentTypes['SearchComplete'];
    SearchCompleteStatsStats: IResolversParentTypes['FileSearchStats'] | IResolversParentTypes['TextSearchStats'];
    FileSearchStats: Omit<IFileSearchStats, 'detailStats'> & {
        detailStats?: Maybe<IResolversParentTypes['FileSearchStatsdetailStats']>;
    };
    FileSearchStatsdetailStats: IResolversParentTypes['SearchEngineStats'] | IResolversParentTypes['CachedSearchStats'] | IResolversParentTypes['FileSearchProviderStats'] | IResolversParentTypes['FileIndexProviderStats'];
    SearchEngineStats: ISearchEngineStats;
    CachedSearchStats: ICachedSearchStats;
    FileSearchProviderStats: IFileSearchProviderStats;
    FileIndexProviderStats: IFileIndexProviderStats;
    FileSearchStatsType: IFileSearchStatsType;
    TextSearchStats: ITextSearchStats;
    TextSearchStatsType: ITextSearchStatsType;
    FileMatch: Omit<IFileMatch, 'results'> & {
        results?: Maybe<Array<Maybe<IResolversParentTypes['TextSearchResult']>>>;
    };
    IFileMatch: IResolversParentTypes['FileMatch'] | IResolversParentTypes['SearchProgressItem'];
    TextSearchResult: IResolversParentTypes['TextSearchMatch'] | IResolversParentTypes['TextSearchContext'];
    TextSearchMatch: ITextSearchMatch;
    SearchRange: ISearchRange;
    TextSearchResultPreview: ITextSearchResultPreview;
    TextSearchContext: ITextSearchContext;
    GalleryQuery: IGalleryQuery;
    GalleryPager: IGalleryPager;
    GalleryExtension: IGalleryExtension;
    ExtensionIdentifier: IExtensionIdentifier;
    Float: Scalars['Float'];
    GalleryExtensionAssets: IGalleryExtensionAssets;
    GalleryExtensionAsset: IGalleryExtensionAsset;
    GalleryExtensionProperties: IGalleryExtensionProperties;
    GalleryExtensionResources: IGalleryExtensionResources;
    ConfigurationData: IConfigurationData;
    ConfigurationModel: IConfigurationModel;
    Overrides: IOverrides;
    FolderConfigurationModel: IFolderConfigurationModel;
    ConfigurationOverrides: IConfigurationOverrides;
    Context: IContext;
    scmResourceGroups: IscmResourceGroups;
    ProvidedRemoteConnectionStates: IProvidedRemoteConnectionStates;
    ConfigurationTarget: ConfigurationTarget;
    Environment: IEnvironment;
    ExtensionHostDebugParams: IExtensionHostDebugParams;
    IDebugParams: IResolversParentTypes['ExtensionHostDebugParams'];
    Keybindings: IKeybindings;
    KeybindingItem: IKeybindingItem;
    KeybindingSource: IKeybindingSource;
    SelectedOutput: ISelectedOutput;
    QuickPickItem: IQuickPickItem;
    QuickPickItemHighlights: IQuickPickItemHighlights;
    Match: IMatch;
    ViewDescriptor: IViewDescriptor;
    IViewDescriptor: IResolversParentTypes['ViewDescriptor'] | IResolversParentTypes['TreeViewDescriptor'];
    WorkspaceData: IWorkspaceData;
    IStaticWorkspaceData: IResolversParentTypes['WorkspaceData'];
    WorkspaceFolderData: IWorkspaceFolderData;
    Arg_Input: IArg_Input;
    WorkspaceValue_Input: IWorkspaceValue_Input;
    ConfigurationOverrides_Input: IConfigurationOverrides_Input;
    GoToLineQuickAccess: IGoToLineQuickAccess;
    LineRange: ILineRange;
    InstalledExtension: IInstalledExtension;
    ExtensionInstance: IExtensionInstance;
    ProcessMonitoring: IProcessMonitoring;
    KeybindingContextMenu: IKeybindingContextMenu;
    EditKeybindingItem: IEditKeybindingItem;
    Notifications: INotifications;
    Notification: INotification;
    NotificationSeverity: NotificationSeverity;
    NotificationActions: INotificationActions;
    Action: IAction;
    QuickInputModel: IQuickInputModel;
    QuickInput: IQuickInput;
    QuickPick: IQuickPick;
    ReadTextFileOptions_Input: IReadTextFileOptions_Input;
    ReadFileOptions_Input_limits: IReadFileOptions_Input_limits;
    TextFileStreamContent: ITextFileStreamContent;
    IBaseTextFileContent: IResolversParentTypes['TextFileStreamContent'] | IResolversParentTypes['TextFilePublishContent'] | IResolversParentTypes['TextFileContent'];
    TextBufferData: ITextBufferData;
    TextFilePublishContent: ITextFilePublishContent;
    FileContentStatus: IFileContentStatus;
    TextFileContent: ITextFileContent;
    TextDocumentRegistrationOptionsInput: ITextDocumentRegistrationOptionsInput;
    ProvideTextDocumentLocationSignatureInput: IProvideTextDocumentLocationSignatureInput;
    TextDocumentIdentifierInput: ITextDocumentIdentifierInput;
    PositionInput: IPositionInput;
    ReadFileOptions_Input: IReadFileOptions_Input;
    FileContent: IFileContent;
    VSBuffer: Scalars['VSBuffer'];
    ResolveAll_toResolveWithMetadata_Input: IResolveAll_toResolveWithMetadata_Input;
    ResolveMetadataFileOptions_Input: IResolveMetadataFileOptions_Input;
    ResolveFileResultWithMetadata: IResolveFileResultWithMetadata;
    LoadOptions_Input: ILoadOptions_Input;
    FileLoadReason: IFileLoadReason;
    Dialog_input: IDialog_input;
    Detail_input: IDetail_input;
    InputTypeDetail_input: IInputTypeDetail_input;
    PrimaryButtonAction_input: IPrimaryButtonAction_input;
    ActionRun_input: IActionRun_input;
    CheckboxOptions_input: ICheckboxOptions_input;
    DialogResult: IDialogResult;
    Notification_input: INotification_input;
    NotificationMessage_input: INotificationMessage_input;
    MessageLink_input: IMessageLink_input;
    NotificationActions_input: INotificationActions_input;
    Action_input: IAction_input;
    Statusbar: Omit<IStatusbar, 'items'> & {
        items?: Maybe<Array<Maybe<IResolversParentTypes['StatusbarItem']>>>;
    };
    StatusbarItem: IResolversParentTypes['Terminal'] | IResolversParentTypes['SelectionStatus'] | IResolversParentTypes['Indentation'] | IResolversParentTypes['EncodingStatus'] | IResolversParentTypes['EndOfLineSequence'] | IResolversParentTypes['LanguageMode'] | IResolversParentTypes['SyncStatus'] | IResolversParentTypes['BranchStatus'];
    SelectionStatus: ISelectionStatus;
    Indentation: IIndentation;
    EncodingStatus: IEncodingStatus;
    EndOfLineSequence: IEndOfLineSequence;
    LanguageMode: ILanguageMode;
    SyncStatus: ISyncStatus;
    BranchStatus: IBranchStatus;
    TextQueryInput: ITextQueryInput;
    PatternInfoInput: IPatternInfoInput;
    TextSearchPreviewOptionsInput: ITextSearchPreviewOptionsInput;
    TreeItem: ITreeItem;
    TreeItemCollapsibleState: ITreeItemCollapsibleState;
    UserPreferencesRes: IUserPreferencesRes;
    IUserPreferences: IIUserPreferences;
    WorkspaceRes: IWorkspaceRes;
    Mutation: {};
    IActivationRequest: IIActivationRequest;
    AddEntry_input: IAddEntry_input;
    StatusbarEntry_input: IStatusbarEntry_input;
    Folder_input: IFolder_input;
    KeybindingItem_input: IKeybindingItem_input;
    Args_input: IArgs_input;
    CloseEditor_Input: ICloseEditor_Input;
    CloseEditorOptions_Input: ICloseEditorOptions_Input;
    TextDocumentPositionParamsInput: ITextDocumentPositionParamsInput;
    Observable: Scalars['Observable'];
    CreateFileOptions_Input: ICreateFileOptions_Input;
    DeleteFileOptions_Input: IDeleteFileOptions_Input;
    EmptyResponse: IEmptyResponse;
    LineRange_input: ILineRange_input;
    IJSONValue_input: IIJSONValue_input;
    KeepOpen_Input: IKeepOpen_Input;
    MoveEditor_Input: IMoveEditor_Input;
    MoveEditorOptions_Input: IMoveEditorOptions_Input;
    PromptChoice_input: IPromptChoice_input;
    PromptChoiceRun: IPromptChoiceRun;
    PromptOptions_input: IPromptOptions_input;
    PromptOptionsCancel: IPromptOptionsCancel;
    OpenEditor_Input: IOpenEditor_Input;
    EditorOpenOptions_Input: IEditorOpenOptions_Input;
    EditorOpenPositioning: EditorOpenPositioning;
    ResourceDiff_Input: IResourceDiff_Input;
    TextEditorOptions_Input: ITextEditorOptions_Input;
    EditorActivation: IEditorActivation;
    EditorOpenContext: IEditorOpenContext;
    TextEditorSelection_Input: ITextEditorSelection_Input;
    TextEditorSelectionRevealType: ITextEditorSelectionRevealType;
    Resource_Input: IResource_Input;
    ResourceSideBySide_Input: IResourceSideBySide_Input;
    UntitledResource_Input: IUntitledResource_Input;
    OpenDocumentParamsInput: IOpenDocumentParamsInput;
    OpenDocumentTextParamsInput: IOpenDocumentTextParamsInput;
    ExtensionRegistryPublishExtensionResult: IExtensionRegistryPublishExtensionResult;
    Keybinding_input: IKeybinding_input;
    RemoveEditor_Input: IRemoveEditor_Input;
    ReplaceContentResult: IReplaceContentResult;
    KeyboardEvent_input: IKeyboardEvent_input;
    KeyboardEvent_output: IKeyboardEvent_output;
    SaveOptions_Input: ISaveOptions_Input;
    SaveReason: ISaveReason;
    FileStat: IFileStat;
    SaveWorkspaceRes: ISaveWorkspaceRes;
    SelectEditor_Input: ISelectEditor_Input;
    TreeData_Input: ITreeData_Input;
    PickItem: IPickItem;
    QuickPickItemHighlights_input: IQuickPickItemHighlights_input;
    Match_input: IMatch_input;
    SetStatusMsg_input: ISetStatusMsg_input;
    ContextMenu_input: IContextMenu_input;
    Anchor_input: IAnchor_input;
    MenuItem_input: IMenuItem_input;
    InputOptions: IInputOptions;
    PickInputOptions: IPickInputOptions;
    ContentChangedEvent_Input: IContentChangedEvent_Input;
    ChangesChunk_Input: IChangesChunk_Input;
    ChangeRange_Input: IChangeRange_Input;
    WriteFileOptions_Input: IWriteFileOptions_Input;
    CodeEditorViewState_Input: ICodeEditorViewState_Input;
    EditorLayout_Input: IEditorLayout_Input;
    EditorChildren_Input: IEditorChildren_Input;
    EditorInput_Input: IEditorInput_Input;
    IModelInput: IIModelInput;
    IWorkspaceRootInput: IIWorkspaceRootInput;
    IViewComponentDataInput: IIViewComponentDataInput;
    TextDocumentItemInput: ITextDocumentItemInput;
    UpdateEntry_input: IUpdateEntry_input;
    FoldersToAdd_Input: IFoldersToAdd_Input;
    WatchOptions_Input: IWatchOptions_Input;
    WriteTextFileOptions_Input: IWriteTextFileOptions_Input;
    UpdatedResource: IUpdatedResource;
    UpdateDelayedResource: IUpdateDelayedResource;
    Subscription: {};
    FileChange: IFileChange;
    FileChangeType: IFileChangeType;
    FileOperationOutput: IFileOperationOutput;
    FileOperation: IFileOperation;
    IConfigurationChangeEvent: IIConfigurationChangeEvent;
    ResourceMapConfigurationModel: IResourceMapConfigurationModel;
    SearchCompleteStream: Omit<ISearchCompleteStream, 'stats'> & {
        stats: IResolversParentTypes['SearchCompleteStatsStats'];
    };
    RegistryEntry: IRegistryEntry;
    TextDocumentRegistrationOptions: ITextDocumentRegistrationOptions;
    DocumentFilter: IDocumentFilter;
    ITextDocumentIdentifier: IResolversParentTypes['TextDocumentIdentifier'] | IResolversParentTypes['TextDocumentItem'];
    TextDocumentIdentifier: ITextDocumentIdentifier;
    ProvideTextDocumentLocationSignature: IProvideTextDocumentLocationSignature;
    TextDocumentPositionParams: IResolversParentTypes['ProvideTextDocumentLocationSignature'];
    Location: IResolversParentTypes['ProvideTextDocumentLocationSignature'];
    MarkupKind: IMarkupKind;
    IViewComponentData: IIViewComponentData;
    TextDocumentItem: ITextDocumentItem;
    IWorkspaceRoot: IIWorkspaceRoot;
    IModel: IIModel;
    ISwitchMapOperator: IISwitchMapOperator;
    IDocumentSelector: IIDocumentSelector;
    IBehaviorSubjectValue: IIBehaviorSubjectValue;
    IBehaviorSubject: IIBehaviorSubject;
    IDestinationAnonymousSubject: IIDestinationAnonymousSubject;
    ISourceAnonymousSubject: IISourceAnonymousSubject;
    IObservableResult: IIObservableResult;
    GalleryFilter: IGalleryFilter;
    ExtensionRegistryCreateExtensionResult: IExtensionRegistryCreateExtensionResult;
    ExtensionRegistryUpdateExtensionResult: IExtensionRegistryUpdateExtensionResult;
    SettingValueType: ISettingValueType;
    KeyPathSegment: IKeyPathSegment;
    IUserSettings: IIUserSettings;
    PreferenceItem: IPreferenceItem;
    CommandType: ICommandType;
    CommandHandlerDescriptionType: ICommandHandlerDescriptionType;
    ArgsType: IArgsType;
    CommandsType: ICommandsType;
    ContextInput: IContextInput;
    scmProviders: IscmProviders;
    commentThread: IcommentThread;
    EditorOptions_Input: IEditorOptions_Input;
    SideBySideEditor: SideBySideEditor;
    EditorPartConfiguration_Input: IEditorPartConfiguration_Input;
    TabCloseButtonType: TabCloseButtonType;
    TabSizingType: TabSizingType;
    OpenPositioningType: OpenPositioningType;
    OpenSideBySideDirection: OpenSideBySideDirection;
    LableFormatType: LableFormatType;
    EditorPartOptions_Input: IEditorPartOptions_Input;
    GroupDirection: GroupDirection;
    GroupLocation: GroupLocation;
    GroupsArrangement: GroupsArrangement;
    GroupLayoutArgument: IGroupLayoutArgument;
    EditorGroupLayout: IEditorGroupLayout;
    CopyEditorOptions_Input: ICopyEditorOptions_Input;
    AddGroupOptions_Input: IAddGroupOptions_Input;
    MergeGroupMode: MergeGroupMode;
    MergeGroupOptions_Input: IMergeGroupOptions_Input;
    CloseDirection: CloseDirection;
    CloseEditorsFilter: Omit<ICloseEditorsFilter, 'except'> & {
        except?: Maybe<IResolversParentTypes['EditorInput']>;
    };
    GroupsOrder: GroupsOrder;
    EditorsOrder: EditorsOrder;
    BaseResourceInput: IBaseResourceInput;
    CloseOptions_Input: ICloseOptions_Input;
    EditorActionType: IEditorActionType;
    EditorIdentifier: Omit<IEditorIdentifier, 'editor'> & {
        editor?: Maybe<IResolversParentTypes['EditorInput']>;
    };
    EditorSettings: IEditorSettings;
    OpenDiff_Input: IOpenDiff_Input;
    DockLayout: Omit<IDockLayout, 'tabs'> & {
        tabs?: Maybe<Array<Maybe<IResolversParentTypes['EditorInput']>>>;
    };
    EDITOR_ID: IEDITOR_ID;
    PendingStatusbarEntry: IPendingStatusbarEntry;
    TreeViewDescriptor: ITreeViewDescriptor;
    RevealOptions: IRevealOptions;
    RangeInput: IRangeInput;
    ExtensionType: IExtensionType;
    BaseExtension: IBaseExtension;
    ExtensionConfigurationProperty: IExtensionConfigurationProperty;
    Contributes: IContributes;
    MessageLink: IMessageLink;
    NotificationChangeType: INotificationChangeType;
    NotificationChangeEvent: INotificationChangeEvent;
    NotificationViewItem: INotificationViewItem;
    NotificationMessage: INotificationMessage;
    NotificationViewItemProgress: INotificationViewItemProgress;
    NotificationViewItemProgressState: INotificationViewItemProgressState;
    NotificationViewItemLabelKind: INotificationViewItemLabelKind;
    ViewContainer: IViewContainer;
    View: IView;
    MenuId: IMenuId;
    MoleculerServiceName: IMoleculerServiceName;
    ConfigurationServiceAction: IConfigurationServiceAction;
    WorkspaceContextServiceAction: IWorkspaceContextServiceAction;
    EnvironmentServiceAction: IEnvironmentServiceAction;
    StorageScope: IStorageScope;
    NativeOpenDialogOptions: INativeOpenDialogOptions;
    EnterWorkspaceResult: IEnterWorkspaceResult;
    WorkspaceIdentifier: IWorkspaceIdentifier;
    CrashReporterStartOptions: ICrashReporterStartOptions;
    OpenDialogOptions: IOpenDialogOptions;
    FileFilter: IFileFilter;
    OpenDialogOptionsProperties: IOpenDialogOptionsProperties;
    MessageBoxResult: IMessageBoxResult;
    OpenSettings: IOpenSettings;
    URIToOpen: IResolversParentTypes['WorkspaceToOpen'] | IResolversParentTypes['FolderToOpen'] | IResolversParentTypes['FileToOpen'];
    WorkspaceToOpen: IWorkspaceToOpen;
    FolderToOpen: IFolderToOpen;
    FileToOpen: IFileToOpen;
    MessageBoxOptions: IMessageBoxOptions;
    SaveDialogOptions: ISaveDialogOptions;
    NewWindowOptions: INewWindowOptions;
    DevToolsOptionsMode: IDevToolsOptionsMode;
    DevToolsOptions: IDevToolsOptions;
    OpenContext: IOpenContext;
    ReadyState: IReadyState;
    IPathData: IResolversParentTypes['Path'];
    Path: IPath;
    IPathsToWaitForData: IResolversParentTypes['PathsToWaitFor'];
    PathsToWaitFor: IPathsToWaitFor;
    WindowConfiguration: IWindowConfiguration;
    OpenFileRequest: IOpenFileRequest;
    AddFoldersRequest: IAddFoldersRequest;
    RunActionInWindowRequestFrom: IRunActionInWindowRequestFrom;
    RunActionInWindowRequest: IRunActionInWindowRequest;
    RunKeybindingInWindowRequest: IRunKeybindingInWindowRequest;
    OpenConfiguration: Omit<IOpenConfiguration, 'urisToOpen'> & {
        urisToOpen?: Maybe<Array<Maybe<IResolversParentTypes['URIToOpen']>>>;
    };
    OneSearchPathPattern: IOneSearchPathPattern;
    SearchPathPattern: ISearchPathPattern;
    FolderQuery: IFolderQuery;
    TextSearchPreviewOptions: ITextSearchPreviewOptions;
    SearchStreamInput: ISearchStreamInput;
    Progress: IProgress;
    SearchLog: ISearchLog;
    LineMatch: ILineMatch;
    ISearchProgress: IResolversParentTypes['SearchProgressItem'];
    SearchProgressItem: Omit<ISearchProgressItem, 'results'> & {
        results?: Maybe<Array<Maybe<IResolversParentTypes['TextSearchResult']>>>;
    };
    PatternInfo: IPatternInfo;
    FileOverwriteOptions: IFileOverwriteOptions;
    FileWriteOptions: IFileWriteOptions;
    FileOpenOptions: IFileOpenOptions;
    FileDeleteOptions: IFileDeleteOptions;
    FileType: IFileType;
    Files_Stat: IFiles_Stat;
    ResolveFileResult: IResolveFileResult;
    VSBufferReadableStream: Scalars['VSBufferReadableStream'];
    FileStreamContent: IFileStreamContent;
    StreamContent: IStreamContent;
    ResolveFileOptions_Input: IResolveFileOptions_Input;
    FileOperationResult: IFileOperationResult;
    HotExitConfiguration: IHotExitConfiguration;
    ImportResult: IImportResult;
    ChangesChangesChunk_Input: IChangesChangesChunk_Input;
    ChunkOptions_Input: IChunkOptions_Input;
    ChangeRange: IChangeRange;
    ContentChangedEvent: IContentChangedEvent;
    ChangesChunk: IChangesChunk;
    ResolveAll_toResolve_Input: IResolveAll_toResolve_Input;
    TextFileOperationResult: ITextFileOperationResult;
    ResourceEncoding: IResourceEncoding;
    FileStateChange: IFileStateChange;
    FileResult: IFileResult;
    ModelLoadOrCreateOptions_Input_reload: IModelLoadOrCreateOptions_Input_reload;
    ModelLoadOrCreateOptions_Input: IModelLoadOrCreateOptions_Input;
    CursorState: ICursorState;
    ViewState: IViewState;
    CursorState_Input: ICursorState_Input;
    ViewState_Input: IViewState_Input;
    EDITOR_INPUT_RESOURCE_TYPE_ID: IEDITOR_INPUT_RESOURCE_TYPE_ID;
    JSONObject: Scalars['JSONObject'];
    User: IUser;
    FieldError: IFieldError;
    WorkspaceStackSettings: IWorkspaceStackSettings;
};
export declare type IActionResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Action'] = IResolversParentTypes['Action']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    tooltip?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    class?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    enabled?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    checked?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    radio?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    run?: Resolver<Maybe<IResolversTypes['ActionRun']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IActionItemResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ActionItem'] = IResolversParentTypes['ActionItem']> = {
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IActionRunResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ActionRun'] = IResolversParentTypes['ActionRun']> = {
    type?: Resolver<Maybe<IResolversTypes['GraphqlCallType']>, ParentType, ContextType>;
    document?: Resolver<Maybe<IResolversTypes['AnyObject']>, ParentType, ContextType>;
    variables?: Resolver<Maybe<IResolversTypes['AnyObject']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IActionsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Actions'] = IResolversParentTypes['Actions']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    command?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    title?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    category?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    actionItem?: Resolver<Maybe<IResolversTypes['ActionItem']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IAddFoldersRequestResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['AddFoldersRequest'] = IResolversParentTypes['AddFoldersRequest']> = {
    foldersToAdd?: Resolver<Maybe<Array<Maybe<IResolversTypes['URI']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IAnchorResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Anchor'] = IResolversParentTypes['Anchor']> = {
    x?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    y?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    height?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    width?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export interface IAnyObjectScalarConfig extends GraphQLScalarTypeConfig<IResolversTypes['AnyObject'], any> {
    name: 'AnyObject';
}
export declare type IArgsTypeResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ArgsType'] = IResolversParentTypes['ArgsType']> = {
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    constraint?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IAssetsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Assets'] = IResolversParentTypes['Assets']> = {
    Type?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    Content?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IAuthorResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Author'] = IResolversParentTypes['Author']> = {
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IBaseExtensionResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['BaseExtension'] = IResolversParentTypes['BaseExtension']> = {
    type?: Resolver<Maybe<IResolversTypes['ExtensionType']>, ParentType, ContextType>;
    identifier?: Resolver<Maybe<IResolversTypes['ExtensionIdentifier']>, ParentType, ContextType>;
    galleryIdentifier?: Resolver<Maybe<IResolversTypes['ExtensionIdentifier']>, ParentType, ContextType>;
    manifest?: Resolver<Maybe<IResolversTypes['ExtensionManifest']>, ParentType, ContextType>;
    location?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export interface IBigIntScalarConfig extends GraphQLScalarTypeConfig<IResolversTypes['BigInt'], any> {
    name: 'BigInt';
}
export declare type IBranchStatusResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['BranchStatus'] = IResolversParentTypes['BranchStatus']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    alignment?: Resolver<Maybe<IResolversTypes['StatusbarAlignment']>, ParentType, ContextType>;
    entry?: Resolver<Maybe<IResolversTypes['StatusbarEntry']>, ParentType, ContextType>;
    priority?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    container?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    labelContainer?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    typeId?: Resolver<Maybe<IResolversTypes['STATUSBAR_ITEM_ID']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IBundlesResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Bundles'] = IResolversParentTypes['Bundles']> = {
    server?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    browser?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ICachedSearchStatsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['CachedSearchStats'] = IResolversParentTypes['CachedSearchStats']> = {
    cacheWasResolved?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    cacheLookupTime?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    cacheFilterTime?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    cacheEntryCount?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IChangeRangeResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ChangeRange'] = IResolversParentTypes['ChangeRange']> = {
    startLineNumber?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    startColumn?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    endLineNumber?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    endColumn?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IChangesChunkResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ChangesChunk'] = IResolversParentTypes['ChangesChunk']> = {
    range?: Resolver<Maybe<IResolversTypes['ChangeRange']>, ParentType, ContextType>;
    rangeLength?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    text?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    rangeOffset?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    forceMoveMarkers?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ICheckboxOptionsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['CheckboxOptions'] = IResolversParentTypes['CheckboxOptions']> = {
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    checked?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ICloseEditorsFilterResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['CloseEditorsFilter'] = IResolversParentTypes['CloseEditorsFilter']> = {
    except?: Resolver<Maybe<IResolversTypes['EditorInput']>, ParentType, ContextType>;
    direction?: Resolver<Maybe<IResolversTypes['CloseDirection']>, ParentType, ContextType>;
    savedOnly?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ICodeEditorViewStateResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['CodeEditorViewState'] = IResolversParentTypes['CodeEditorViewState']> = {
    cursorState?: Resolver<Maybe<IResolversTypes['JSON']>, ParentType, ContextType>;
    viewState?: Resolver<Maybe<IResolversTypes['JSON']>, ParentType, ContextType>;
    contributionsState?: Resolver<Maybe<IResolversTypes['JSON']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ICommandHandlerDescriptionTypeResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['CommandHandlerDescriptionType'] = IResolversParentTypes['CommandHandlerDescriptionType']> = {
    description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    args?: Resolver<Maybe<Array<Maybe<IResolversTypes['ArgsType']>>>, ParentType, ContextType>;
    returns?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ICommandsTypeResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['CommandsType'] = IResolversParentTypes['CommandsType']> = {
    commands?: Resolver<Maybe<Array<Maybe<IResolversTypes['CommandType']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ICommandTypeResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['CommandType'] = IResolversParentTypes['CommandType']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    handler?: Resolver<Maybe<IResolversTypes['AnyObject']>, ParentType, ContextType>;
    description?: Resolver<Maybe<IResolversTypes['CommandHandlerDescriptionType']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IConfigurationResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Configuration'] = IResolversParentTypes['Configuration']> = {
    defaultSetting?: Resolver<Maybe<Array<Maybe<IResolversTypes['SettingsGroup']>>>, ParentType, ContextType>;
    files?: Resolver<Maybe<IResolversTypes['Files']>, ParentType, ContextType>;
    git?: Resolver<Maybe<IResolversTypes['Git']>, ParentType, ContextType>;
    languages?: Resolver<Maybe<IResolversTypes['Languages']>, ParentType, ContextType>;
    output?: Resolver<Maybe<IResolversTypes['Output']>, ParentType, ContextType>;
    search?: Resolver<Maybe<IResolversTypes['Search']>, ParentType, ContextType>;
    terminal?: Resolver<Maybe<IResolversTypes['Terminal']>, ParentType, ContextType>;
    workspace?: Resolver<Maybe<IResolversTypes['WorkspacePreferenceWorkbench']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IConfigurationDataResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ConfigurationData'] = IResolversParentTypes['ConfigurationData']> = {
    defaults?: Resolver<Maybe<IResolversTypes['ConfigurationModel']>, ParentType, ContextType>;
    user?: Resolver<Maybe<IResolversTypes['ConfigurationModel']>, ParentType, ContextType>;
    workspace?: Resolver<Maybe<IResolversTypes['ConfigurationModel']>, ParentType, ContextType>;
    folders?: Resolver<Maybe<Array<Maybe<IResolversTypes['FolderConfigurationModel']>>>, ParentType, ContextType>;
    isComplete?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IConfigurationExtensionInfoResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ConfigurationExtensionInfo'] = IResolversParentTypes['ConfigurationExtensionInfo']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IConfigurationModelResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ConfigurationModel'] = IResolversParentTypes['ConfigurationModel']> = {
    contents?: Resolver<Maybe<IResolversTypes['AnyObject']>, ParentType, ContextType>;
    keys?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    overrides?: Resolver<Maybe<Array<Maybe<IResolversTypes['Overrides']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IConfigurationOverridesResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ConfigurationOverrides'] = IResolversParentTypes['ConfigurationOverrides']> = {
    resource?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    overrideIdentifier?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IContentChangedEventResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ContentChangedEvent'] = IResolversParentTypes['ContentChangedEvent']> = {
    changes?: Resolver<Maybe<Array<Maybe<IResolversTypes['ChangesChunk']>>>, ParentType, ContextType>;
    eol?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    versionId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    isUndoing?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isRedoing?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isFlush?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IContextResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Context'] = IResolversParentTypes['Context']> = {
    originalResourceScheme?: Resolver<Maybe<IResolversTypes['scmResourceGroups']>, ParentType, ContextType>;
    view?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    viewItem?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    gitOpenRepositoryCount?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    isInDiffEditor?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isInDiffRightEditor?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    resourceScheme?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    resourceFilename?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    resourceLangId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    resource?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    resourceExtName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    resourceSet?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isFileSystemResource?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inputFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    suggestWidgetVisible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    suggestWidgetMultipleSuggestions?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    suggestionMakesTextEdit?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    acceptSuggestionOnEnter?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    hasOtherSuggestions?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    groupFocusedInOpenEditors?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    dirtyEditor?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    resourceSelectedForCompare?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    fileCopied?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    breadcrumbsPossible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    breadcrumbsVisible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    breadcrumbsActive?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    canNavigateBack?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    canNavigateForward?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    canNavigateToLastEditLocation?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    dirtyDiffVisible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    cancellableOperation?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    parameterHintsVisible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    parameterHintsMultipleSignatures?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    markdownPreviewFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isMac?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isLinux?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isWindows?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    remoteAuthority?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    remoteConnectionState?: Resolver<Maybe<IResolversTypes['ProvidedRemoteConnectionStates']>, ParentType, ContextType>;
    hasMacNativeTabs?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    supportsWorkspaces?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isDevelopment?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    workbenchState?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    workspaceFolderCount?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    remoteFileDialogVisible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isFullscreen?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    atEndOfWord?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    scmRepository?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    scmProvider?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    scmResourceGroup?: Resolver<Maybe<IResolversTypes['scmResourceGroups']>, ParentType, ContextType>;
    inDiffEditorKey?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isDominatedByLongLines?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isWordWrapMinified?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    commentThread?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    commentThreadisEmpty?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    commentIsEmpty?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    commentEditorFocused?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    interfaceOverviewVisible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inReferenceSearchEditor?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    referenceSearchVisible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    listFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    listSupportsMultiSelect?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    listHasSelectionOrFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    listDoubleSelection?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    listMultiSelection?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    listSupportsKeyboardNavigation?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    WorkbenchListAutomaticKeyboardNavigationKey?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    accessibilityHelpWidgetVisible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inQuickOpenKey?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    supportedCodeAction?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    hasSymbols?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    hasSnippetCompletions?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    messageVisible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorHasCallHierarchyProvider?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    callHierarchyVisible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    searchViewletVisible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    searchViewletFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inputBoxFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    searchInputBoxFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    replaceInputBoxFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    patternIncludesInputBoxFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    patternExcludesInputBoxFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    replaceActive?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    hasSearchResult?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    firstMatchFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    fileMatchOrMatchFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    fileMatchOrFolderMatchFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    fileMatchFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    folderMatchFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    matchFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inRecentFilesPicker?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inWindowsPicker?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    findWidgetVisible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    findInputFocussed?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    replaceInputFocussed?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorTextFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    textInputFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorReadonly?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorHasSelection?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorHasMultipleSelections?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorTabMoveFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isInEmbeddedEditor?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    canUndo?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    canRedo?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorLangId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    editorHasCompletionItemProvider?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorHasCodeActionsProvider?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorHasDefinitionProvider?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorHasDeclarationProvider?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorHasImplementationProvider?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorHasTypeDefinitionProvider?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorHasHoverProvider?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorHadDocumentHighlightProvider?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorHasDocumentSymbolProvider?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorHasReferenceProvider?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorHasRenameProvider?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorHasSignatureHelpProvider?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorHasDocumentFormattingProvider?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorHasDocumentSelectionFormattingProvider?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorHasMultipleDocumentSelectionFormattingProvider?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    activeEditor?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    editorIsOpen?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorPinned?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    groupActiveEditorDirty?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    groupEditorsCount?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    textCompareEditorVisible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    textCompareEditorActive?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    activeEditorGroupEmpty?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    multipleEditorGroups?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inZenMode?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inCenteredLayout?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    splitEditorsVertically?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    sideBarVisible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    sideBarFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    activeViewlet?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    activePanel?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    panelFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    panelPosition?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    debugType?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    debugConfigurationType?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    debugState?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    inDebugMode?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inDebugRepl?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    breakpointWidgetVisible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    watchExpressionsFocused?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    variablesFocused?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    expressionSelected?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    breakpointSelected?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    callStackItemType?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    loadedScriptsSupported?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    loadedScriptsItemType?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    focusedSessionIsAttach?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    stepBackSupported?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    restartFrameSupported?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inSettingsEditor?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inSettingsJSONEditor?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inSettingsSearch?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    settingsTocRowFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inKeybindings?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inKeybindingsSearch?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    keybindingFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    explorerViewletVisible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    explorerResourceIsFolder?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    explorerResourceReadonly?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    explorerResourceIsRoot?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    explorerResourceCut?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    explorerResourceMoveableToTrash?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    filesExplorerFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    openEditorsVisible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    openEditorsFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    explorerViewletFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    terminalIsOpen?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    terminalFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    terminalTextSelected?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    terminalFindWidgetVisible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    terminalFindWidgetInputFocused?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    terminalFindWidgetFocused?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    webviewFindWidgetVisible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    taskRunning?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    referenceSearchTreeFocused?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    interactivePlaygroundFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    outlineFiltered?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    outlineFocused?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    problemsViewFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    problemFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    problemsFilterFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    relatedInformationFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inOutput?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    activeLogOutput?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    multiCursorModifier?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    saveConflictResolutionContext?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    markersNavigationVisible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    hasWordHighlights?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    profileSessionState?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    extensionHostProfileRecorded?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    historyNavigationEnabled?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    historyNavigationWidget?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    nonEmptyWorkspace?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    defaultExtensionViews?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    searchMarketplaceExtensions?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    searchInstalledExtensions?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    searchOutdatedExtensions?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    searchEnabledExtensions?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    searchDisabledExtensions?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    hasInstalledExtensions?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    searchBuiltInExtensions?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    recommendedExtensions?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    defaultRecommendedExtensions?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    workspaceRecommendations?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    workspaceFolderRecommendations?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    addToWorkspaceRecommendations?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    addToWorkspaceFolderRecommendations?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IContextMenuResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ContextMenu'] = IResolversParentTypes['ContextMenu']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    isShow?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    anchor?: Resolver<Maybe<IResolversTypes['Anchor']>, ParentType, ContextType>;
    menuItems?: Resolver<Maybe<Array<Maybe<IResolversTypes['MenuItem']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IContributesResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Contributes'] = IResolversParentTypes['Contributes']> = {
    menus?: Resolver<Maybe<IResolversTypes['Menus']>, ParentType, ContextType>;
    actions?: Resolver<Maybe<Array<Maybe<IResolversTypes['Actions']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ICrashReporterStartOptionsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['CrashReporterStartOptions'] = IResolversParentTypes['CrashReporterStartOptions']> = {
    companyName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    submitURL?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    productName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    uploadToServer?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    ignoreSystemCrashHandler?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    extra?: Resolver<Maybe<IResolversTypes['AnyObject']>, ParentType, ContextType>;
    crashesDirectory?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ICursorStateResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['CursorState'] = IResolversParentTypes['CursorState']> = {
    inSelectionMode?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    selectionStart?: Resolver<Maybe<IResolversTypes['Position']>, ParentType, ContextType>;
    position?: Resolver<Maybe<IResolversTypes['Position']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IDataUriEditorInputResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['DataUriEditorInput'] = IResolversParentTypes['DataUriEditorInput']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    resource?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    typeId?: Resolver<Maybe<IResolversTypes['EDITOR_INPUT_ID']>, ParentType, ContextType>;
    description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    fileReference?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType>;
    preferredEditorId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    isSupportsSplitEditor?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isActive?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    preview?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isPinned?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    status?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    closable?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    mime?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    etag?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    size?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IDebuggerResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Debugger'] = IResolversParentTypes['Debugger']> = {
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    type?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    runtime?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IDefaultPreferencesResponseResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['DefaultPreferencesResponse'] = IResolversParentTypes['DefaultPreferencesResponse']> = {
    preferences?: Resolver<Maybe<Array<Maybe<IResolversTypes['PreferencesType']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IDefaultSettingsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['DefaultSettings'] = IResolversParentTypes['DefaultSettings']> = {
    id?: Resolver<Maybe<IResolversTypes['ID']>, ParentType, ContextType>;
    latestSettings?: Resolver<Maybe<IResolversTypes['Settings']>, ParentType, ContextType>;
    settingsURL?: Resolver<IResolversTypes['URI'], ParentType, ContextType>;
    viewerCanAdminister?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>;
    settingsCascade?: Resolver<IResolversTypes['SettingsCascade'], ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IDetailResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Detail'] = IResolversParentTypes['Detail']> = {
    inputName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    inputType?: Resolver<Maybe<IResolversTypes['InputTypeDetail']>, ParentType, ContextType>;
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    placeholder?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    defaultValue?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    required?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IDevToolsOptionsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['DevToolsOptions'] = IResolversParentTypes['DevToolsOptions']> = {
    mode?: Resolver<Maybe<IResolversTypes['DevToolsOptionsMode']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IDialogResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Dialog'] = IResolversParentTypes['Dialog']> = {
    dialogType?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    detail?: Resolver<Maybe<Array<Maybe<IResolversTypes['Detail']>>>, ParentType, ContextType>;
    primaryButton?: Resolver<Maybe<IResolversTypes['PrimaryButtonAction']>, ParentType, ContextType>;
    secondaryButton?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    checkbox?: Resolver<Maybe<IResolversTypes['CheckboxOptions']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IDialogResultResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['DialogResult'] = IResolversParentTypes['DialogResult']> = {
    confirmed?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    checkboxChecked?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IDiffEditorInputResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['DiffEditorInput'] = IResolversParentTypes['DiffEditorInput']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    resource?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    typeId?: Resolver<Maybe<IResolversTypes['EDITOR_INPUT_ID']>, ParentType, ContextType>;
    description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    fileReference?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType>;
    preferredEditorId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    isSupportsSplitEditor?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isActive?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    preview?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isPinned?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    status?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    closable?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    originalInput?: Resolver<Maybe<IResolversTypes['EditorInput']>, ParentType, ContextType>;
    modifiedInput?: Resolver<Maybe<IResolversTypes['EditorInput']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IDockLayoutResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['DockLayout'] = IResolversParentTypes['DockLayout']> = {
    id?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    size?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    activeId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    mode?: Resolver<Maybe<IResolversTypes['GroupOrientation']>, ParentType, ContextType>;
    children?: Resolver<Maybe<Array<Maybe<IResolversTypes['DockLayout']>>>, ParentType, ContextType>;
    tabs?: Resolver<Maybe<Array<Maybe<IResolversTypes['EditorInput']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IDocSitePageResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['DocSitePage'] = IResolversParentTypes['DocSitePage']> = {
    title?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    contentHTML?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    indexHTML?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    filePath?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IDocumentFilterResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['DocumentFilter'] = IResolversParentTypes['DocumentFilter']> = {
    language?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    schema?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    pattern?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IEditKeybindingItemResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['EditKeybindingItem'] = IResolversParentTypes['EditKeybindingItem']> = {
    command?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    key?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    when?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    isDefault?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IEditorChildrenResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['EditorChildren'] = IResolversParentTypes['EditorChildren']> = {
    __resolveType: TypeResolveFn<'EditorPart' | 'EditorGroup', ParentType, ContextType>;
};
export declare type IEditorGroupResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['EditorGroup'] = IResolversParentTypes['EditorGroup']> = {
    id?: Resolver<IResolversTypes['Int'], ParentType, ContextType>;
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    isActive?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    size?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    activeId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    tabs?: Resolver<Maybe<Array<Maybe<IResolversTypes['EditorInput']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IEditorGroupLayoutResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['EditorGroupLayout'] = IResolversParentTypes['EditorGroupLayout']> = {
    orientation?: Resolver<Maybe<IResolversTypes['GroupOrientation']>, ParentType, ContextType>;
    groups?: Resolver<Maybe<Array<Maybe<IResolversTypes['GroupLayoutArgument']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IEditorIdentifierResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['EditorIdentifier'] = IResolversParentTypes['EditorIdentifier']> = {
    groupId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    editor?: Resolver<Maybe<IResolversTypes['EditorInput']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IEditorInputResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['EditorInput'] = IResolversParentTypes['EditorInput']> = {
    __resolveType: TypeResolveFn<'DataUriEditorInput' | 'DiffEditorInput' | 'FileEditorInput' | 'KeybindingEditorInput' | 'PreferencesEditorInput' | 'ResourceEditorInput' | 'SideBySideEditorInput' | 'UntitledEditorInput', ParentType, ContextType>;
};
export declare type IEditorPartResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['EditorPart'] = IResolversParentTypes['EditorPart']> = {
    id?: Resolver<IResolversTypes['Int'], ParentType, ContextType>;
    mode?: Resolver<Maybe<IResolversTypes['GroupOrientation']>, ParentType, ContextType>;
    height?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    size?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    children?: Resolver<Maybe<Array<Maybe<IResolversTypes['EditorChildren']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IEditorPartOptions_InputResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['EditorPartOptions_Input'] = IResolversParentTypes['EditorPartOptions_Input']> = {
    showTabs?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    highlightModifiedTabs?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    tabCloseButton?: Resolver<Maybe<IResolversTypes['TabCloseButtonType']>, ParentType, ContextType>;
    tabSizing?: Resolver<Maybe<IResolversTypes['TabSizingType']>, ParentType, ContextType>;
    focusRecentEditorAfterClose?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    showIcons?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    enablePreview?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    enablePreviewFromQuickOpen?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    closeOnFileDelete?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    openPositioning?: Resolver<Maybe<IResolversTypes['OpenPositioningType']>, ParentType, ContextType>;
    openSideBySideDirection?: Resolver<Maybe<IResolversTypes['OpenSideBySideDirection']>, ParentType, ContextType>;
    closeEmptyGroup?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    revealIfOpen?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    swipeToNavigate?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    labelFormat?: Resolver<Maybe<IResolversTypes['LableFormatType']>, ParentType, ContextType>;
    restoreViewState?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    iconTheme?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IEditorSettingsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['EditorSettings'] = IResolversParentTypes['EditorSettings']> = {
    editorOpenPositioning?: Resolver<Maybe<IResolversTypes['EditorOpenPositioning']>, ParentType, ContextType>;
    focusRecentEditorAfterClose?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IEmptyResponseResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['EmptyResponse'] = IResolversParentTypes['EmptyResponse']> = {
    alwaysNil?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IEncodingStatusResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['EncodingStatus'] = IResolversParentTypes['EncodingStatus']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    alignment?: Resolver<Maybe<IResolversTypes['StatusbarAlignment']>, ParentType, ContextType>;
    entry?: Resolver<Maybe<IResolversTypes['StatusbarEntry']>, ParentType, ContextType>;
    priority?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    container?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    labelContainer?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    typeId?: Resolver<Maybe<IResolversTypes['STATUSBAR_ITEM_ID']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IEndOfLineSequenceResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['EndOfLineSequence'] = IResolversParentTypes['EndOfLineSequence']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    alignment?: Resolver<Maybe<IResolversTypes['StatusbarAlignment']>, ParentType, ContextType>;
    entry?: Resolver<Maybe<IResolversTypes['StatusbarEntry']>, ParentType, ContextType>;
    priority?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    container?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    labelContainer?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    typeId?: Resolver<Maybe<IResolversTypes['STATUSBAR_ITEM_ID']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IEnginesResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Engines'] = IResolversParentTypes['Engines']> = {
    node?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    vscode?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IEnterWorkspaceResultResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['EnterWorkspaceResult'] = IResolversParentTypes['EnterWorkspaceResult']> = {
    workspace?: Resolver<IResolversTypes['WorkspaceIdentifier'], ParentType, ContextType>;
    backupPath?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IEnvironmentResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Environment'] = IResolversParentTypes['Environment']> = {
    args?: Resolver<Maybe<IResolversTypes['AnyObject']>, ParentType, ContextType>;
    execPath?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    cliPath?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    appRoot?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    userHome?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    userDataPath?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    appNameLong?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    appQuality?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    appSettingsHome?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    appSettingsPath?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    appKeybindingsPath?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    settingsSearchBuildId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    settingsSearchUrl?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    globalStorageHome?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    workspaceStorageHome?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    backupHome?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    backupWorkspacesPath?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    untitledWorkspacesHome?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    workspacesHome?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    workspacesProjectPath?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    workspaceSettingsPath?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    isExtensionDevelopment?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    disableExtensions?: Resolver<Maybe<IResolversTypes['AnyObject']>, ParentType, ContextType>;
    builtinExtensionsPath?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    extensionsPath?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    extensionDevelopmentLocationURI?: Resolver<Maybe<Array<Maybe<IResolversTypes['URI']>>>, ParentType, ContextType>;
    extensionTestsPath?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    debugExtensionHost?: Resolver<Maybe<IResolversTypes['ExtensionHostDebugParams']>, ParentType, ContextType>;
    debugSearch?: Resolver<Maybe<IResolversTypes['IDebugParams']>, ParentType, ContextType>;
    logExtensionHostCommunication?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isBuilt?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    wait?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    status?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    performance?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    log?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    logsPath?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    verbose?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    logLevel?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    skipGettingStarted?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    skipReleaseNotes?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    skipAddToRecentlyOpened?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    nodeCachedDataDir?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    installSourcePath?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    disableUpdates?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    disableCrashReporter?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    driverHandle?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    driverVerbose?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    keyboardLayoutResource?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    keybindingsResource?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    userRoamingDataHome?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    settingsResource?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IExtensionColorResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ExtensionColor'] = IResolversParentTypes['ExtensionColor']> = {
    id?: Resolver<Maybe<IResolversTypes['ID']>, ParentType, ContextType>;
    description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    defaults?: Resolver<Maybe<IResolversTypes['ExtensionColorTypes']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IExtensionColorTypesResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ExtensionColorTypes'] = IResolversParentTypes['ExtensionColorTypes']> = {
    light?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    dark?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    highContrast?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IExtensionConfigurationResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ExtensionConfiguration'] = IResolversParentTypes['ExtensionConfiguration']> = {
    properties?: Resolver<Maybe<IResolversTypes['JSON']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IExtensionConfigurationPropertyResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ExtensionConfigurationProperty'] = IResolversParentTypes['ExtensionConfigurationProperty']> = {
    description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    type?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    defaults?: Resolver<Maybe<IResolversTypes['JSON']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IExtensionContributionsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ExtensionContributions'] = IResolversParentTypes['ExtensionContributions']> = {
    actions?: Resolver<Maybe<Array<Maybe<IResolversTypes['Actions']>>>, ParentType, ContextType>;
    commands?: Resolver<Maybe<Array<Maybe<IResolversTypes['Actions']>>>, ParentType, ContextType>;
    configuration?: Resolver<Maybe<Array<Maybe<IResolversTypes['ExtensionConfiguration']>>>, ParentType, ContextType>;
    debuggers?: Resolver<Maybe<Array<Maybe<IResolversTypes['Debugger']>>>, ParentType, ContextType>;
    grammars?: Resolver<Maybe<Array<Maybe<IResolversTypes['Grammar']>>>, ParentType, ContextType>;
    jsonValidation?: Resolver<Maybe<Array<Maybe<IResolversTypes['ExtensionJSONValidation']>>>, ParentType, ContextType>;
    keybindings?: Resolver<Maybe<Array<Maybe<IResolversTypes['KeyBinding']>>>, ParentType, ContextType>;
    languages?: Resolver<Maybe<Array<Maybe<IResolversTypes['ExtensionLanguage']>>>, ParentType, ContextType>;
    menus?: Resolver<Maybe<IResolversTypes['Menus']>, ParentType, ContextType>;
    snippets?: Resolver<Maybe<Array<Maybe<IResolversTypes['Snippet']>>>, ParentType, ContextType>;
    themes?: Resolver<Maybe<Array<Maybe<IResolversTypes['ThemeLabel']>>>, ParentType, ContextType>;
    iconThemes?: Resolver<Maybe<Array<Maybe<IResolversTypes['ThemeLabel']>>>, ParentType, ContextType>;
    viewsContainers?: Resolver<Maybe<IResolversTypes['JSON']>, ParentType, ContextType>;
    views?: Resolver<Maybe<IResolversTypes['JSON']>, ParentType, ContextType>;
    colors?: Resolver<Maybe<Array<Maybe<IResolversTypes['ExtensionColor']>>>, ParentType, ContextType>;
    localizations?: Resolver<Maybe<Array<Maybe<IResolversTypes['Localization']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IExtensionHostDebugParamsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ExtensionHostDebugParams'] = IResolversParentTypes['ExtensionHostDebugParams']> = {
    port?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    break?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    debugId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IExtensionIdentifierResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ExtensionIdentifier'] = IResolversParentTypes['ExtensionIdentifier']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    uuid?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IExtensionInstanceResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ExtensionInstance'] = IResolversParentTypes['ExtensionInstance']> = {
    pid?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    path?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    env?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    status?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    extensionID?: Resolver<Maybe<IResolversTypes['ID']>, ParentType, ContextType>;
    monit?: Resolver<Maybe<IResolversTypes['ProcessMonitoring']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IExtensionJSONValidationResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ExtensionJSONValidation'] = IResolversParentTypes['ExtensionJSONValidation']> = {
    fileMatch?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    url?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IExtensionLanguageResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ExtensionLanguage'] = IResolversParentTypes['ExtensionLanguage']> = {
    id?: Resolver<Maybe<IResolversTypes['ID']>, ParentType, ContextType>;
    extensions?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    aliases?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IExtensionManifestResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ExtensionManifest'] = IResolversParentTypes['ExtensionManifest']> = {
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    version?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    main?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    badges?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    preview?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    keywords?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    license?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    homepage?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    publisher?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    categories?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    extensionID?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    displayName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    dependencies?: Resolver<Maybe<IResolversTypes['JSON']>, ParentType, ContextType>;
    devDependencies?: Resolver<Maybe<IResolversTypes['JSON']>, ParentType, ContextType>;
    extensionPack?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    extensionKind?: Resolver<Maybe<IResolversTypes['ExtensionKind']>, ParentType, ContextType>;
    extensionDependencies?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    bundle?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    raw?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    assets?: Resolver<Maybe<Array<Maybe<IResolversTypes['Assets']>>>, ParentType, ContextType>;
    scripts?: Resolver<Maybe<IResolversTypes['Scripts']>, ParentType, ContextType>;
    bundles?: Resolver<Maybe<IResolversTypes['Bundles']>, ParentType, ContextType>;
    bundleURL?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    extension?: Resolver<Maybe<IResolversTypes['ExtensionPackageType']>, ParentType, ContextType>;
    engines?: Resolver<Maybe<IResolversTypes['Engines']>, ParentType, ContextType>;
    makrdown?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    qna?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    author?: Resolver<Maybe<IResolversTypes['Author']>, ParentType, ContextType>;
    galleryBanner?: Resolver<Maybe<IResolversTypes['GalleryBanner']>, ParentType, ContextType>;
    activationEvents?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    contributes?: Resolver<Maybe<IResolversTypes['ExtensionContributions']>, ParentType, ContextType>;
    icon?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    bugs?: Resolver<Maybe<IResolversTypes['ExtensionManifestBugs']>, ParentType, ContextType>;
    repository?: Resolver<Maybe<IResolversTypes['ExtensionManifestRepository']>, ParentType, ContextType>;
    enableProposedApi?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    api?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IExtensionManifestBugsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ExtensionManifestBugs'] = IResolversParentTypes['ExtensionManifestBugs']> = {
    url?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    email?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IExtensionManifestRepositoryResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ExtensionManifestRepository'] = IResolversParentTypes['ExtensionManifestRepository']> = {
    type?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    url?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IExtensionPackageTypeResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ExtensionPackageType'] = IResolversParentTypes['ExtensionPackageType']> = {
    type?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IExtensionRegistryResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ExtensionRegistry'] = IResolversParentTypes['ExtensionRegistry']> = {
    extension?: Resolver<Maybe<IResolversTypes['RegistryExtension']>, ParentType, ContextType, RequireFields<IExtensionRegistryextensionArgs, 'extensionID'>>;
    extensions?: Resolver<IResolversTypes['RegistryExtensionConnection'], ParentType, ContextType, RequireFields<IExtensionRegistryextensionsArgs, 'local' | 'remote' | 'includeWIP'>>;
    releases?: Resolver<Maybe<Array<Maybe<IResolversTypes['ExtensionRelease']>>>, ParentType, ContextType, RequireFields<IExtensionRegistryreleasesArgs, 'extensionID'>>;
    publishers?: Resolver<IResolversTypes['RegistryPublisherConnection'], ParentType, ContextType, RequireFields<IExtensionRegistrypublishersArgs, never>>;
    viewerPublishers?: Resolver<Array<IResolversTypes['RegistryPublisher']>, ParentType, ContextType>;
    localExtensionIDPrefix?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IExtensionRegistryCreateExtensionResultResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ExtensionRegistryCreateExtensionResult'] = IResolversParentTypes['ExtensionRegistryCreateExtensionResult']> = {
    extension?: Resolver<IResolversTypes['RegistryExtension'], ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IExtensionRegistryPublishExtensionResultResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ExtensionRegistryPublishExtensionResult'] = IResolversParentTypes['ExtensionRegistryPublishExtensionResult']> = {
    extension?: Resolver<IResolversTypes['RegistryExtension'], ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IExtensionRegistryUpdateExtensionResultResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ExtensionRegistryUpdateExtensionResult'] = IResolversParentTypes['ExtensionRegistryUpdateExtensionResult']> = {
    extension?: Resolver<IResolversTypes['RegistryExtension'], ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IExtensionReleaseResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ExtensionRelease'] = IResolversParentTypes['ExtensionRelease']> = {
    id?: Resolver<Maybe<IResolversTypes['ID']>, ParentType, ContextType>;
    bundle?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    bundleURL?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    version?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    manifest?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    sourceMap?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    extensionID?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    creatorUserId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    releaseVersion?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    activationEvents?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFieldErrorResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['FieldError'] = IResolversParentTypes['FieldError']> = {
    field?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    message?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFileChangeResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['FileChange'] = IResolversParentTypes['FileChange']> = {
    type?: Resolver<Maybe<IResolversTypes['FileChangeType']>, ParentType, ContextType>;
    resource?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFileContentResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['FileContent'] = IResolversParentTypes['FileContent']> = {
    resource?: Resolver<IResolversTypes['URI'], ParentType, ContextType>;
    name?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    mtime?: Resolver<IResolversTypes['BigInt'], ParentType, ContextType>;
    etag?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    size?: Resolver<IResolversTypes['Int'], ParentType, ContextType>;
    isReadonly?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    value?: Resolver<Maybe<IResolversTypes['VSBuffer']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFileDeleteOptionsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['FileDeleteOptions'] = IResolversParentTypes['FileDeleteOptions']> = {
    recursive?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>;
    useTrash?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFileEditorInputResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['FileEditorInput'] = IResolversParentTypes['FileEditorInput']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    resource?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    typeId?: Resolver<Maybe<IResolversTypes['EDITOR_INPUT_ID']>, ParentType, ContextType>;
    description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    fileReference?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType>;
    preferredEditorId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    isSupportsSplitEditor?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isActive?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    preview?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isPinned?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    status?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    closable?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    preferredEncoding?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    preferredMode?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    forceOpenAsBinary?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    encoding?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    mode?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFileFilterResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['FileFilter'] = IResolversParentTypes['FileFilter']> = {
    extensions?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFileIndexProviderStatsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['FileIndexProviderStats'] = IResolversParentTypes['FileIndexProviderStats']> = {
    providerTime?: Resolver<IResolversTypes['Int'], ParentType, ContextType>;
    providerResultCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>;
    fileWalkTime?: Resolver<IResolversTypes['Int'], ParentType, ContextType>;
    directoriesWalked?: Resolver<IResolversTypes['Int'], ParentType, ContextType>;
    filesWalked?: Resolver<IResolversTypes['Int'], ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFileMatchResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['FileMatch'] = IResolversParentTypes['FileMatch']> = {
    resource?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    results?: Resolver<Maybe<Array<Maybe<IResolversTypes['TextSearchResult']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFileOpenOptionsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['FileOpenOptions'] = IResolversParentTypes['FileOpenOptions']> = {
    create?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFileOperationOutputResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['FileOperationOutput'] = IResolversParentTypes['FileOperationOutput']> = {
    resource?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    target?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType>;
    operation?: Resolver<Maybe<IResolversTypes['FileOperation']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFileOverwriteOptionsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['FileOverwriteOptions'] = IResolversParentTypes['FileOverwriteOptions']> = {
    overwrite?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFileResultResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['FileResult'] = IResolversParentTypes['FileResult']> = {
    source?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    target?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    success?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFilesResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Files'] = IResolversParentTypes['Files']> = {
    eol?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    hotExit?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    encoding?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    autoSave?: Resolver<Maybe<IResolversTypes['AutoSaveConfigurationType']>, ParentType, ContextType>;
    autoSaveDelay?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    defaultLanguage?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    autoGuessEncoding?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    insertFinalNewline?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    trimTrailingWhitespace?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    useExperimentalFileWatcher?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    watcherExclude?: Resolver<Maybe<IResolversTypes['JSON']>, ParentType, ContextType>;
    exclude?: Resolver<Maybe<IResolversTypes['JSON']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFiles_StatResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Files_Stat'] = IResolversParentTypes['Files_Stat']> = {
    type?: Resolver<Maybe<IResolversTypes['FileType']>, ParentType, ContextType>;
    mtime?: Resolver<Maybe<IResolversTypes['BigInt']>, ParentType, ContextType>;
    ctime?: Resolver<Maybe<IResolversTypes['BigInt']>, ParentType, ContextType>;
    size?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFileSearchProviderStatsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['FileSearchProviderStats'] = IResolversParentTypes['FileSearchProviderStats']> = {
    providerTime?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    postProcessTime?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFileSearchStatsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['FileSearchStats'] = IResolversParentTypes['FileSearchStats']> = {
    fromCache?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    detailStats?: Resolver<Maybe<IResolversTypes['FileSearchStatsdetailStats']>, ParentType, ContextType>;
    resultCount?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    type?: Resolver<Maybe<IResolversTypes['FileSearchStatsType']>, ParentType, ContextType>;
    sortingTime?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFileSearchStatsdetailStatsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['FileSearchStatsdetailStats'] = IResolversParentTypes['FileSearchStatsdetailStats']> = {
    __resolveType: TypeResolveFn<'SearchEngineStats' | 'CachedSearchStats' | 'FileSearchProviderStats' | 'FileIndexProviderStats', ParentType, ContextType>;
};
export declare type IFileStatResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['FileStat'] = IResolversParentTypes['FileStat']> = {
    resource?: Resolver<IResolversTypes['URI'], ParentType, ContextType>;
    name?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    size?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    mtime?: Resolver<Maybe<IResolversTypes['BigInt']>, ParentType, ContextType>;
    etag?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    isReadonly?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isDirectory?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isSymbolicLink?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    children?: Resolver<Maybe<Array<Maybe<IResolversTypes['FileStat']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFileStatWithMetadataResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['FileStatWithMetadata'] = IResolversParentTypes['FileStatWithMetadata']> = {
    active?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    changes?: Resolver<Maybe<IResolversTypes['JSON']>, ParentType, ContextType>;
    children?: Resolver<Maybe<Array<Maybe<IResolversTypes['FileStatWithMetadata']>>>, ParentType, ContextType>;
    childrenGen?: Resolver<Maybe<Array<Maybe<IResolversTypes['FileStatWithMetadata']>>>, ParentType, ContextType>;
    dirty?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    encoding?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    eol?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    etag?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    expanded?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    hasChildren?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inConflictMode?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inErrorMode?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inOrphanMode?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inPendingSave?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isDirectory?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isEmpty?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isFlush?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isReadonly?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isRedoing?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isSymbolicLink?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isUndoing?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    mtime?: Resolver<IResolversTypes['BigInt'], ParentType, ContextType>;
    name?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    path?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    preferredEncoding?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    preferredMode?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    resource?: Resolver<IResolversTypes['URI'], ParentType, ContextType>;
    resourcePath?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    size?: Resolver<IResolversTypes['Int'], ParentType, ContextType>;
    state?: Resolver<Maybe<IResolversTypes['FileModelState']>, ParentType, ContextType>;
    subtitle?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    title?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    value?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    versionId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFileStreamContentResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['FileStreamContent'] = IResolversParentTypes['FileStreamContent']> = {
    resource?: Resolver<IResolversTypes['URI'], ParentType, ContextType>;
    name?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    mtime?: Resolver<IResolversTypes['BigInt'], ParentType, ContextType>;
    etag?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    size?: Resolver<IResolversTypes['Int'], ParentType, ContextType>;
    isReadonly?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    value?: Resolver<Maybe<IResolversTypes['VSBufferReadableStream']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFileToOpenResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['FileToOpen'] = IResolversParentTypes['FileToOpen']> = {
    fileUri?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFileWriteOptionsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['FileWriteOptions'] = IResolversParentTypes['FileWriteOptions']> = {
    overwrite?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>;
    create?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFolderConfigurationModelResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['FolderConfigurationModel'] = IResolversParentTypes['FolderConfigurationModel']> = {
    id?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    contents?: Resolver<Maybe<IResolversTypes['AnyObject']>, ParentType, ContextType>;
    keys?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    overrides?: Resolver<Maybe<IResolversTypes['ConfigurationOverrides']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFolderQueryResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['FolderQuery'] = IResolversParentTypes['FolderQuery']> = {
    folder?: Resolver<IResolversTypes['URI'], ParentType, ContextType>;
    excludePattern?: Resolver<Maybe<IResolversTypes['AnyObject']>, ParentType, ContextType>;
    includePattern?: Resolver<Maybe<IResolversTypes['AnyObject']>, ParentType, ContextType>;
    fileEncoding?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    disregardIgnoreFiles?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFolderSettingsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['FolderSettings'] = IResolversParentTypes['FolderSettings']> = {
    id?: Resolver<Maybe<IResolversTypes['ID']>, ParentType, ContextType>;
    latestSettings?: Resolver<Maybe<IResolversTypes['Settings']>, ParentType, ContextType>;
    settingsURL?: Resolver<IResolversTypes['URI'], ParentType, ContextType>;
    viewerCanAdminister?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>;
    settingsCascade?: Resolver<IResolversTypes['SettingsCascade'], ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFolderToOpenResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['FolderToOpen'] = IResolversParentTypes['FolderToOpen']> = {
    folderUri?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IGalleryBannerResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['GalleryBanner'] = IResolversParentTypes['GalleryBanner']> = {
    color?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    theme?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IGalleryExtensionResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['GalleryExtension'] = IResolversParentTypes['GalleryExtension']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    identifier?: Resolver<Maybe<IResolversTypes['ExtensionIdentifier']>, ParentType, ContextType>;
    version?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    date?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    icon?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    displayName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    publisherId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    publisher?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    publisherDisplayName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    installCount?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    rating?: Resolver<Maybe<IResolversTypes['Float']>, ParentType, ContextType>;
    ratingCount?: Resolver<Maybe<IResolversTypes['Float']>, ParentType, ContextType>;
    assets?: Resolver<Maybe<IResolversTypes['GalleryExtensionAssets']>, ParentType, ContextType>;
    properties?: Resolver<Maybe<IResolversTypes['GalleryExtensionProperties']>, ParentType, ContextType>;
    preview?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    resources?: Resolver<Maybe<IResolversTypes['GalleryExtensionResources']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IGalleryExtensionAssetResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['GalleryExtensionAsset'] = IResolversParentTypes['GalleryExtensionAsset']> = {
    uri?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    fallbackUri?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IGalleryExtensionAssetsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['GalleryExtensionAssets'] = IResolversParentTypes['GalleryExtensionAssets']> = {
    manifest?: Resolver<Maybe<IResolversTypes['GalleryExtensionAsset']>, ParentType, ContextType>;
    readme?: Resolver<Maybe<IResolversTypes['GalleryExtensionAsset']>, ParentType, ContextType>;
    changelog?: Resolver<Maybe<IResolversTypes['GalleryExtensionAsset']>, ParentType, ContextType>;
    download?: Resolver<Maybe<IResolversTypes['GalleryExtensionAsset']>, ParentType, ContextType>;
    icon?: Resolver<Maybe<IResolversTypes['GalleryExtensionAsset']>, ParentType, ContextType>;
    license?: Resolver<Maybe<IResolversTypes['GalleryExtensionAsset']>, ParentType, ContextType>;
    repository?: Resolver<Maybe<IResolversTypes['GalleryExtensionAsset']>, ParentType, ContextType>;
    coreTranslations?: Resolver<Maybe<IResolversTypes['JSON']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IGalleryExtensionPropertiesResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['GalleryExtensionProperties'] = IResolversParentTypes['GalleryExtensionProperties']> = {
    engine?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    dependencies?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    extensionPack?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    localizedLanguages?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IGalleryExtensionResourcesResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['GalleryExtensionResources'] = IResolversParentTypes['GalleryExtensionResources']> = {
    manifest?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    readme?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    changelog?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    download?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    icon?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    license?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    repository?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IGalleryPagerResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['GalleryPager'] = IResolversParentTypes['GalleryPager']> = {
    page?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    total?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    pageSize?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    firstPage?: Resolver<Maybe<Array<Maybe<IResolversTypes['GalleryExtension']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IGitResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Git'] = IResolversParentTypes['Git']> = {
    path?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    enabled?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    autofetch?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    countBadge?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    autorefresh?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    confirmSync?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    checkoutType?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    inputValidation?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    detectSubmodules?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    enableSmartCommit?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    ignoreLimitWarning?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    ignoreLegacyWarning?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    enableCommitSigning?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    defaultCloneDirectory?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    autoRepositoryDetection?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    ignoreMissingGitWarning?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    showInlineOpenFileAction?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    promptToSaveFilesBeforeCommit?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    decorations?: Resolver<Maybe<IResolversTypes['GitDecorations']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IGitDecorationsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['GitDecorations'] = IResolversParentTypes['GitDecorations']> = {
    enabled?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IGlobalSettingsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['GlobalSettings'] = IResolversParentTypes['GlobalSettings']> = {
    id?: Resolver<Maybe<IResolversTypes['ID']>, ParentType, ContextType>;
    latestSettings?: Resolver<Maybe<IResolversTypes['Settings']>, ParentType, ContextType>;
    settingsURL?: Resolver<IResolversTypes['URI'], ParentType, ContextType>;
    viewerCanAdminister?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>;
    settingsCascade?: Resolver<IResolversTypes['SettingsCascade'], ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IGoToLineQuickAccessResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['GoToLineQuickAccess'] = IResolversParentTypes['GoToLineQuickAccess']> = {
    range?: Resolver<Maybe<IResolversTypes['LineRange']>, ParentType, ContextType>;
    highlight?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    focus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IGrammarResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Grammar'] = IResolversParentTypes['Grammar']> = {
    language?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IGroupLayoutArgumentResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['GroupLayoutArgument'] = IResolversParentTypes['GroupLayoutArgument']> = {
    size?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    groups?: Resolver<Maybe<Array<Maybe<IResolversTypes['GroupLayoutArgument']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IIBaseStatResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['IBaseStat'] = IResolversParentTypes['IBaseStat']> = {
    __resolveType: TypeResolveFn<'FileStatWithMetadata' | 'TextFileStreamContent' | 'TextFilePublishContent' | 'TextFileContent' | 'FileContent' | 'FileStat' | 'FileStreamContent', ParentType, ContextType>;
    resource?: Resolver<IResolversTypes['URI'], ParentType, ContextType>;
    name?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    size?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    mtime?: Resolver<Maybe<IResolversTypes['BigInt']>, ParentType, ContextType>;
    etag?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    isReadonly?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
};
export declare type IIBaseStatWithMetadataResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['IBaseStatWithMetadata'] = IResolversParentTypes['IBaseStatWithMetadata']> = {
    __resolveType: TypeResolveFn<'FileStatWithMetadata' | 'TextFileStreamContent' | 'TextFileContent' | 'FileContent' | 'FileStreamContent', ParentType, ContextType>;
    mtime?: Resolver<IResolversTypes['BigInt'], ParentType, ContextType>;
    etag?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    size?: Resolver<IResolversTypes['Int'], ParentType, ContextType>;
};
export declare type IIBaseTextFileContentResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['IBaseTextFileContent'] = IResolversParentTypes['IBaseTextFileContent']> = {
    __resolveType: TypeResolveFn<'TextFileStreamContent' | 'TextFilePublishContent' | 'TextFileContent', ParentType, ContextType>;
    encoding?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
};
export declare type IIBehaviorSubjectResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['IBehaviorSubject'] = IResolversParentTypes['IBehaviorSubject']> = {
    closed?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    hasError?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isStopped?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    observers?: Resolver<Maybe<Array<Maybe<IResolversTypes['JSON']>>>, ParentType, ContextType>;
    thrownError?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    _isScalar?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    value?: Resolver<Maybe<Array<Maybe<IResolversTypes['IBehaviorSubjectValue']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IIBehaviorSubjectValueResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['IBehaviorSubjectValue'] = IResolversParentTypes['IBehaviorSubjectValue']> = {
    provider?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    registrationOptions?: Resolver<Maybe<IResolversTypes['IDocumentSelector']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IIConfigurationChangeEventResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['IConfigurationChangeEvent'] = IResolversParentTypes['IConfigurationChangeEvent']> = {
    source?: Resolver<Maybe<IResolversTypes['ConfigurationTarget']>, ParentType, ContextType>;
    affectedKeys?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    sourceConfig?: Resolver<Maybe<IResolversTypes['AnyObject']>, ParentType, ContextType>;
    changedConfiguration?: Resolver<Maybe<IResolversTypes['ConfigurationModel']>, ParentType, ContextType>;
    changedConfigurationByResource?: Resolver<Maybe<IResolversTypes['ResourceMapConfigurationModel']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IIContentChangedEventResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['IContentChangedEvent'] = IResolversParentTypes['IContentChangedEvent']> = {
    __resolveType: TypeResolveFn<'FileStatWithMetadata', ParentType, ContextType>;
    changes?: Resolver<Maybe<IResolversTypes['JSON']>, ParentType, ContextType>;
    eol?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    versionId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    isUndoing?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isRedoing?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isFlush?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
};
export declare type IIDebugParamsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['IDebugParams'] = IResolversParentTypes['IDebugParams']> = {
    __resolveType: TypeResolveFn<'ExtensionHostDebugParams', ParentType, ContextType>;
    port?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    break?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
};
export declare type IIDestinationAnonymousSubjectResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['IDestinationAnonymousSubject'] = IResolversParentTypes['IDestinationAnonymousSubject']> = {
    closed?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    destination?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    hasError?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isStopped?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    observers?: Resolver<Maybe<Array<Maybe<IResolversTypes['JSON']>>>, ParentType, ContextType>;
    operator?: Resolver<Maybe<IResolversTypes['ISwitchMapOperator']>, ParentType, ContextType>;
    source?: Resolver<Maybe<IResolversTypes['IBehaviorSubject']>, ParentType, ContextType>;
    thrownError?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    _isScalar?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IIDocumentSelectorResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['IDocumentSelector'] = IResolversParentTypes['IDocumentSelector']> = {
    documentSelector?: Resolver<Maybe<IResolversTypes['JSON']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IIEditorGroupResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['IEditorGroup'] = IResolversParentTypes['IEditorGroup']> = {
    __resolveType: TypeResolveFn<'EditorGroup', ParentType, ContextType>;
    id?: Resolver<IResolversTypes['Int'], ParentType, ContextType>;
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
};
export declare type IIEditorInputResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['IEditorInput'] = IResolversParentTypes['IEditorInput']> = {
    __resolveType: TypeResolveFn<'DataUriEditorInput' | 'DiffEditorInput' | 'FileEditorInput' | 'KeybindingEditorInput' | 'PreferencesEditorInput' | 'ResourceEditorInput' | 'SideBySideEditorInput' | 'UntitledEditorInput', ParentType, ContextType>;
    resource?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    typeId?: Resolver<Maybe<IResolversTypes['EDITOR_INPUT_ID']>, ParentType, ContextType>;
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    fileReference?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType>;
    preferredEditorId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    isSupportsSplitEditor?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
};
export declare type IIEditorInputWithGroupFieldsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['IEditorInputWithGroupFields'] = IResolversParentTypes['IEditorInputWithGroupFields']> = {
    __resolveType: TypeResolveFn<'DataUriEditorInput' | 'DiffEditorInput' | 'FileEditorInput' | 'KeybindingEditorInput' | 'PreferencesEditorInput' | 'ResourceEditorInput' | 'SideBySideEditorInput' | 'UntitledEditorInput', ParentType, ContextType>;
    isActive?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isPinned?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    preview?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    status?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    closable?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
};
export declare type IIEncodingSupportResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['IEncodingSupport'] = IResolversParentTypes['IEncodingSupport']> = {
    __resolveType: TypeResolveFn<'FileEditorInput', ParentType, ContextType>;
    encoding?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
};
export declare type IIFileClientMetadataResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['IFileClientMetadata'] = IResolversParentTypes['IFileClientMetadata']> = {
    __resolveType: TypeResolveFn<'FileStatWithMetadata' | 'TextFileContent', ParentType, ContextType>;
    dirty?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inConflictMode?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inOrphanMode?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inErrorMode?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inPendingSave?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    preferredMode?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    encoding?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    preferredEncoding?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    state?: Resolver<Maybe<IResolversTypes['FileModelState']>, ParentType, ContextType>;
};
export declare type IIFileEditorInputResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['IFileEditorInput'] = IResolversParentTypes['IFileEditorInput']> = {
    __resolveType: TypeResolveFn<'FileEditorInput', ParentType, ContextType>;
    preferredEncoding?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    preferredMode?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    forceOpenAsBinary?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
};
export declare type IIFileMatchResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['IFileMatch'] = IResolversParentTypes['IFileMatch']> = {
    __resolveType: TypeResolveFn<'FileMatch' | 'SearchProgressItem', ParentType, ContextType>;
    resource?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    results?: Resolver<Maybe<Array<Maybe<IResolversTypes['TextSearchResult']>>>, ParentType, ContextType>;
};
export declare type IIModelResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['IModel'] = IResolversParentTypes['IModel']> = {
    roots?: Resolver<Maybe<IResolversTypes['IWorkspaceRoot']>, ParentType, ContextType>;
    visibleViewComponents?: Resolver<Maybe<Array<Maybe<IResolversTypes['IViewComponentData']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IIModeSupportResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['IModeSupport'] = IResolversParentTypes['IModeSupport']> = {
    __resolveType: TypeResolveFn<'FileEditorInput', ParentType, ContextType>;
    mode?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
};
export declare type IImportResultResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ImportResult'] = IResolversParentTypes['ImportResult']> = {
    stat?: Resolver<Maybe<IResolversTypes['FileStat']>, ParentType, ContextType>;
    isNew?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IIndentationResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Indentation'] = IResolversParentTypes['Indentation']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    alignment?: Resolver<Maybe<IResolversTypes['StatusbarAlignment']>, ParentType, ContextType>;
    entry?: Resolver<Maybe<IResolversTypes['StatusbarEntry']>, ParentType, ContextType>;
    priority?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    container?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    labelContainer?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    typeId?: Resolver<Maybe<IResolversTypes['STATUSBAR_ITEM_ID']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IInputTypeDetailResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['InputTypeDetail'] = IResolversParentTypes['InputTypeDetail']> = {
    type?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    options?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IInstalledExtensionResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['InstalledExtension'] = IResolversParentTypes['InstalledExtension']> = {
    extension?: Resolver<Maybe<IResolversTypes['GalleryExtension']>, ParentType, ContextType>;
    identifier?: Resolver<Maybe<IResolversTypes['ExtensionIdentifier']>, ParentType, ContextType>;
    galleryIdentifier?: Resolver<Maybe<IResolversTypes['ExtensionIdentifier']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IIntegratedResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Integrated'] = IResolversParentTypes['Integrated']> = {
    setLocaleVariables?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    shellArgs?: Resolver<Maybe<IResolversTypes['ShellArgs']>, ParentType, ContextType>;
    shell?: Resolver<Maybe<IResolversTypes['Shell']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IIObservableResultResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['IObservableResult'] = IResolversParentTypes['IObservableResult']> = {
    closed?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    destination?: Resolver<Maybe<IResolversTypes['IDestinationAnonymousSubject']>, ParentType, ContextType>;
    hasError?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isStopped?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    observers?: Resolver<Maybe<Array<Maybe<IResolversTypes['JSON']>>>, ParentType, ContextType>;
    operator?: Resolver<Maybe<IResolversTypes['ISwitchMapOperator']>, ParentType, ContextType>;
    source?: Resolver<Maybe<IResolversTypes['ISourceAnonymousSubject']>, ParentType, ContextType>;
    thrownError?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    _isScalar?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IIPathDataResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['IPathData'] = IResolversParentTypes['IPathData']> = {
    __resolveType: TypeResolveFn<'Path', ParentType, ContextType>;
    fileUri?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    lineNumber?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    columnNumber?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    exists?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
};
export declare type IIPathsToWaitForDataResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['IPathsToWaitForData'] = IResolversParentTypes['IPathsToWaitForData']> = {
    __resolveType: TypeResolveFn<'PathsToWaitFor', ParentType, ContextType>;
    paths?: Resolver<Maybe<Array<Maybe<IResolversTypes['IPathData']>>>, ParentType, ContextType>;
    waitMarkerFileUri?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
};
export declare type IISearchCompleteStatsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ISearchCompleteStats'] = IResolversParentTypes['ISearchCompleteStats']> = {
    __resolveType: TypeResolveFn<'SearchComplete', ParentType, ContextType>;
    limitHit?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    stats?: Resolver<Maybe<IResolversTypes['SearchCompleteStatsStats']>, ParentType, ContextType>;
};
export declare type IISearchProgressResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ISearchProgress'] = IResolversParentTypes['ISearchProgress']> = {
    __resolveType: TypeResolveFn<'SearchProgressItem', ParentType, ContextType>;
    total?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    worked?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    message?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
};
export declare type IISettingsSubjectResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ISettingsSubject'] = IResolversParentTypes['ISettingsSubject']> = {
    __resolveType: TypeResolveFn<'DefaultSettings' | 'UserSettings' | 'LocalUserSettings' | 'RemoteUserSettings' | 'FolderSettings' | 'GlobalSettings' | 'WorkspaceSettings' | 'MemorySettings', ParentType, ContextType>;
    id?: Resolver<Maybe<IResolversTypes['ID']>, ParentType, ContextType>;
    latestSettings?: Resolver<Maybe<IResolversTypes['Settings']>, ParentType, ContextType>;
    settingsURL?: Resolver<IResolversTypes['URI'], ParentType, ContextType>;
    viewerCanAdminister?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>;
    settingsCascade?: Resolver<IResolversTypes['SettingsCascade'], ParentType, ContextType>;
};
export declare type IISideBySideEditorInputResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ISideBySideEditorInput'] = IResolversParentTypes['ISideBySideEditorInput']> = {
    __resolveType: TypeResolveFn<'PreferencesEditorInput' | 'SideBySideEditorInput', ParentType, ContextType>;
    master?: Resolver<Maybe<IResolversTypes['EditorInput']>, ParentType, ContextType>;
    details?: Resolver<Maybe<IResolversTypes['EditorInput']>, ParentType, ContextType>;
};
export declare type IISourceAnonymousSubjectResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ISourceAnonymousSubject'] = IResolversParentTypes['ISourceAnonymousSubject']> = {
    closed?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    destination?: Resolver<Maybe<IResolversTypes['IDestinationAnonymousSubject']>, ParentType, ContextType>;
    hasError?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isStopped?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    observers?: Resolver<Maybe<Array<Maybe<IResolversTypes['JSON']>>>, ParentType, ContextType>;
    operator?: Resolver<Maybe<IResolversTypes['ISwitchMapOperator']>, ParentType, ContextType>;
    source?: Resolver<Maybe<IResolversTypes['IBehaviorSubject']>, ParentType, ContextType>;
    thrownError?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    _isScalar?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IIStaticWorkspaceDataResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['IStaticWorkspaceData'] = IResolversParentTypes['IStaticWorkspaceData']> = {
    __resolveType: TypeResolveFn<'WorkspaceData', ParentType, ContextType>;
    id?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    configuration?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    isUntitled?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
};
export declare type IIStatusbarItemResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['IStatusbarItem'] = IResolversParentTypes['IStatusbarItem']> = {
    __resolveType: TypeResolveFn<'Terminal' | 'SelectionStatus' | 'Indentation' | 'EncodingStatus' | 'EndOfLineSequence' | 'LanguageMode' | 'SyncStatus' | 'BranchStatus', ParentType, ContextType>;
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    alignment?: Resolver<Maybe<IResolversTypes['StatusbarAlignment']>, ParentType, ContextType>;
    entry?: Resolver<Maybe<IResolversTypes['StatusbarEntry']>, ParentType, ContextType>;
    priority?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    container?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    labelContainer?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    typeId?: Resolver<Maybe<IResolversTypes['STATUSBAR_ITEM_ID']>, ParentType, ContextType>;
};
export declare type IISwitchMapOperatorResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ISwitchMapOperator'] = IResolversParentTypes['ISwitchMapOperator']> = {
    project?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IITextDocumentIdentifierResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ITextDocumentIdentifier'] = IResolversParentTypes['ITextDocumentIdentifier']> = {
    __resolveType: TypeResolveFn<'TextDocumentIdentifier' | 'TextDocumentItem', ParentType, ContextType>;
    uri?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    languageId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
};
export declare type IITreeItemResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ITreeItem'] = IResolversParentTypes['ITreeItem']> = {
    __resolveType: TypeResolveFn<'FileStatWithMetadata', ParentType, ContextType>;
    path?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    title?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    subtitle?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    isDirectory?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    active?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    expanded?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    hasChildren?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isEmpty?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
};
export declare type IIUntitledFileValueResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['IUntitledFileValue'] = IResolversParentTypes['IUntitledFileValue']> = {
    __resolveType: TypeResolveFn<'FileStatWithMetadata', ParentType, ContextType>;
    value?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
};
export declare type IIUserPreferencesResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['IUserPreferences'] = IResolversParentTypes['IUserPreferences']> = {
    content?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    user?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IIUserSettingsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['IUserSettings'] = IResolversParentTypes['IUserSettings']> = {
    data?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IIViewComponentDataResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['IViewComponentData'] = IResolversParentTypes['IViewComponentData']> = {
    type?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    item?: Resolver<Maybe<IResolversTypes['TextDocumentItem']>, ParentType, ContextType>;
    isActive?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IIViewDescriptorResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['IViewDescriptor'] = IResolversParentTypes['IViewDescriptor']> = {
    __resolveType: TypeResolveFn<'ViewDescriptor' | 'TreeViewDescriptor', ParentType, ContextType>;
    id?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    when?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    order?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    weight?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    collapsed?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    canToggleVisibility?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    hideByDefault?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    workspace?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
};
export declare type IIWorkspaceRootResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['IWorkspaceRoot'] = IResolversParentTypes['IWorkspaceRoot']> = {
    url?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export interface IJSONScalarConfig extends GraphQLScalarTypeConfig<IResolversTypes['JSON'], any> {
    name: 'JSON';
}
export interface IJSONObjectScalarConfig extends GraphQLScalarTypeConfig<IResolversTypes['JSONObject'], any> {
    name: 'JSONObject';
}
export declare type IKeyBindingResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['KeyBinding'] = IResolversParentTypes['KeyBinding']> = {
    command?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    key?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    when?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    mac?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    linux?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    win?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IKeybindingContextMenuResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['KeybindingContextMenu'] = IResolversParentTypes['KeybindingContextMenu']> = {
    editItem?: Resolver<Maybe<IResolversTypes['EditKeybindingItem']>, ParentType, ContextType>;
    selectedItemIndex?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    editWhenIndex?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    newWhen?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    isOpenDialog?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    search?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IKeybindingEditorInputResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['KeybindingEditorInput'] = IResolversParentTypes['KeybindingEditorInput']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    resource?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    typeId?: Resolver<Maybe<IResolversTypes['EDITOR_INPUT_ID']>, ParentType, ContextType>;
    description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    fileReference?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType>;
    preferredEditorId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    isSupportsSplitEditor?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isActive?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    preview?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isPinned?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    status?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    closable?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IKeybindingItemResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['KeybindingItem'] = IResolversParentTypes['KeybindingItem']> = {
    command?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    key?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    when?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    source?: Resolver<Maybe<IResolversTypes['KeybindingSource']>, ParentType, ContextType>;
    run?: Resolver<Maybe<IResolversTypes['ActionRun']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IKeybindingsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Keybindings'] = IResolversParentTypes['Keybindings']> = {
    items?: Resolver<Maybe<Array<Maybe<IResolversTypes['KeybindingItem']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IKeyboardEvent_outputResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['KeyboardEvent_output'] = IResolversParentTypes['KeyboardEvent_output']> = {
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    key?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ILanguageModeResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['LanguageMode'] = IResolversParentTypes['LanguageMode']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    alignment?: Resolver<Maybe<IResolversTypes['StatusbarAlignment']>, ParentType, ContextType>;
    entry?: Resolver<Maybe<IResolversTypes['StatusbarEntry']>, ParentType, ContextType>;
    priority?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    container?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    labelContainer?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    typeId?: Resolver<Maybe<IResolversTypes['STATUSBAR_ITEM_ID']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ILanguagesResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Languages'] = IResolversParentTypes['Languages']> = {
    go?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    css?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    html?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    json?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    yaml?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    typescript?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    javascript?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ILineMatchResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['LineMatch'] = IResolversParentTypes['LineMatch']> = {
    preview?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    lineNumber?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    offsetAndLengths?: Resolver<Maybe<Array<Maybe<Array<Maybe<IResolversTypes['Int']>>>>>, ParentType, ContextType>;
    part?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ILineRangeResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['LineRange'] = IResolversParentTypes['LineRange']> = {
    endColumn?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    endLine?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    startColumn?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    startLine?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ILocalizationResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Localization'] = IResolversParentTypes['Localization']> = {
    languageId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    languageName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    localizedLanguageName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    translations?: Resolver<Maybe<Array<Maybe<IResolversTypes['LocalizationTranslation']>>>, ParentType, ContextType>;
    minimalTranslations?: Resolver<Maybe<IResolversTypes['JSON']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ILocalizationTranslationResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['LocalizationTranslation'] = IResolversParentTypes['LocalizationTranslation']> = {
    id?: Resolver<Maybe<IResolversTypes['ID']>, ParentType, ContextType>;
    path?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ILocalUserSettingsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['LocalUserSettings'] = IResolversParentTypes['LocalUserSettings']> = {
    id?: Resolver<Maybe<IResolversTypes['ID']>, ParentType, ContextType>;
    latestSettings?: Resolver<Maybe<IResolversTypes['Settings']>, ParentType, ContextType>;
    settingsURL?: Resolver<IResolversTypes['URI'], ParentType, ContextType>;
    viewerCanAdminister?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>;
    settingsCascade?: Resolver<IResolversTypes['SettingsCascade'], ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ILocationResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Location'] = IResolversParentTypes['Location']> = {
    __resolveType: TypeResolveFn<'ProvideTextDocumentLocationSignature', ParentType, ContextType>;
    rangeOrUri?: Resolver<Maybe<IResolversTypes['Position']>, ParentType, ContextType>;
    uriRangeOrPosition?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    range?: Resolver<Maybe<IResolversTypes['Position']>, ParentType, ContextType>;
    uri?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
};
export declare type IMatchResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Match'] = IResolversParentTypes['Match']> = {
    start?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    end?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IMemorySettingsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['MemorySettings'] = IResolversParentTypes['MemorySettings']> = {
    id?: Resolver<Maybe<IResolversTypes['ID']>, ParentType, ContextType>;
    latestSettings?: Resolver<Maybe<IResolversTypes['Settings']>, ParentType, ContextType>;
    settingsURL?: Resolver<IResolversTypes['URI'], ParentType, ContextType>;
    viewerCanAdminister?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>;
    settingsCascade?: Resolver<IResolversTypes['SettingsCascade'], ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IMenuItemResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['MenuItem'] = IResolversParentTypes['MenuItem']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    enabled?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    run?: Resolver<Maybe<IResolversTypes['ActionRun']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IMenuItemActionResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['MenuItemAction'] = IResolversParentTypes['MenuItemAction']> = {
    action?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    when?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IMenuItemActionContextResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['MenuItemActionContext'] = IResolversParentTypes['MenuItemActionContext']> = {
    context?: Resolver<Maybe<Array<Maybe<IResolversTypes['MenuItemAction']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IMenuItemActionDebugResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['MenuItemActionDebug'] = IResolversParentTypes['MenuItemActionDebug']> = {
    callstack?: Resolver<Maybe<IResolversTypes['MenuItemActionContext']>, ParentType, ContextType>;
    toolbar?: Resolver<Maybe<Array<Maybe<IResolversTypes['MenuItemAction']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IMenuItemActionEditorResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['MenuItemActionEditor'] = IResolversParentTypes['MenuItemActionEditor']> = {
    context?: Resolver<Maybe<Array<Maybe<IResolversTypes['MenuItemAction']>>>, ParentType, ContextType>;
    title?: Resolver<Maybe<IResolversTypes['MenuItemActionEditorTitle']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IMenuItemActionEditorTitleResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['MenuItemActionEditorTitle'] = IResolversParentTypes['MenuItemActionEditorTitle']> = {
    own?: Resolver<Maybe<Array<Maybe<IResolversTypes['MenuItemAction']>>>, ParentType, ContextType>;
    context?: Resolver<Maybe<Array<Maybe<IResolversTypes['MenuItemAction']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IMenuItemActionScmResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['MenuItemActionScm'] = IResolversParentTypes['MenuItemActionScm']> = {
    title?: Resolver<Maybe<Array<Maybe<IResolversTypes['MenuItemAction']>>>, ParentType, ContextType>;
    resourceGroup?: Resolver<Maybe<IResolversTypes['MenuItemActionContext']>, ParentType, ContextType>;
    resource?: Resolver<Maybe<IResolversTypes['MenuItemActionContext']>, ParentType, ContextType>;
    change?: Resolver<Maybe<IResolversTypes['MenuItemActionScmChange']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IMenuItemActionScmChangeResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['MenuItemActionScmChange'] = IResolversParentTypes['MenuItemActionScmChange']> = {
    title?: Resolver<Maybe<Array<Maybe<IResolversTypes['MenuItemAction']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IMenuItemActionViewResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['MenuItemActionView'] = IResolversParentTypes['MenuItemActionView']> = {
    title?: Resolver<Maybe<Array<Maybe<IResolversTypes['MenuItemAction']>>>, ParentType, ContextType>;
    item?: Resolver<Maybe<IResolversTypes['MenuItemActionContext']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IMenusResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Menus'] = IResolversParentTypes['Menus']> = {
    commandPalette?: Resolver<Maybe<Array<Maybe<IResolversTypes['MenuItemAction']>>>, ParentType, ContextType>;
    explorer?: Resolver<Maybe<IResolversTypes['MenuItemActionContext']>, ParentType, ContextType>;
    editor?: Resolver<Maybe<IResolversTypes['MenuItemActionEditor']>, ParentType, ContextType>;
    debug?: Resolver<Maybe<IResolversTypes['MenuItemActionDebug']>, ParentType, ContextType>;
    scm?: Resolver<Maybe<IResolversTypes['MenuItemActionScm']>, ParentType, ContextType>;
    view?: Resolver<Maybe<IResolversTypes['MenuItemActionView']>, ParentType, ContextType>;
    touchBar?: Resolver<Maybe<Array<Maybe<IResolversTypes['MenuItemAction']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IMessageBoxOptionsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['MessageBoxOptions'] = IResolversParentTypes['MessageBoxOptions']> = {
    type?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    buttons?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    defaultId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    title?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    message?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    detail?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    checkboxLabel?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    checkboxChecked?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    cancelId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    noLink?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    normalizeAccessKeys?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IMessageBoxResultResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['MessageBoxResult'] = IResolversParentTypes['MessageBoxResult']> = {
    button?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    checkboxChecked?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IMessageLinkResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['MessageLink'] = IResolversParentTypes['MessageLink']> = {
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    href?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    offset?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    length?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IMutationResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Mutation'] = IResolversParentTypes['Mutation']> = {
    activate?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationactivateArgs, 'request'>>;
    activateEditor?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationactivateEditorArgs, never>>;
    addEntry?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationaddEntryArgs, never>>;
    addFolders?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationaddFoldersArgs, never>>;
    addNotification?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationaddNotificationArgs, never>>;
    canHandleResource?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationcanHandleResourceArgs, 'resource'>>;
    changeEdit?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationchangeEditArgs, never>>;
    changeKeybinding?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationchangeKeybindingArgs, never>>;
    changeWhenExpression?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationchangeWhenExpressionArgs, never>>;
    changeWorkspace?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationchangeWorkspaceArgs, never>>;
    clearSearchCache?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationclearSearchCacheArgs, never>>;
    closeAllEditors?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    closeDialog?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    closeEditor?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationcloseEditorArgs, never>>;
    closeEditors?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationcloseEditorsArgs, never>>;
    closeNotification?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationcloseNotificationArgs, never>>;
    codeLenseProviderDefinition?: Resolver<Maybe<IResolversTypes['Observable']>, ParentType, ContextType, RequireFields<IMutationcodeLenseProviderDefinitionArgs, never>>;
    completionProviderDefinition?: Resolver<Maybe<IResolversTypes['Observable']>, ParentType, ContextType, RequireFields<IMutationcompletionProviderDefinitionArgs, never>>;
    copy?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationcopyArgs, never>>;
    copyFile?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType, RequireFields<IMutationcopyFileArgs, 'source' | 'target'>>;
    createExtension?: Resolver<IResolversTypes['RegistryExtension'], ParentType, ContextType, RequireFields<IMutationcreateExtensionArgs, 'publisher' | 'name'>>;
    createFile?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType, RequireFields<IMutationcreateFileArgs, 'resource'>>;
    createFolder?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType, RequireFields<IMutationcreateFolderArgs, 'resource'>>;
    createTextFile?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType, RequireFields<IMutationcreateTextFileArgs, 'resource'>>;
    createUntitledFile?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType, RequireFields<IMutationcreateUntitledFileArgs, never>>;
    definitionDefinition?: Resolver<Maybe<IResolversTypes['Observable']>, ParentType, ContextType, RequireFields<IMutationdefinitionDefinitionArgs, never>>;
    del?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationdelArgs, 'resource'>>;
    deleteExtension?: Resolver<IResolversTypes['EmptyResponse'], ParentType, ContextType, RequireFields<IMutationdeleteExtensionArgs, 'extension'>>;
    deleteTextFile?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationdeleteTextFileArgs, 'resource'>>;
    documentFormattingProviderDefinition?: Resolver<Maybe<IResolversTypes['Observable']>, ParentType, ContextType, RequireFields<IMutationdocumentFormattingProviderDefinitionArgs, never>>;
    documentHighLightProviderDefinition?: Resolver<Maybe<IResolversTypes['Observable']>, ParentType, ContextType, RequireFields<IMutationdocumentHighLightProviderDefinitionArgs, never>>;
    documentSymbolDefinition?: Resolver<Maybe<IResolversTypes['Observable']>, ParentType, ContextType, RequireFields<IMutationdocumentSymbolDefinitionArgs, never>>;
    dummy?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    editKeybinding?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationeditKeybindingArgs, never>>;
    findFileStat?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType, RequireFields<IMutationfindFileStatArgs, 'resource'>>;
    getConfigurationTarget?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType, RequireFields<IMutationgetConfigurationTargetArgs, never>>;
    getEditorState?: Resolver<Maybe<IResolversTypes['CodeEditorViewState']>, ParentType, ContextType, RequireFields<IMutationgetEditorStateArgs, 'editorId' | 'resource'>>;
    getFilesTreeData?: Resolver<Maybe<Array<Maybe<IResolversTypes['FileStatWithMetadata']>>>, ParentType, ContextType, RequireFields<IMutationgetFilesTreeDataArgs, 'resource'>>;
    gotoLine?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationgotoLineArgs, never>>;
    handler?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationhandlerArgs, never>>;
    hideContextMenu?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    hideInputModel?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    hideKeybindingDialog?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    highlightLine?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationhighlightLineArgs, never>>;
    hoverProviderDefinition?: Resolver<Maybe<IResolversTypes['Observable']>, ParentType, ContextType, RequireFields<IMutationhoverProviderDefinitionArgs, never>>;
    install?: Resolver<Maybe<IResolversTypes['ExtensionIdentifier']>, ParentType, ContextType, RequireFields<IMutationinstallArgs, 'vsix'>>;
    jsonWrite?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationjsonWriteArgs, never>>;
    keepOpen?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationkeepOpenArgs, never>>;
    loadFile?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType, RequireFields<IMutationloadFileArgs, 'resource'>>;
    loadFileContent?: Resolver<Maybe<IResolversTypes['FileContent']>, ParentType, ContextType, RequireFields<IMutationloadFileContentArgs, 'resource'>>;
    loadFileWithContent?: Resolver<Maybe<IResolversTypes['TextFileContent']>, ParentType, ContextType, RequireFields<IMutationloadFileWithContentArgs, 'resource'>>;
    loadFilesTreeData?: Resolver<Maybe<Array<Maybe<IResolversTypes['FileStatWithMetadata']>>>, ParentType, ContextType, RequireFields<IMutationloadFilesTreeDataArgs, 'resource'>>;
    lookupKeybinding?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType, RequireFields<IMutationlookupKeybindingArgs, never>>;
    makePinEditor?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationmakePinEditorArgs, never>>;
    moveEditorInsideGroup?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationmoveEditorInsideGroupArgs, never>>;
    moveFile?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType, RequireFields<IMutationmoveFileArgs, 'source' | 'target'>>;
    moveTextFile?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType, RequireFields<IMutationmoveTextFileArgs, 'source' | 'target'>>;
    notify?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationnotifyArgs, never>>;
    notifyError?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationnotifyErrorArgs, never>>;
    notifyInfo?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationnotifyInfoArgs, never>>;
    notifyPrompt?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationnotifyPromptArgs, never>>;
    notifyWarn?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationnotifyWarnArgs, never>>;
    openEditor?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationopenEditorArgs, 'content'>>;
    openEditorWithResourceDiffInput?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationopenEditorWithResourceDiffInputArgs, 'editor'>>;
    openEditorWithResourceInput?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationopenEditorWithResourceInputArgs, 'editor'>>;
    openEditorWithResourceSideBySideInput?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationopenEditorWithResourceSideBySideInputArgs, 'editor'>>;
    openEditorWithUntitledResourceInput?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationopenEditorWithUntitledResourceInputArgs, 'editor'>>;
    openFile?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationopenFileArgs, 'content'>>;
    openGlobalKeybindingSettings?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationopenGlobalKeybindingSettingsArgs, never>>;
    openLanguageDocument?: Resolver<Maybe<IResolversTypes['Observable']>, ParentType, ContextType, RequireFields<IMutationopenLanguageDocumentArgs, never>>;
    openPreferenceSettings?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationopenPreferenceSettingsArgs, never>>;
    publishExtension?: Resolver<IResolversTypes['ExtensionRegistryPublishExtensionResult'], ParentType, ContextType, RequireFields<IMutationpublishExtensionArgs, 'extensionID' | 'manifest' | 'force'>>;
    readTextFile?: Resolver<Maybe<IResolversTypes['TextFileContent']>, ParentType, ContextType, RequireFields<IMutationreadTextFileArgs, 'resource'>>;
    referenceProviderDefinition?: Resolver<Maybe<IResolversTypes['Observable']>, ParentType, ContextType, RequireFields<IMutationreferenceProviderDefinitionArgs, never>>;
    registerKeybinding?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationregisterKeybindingArgs, never>>;
    removeChangedContent?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationremoveChangedContentArgs, 'resource'>>;
    removeEdit?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationremoveEditArgs, never>>;
    removeExtension?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationremoveExtensionArgs, 'id'>>;
    removeFolders?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationremoveFoldersArgs, never>>;
    removeKeybinding?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationremoveKeybindingArgs, never>>;
    removeStatusbarEntry?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationremoveStatusbarEntryArgs, 'id'>>;
    rename?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType, RequireFields<IMutationrenameArgs, 'resource' | 'target'>>;
    renameDefinition?: Resolver<Maybe<IResolversTypes['Observable']>, ParentType, ContextType, RequireFields<IMutationrenameDefinitionArgs, never>>;
    replaceContent?: Resolver<Maybe<IResolversTypes['ReplaceContentResult']>, ParentType, ContextType, RequireFields<IMutationreplaceContentArgs, never>>;
    resetKeybinding?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationresetKeybindingArgs, never>>;
    resetSetting?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationresetSettingArgs, never>>;
    resolveKeyboardEvent?: Resolver<Maybe<IResolversTypes['KeyboardEvent_output']>, ParentType, ContextType, RequireFields<IMutationresolveKeyboardEventArgs, never>>;
    runMenuAction?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationrunMenuActionArgs, never>>;
    saveAllEditor?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationsaveAllEditorArgs, never>>;
    saveFile?: Resolver<Maybe<IResolversTypes['FileStat']>, ParentType, ContextType, RequireFields<IMutationsaveFileArgs, 'resource' | 'options'>>;
    saveFileAs?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType, RequireFields<IMutationsaveFileAsArgs, 'resource' | 'options'>>;
    saveUserSettings?: Resolver<Maybe<IResolversTypes['SaveWorkspaceRes']>, ParentType, ContextType, RequireFields<IMutationsaveUserSettingsArgs, never>>;
    saveWorkspaceSettings?: Resolver<Maybe<IResolversTypes['SaveWorkspaceRes']>, ParentType, ContextType>;
    searchKeybinding?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationsearchKeybindingArgs, never>>;
    selectEdit?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationselectEditArgs, never>>;
    setEncoding?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationsetEncodingArgs, 'resource'>>;
    setFilesTreeData?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationsetFilesTreeDataArgs, never>>;
    setSelected?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationsetSelectedArgs, never>>;
    setSelectedKeybindingIndex?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationsetSelectedKeybindingIndexArgs, never>>;
    setStatusMessage?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType, RequireFields<IMutationsetStatusMessageArgs, never>>;
    show?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationshowArgs, never>>;
    showContextMenu?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationshowContextMenuArgs, never>>;
    showInput?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationshowInputArgs, never>>;
    showPickInput?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationshowPickInputArgs, never>>;
    startExtensionHost?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationstartExtensionHostArgs, never>>;
    stopEditWhenExpression?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    switchSettings?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationswitchSettingsArgs, never>>;
    testNotification?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    textSearch_?: Resolver<Maybe<IResolversTypes['SearchComplete']>, ParentType, ContextType, RequireFields<IMutationtextSearch_Args, never>>;
    unwatch?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationunwatchArgs, 'resource' | 'session'>>;
    unwatchFileChanges?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationunwatchFileChangesArgs, 'resource' | 'session'>>;
    updateChangedContent?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationupdateChangedContentArgs, 'resource' | 'changedEvent'>>;
    updateConfigurationValue?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationupdateConfigurationValueArgs, 'key' | 'value'>>;
    updateContent?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType, RequireFields<IMutationupdateContentArgs, 'resource' | 'value' | 'options'>>;
    updateContext?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationupdateContextArgs, never>>;
    updateEditorState?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationupdateEditorStateArgs, 'editorId' | 'resource' | 'state'>>;
    updateExtension?: Resolver<IResolversTypes['RegistryExtension'], ParentType, ContextType, RequireFields<IMutationupdateExtensionArgs, 'extension'>>;
    updateFileDirtyState?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationupdateFileDirtyStateArgs, 'resource' | 'isFileDirty'>>;
    updateFolders?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationupdateFoldersArgs, never>>;
    updateLayout?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationupdateLayoutArgs, never>>;
    updateModel?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationupdateModelArgs, never>>;
    updateSelectedResource?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationupdateSelectedResourceArgs, 'resource'>>;
    updateStatusbarEntry?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationupdateStatusbarEntryArgs, never>>;
    updateWorkspaceContextAddFolders?: Resolver<Maybe<Array<Maybe<IResolversTypes['WorkspaceFolderData']>>>, ParentType, ContextType, RequireFields<IMutationupdateWorkspaceContextAddFoldersArgs, never>>;
    updateWorkspaceContextRemoveFolders?: Resolver<Maybe<Array<Maybe<IResolversTypes['WorkspaceFolderData']>>>, ParentType, ContextType, RequireFields<IMutationupdateWorkspaceContextRemoveFoldersArgs, never>>;
    updateWorkspaceContextUpdateFolders?: Resolver<Maybe<Array<Maybe<IResolversTypes['WorkspaceFolderData']>>>, ParentType, ContextType, RequireFields<IMutationupdateWorkspaceContextUpdateFoldersArgs, never>>;
    watchFile?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType, RequireFields<IMutationwatchFileArgs, 'resource'>>;
    watchFileChanges?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationwatchFileChangesArgs, 'resource' | 'options'>>;
    writeChunk?: Resolver<Maybe<IResolversTypes['UpdatedResource']>, ParentType, ContextType, RequireFields<IMutationwriteChunkArgs, 'resource' | 'changes' | 'options'>>;
    writeChunkWithDelay?: Resolver<Maybe<IResolversTypes['UpdateDelayedResource']>, ParentType, ContextType, RequireFields<IMutationwriteChunkWithDelayArgs, 'resource' | 'changes' | 'options'>>;
    writeContent?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    writeTextFile?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType, RequireFields<IMutationwriteTextFileArgs, 'resource' | 'value' | 'options'>>;
};
export declare type INativeOpenDialogOptionsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['NativeOpenDialogOptions'] = IResolversParentTypes['NativeOpenDialogOptions']> = {
    windowId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    forceNewWindow?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    defaultPath?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    telemetryEventName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type INewWindowOptionsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['NewWindowOptions'] = IResolversParentTypes['NewWindowOptions']> = {
    remoteAuthority?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    reuseWindow?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type INodeResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Node'] = IResolversParentTypes['Node']> = {
    __resolveType: TypeResolveFn<'RegistryExtension', ParentType, ContextType>;
    id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>;
};
export declare type INotificationResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Notification'] = IResolversParentTypes['Notification']> = {
    index?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    severity?: Resolver<Maybe<IResolversTypes['NotificationSeverity']>, ParentType, ContextType>;
    message?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    source?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    actions?: Resolver<Maybe<IResolversTypes['NotificationActions']>, ParentType, ContextType>;
    sticky?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type INotificationActionsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['NotificationActions'] = IResolversParentTypes['NotificationActions']> = {
    primary?: Resolver<Maybe<Array<Maybe<IResolversTypes['Action']>>>, ParentType, ContextType>;
    secondary?: Resolver<Maybe<Array<Maybe<IResolversTypes['Action']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type INotificationChangeEventResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['NotificationChangeEvent'] = IResolversParentTypes['NotificationChangeEvent']> = {
    index?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    item?: Resolver<Maybe<IResolversTypes['NotificationViewItem']>, ParentType, ContextType>;
    kind?: Resolver<Maybe<IResolversTypes['NotificationChangeType']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type INotificationMessageResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['NotificationMessage'] = IResolversParentTypes['NotificationMessage']> = {
    raw?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    original?: Resolver<Maybe<IResolversTypes['NotificationMessage']>, ParentType, ContextType>;
    value?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    links?: Resolver<Maybe<Array<Maybe<IResolversTypes['MessageLink']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type INotificationsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Notifications'] = IResolversParentTypes['Notifications']> = {
    notifications?: Resolver<Maybe<Array<Maybe<IResolversTypes['Notification']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type INotificationViewItemResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['NotificationViewItem'] = IResolversParentTypes['NotificationViewItem']> = {
    severity?: Resolver<Maybe<IResolversTypes['NotificationSeverity']>, ParentType, ContextType>;
    sticky?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    silent?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    message?: Resolver<Maybe<IResolversTypes['NotificationMessage']>, ParentType, ContextType>;
    source?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    action?: Resolver<Maybe<IResolversTypes['NotificationActions']>, ParentType, ContextType>;
    progress?: Resolver<Maybe<IResolversTypes['NotificationViewItemProgress']>, ParentType, ContextType>;
    expanded?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    canCollapse?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type INotificationViewItemProgressResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['NotificationViewItemProgress'] = IResolversParentTypes['NotificationViewItemProgress']> = {
    state?: Resolver<Maybe<IResolversTypes['NotificationViewItemProgressState']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type INotificationViewItemProgressStateResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['NotificationViewItemProgressState'] = IResolversParentTypes['NotificationViewItemProgressState']> = {
    infinite?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    total?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    worked?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    done?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export interface IObservableScalarConfig extends GraphQLScalarTypeConfig<IResolversTypes['Observable'], any> {
    name: 'Observable';
}
export declare type IOneSearchPathPatternResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['OneSearchPathPattern'] = IResolversParentTypes['OneSearchPathPattern']> = {
    searchPath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    pattern?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IOpenConfigurationResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['OpenConfiguration'] = IResolversParentTypes['OpenConfiguration']> = {
    context?: Resolver<Maybe<IResolversTypes['OpenContext']>, ParentType, ContextType>;
    contextWindowId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    cli?: Resolver<Maybe<IResolversTypes['AnyObject']>, ParentType, ContextType>;
    userEnv?: Resolver<Maybe<IResolversTypes['AnyObject']>, ParentType, ContextType>;
    urisToOpen?: Resolver<Maybe<Array<Maybe<IResolversTypes['URIToOpen']>>>, ParentType, ContextType>;
    waitMarkerFileURI?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    preferNewWindow?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    forceNewWindow?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    forceNewTabbedWindow?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    forceReuseWindow?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    forceEmpty?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    diffMode?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    addMode?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    initialStartup?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    noRecentEntry?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IOpenDialogOptionsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['OpenDialogOptions'] = IResolversParentTypes['OpenDialogOptions']> = {
    title?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    defaultPath?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    buttonLabel?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    filters?: Resolver<Maybe<Array<Maybe<IResolversTypes['FileFilter']>>>, ParentType, ContextType>;
    properties?: Resolver<Maybe<Array<Maybe<IResolversTypes['OpenDialogOptionsProperties']>>>, ParentType, ContextType>;
    message?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IOpenFileRequestResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['OpenFileRequest'] = IResolversParentTypes['OpenFileRequest']> = {
    filesToOpenOrCreate?: Resolver<Maybe<Array<Maybe<IResolversTypes['IPathData']>>>, ParentType, ContextType>;
    filesToDiff?: Resolver<Maybe<Array<Maybe<IResolversTypes['IPathData']>>>, ParentType, ContextType>;
    filesToWait?: Resolver<Maybe<IResolversTypes['IPathsToWaitForData']>, ParentType, ContextType>;
    termProgram?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IOpenSettingsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['OpenSettings'] = IResolversParentTypes['OpenSettings']> = {
    forceNewWindow?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    forceReuseWindow?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    diffMode?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    addMode?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    noRecentEntry?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    waitMarkerFileURI?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    args?: Resolver<Maybe<IResolversTypes['AnyObject']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IOutputResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Output'] = IResolversParentTypes['Output']> = {
    maxChannelHistory?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IOverridesResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Overrides'] = IResolversParentTypes['Overrides']> = {
    contents?: Resolver<Maybe<IResolversTypes['AnyObject']>, ParentType, ContextType>;
    identifiers?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IPageInfoResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['PageInfo'] = IResolversParentTypes['PageInfo']> = {
    hasNextPage?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IPathResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Path'] = IResolversParentTypes['Path']> = {
    lineNumber?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    columnNumber?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    exists?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    fileUri?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IPathsToWaitForResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['PathsToWaitFor'] = IResolversParentTypes['PathsToWaitFor']> = {
    paths?: Resolver<Maybe<Array<Maybe<IResolversTypes['Path']>>>, ParentType, ContextType>;
    waitMarkerFileUri?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IPatternInfoResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['PatternInfo'] = IResolversParentTypes['PatternInfo']> = {
    pattern?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    isRegExp?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isWordMatch?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    wordSeparators?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    isMultiline?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isCaseSensitive?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isSmartCase?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IPendingStatusbarEntryResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['PendingStatusbarEntry'] = IResolversParentTypes['PendingStatusbarEntry']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    alignment?: Resolver<Maybe<IResolversTypes['StatusbarAlignment']>, ParentType, ContextType>;
    priority?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IPositionResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Position'] = IResolversParentTypes['Position']> = {
    lineNumber?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    column?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    line?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    character?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IPreferenceItemResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['PreferenceItem'] = IResolversParentTypes['PreferenceItem']> = {
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    type?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    default?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    categoryType?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    settings?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    enum?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    enumDescriptions?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IPreferencesEditorInputResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['PreferencesEditorInput'] = IResolversParentTypes['PreferencesEditorInput']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    resource?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    typeId?: Resolver<Maybe<IResolversTypes['EDITOR_INPUT_ID']>, ParentType, ContextType>;
    description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    fileReference?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType>;
    preferredEditorId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    isSupportsSplitEditor?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isActive?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    preview?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isPinned?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    status?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    closable?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    master?: Resolver<Maybe<IResolversTypes['EditorInput']>, ParentType, ContextType>;
    details?: Resolver<Maybe<IResolversTypes['EditorInput']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IPreferencesTypeResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['PreferencesType'] = IResolversParentTypes['PreferencesType']> = {
    type?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    data?: Resolver<Maybe<Array<Maybe<IResolversTypes['Setting']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IPrimaryButtonActionResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['PrimaryButtonAction'] = IResolversParentTypes['PrimaryButtonAction']> = {
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    run?: Resolver<Maybe<IResolversTypes['ActionRun']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IProcessMonitoringResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ProcessMonitoring'] = IResolversParentTypes['ProcessMonitoring']> = {
    cpu?: Resolver<Maybe<IResolversTypes['Float']>, ParentType, ContextType>;
    memory?: Resolver<Maybe<IResolversTypes['Float']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IProgressResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Progress'] = IResolversParentTypes['Progress']> = {
    total?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    worked?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IProvideTextDocumentLocationSignatureResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ProvideTextDocumentLocationSignature'] = IResolversParentTypes['ProvideTextDocumentLocationSignature']> = {
    textDocument?: Resolver<Maybe<IResolversTypes['TextDocumentIdentifier']>, ParentType, ContextType>;
    position?: Resolver<Maybe<IResolversTypes['Position']>, ParentType, ContextType>;
    rangeOrUri?: Resolver<Maybe<IResolversTypes['Position']>, ParentType, ContextType>;
    uriRangeOrPosition?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    range?: Resolver<Maybe<IResolversTypes['Position']>, ParentType, ContextType>;
    uri?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IQueryResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Query'] = IResolversParentTypes['Query']> = {
    contextMenu?: Resolver<Maybe<IResolversTypes['ContextMenu']>, ParentType, ContextType>;
    defaultPreferences?: Resolver<Maybe<IResolversTypes['DefaultPreferencesResponse']>, ParentType, ContextType>;
    defaultSetting?: Resolver<Maybe<IResolversTypes['Setting']>, ParentType, ContextType>;
    defaultViewerSettingsSubject?: Resolver<IResolversTypes['DefaultSettings'], ParentType, ContextType, RequireFields<IQuerydefaultViewerSettingsSubjectArgs, never>>;
    dialog?: Resolver<Maybe<IResolversTypes['Dialog']>, ParentType, ContextType>;
    docSitePage?: Resolver<Maybe<IResolversTypes['DocSitePage']>, ParentType, ContextType, RequireFields<IQuerydocSitePageArgs, 'path'>>;
    dummy?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    editorPart?: Resolver<Maybe<IResolversTypes['EditorPart']>, ParentType, ContextType>;
    editorState?: Resolver<Maybe<IResolversTypes['CodeEditorViewState']>, ParentType, ContextType, RequireFields<IQueryeditorStateArgs, 'editorId' | 'resource'>>;
    existsFile?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IQueryexistsFileArgs, 'resource'>>;
    extension?: Resolver<Maybe<IResolversTypes['RegistryExtension']>, ParentType, ContextType, RequireFields<IQueryextensionArgs, 'extensionID'>>;
    extensionRegistry?: Resolver<IResolversTypes['ExtensionRegistry'], ParentType, ContextType>;
    extensions?: Resolver<IResolversTypes['RegistryExtensionConnection'], ParentType, ContextType, RequireFields<IQueryextensionsArgs, 'local' | 'remote' | 'includeWIP'>>;
    fileSearch?: Resolver<Maybe<IResolversTypes['SearchComplete']>, ParentType, ContextType, RequireFields<IQueryfileSearchArgs, never>>;
    gallery?: Resolver<Maybe<IResolversTypes['GalleryPager']>, ParentType, ContextType, RequireFields<IQuerygalleryArgs, never>>;
    galleryExtension?: Resolver<Maybe<IResolversTypes['GalleryExtension']>, ParentType, ContextType, RequireFields<IQuerygalleryExtensionArgs, 'extensionID'>>;
    getChangedEvent?: Resolver<Maybe<IResolversTypes['IContentChangedEvent']>, ParentType, ContextType, RequireFields<IQuerygetChangedEventArgs, 'resource'>>;
    getConfigurationData?: Resolver<Maybe<IResolversTypes['ConfigurationData']>, ParentType, ContextType>;
    getConfigurationTarget?: Resolver<Maybe<IResolversTypes['ConfigurationScope']>, ParentType, ContextType>;
    getContextData?: Resolver<Maybe<IResolversTypes['Context']>, ParentType, ContextType>;
    getContextProperty?: Resolver<Maybe<IResolversTypes['Context']>, ParentType, ContextType, RequireFields<IQuerygetContextPropertyArgs, never>>;
    getDefaultSettings?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType, RequireFields<IQuerygetDefaultSettingsArgs, never>>;
    getDefaultSettingsResource?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType, RequireFields<IQuerygetDefaultSettingsResourceArgs, never>>;
    getEnvironment?: Resolver<Maybe<IResolversTypes['Environment']>, ParentType, ContextType>;
    getKeybindings?: Resolver<Maybe<IResolversTypes['Keybindings']>, ParentType, ContextType>;
    getMostCommonlyUsedSettings?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    getSelectedValue?: Resolver<Maybe<IResolversTypes['SelectedOutput']>, ParentType, ContextType>;
    getViews?: Resolver<Maybe<Array<Maybe<IResolversTypes['ViewDescriptor']>>>, ParentType, ContextType, RequireFields<IQuerygetViewsArgs, 'containerId'>>;
    getWorkspace?: Resolver<Maybe<IResolversTypes['WorkspaceData']>, ParentType, ContextType>;
    getWorkspaceFolderContext?: Resolver<Maybe<IResolversTypes['WorkspaceData']>, ParentType, ContextType, RequireFields<IQuerygetWorkspaceFolderContextArgs, never>>;
    getWorkspaceValue?: Resolver<Maybe<IResolversTypes['AnyObject']>, ParentType, ContextType, RequireFields<IQuerygetWorkspaceValueArgs, never>>;
    gotoLineQuickAccess?: Resolver<Maybe<IResolversTypes['GoToLineQuickAccess']>, ParentType, ContextType>;
    installed?: Resolver<Maybe<Array<Maybe<IResolversTypes['InstalledExtension']>>>, ParentType, ContextType>;
    instances?: Resolver<Maybe<Array<Maybe<IResolversTypes['ExtensionInstance']>>>, ParentType, ContextType>;
    keybindingContextMenu?: Resolver<Maybe<IResolversTypes['KeybindingContextMenu']>, ParentType, ContextType>;
    keybindings?: Resolver<Maybe<IResolversTypes['Keybindings']>, ParentType, ContextType>;
    notifications?: Resolver<Maybe<IResolversTypes['Notifications']>, ParentType, ContextType>;
    quickInputModel?: Resolver<Maybe<IResolversTypes['QuickInputModel']>, ParentType, ContextType>;
    readStreamTextFile?: Resolver<Maybe<IResolversTypes['TextFileStreamContent']>, ParentType, ContextType, RequireFields<IQueryreadStreamTextFileArgs, 'resource'>>;
    readStringStreamTextFile?: Resolver<Maybe<IResolversTypes['TextFilePublishContent']>, ParentType, ContextType, RequireFields<IQueryreadStringStreamTextFileArgs, 'resource'>>;
    readTextFile?: Resolver<Maybe<IResolversTypes['TextFileContent']>, ParentType, ContextType, RequireFields<IQueryreadTextFileArgs, 'resource'>>;
    registerProvider?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IQueryregisterProviderArgs, never>>;
    releases?: Resolver<Maybe<Array<Maybe<IResolversTypes['ExtensionRelease']>>>, ParentType, ContextType, RequireFields<IQueryreleasesArgs, 'extensionID'>>;
    resolveContent?: Resolver<Maybe<IResolversTypes['FileContent']>, ParentType, ContextType, RequireFields<IQueryresolveContentArgs, 'resource'>>;
    resolveContents?: Resolver<Maybe<Array<Maybe<IResolversTypes['ResolveFileResultWithMetadata']>>>, ParentType, ContextType, RequireFields<IQueryresolveContentsArgs, never>>;
    resolveFile?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType, RequireFields<IQueryresolveFileArgs, 'resource'>>;
    resolveFileContent?: Resolver<Maybe<IResolversTypes['TextFileContent']>, ParentType, ContextType, RequireFields<IQueryresolveFileContentArgs, 'resource'>>;
    resolveUntitledFileContent?: Resolver<Maybe<IResolversTypes['TextFileContent']>, ParentType, ContextType, RequireFields<IQueryresolveUntitledFileContentArgs, 'resource'>>;
    selectedResource?: Resolver<Maybe<IResolversTypes['Context']>, ParentType, ContextType>;
    settingsSubject?: Resolver<Maybe<IResolversTypes['ISettingsSubject']>, ParentType, ContextType, RequireFields<IQuerysettingsSubjectArgs, 'id'>>;
    showDialog?: Resolver<Maybe<IResolversTypes['DialogResult']>, ParentType, ContextType, RequireFields<IQueryshowDialogArgs, never>>;
    showNotification?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IQueryshowNotificationArgs, never>>;
    statusbar?: Resolver<Maybe<IResolversTypes['Statusbar']>, ParentType, ContextType>;
    statusbarItem?: Resolver<Maybe<IResolversTypes['StatusbarItem']>, ParentType, ContextType, RequireFields<IQuerystatusbarItemArgs, never>>;
    textSearch?: Resolver<Maybe<IResolversTypes['SearchComplete']>, ParentType, ContextType, RequireFields<IQuerytextSearchArgs, never>>;
    treeViewData?: Resolver<Maybe<Array<Maybe<IResolversTypes['TreeItem']>>>, ParentType, ContextType>;
    untitledResources?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    userPreferences?: Resolver<Maybe<IResolversTypes['UserPreferencesRes']>, ParentType, ContextType, RequireFields<IQueryuserPreferencesArgs, never>>;
    viewerSettings?: Resolver<IResolversTypes['SettingsCascade'], ParentType, ContextType>;
    workspaces?: Resolver<Maybe<Array<Maybe<IResolversTypes['WorkspaceRes']>>>, ParentType, ContextType>;
};
export declare type IQuickInputResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['QuickInput'] = IResolversParentTypes['QuickInput']> = {
    title?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    step?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    totalSteps?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    enabled?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    ignoreFocusOut?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    value?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    placeholder?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    prompt?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    validationMessage?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IQuickInputModelResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['QuickInputModel'] = IResolversParentTypes['QuickInputModel']> = {
    show?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    title?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    input?: Resolver<Maybe<IResolversTypes['QuickInput']>, ParentType, ContextType>;
    quickPick?: Resolver<Maybe<IResolversTypes['QuickPick']>, ParentType, ContextType>;
    inputValue?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    selectedValue?: Resolver<Maybe<Array<Maybe<IResolversTypes['QuickPickItem']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IQuickPickResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['QuickPick'] = IResolversParentTypes['QuickPick']> = {
    placeholder?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    canSelectMany?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    autoFocusOnList?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    items?: Resolver<Maybe<Array<Maybe<IResolversTypes['QuickPickItem']>>>, ParentType, ContextType>;
    activeItem?: Resolver<Maybe<IResolversTypes['QuickPickItem']>, ParentType, ContextType>;
    selectedItems?: Resolver<Maybe<Array<Maybe<IResolversTypes['QuickPickItem']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IQuickPickItemResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['QuickPickItem'] = IResolversParentTypes['QuickPickItem']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    detail?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    keybinding?: Resolver<Maybe<IResolversTypes['KeybindingItem']>, ParentType, ContextType>;
    italic?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    highlights?: Resolver<Maybe<IResolversTypes['QuickPickItemHighlights']>, ParentType, ContextType>;
    picked?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    alwaysShow?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IQuickPickItemHighlightsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['QuickPickItemHighlights'] = IResolversParentTypes['QuickPickItemHighlights']> = {
    label?: Resolver<Maybe<Array<Maybe<IResolversTypes['Match']>>>, ParentType, ContextType>;
    description?: Resolver<Maybe<Array<Maybe<IResolversTypes['Match']>>>, ParentType, ContextType>;
    detail?: Resolver<Maybe<Array<Maybe<IResolversTypes['Match']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IRangeResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Range'] = IResolversParentTypes['Range']> = {
    start?: Resolver<Maybe<IResolversTypes['Position']>, ParentType, ContextType>;
    end?: Resolver<Maybe<IResolversTypes['Position']>, ParentType, ContextType>;
    startLineNumber?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    startColumn?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    endLineNumber?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    endColumn?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IRegistryEntryResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['RegistryEntry'] = IResolversParentTypes['RegistryEntry']> = {
    registrationOptions?: Resolver<Maybe<IResolversTypes['TextDocumentRegistrationOptions']>, ParentType, ContextType>;
    provider?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IRegistryExtensionResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['RegistryExtension'] = IResolversParentTypes['RegistryExtension']> = {
    id?: Resolver<IResolversTypes['ID'], ParentType, ContextType>;
    uuid?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    publisher?: Resolver<Maybe<IResolversTypes['RegistryPublisher']>, ParentType, ContextType>;
    extensionID?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    extensionIDWithoutRegistry?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    name?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    version?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    activationEvents?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    manifest?: Resolver<Maybe<IResolversTypes['ExtensionManifest']>, ParentType, ContextType>;
    updatedAt?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    url?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    remoteURL?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    isLocal?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    viewerCanAdminister?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    releases?: Resolver<Maybe<Array<Maybe<IResolversTypes['ExtensionRelease']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IRegistryExtensionConnectionResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['RegistryExtensionConnection'] = IResolversParentTypes['RegistryExtensionConnection']> = {
    nodes?: Resolver<Array<IResolversTypes['RegistryExtension']>, ParentType, ContextType>;
    totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>;
    pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>;
    url?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    error?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IRegistryPublisherResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['RegistryPublisher'] = IResolversParentTypes['RegistryPublisher']> = {
    UserId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IRegistryPublisherConnectionResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['RegistryPublisherConnection'] = IResolversParentTypes['RegistryPublisherConnection']> = {
    nodes?: Resolver<Array<IResolversTypes['RegistryPublisher']>, ParentType, ContextType>;
    totalCount?: Resolver<IResolversTypes['Int'], ParentType, ContextType>;
    pageInfo?: Resolver<IResolversTypes['PageInfo'], ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IRemoteUserSettingsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['RemoteUserSettings'] = IResolversParentTypes['RemoteUserSettings']> = {
    id?: Resolver<Maybe<IResolversTypes['ID']>, ParentType, ContextType>;
    latestSettings?: Resolver<Maybe<IResolversTypes['Settings']>, ParentType, ContextType>;
    settingsURL?: Resolver<IResolversTypes['URI'], ParentType, ContextType>;
    viewerCanAdminister?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>;
    settingsCascade?: Resolver<IResolversTypes['SettingsCascade'], ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IReplaceContentResultResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ReplaceContentResult'] = IResolversParentTypes['ReplaceContentResult']> = {
    resource?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    oldText?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    newText?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IResolveFileResultResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ResolveFileResult'] = IResolversParentTypes['ResolveFileResult']> = {
    stat?: Resolver<Maybe<IResolversTypes['FileStat']>, ParentType, ContextType>;
    success?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>;
    value?: Resolver<Maybe<IResolversTypes['VSBufferReadableStream']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IResolveFileResultWithMetadataResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ResolveFileResultWithMetadata'] = IResolversParentTypes['ResolveFileResultWithMetadata']> = {
    stat?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType>;
    success?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IResourceEditorInputResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ResourceEditorInput'] = IResolversParentTypes['ResourceEditorInput']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    resource?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    typeId?: Resolver<Maybe<IResolversTypes['EDITOR_INPUT_ID']>, ParentType, ContextType>;
    description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    fileReference?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType>;
    preferredEditorId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    isSupportsSplitEditor?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isActive?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    preview?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isPinned?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    status?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    closable?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    mode?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    preferredMode?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IResourceEncodingResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ResourceEncoding'] = IResolversParentTypes['ResourceEncoding']> = {
    encoding?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    hasBOM?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IResourceMapConfigurationModelResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ResourceMapConfigurationModel'] = IResolversParentTypes['ResourceMapConfigurationModel']> = {
    resource?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    contents?: Resolver<Maybe<IResolversTypes['AnyObject']>, ParentType, ContextType>;
    keys?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    overrides?: Resolver<Maybe<IResolversTypes['ConfigurationOverrides']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IRevealOptionsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['RevealOptions'] = IResolversParentTypes['RevealOptions']> = {
    select?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    focus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    expand?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IRunActionInWindowRequestResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['RunActionInWindowRequest'] = IResolversParentTypes['RunActionInWindowRequest']> = {
    id?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    from?: Resolver<Maybe<IResolversTypes['RunActionInWindowRequestFrom']>, ParentType, ContextType>;
    args?: Resolver<Maybe<Array<Maybe<IResolversTypes['AnyObject']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IRunKeybindingInWindowRequestResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['RunKeybindingInWindowRequest'] = IResolversParentTypes['RunKeybindingInWindowRequest']> = {
    userSettingsLabel?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ISaveDialogOptionsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['SaveDialogOptions'] = IResolversParentTypes['SaveDialogOptions']> = {
    title?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    defaultPath?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    buttonLabel?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    filters?: Resolver<Maybe<Array<Maybe<IResolversTypes['FileFilter']>>>, ParentType, ContextType>;
    message?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    nameFieldLabel?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    showTagField?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ISaveWorkspaceResResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['SaveWorkspaceRes'] = IResolversParentTypes['SaveWorkspaceRes']> = {
    updated?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IScriptsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Scripts'] = IResolversParentTypes['Scripts']> = {
    cdebasebuild?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    cdebasepublish?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ISearchResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Search'] = IResolversParentTypes['Search']> = {
    location?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    smartCase?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    useRipgrep?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    useIgnoreFiles?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    followSymlinks?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    globalFindClipboard?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    quickOpen?: Resolver<Maybe<IResolversTypes['SearchQuickOpen']>, ParentType, ContextType>;
    exclude?: Resolver<Maybe<IResolversTypes['JSON']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ISearchCompleteResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['SearchComplete'] = IResolversParentTypes['SearchComplete']> = {
    limitHit?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    stats?: Resolver<IResolversTypes['SearchCompleteStatsStats'], ParentType, ContextType>;
    results?: Resolver<Maybe<Array<Maybe<IResolversTypes['FileMatch']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ISearchCompleteStatsStatsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['SearchCompleteStatsStats'] = IResolversParentTypes['SearchCompleteStatsStats']> = {
    __resolveType: TypeResolveFn<'FileSearchStats' | 'TextSearchStats', ParentType, ContextType>;
};
export declare type ISearchCompleteStreamResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['SearchCompleteStream'] = IResolversParentTypes['SearchCompleteStream']> = {
    isEnd?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    limitHit?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    results?: Resolver<Maybe<Array<Maybe<IResolversTypes['FileMatch']>>>, ParentType, ContextType>;
    stats?: Resolver<IResolversTypes['SearchCompleteStatsStats'], ParentType, ContextType>;
    part?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    size?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ISearchEngineStatsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['SearchEngineStats'] = IResolversParentTypes['SearchEngineStats']> = {
    traversal?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    fileWalkTime?: Resolver<IResolversTypes['Int'], ParentType, ContextType>;
    directoriesWalked?: Resolver<IResolversTypes['Int'], ParentType, ContextType>;
    filesWalked?: Resolver<IResolversTypes['Int'], ParentType, ContextType>;
    cmdTime?: Resolver<IResolversTypes['Int'], ParentType, ContextType>;
    cmdResultCount?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ISearchLogResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['SearchLog'] = IResolversParentTypes['SearchLog']> = {
    message?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ISearchPathPatternResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['SearchPathPattern'] = IResolversParentTypes['SearchPathPattern']> = {
    searchPath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    pattern?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ISearchProgressItemResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['SearchProgressItem'] = IResolversParentTypes['SearchProgressItem']> = {
    resource?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    results?: Resolver<Maybe<Array<Maybe<IResolversTypes['TextSearchResult']>>>, ParentType, ContextType>;
    total?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    worked?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    message?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ISearchQuickOpenResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['SearchQuickOpen'] = IResolversParentTypes['SearchQuickOpen']> = {
    includeSymbols?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ISearchRangeResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['SearchRange'] = IResolversParentTypes['SearchRange']> = {
    startLineNumber?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    startColumn?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    endLineNumber?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    endColumn?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ISelectedOutputResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['SelectedOutput'] = IResolversParentTypes['SelectedOutput']> = {
    title?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    inputValue?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    selectedValue?: Resolver<Maybe<Array<Maybe<IResolversTypes['QuickPickItem']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ISelectionStatusResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['SelectionStatus'] = IResolversParentTypes['SelectionStatus']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    alignment?: Resolver<Maybe<IResolversTypes['StatusbarAlignment']>, ParentType, ContextType>;
    entry?: Resolver<Maybe<IResolversTypes['StatusbarEntry']>, ParentType, ContextType>;
    priority?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    container?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    labelContainer?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    typeId?: Resolver<Maybe<IResolversTypes['STATUSBAR_ITEM_ID']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ISettingResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Setting'] = IResolversParentTypes['Setting']> = {
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    range?: Resolver<Maybe<IResolversTypes['Range']>, ParentType, ContextType>;
    key?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    keyRange?: Resolver<Maybe<IResolversTypes['Range']>, ParentType, ContextType>;
    default?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    value?: Resolver<Maybe<IResolversTypes['AnyObject']>, ParentType, ContextType>;
    valueRange?: Resolver<Maybe<IResolversTypes['Range']>, ParentType, ContextType>;
    description?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    descriptionIsMarkdown?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    descriptionRanges?: Resolver<Maybe<Array<Maybe<IResolversTypes['Range']>>>, ParentType, ContextType>;
    overrides?: Resolver<Maybe<Array<Maybe<IResolversTypes['Setting']>>>, ParentType, ContextType>;
    overrideOf?: Resolver<Maybe<IResolversTypes['Setting']>, ParentType, ContextType>;
    deprecationMessage?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    scope?: Resolver<Maybe<IResolversTypes['ConfigurationScope']>, ParentType, ContextType>;
    type?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    enum?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    enumDescriptions?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    enumDescriptionsAreMarkdown?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    tags?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    extensionInfo?: Resolver<Maybe<IResolversTypes['ConfigurationExtensionInfo']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ISettingsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Settings'] = IResolversParentTypes['Settings']> = {
    createdAt?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    contents?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ISettingsCascadeResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['SettingsCascade'] = IResolversParentTypes['SettingsCascade']> = {
    subjects?: Resolver<Maybe<Array<Maybe<IResolversTypes['SettingsSubject']>>>, ParentType, ContextType>;
    final?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    finalConfiguration?: Resolver<Maybe<IResolversTypes['Configuration']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ISettingsGroupResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['SettingsGroup'] = IResolversParentTypes['SettingsGroup']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    range?: Resolver<Maybe<IResolversTypes['Range']>, ParentType, ContextType>;
    title?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    titleRange?: Resolver<Maybe<IResolversTypes['Range']>, ParentType, ContextType>;
    sections?: Resolver<Maybe<Array<Maybe<IResolversTypes['SettingsSection']>>>, ParentType, ContextType>;
    contributedByExtension?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ISettingsSectionResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['SettingsSection'] = IResolversParentTypes['SettingsSection']> = {
    titleRange?: Resolver<Maybe<IResolversTypes['Range']>, ParentType, ContextType>;
    title?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    settings?: Resolver<Maybe<Array<Maybe<IResolversTypes['Setting']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ISettingsSubjectResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['SettingsSubject'] = IResolversParentTypes['SettingsSubject']> = {
    __resolveType: TypeResolveFn<'UserSettings' | 'LocalUserSettings' | 'RemoteUserSettings' | 'FolderSettings' | 'GlobalSettings' | 'WorkspaceSettings' | 'MemorySettings' | 'DefaultSettings', ParentType, ContextType>;
};
export declare type IShellResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Shell'] = IResolversParentTypes['Shell']> = {
    osx?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    linux?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    windows?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    container?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IShellArgsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ShellArgs'] = IResolversParentTypes['ShellArgs']> = {
    container?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    windows?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    linux?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    osx?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ISideBySideEditorInputResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['SideBySideEditorInput'] = IResolversParentTypes['SideBySideEditorInput']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    resource?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    typeId?: Resolver<Maybe<IResolversTypes['EDITOR_INPUT_ID']>, ParentType, ContextType>;
    description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    fileReference?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType>;
    preferredEditorId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    isSupportsSplitEditor?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isActive?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    preview?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isPinned?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    status?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    closable?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    master?: Resolver<Maybe<IResolversTypes['EditorInput']>, ParentType, ContextType>;
    details?: Resolver<Maybe<IResolversTypes['EditorInput']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ISnippetResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Snippet'] = IResolversParentTypes['Snippet']> = {
    language?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IStatusbarResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Statusbar'] = IResolversParentTypes['Statusbar']> = {
    items?: Resolver<Maybe<Array<Maybe<IResolversTypes['StatusbarItem']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IStatusbarEntryResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['StatusbarEntry'] = IResolversParentTypes['StatusbarEntry']> = {
    showTabsButtons?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    showIcons?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    showStatusbar?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    text?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    ariaLabel?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    tooltip?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    color?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    backgroundColor?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    command?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    arguments?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    showBeak?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IStatusbarItemResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['StatusbarItem'] = IResolversParentTypes['StatusbarItem']> = {
    __resolveType: TypeResolveFn<'Terminal' | 'SelectionStatus' | 'Indentation' | 'EncodingStatus' | 'EndOfLineSequence' | 'LanguageMode' | 'SyncStatus' | 'BranchStatus', ParentType, ContextType>;
};
export declare type IStreamContentResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['StreamContent'] = IResolversParentTypes['StreamContent']> = {
    resource?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    mtime?: Resolver<Maybe<IResolversTypes['BigInt']>, ParentType, ContextType>;
    etag?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    value?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    status?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    encoding?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    linesRange?: Resolver<Maybe<IResolversTypes['LineRange']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ISubscriptionResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Subscription'] = IResolversParentTypes['Subscription']> = {
    dummy?: SubscriptionResolver<Maybe<IResolversTypes['Int']>, "dummy", ParentType, ContextType>;
    fileData?: SubscriptionResolver<Maybe<Array<Maybe<IResolversTypes['FileChange']>>>, "fileData", ParentType, ContextType, RequireFields<ISubscriptionfileDataArgs, 'resource'>>;
    fileOperation?: SubscriptionResolver<Maybe<IResolversTypes['FileOperationOutput']>, "fileOperation", ParentType, ContextType, RequireFields<ISubscriptionfileOperationArgs, 'resource'>>;
    onDidChangeConfiguration?: SubscriptionResolver<Maybe<IResolversTypes['IConfigurationChangeEvent']>, "onDidChangeConfiguration", ParentType, ContextType>;
    readStreamTextFile?: SubscriptionResolver<Maybe<IResolversTypes['TextFileStreamContent']>, "readStreamTextFile", ParentType, ContextType, RequireFields<ISubscriptionreadStreamTextFileArgs, 'resource'>>;
    readStreamTextString?: SubscriptionResolver<Maybe<IResolversTypes['TextFilePublishContent']>, "readStreamTextString", ParentType, ContextType, RequireFields<ISubscriptionreadStreamTextStringArgs, 'resource'>>;
    searchStreamContent?: SubscriptionResolver<Maybe<IResolversTypes['SearchCompleteStream']>, "searchStreamContent", ParentType, ContextType, RequireFields<ISubscriptionsearchStreamContentArgs, never>>;
};
export declare type ISyncStatusResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['SyncStatus'] = IResolversParentTypes['SyncStatus']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    alignment?: Resolver<Maybe<IResolversTypes['StatusbarAlignment']>, ParentType, ContextType>;
    entry?: Resolver<Maybe<IResolversTypes['StatusbarEntry']>, ParentType, ContextType>;
    priority?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    container?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    labelContainer?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    typeId?: Resolver<Maybe<IResolversTypes['STATUSBAR_ITEM_ID']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ITerminalResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['Terminal'] = IResolversParentTypes['Terminal']> = {
    alignment?: Resolver<Maybe<IResolversTypes['StatusbarAlignment']>, ParentType, ContextType>;
    container?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    entry?: Resolver<Maybe<IResolversTypes['StatusbarEntry']>, ParentType, ContextType>;
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    integrated?: Resolver<Maybe<IResolversTypes['Integrated']>, ParentType, ContextType>;
    labelContainer?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    priority?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    typeId?: Resolver<Maybe<IResolversTypes['STATUSBAR_ITEM_ID']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ITextBufferDataResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['TextBufferData'] = IResolversParentTypes['TextBufferData']> = {
    EOL?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    lines?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    containsRTL?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isBasicASCII?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ITextDocumentIdentifierResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['TextDocumentIdentifier'] = IResolversParentTypes['TextDocumentIdentifier']> = {
    uri?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    languageId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ITextDocumentItemResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['TextDocumentItem'] = IResolversParentTypes['TextDocumentItem']> = {
    uri?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    languageId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    text?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ITextDocumentPositionParamsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['TextDocumentPositionParams'] = IResolversParentTypes['TextDocumentPositionParams']> = {
    __resolveType: TypeResolveFn<'ProvideTextDocumentLocationSignature', ParentType, ContextType>;
    textDocument?: Resolver<Maybe<IResolversTypes['TextDocumentIdentifier']>, ParentType, ContextType>;
    position?: Resolver<Maybe<IResolversTypes['Position']>, ParentType, ContextType>;
};
export declare type ITextDocumentRegistrationOptionsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['TextDocumentRegistrationOptions'] = IResolversParentTypes['TextDocumentRegistrationOptions']> = {
    documentSelector?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ITextFileContentResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['TextFileContent'] = IResolversParentTypes['TextFileContent']> = {
    dirty?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    encoding?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    etag?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    inConflictMode?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inErrorMode?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inOrphanMode?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inPendingSave?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isReadonly?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    mtime?: Resolver<IResolversTypes['BigInt'], ParentType, ContextType>;
    name?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    preferredEncoding?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    preferredMode?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    resource?: Resolver<IResolversTypes['URI'], ParentType, ContextType>;
    size?: Resolver<IResolversTypes['Int'], ParentType, ContextType>;
    state?: Resolver<Maybe<IResolversTypes['FileModelState']>, ParentType, ContextType>;
    value?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ITextFilePublishContentResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['TextFilePublishContent'] = IResolversParentTypes['TextFilePublishContent']> = {
    resource?: Resolver<IResolversTypes['URI'], ParentType, ContextType>;
    name?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    mtime?: Resolver<Maybe<IResolversTypes['BigInt']>, ParentType, ContextType>;
    etag?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    size?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    isReadonly?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    streamSeq?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    encoding?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    value?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    status?: Resolver<Maybe<IResolversTypes['FileContentStatus']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ITextFileStreamContentResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['TextFileStreamContent'] = IResolversParentTypes['TextFileStreamContent']> = {
    resource?: Resolver<IResolversTypes['URI'], ParentType, ContextType>;
    name?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    size?: Resolver<IResolversTypes['Int'], ParentType, ContextType>;
    mtime?: Resolver<IResolversTypes['BigInt'], ParentType, ContextType>;
    etag?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    isReadonly?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    encoding?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    value?: Resolver<Maybe<IResolversTypes['TextBufferData']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ITextSearchContextResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['TextSearchContext'] = IResolversParentTypes['TextSearchContext']> = {
    uri?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    text?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    lineNumber?: Resolver<IResolversTypes['Int'], ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ITextSearchMatchResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['TextSearchMatch'] = IResolversParentTypes['TextSearchMatch']> = {
    uri?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    ranges?: Resolver<Maybe<Array<Maybe<IResolversTypes['SearchRange']>>>, ParentType, ContextType>;
    preview?: Resolver<Maybe<IResolversTypes['TextSearchResultPreview']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ITextSearchPreviewOptionsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['TextSearchPreviewOptions'] = IResolversParentTypes['TextSearchPreviewOptions']> = {
    matchLines?: Resolver<IResolversTypes['Int'], ParentType, ContextType>;
    charsPerLine?: Resolver<IResolversTypes['Int'], ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ITextSearchResultResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['TextSearchResult'] = IResolversParentTypes['TextSearchResult']> = {
    __resolveType: TypeResolveFn<'TextSearchMatch' | 'TextSearchContext', ParentType, ContextType>;
};
export declare type ITextSearchResultPreviewResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['TextSearchResultPreview'] = IResolversParentTypes['TextSearchResultPreview']> = {
    text?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    matches?: Resolver<Maybe<Array<Maybe<IResolversTypes['SearchRange']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ITextSearchStatsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['TextSearchStats'] = IResolversParentTypes['TextSearchStats']> = {
    type?: Resolver<Maybe<IResolversTypes['TextSearchStatsType']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IThemeLabelResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ThemeLabel'] = IResolversParentTypes['ThemeLabel']> = {
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    uiTheme?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    path?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ITreeItemResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['TreeItem'] = IResolversParentTypes['TreeItem']> = {
    handle?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    parentHandle?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    collapsibleState?: Resolver<Maybe<IResolversTypes['TreeItemCollapsibleState']>, ParentType, ContextType>;
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    icon?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    iconDark?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    themeIcon?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    resourceUri?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    tooltip?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    contextValue?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    children?: Resolver<Maybe<Array<Maybe<IResolversTypes['TreeItem']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ITreeViewDescriptorResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['TreeViewDescriptor'] = IResolversParentTypes['TreeViewDescriptor']> = {
    id?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    when?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    order?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    weight?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    collapsed?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    canToggleVisibility?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    hideByDefault?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    workspace?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IUntitledEditorInputResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['UntitledEditorInput'] = IResolversParentTypes['UntitledEditorInput']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    resource?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    typeId?: Resolver<Maybe<IResolversTypes['EDITOR_INPUT_ID']>, ParentType, ContextType>;
    description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    fileReference?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType>;
    preferredEditorId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    isSupportsSplitEditor?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isActive?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    preview?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isPinned?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    status?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    closable?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    hasAssociatedFilePath?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    shortDescription?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    mediumDescription?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    longDescription?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    shortTitle?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    mediumTitle?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    longTitle?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    suggestFileName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    enconding?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    mode?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IUpdateDelayedResourceResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['UpdateDelayedResource'] = IResolversParentTypes['UpdateDelayedResource']> = {
    resource?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IUpdatedResourceResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['UpdatedResource'] = IResolversParentTypes['UpdatedResource']> = {
    resource?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    etag?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export interface IURIScalarConfig extends GraphQLScalarTypeConfig<IResolversTypes['URI'], any> {
    name: 'URI';
}
export declare type IURIToOpenResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['URIToOpen'] = IResolversParentTypes['URIToOpen']> = {
    __resolveType: TypeResolveFn<'WorkspaceToOpen' | 'FolderToOpen' | 'FileToOpen', ParentType, ContextType>;
};
export declare type IUserResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['User'] = IResolversParentTypes['User']> = {
    username?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IUserPreferencesResResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['UserPreferencesRes'] = IResolversParentTypes['UserPreferencesRes']> = {
    prefs?: Resolver<Maybe<IResolversTypes['IUserPreferences']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IUserSettingsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['UserSettings'] = IResolversParentTypes['UserSettings']> = {
    id?: Resolver<Maybe<IResolversTypes['ID']>, ParentType, ContextType>;
    latestSettings?: Resolver<Maybe<IResolversTypes['Settings']>, ParentType, ContextType>;
    settingsURL?: Resolver<IResolversTypes['URI'], ParentType, ContextType>;
    viewerCanAdminister?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>;
    settingsCascade?: Resolver<IResolversTypes['SettingsCascade'], ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IViewResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['View'] = IResolversParentTypes['View']> = {
    id?: Resolver<Maybe<IResolversTypes['ID']>, ParentType, ContextType>;
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IViewContainerResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ViewContainer'] = IResolversParentTypes['ViewContainer']> = {
    id?: Resolver<Maybe<IResolversTypes['ID']>, ParentType, ContextType>;
    title?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IViewDescriptorResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ViewDescriptor'] = IResolversParentTypes['ViewDescriptor']> = {
    id?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    when?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    order?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    weight?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    collapsed?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    canToggleVisibility?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    hideByDefault?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    workspace?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IViewStateResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['ViewState'] = IResolversParentTypes['ViewState']> = {
    scrollTop?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    scrollTopWithoutViewZones?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    scrollLeft?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    firstPosition?: Resolver<Maybe<IResolversTypes['Position']>, ParentType, ContextType>;
    firstPositionDeltaTop?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export interface IVSBufferScalarConfig extends GraphQLScalarTypeConfig<IResolversTypes['VSBuffer'], any> {
    name: 'VSBuffer';
}
export interface IVSBufferReadableStreamScalarConfig extends GraphQLScalarTypeConfig<IResolversTypes['VSBufferReadableStream'], any> {
    name: 'VSBufferReadableStream';
}
export declare type IWindowConfigurationResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['WindowConfiguration'] = IResolversParentTypes['WindowConfiguration']> = {
    machineId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    windowId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    logLevel?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    mainPid?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    appRoot?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    execPath?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    isInitialStartup?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    nodeCacheDataDir?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    backupPath?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    workspace?: Resolver<Maybe<IResolversTypes['WorkspaceIdentifier']>, ParentType, ContextType>;
    folderUri?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    remoteAuthority?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    zoomLevel?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    fullscreen?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    maximized?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    highContrast?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    frameless?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    accessibilitySupport?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    partsSplashPath?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    perfStartTime?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    perfAppReady?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    perfWindowLoadTime?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    perfEntries?: Resolver<Maybe<IResolversTypes['AnyObject']>, ParentType, ContextType>;
    filesToOpenOrCreate?: Resolver<Maybe<Array<Maybe<IResolversTypes['Path']>>>, ParentType, ContextType>;
    filesToDiff?: Resolver<Maybe<Array<Maybe<IResolversTypes['Path']>>>, ParentType, ContextType>;
    filesToWait?: Resolver<Maybe<IResolversTypes['PathsToWaitFor']>, ParentType, ContextType>;
    termProgram?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IWorkspaceDataResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['WorkspaceData'] = IResolversParentTypes['WorkspaceData']> = {
    id?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    folders?: Resolver<Array<Maybe<IResolversTypes['WorkspaceFolderData']>>, ParentType, ContextType>;
    configuration?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    isUntitled?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IWorkspaceFolderDataResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['WorkspaceFolderData'] = IResolversParentTypes['WorkspaceFolderData']> = {
    uri?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    name?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    index?: Resolver<IResolversTypes['Int'], ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IWorkspaceIdentifierResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['WorkspaceIdentifier'] = IResolversParentTypes['WorkspaceIdentifier']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    configPath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IWorkspacePreferenceActivityBarResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['WorkspacePreferenceActivityBar'] = IResolversParentTypes['WorkspacePreferenceActivityBar']> = {
    visible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IWorkspacePreferenceCommandPaletteResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['WorkspacePreferenceCommandPalette'] = IResolversParentTypes['WorkspacePreferenceCommandPalette']> = {
    history?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    preserveInput?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IWorkspacePreferenceEditorResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['WorkspacePreferenceEditor'] = IResolversParentTypes['WorkspacePreferenceEditor']> = {
    centeredLayoutAutoResize?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    closeEmptyGroups?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    closeOnFileDelete?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    enablePreview?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    enablePreviewFromQuickOpen?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    focusRecentEditorAfterClose?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    highlightModifiedTabs?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    labelFormat?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    openPositioning?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    openSideBySideDirection?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    restoreViewState?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    revealIfOpen?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    showIcons?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    showTabs?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    splitSizing?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    tabCloseButton?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    tabSizing?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IWorkspacePreferenceExperimentalResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['WorkspacePreferenceExperimental'] = IResolversParentTypes['WorkspacePreferenceExperimental']> = {
    editorAssociations?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IWorkspacePreferenceListResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['WorkspacePreferenceList'] = IResolversParentTypes['WorkspacePreferenceList']> = {
    automaticKeyboardNavigation?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    horizontalScrolling?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    keyboardNavigation?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    multiSelectModifier?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    openMode?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IWorkspacePreferencePanelResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['WorkspacePreferencePanel'] = IResolversParentTypes['WorkspacePreferencePanel']> = {
    defaultLocation?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IWorkspacePreferenceQuickOpenResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['WorkspacePreferenceQuickOpen'] = IResolversParentTypes['WorkspacePreferenceQuickOpen']> = {
    closeOnFocusLost?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    preserveInput?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IWorkspacePreferenceSettingsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['WorkspacePreferenceSettings'] = IResolversParentTypes['WorkspacePreferenceSettings']> = {
    editor?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    enableNaturalLanguageSearch?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    openDefaultKeybindings?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    settingsSearchTocBehavior?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    useSplitJSON?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IWorkspacePreferenceSideBarResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['WorkspacePreferenceSideBar'] = IResolversParentTypes['WorkspacePreferenceSideBar']> = {
    location?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IWorkspacePreferenceStatusBarResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['WorkspacePreferenceStatusBar'] = IResolversParentTypes['WorkspacePreferenceStatusBar']> = {
    visible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IWorkspacePreferenceTipsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['WorkspacePreferenceTips'] = IResolversParentTypes['WorkspacePreferenceTips']> = {
    enabled?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    horizontalScrolling?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    indent?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    renderIndentGuides?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IWorkspacePreferenceViewResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['WorkspacePreferenceView'] = IResolversParentTypes['WorkspacePreferenceView']> = {
    alwaysShowHeaderActions?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IWorkspacePreferenceWorkbenchResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['WorkspacePreferenceWorkbench'] = IResolversParentTypes['WorkspacePreferenceWorkbench']> = {
    colorTheme?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    enableExperiments?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    fontAliasing?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    iconTheme?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    startupEditor?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    view?: Resolver<Maybe<IResolversTypes['WorkspacePreferenceView']>, ParentType, ContextType>;
    tips?: Resolver<Maybe<IResolversTypes['WorkspacePreferenceTips']>, ParentType, ContextType>;
    statusBar?: Resolver<Maybe<IResolversTypes['WorkspacePreferenceStatusBar']>, ParentType, ContextType>;
    sideBar?: Resolver<Maybe<IResolversTypes['WorkspacePreferenceSideBar']>, ParentType, ContextType>;
    settings?: Resolver<Maybe<IResolversTypes['WorkspacePreferenceSettings']>, ParentType, ContextType>;
    quickOpen?: Resolver<Maybe<IResolversTypes['WorkspacePreferenceQuickOpen']>, ParentType, ContextType>;
    panel?: Resolver<Maybe<IResolversTypes['WorkspacePreferencePanel']>, ParentType, ContextType>;
    list?: Resolver<Maybe<IResolversTypes['WorkspacePreferenceList']>, ParentType, ContextType>;
    experimental?: Resolver<Maybe<IResolversTypes['WorkspacePreferenceExperimental']>, ParentType, ContextType>;
    editor?: Resolver<Maybe<IResolversTypes['WorkspacePreferenceEditor']>, ParentType, ContextType>;
    commandPalette?: Resolver<Maybe<IResolversTypes['WorkspacePreferenceCommandPalette']>, ParentType, ContextType>;
    activityBar?: Resolver<Maybe<IResolversTypes['WorkspacePreferenceActivityBar']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IWorkspaceResResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['WorkspaceRes'] = IResolversParentTypes['WorkspaceRes']> = {
    uri?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IWorkspaceSettingsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['WorkspaceSettings'] = IResolversParentTypes['WorkspaceSettings']> = {
    id?: Resolver<Maybe<IResolversTypes['ID']>, ParentType, ContextType>;
    latestSettings?: Resolver<Maybe<IResolversTypes['Settings']>, ParentType, ContextType>;
    settingsURL?: Resolver<IResolversTypes['URI'], ParentType, ContextType>;
    viewerCanAdminister?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>;
    settingsCascade?: Resolver<IResolversTypes['SettingsCascade'], ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IWorkspaceStackSettingsResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['WorkspaceStackSettings'] = IResolversParentTypes['WorkspaceStackSettings']> = {
    dummy?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IWorkspaceToOpenResolvers<ContextType = ApolloContext, ParentType extends IResolversParentTypes['WorkspaceToOpen'] = IResolversParentTypes['WorkspaceToOpen']> = {
    workspaceUri?: Resolver<IResolversTypes['URI'], ParentType, ContextType>;
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IResolvers<ContextType = ApolloContext> = {
    Action?: IActionResolvers<ContextType>;
    ActionItem?: IActionItemResolvers<ContextType>;
    ActionRun?: IActionRunResolvers<ContextType>;
    Actions?: IActionsResolvers<ContextType>;
    AddFoldersRequest?: IAddFoldersRequestResolvers<ContextType>;
    Anchor?: IAnchorResolvers<ContextType>;
    AnyObject?: GraphQLScalarType;
    ArgsType?: IArgsTypeResolvers<ContextType>;
    Assets?: IAssetsResolvers<ContextType>;
    Author?: IAuthorResolvers<ContextType>;
    BaseExtension?: IBaseExtensionResolvers<ContextType>;
    BigInt?: GraphQLScalarType;
    BranchStatus?: IBranchStatusResolvers<ContextType>;
    Bundles?: IBundlesResolvers<ContextType>;
    CachedSearchStats?: ICachedSearchStatsResolvers<ContextType>;
    ChangeRange?: IChangeRangeResolvers<ContextType>;
    ChangesChunk?: IChangesChunkResolvers<ContextType>;
    CheckboxOptions?: ICheckboxOptionsResolvers<ContextType>;
    CloseEditorsFilter?: ICloseEditorsFilterResolvers<ContextType>;
    CodeEditorViewState?: ICodeEditorViewStateResolvers<ContextType>;
    CommandHandlerDescriptionType?: ICommandHandlerDescriptionTypeResolvers<ContextType>;
    CommandsType?: ICommandsTypeResolvers<ContextType>;
    CommandType?: ICommandTypeResolvers<ContextType>;
    Configuration?: IConfigurationResolvers<ContextType>;
    ConfigurationData?: IConfigurationDataResolvers<ContextType>;
    ConfigurationExtensionInfo?: IConfigurationExtensionInfoResolvers<ContextType>;
    ConfigurationModel?: IConfigurationModelResolvers<ContextType>;
    ConfigurationOverrides?: IConfigurationOverridesResolvers<ContextType>;
    ContentChangedEvent?: IContentChangedEventResolvers<ContextType>;
    Context?: IContextResolvers<ContextType>;
    ContextMenu?: IContextMenuResolvers<ContextType>;
    Contributes?: IContributesResolvers<ContextType>;
    CrashReporterStartOptions?: ICrashReporterStartOptionsResolvers<ContextType>;
    CursorState?: ICursorStateResolvers<ContextType>;
    DataUriEditorInput?: IDataUriEditorInputResolvers<ContextType>;
    Debugger?: IDebuggerResolvers<ContextType>;
    DefaultPreferencesResponse?: IDefaultPreferencesResponseResolvers<ContextType>;
    DefaultSettings?: IDefaultSettingsResolvers<ContextType>;
    Detail?: IDetailResolvers<ContextType>;
    DevToolsOptions?: IDevToolsOptionsResolvers<ContextType>;
    Dialog?: IDialogResolvers<ContextType>;
    DialogResult?: IDialogResultResolvers<ContextType>;
    DiffEditorInput?: IDiffEditorInputResolvers<ContextType>;
    DockLayout?: IDockLayoutResolvers<ContextType>;
    DocSitePage?: IDocSitePageResolvers<ContextType>;
    DocumentFilter?: IDocumentFilterResolvers<ContextType>;
    EditKeybindingItem?: IEditKeybindingItemResolvers<ContextType>;
    EditorChildren?: IEditorChildrenResolvers;
    EditorGroup?: IEditorGroupResolvers<ContextType>;
    EditorGroupLayout?: IEditorGroupLayoutResolvers<ContextType>;
    EditorIdentifier?: IEditorIdentifierResolvers<ContextType>;
    EditorInput?: IEditorInputResolvers;
    EditorPart?: IEditorPartResolvers<ContextType>;
    EditorPartOptions_Input?: IEditorPartOptions_InputResolvers<ContextType>;
    EditorSettings?: IEditorSettingsResolvers<ContextType>;
    EmptyResponse?: IEmptyResponseResolvers<ContextType>;
    EncodingStatus?: IEncodingStatusResolvers<ContextType>;
    EndOfLineSequence?: IEndOfLineSequenceResolvers<ContextType>;
    Engines?: IEnginesResolvers<ContextType>;
    EnterWorkspaceResult?: IEnterWorkspaceResultResolvers<ContextType>;
    Environment?: IEnvironmentResolvers<ContextType>;
    ExtensionColor?: IExtensionColorResolvers<ContextType>;
    ExtensionColorTypes?: IExtensionColorTypesResolvers<ContextType>;
    ExtensionConfiguration?: IExtensionConfigurationResolvers<ContextType>;
    ExtensionConfigurationProperty?: IExtensionConfigurationPropertyResolvers<ContextType>;
    ExtensionContributions?: IExtensionContributionsResolvers<ContextType>;
    ExtensionHostDebugParams?: IExtensionHostDebugParamsResolvers<ContextType>;
    ExtensionIdentifier?: IExtensionIdentifierResolvers<ContextType>;
    ExtensionInstance?: IExtensionInstanceResolvers<ContextType>;
    ExtensionJSONValidation?: IExtensionJSONValidationResolvers<ContextType>;
    ExtensionLanguage?: IExtensionLanguageResolvers<ContextType>;
    ExtensionManifest?: IExtensionManifestResolvers<ContextType>;
    ExtensionManifestBugs?: IExtensionManifestBugsResolvers<ContextType>;
    ExtensionManifestRepository?: IExtensionManifestRepositoryResolvers<ContextType>;
    ExtensionPackageType?: IExtensionPackageTypeResolvers<ContextType>;
    ExtensionRegistry?: IExtensionRegistryResolvers<ContextType>;
    ExtensionRegistryCreateExtensionResult?: IExtensionRegistryCreateExtensionResultResolvers<ContextType>;
    ExtensionRegistryPublishExtensionResult?: IExtensionRegistryPublishExtensionResultResolvers<ContextType>;
    ExtensionRegistryUpdateExtensionResult?: IExtensionRegistryUpdateExtensionResultResolvers<ContextType>;
    ExtensionRelease?: IExtensionReleaseResolvers<ContextType>;
    FieldError?: IFieldErrorResolvers<ContextType>;
    FileChange?: IFileChangeResolvers<ContextType>;
    FileContent?: IFileContentResolvers<ContextType>;
    FileDeleteOptions?: IFileDeleteOptionsResolvers<ContextType>;
    FileEditorInput?: IFileEditorInputResolvers<ContextType>;
    FileFilter?: IFileFilterResolvers<ContextType>;
    FileIndexProviderStats?: IFileIndexProviderStatsResolvers<ContextType>;
    FileMatch?: IFileMatchResolvers<ContextType>;
    FileOpenOptions?: IFileOpenOptionsResolvers<ContextType>;
    FileOperationOutput?: IFileOperationOutputResolvers<ContextType>;
    FileOverwriteOptions?: IFileOverwriteOptionsResolvers<ContextType>;
    FileResult?: IFileResultResolvers<ContextType>;
    Files?: IFilesResolvers<ContextType>;
    Files_Stat?: IFiles_StatResolvers<ContextType>;
    FileSearchProviderStats?: IFileSearchProviderStatsResolvers<ContextType>;
    FileSearchStats?: IFileSearchStatsResolvers<ContextType>;
    FileSearchStatsdetailStats?: IFileSearchStatsdetailStatsResolvers;
    FileStat?: IFileStatResolvers<ContextType>;
    FileStatWithMetadata?: IFileStatWithMetadataResolvers<ContextType>;
    FileStreamContent?: IFileStreamContentResolvers<ContextType>;
    FileToOpen?: IFileToOpenResolvers<ContextType>;
    FileWriteOptions?: IFileWriteOptionsResolvers<ContextType>;
    FolderConfigurationModel?: IFolderConfigurationModelResolvers<ContextType>;
    FolderQuery?: IFolderQueryResolvers<ContextType>;
    FolderSettings?: IFolderSettingsResolvers<ContextType>;
    FolderToOpen?: IFolderToOpenResolvers<ContextType>;
    GalleryBanner?: IGalleryBannerResolvers<ContextType>;
    GalleryExtension?: IGalleryExtensionResolvers<ContextType>;
    GalleryExtensionAsset?: IGalleryExtensionAssetResolvers<ContextType>;
    GalleryExtensionAssets?: IGalleryExtensionAssetsResolvers<ContextType>;
    GalleryExtensionProperties?: IGalleryExtensionPropertiesResolvers<ContextType>;
    GalleryExtensionResources?: IGalleryExtensionResourcesResolvers<ContextType>;
    GalleryPager?: IGalleryPagerResolvers<ContextType>;
    Git?: IGitResolvers<ContextType>;
    GitDecorations?: IGitDecorationsResolvers<ContextType>;
    GlobalSettings?: IGlobalSettingsResolvers<ContextType>;
    GoToLineQuickAccess?: IGoToLineQuickAccessResolvers<ContextType>;
    Grammar?: IGrammarResolvers<ContextType>;
    GroupLayoutArgument?: IGroupLayoutArgumentResolvers<ContextType>;
    IBaseStat?: IIBaseStatResolvers;
    IBaseStatWithMetadata?: IIBaseStatWithMetadataResolvers;
    IBaseTextFileContent?: IIBaseTextFileContentResolvers;
    IBehaviorSubject?: IIBehaviorSubjectResolvers<ContextType>;
    IBehaviorSubjectValue?: IIBehaviorSubjectValueResolvers<ContextType>;
    IConfigurationChangeEvent?: IIConfigurationChangeEventResolvers<ContextType>;
    IContentChangedEvent?: IIContentChangedEventResolvers;
    IDebugParams?: IIDebugParamsResolvers;
    IDestinationAnonymousSubject?: IIDestinationAnonymousSubjectResolvers<ContextType>;
    IDocumentSelector?: IIDocumentSelectorResolvers<ContextType>;
    IEditorGroup?: IIEditorGroupResolvers;
    IEditorInput?: IIEditorInputResolvers;
    IEditorInputWithGroupFields?: IIEditorInputWithGroupFieldsResolvers;
    IEncodingSupport?: IIEncodingSupportResolvers;
    IFileClientMetadata?: IIFileClientMetadataResolvers;
    IFileEditorInput?: IIFileEditorInputResolvers;
    IFileMatch?: IIFileMatchResolvers;
    IModel?: IIModelResolvers<ContextType>;
    IModeSupport?: IIModeSupportResolvers;
    ImportResult?: IImportResultResolvers<ContextType>;
    Indentation?: IIndentationResolvers<ContextType>;
    InputTypeDetail?: IInputTypeDetailResolvers<ContextType>;
    InstalledExtension?: IInstalledExtensionResolvers<ContextType>;
    Integrated?: IIntegratedResolvers<ContextType>;
    IObservableResult?: IIObservableResultResolvers<ContextType>;
    IPathData?: IIPathDataResolvers;
    IPathsToWaitForData?: IIPathsToWaitForDataResolvers;
    ISearchCompleteStats?: IISearchCompleteStatsResolvers;
    ISearchProgress?: IISearchProgressResolvers;
    ISettingsSubject?: IISettingsSubjectResolvers;
    ISideBySideEditorInput?: IISideBySideEditorInputResolvers;
    ISourceAnonymousSubject?: IISourceAnonymousSubjectResolvers<ContextType>;
    IStaticWorkspaceData?: IIStaticWorkspaceDataResolvers;
    IStatusbarItem?: IIStatusbarItemResolvers;
    ISwitchMapOperator?: IISwitchMapOperatorResolvers<ContextType>;
    ITextDocumentIdentifier?: IITextDocumentIdentifierResolvers;
    ITreeItem?: IITreeItemResolvers;
    IUntitledFileValue?: IIUntitledFileValueResolvers;
    IUserPreferences?: IIUserPreferencesResolvers<ContextType>;
    IUserSettings?: IIUserSettingsResolvers<ContextType>;
    IViewComponentData?: IIViewComponentDataResolvers<ContextType>;
    IViewDescriptor?: IIViewDescriptorResolvers;
    IWorkspaceRoot?: IIWorkspaceRootResolvers<ContextType>;
    JSON?: GraphQLScalarType;
    JSONObject?: GraphQLScalarType;
    KeyBinding?: IKeyBindingResolvers<ContextType>;
    KeybindingContextMenu?: IKeybindingContextMenuResolvers<ContextType>;
    KeybindingEditorInput?: IKeybindingEditorInputResolvers<ContextType>;
    KeybindingItem?: IKeybindingItemResolvers<ContextType>;
    Keybindings?: IKeybindingsResolvers<ContextType>;
    KeyboardEvent_output?: IKeyboardEvent_outputResolvers<ContextType>;
    LanguageMode?: ILanguageModeResolvers<ContextType>;
    Languages?: ILanguagesResolvers<ContextType>;
    LineMatch?: ILineMatchResolvers<ContextType>;
    LineRange?: ILineRangeResolvers<ContextType>;
    Localization?: ILocalizationResolvers<ContextType>;
    LocalizationTranslation?: ILocalizationTranslationResolvers<ContextType>;
    LocalUserSettings?: ILocalUserSettingsResolvers<ContextType>;
    Location?: ILocationResolvers;
    Match?: IMatchResolvers<ContextType>;
    MemorySettings?: IMemorySettingsResolvers<ContextType>;
    MenuItem?: IMenuItemResolvers<ContextType>;
    MenuItemAction?: IMenuItemActionResolvers<ContextType>;
    MenuItemActionContext?: IMenuItemActionContextResolvers<ContextType>;
    MenuItemActionDebug?: IMenuItemActionDebugResolvers<ContextType>;
    MenuItemActionEditor?: IMenuItemActionEditorResolvers<ContextType>;
    MenuItemActionEditorTitle?: IMenuItemActionEditorTitleResolvers<ContextType>;
    MenuItemActionScm?: IMenuItemActionScmResolvers<ContextType>;
    MenuItemActionScmChange?: IMenuItemActionScmChangeResolvers<ContextType>;
    MenuItemActionView?: IMenuItemActionViewResolvers<ContextType>;
    Menus?: IMenusResolvers<ContextType>;
    MessageBoxOptions?: IMessageBoxOptionsResolvers<ContextType>;
    MessageBoxResult?: IMessageBoxResultResolvers<ContextType>;
    MessageLink?: IMessageLinkResolvers<ContextType>;
    Mutation?: IMutationResolvers<ContextType>;
    NativeOpenDialogOptions?: INativeOpenDialogOptionsResolvers<ContextType>;
    NewWindowOptions?: INewWindowOptionsResolvers<ContextType>;
    Node?: INodeResolvers;
    Notification?: INotificationResolvers<ContextType>;
    NotificationActions?: INotificationActionsResolvers<ContextType>;
    NotificationChangeEvent?: INotificationChangeEventResolvers<ContextType>;
    NotificationMessage?: INotificationMessageResolvers<ContextType>;
    Notifications?: INotificationsResolvers<ContextType>;
    NotificationViewItem?: INotificationViewItemResolvers<ContextType>;
    NotificationViewItemProgress?: INotificationViewItemProgressResolvers<ContextType>;
    NotificationViewItemProgressState?: INotificationViewItemProgressStateResolvers<ContextType>;
    Observable?: GraphQLScalarType;
    OneSearchPathPattern?: IOneSearchPathPatternResolvers<ContextType>;
    OpenConfiguration?: IOpenConfigurationResolvers<ContextType>;
    OpenDialogOptions?: IOpenDialogOptionsResolvers<ContextType>;
    OpenFileRequest?: IOpenFileRequestResolvers<ContextType>;
    OpenSettings?: IOpenSettingsResolvers<ContextType>;
    Output?: IOutputResolvers<ContextType>;
    Overrides?: IOverridesResolvers<ContextType>;
    PageInfo?: IPageInfoResolvers<ContextType>;
    Path?: IPathResolvers<ContextType>;
    PathsToWaitFor?: IPathsToWaitForResolvers<ContextType>;
    PatternInfo?: IPatternInfoResolvers<ContextType>;
    PendingStatusbarEntry?: IPendingStatusbarEntryResolvers<ContextType>;
    Position?: IPositionResolvers<ContextType>;
    PreferenceItem?: IPreferenceItemResolvers<ContextType>;
    PreferencesEditorInput?: IPreferencesEditorInputResolvers<ContextType>;
    PreferencesType?: IPreferencesTypeResolvers<ContextType>;
    PrimaryButtonAction?: IPrimaryButtonActionResolvers<ContextType>;
    ProcessMonitoring?: IProcessMonitoringResolvers<ContextType>;
    Progress?: IProgressResolvers<ContextType>;
    ProvideTextDocumentLocationSignature?: IProvideTextDocumentLocationSignatureResolvers<ContextType>;
    Query?: IQueryResolvers<ContextType>;
    QuickInput?: IQuickInputResolvers<ContextType>;
    QuickInputModel?: IQuickInputModelResolvers<ContextType>;
    QuickPick?: IQuickPickResolvers<ContextType>;
    QuickPickItem?: IQuickPickItemResolvers<ContextType>;
    QuickPickItemHighlights?: IQuickPickItemHighlightsResolvers<ContextType>;
    Range?: IRangeResolvers<ContextType>;
    RegistryEntry?: IRegistryEntryResolvers<ContextType>;
    RegistryExtension?: IRegistryExtensionResolvers<ContextType>;
    RegistryExtensionConnection?: IRegistryExtensionConnectionResolvers<ContextType>;
    RegistryPublisher?: IRegistryPublisherResolvers<ContextType>;
    RegistryPublisherConnection?: IRegistryPublisherConnectionResolvers<ContextType>;
    RemoteUserSettings?: IRemoteUserSettingsResolvers<ContextType>;
    ReplaceContentResult?: IReplaceContentResultResolvers<ContextType>;
    ResolveFileResult?: IResolveFileResultResolvers<ContextType>;
    ResolveFileResultWithMetadata?: IResolveFileResultWithMetadataResolvers<ContextType>;
    ResourceEditorInput?: IResourceEditorInputResolvers<ContextType>;
    ResourceEncoding?: IResourceEncodingResolvers<ContextType>;
    ResourceMapConfigurationModel?: IResourceMapConfigurationModelResolvers<ContextType>;
    RevealOptions?: IRevealOptionsResolvers<ContextType>;
    RunActionInWindowRequest?: IRunActionInWindowRequestResolvers<ContextType>;
    RunKeybindingInWindowRequest?: IRunKeybindingInWindowRequestResolvers<ContextType>;
    SaveDialogOptions?: ISaveDialogOptionsResolvers<ContextType>;
    SaveWorkspaceRes?: ISaveWorkspaceResResolvers<ContextType>;
    Scripts?: IScriptsResolvers<ContextType>;
    Search?: ISearchResolvers<ContextType>;
    SearchComplete?: ISearchCompleteResolvers<ContextType>;
    SearchCompleteStatsStats?: ISearchCompleteStatsStatsResolvers;
    SearchCompleteStream?: ISearchCompleteStreamResolvers<ContextType>;
    SearchEngineStats?: ISearchEngineStatsResolvers<ContextType>;
    SearchLog?: ISearchLogResolvers<ContextType>;
    SearchPathPattern?: ISearchPathPatternResolvers<ContextType>;
    SearchProgressItem?: ISearchProgressItemResolvers<ContextType>;
    SearchQuickOpen?: ISearchQuickOpenResolvers<ContextType>;
    SearchRange?: ISearchRangeResolvers<ContextType>;
    SelectedOutput?: ISelectedOutputResolvers<ContextType>;
    SelectionStatus?: ISelectionStatusResolvers<ContextType>;
    Setting?: ISettingResolvers<ContextType>;
    Settings?: ISettingsResolvers<ContextType>;
    SettingsCascade?: ISettingsCascadeResolvers<ContextType>;
    SettingsGroup?: ISettingsGroupResolvers<ContextType>;
    SettingsSection?: ISettingsSectionResolvers<ContextType>;
    SettingsSubject?: ISettingsSubjectResolvers;
    Shell?: IShellResolvers<ContextType>;
    ShellArgs?: IShellArgsResolvers<ContextType>;
    SideBySideEditorInput?: ISideBySideEditorInputResolvers<ContextType>;
    Snippet?: ISnippetResolvers<ContextType>;
    Statusbar?: IStatusbarResolvers<ContextType>;
    StatusbarEntry?: IStatusbarEntryResolvers<ContextType>;
    StatusbarItem?: IStatusbarItemResolvers;
    StreamContent?: IStreamContentResolvers<ContextType>;
    Subscription?: ISubscriptionResolvers<ContextType>;
    SyncStatus?: ISyncStatusResolvers<ContextType>;
    Terminal?: ITerminalResolvers<ContextType>;
    TextBufferData?: ITextBufferDataResolvers<ContextType>;
    TextDocumentIdentifier?: ITextDocumentIdentifierResolvers<ContextType>;
    TextDocumentItem?: ITextDocumentItemResolvers<ContextType>;
    TextDocumentPositionParams?: ITextDocumentPositionParamsResolvers;
    TextDocumentRegistrationOptions?: ITextDocumentRegistrationOptionsResolvers<ContextType>;
    TextFileContent?: ITextFileContentResolvers<ContextType>;
    TextFilePublishContent?: ITextFilePublishContentResolvers<ContextType>;
    TextFileStreamContent?: ITextFileStreamContentResolvers<ContextType>;
    TextSearchContext?: ITextSearchContextResolvers<ContextType>;
    TextSearchMatch?: ITextSearchMatchResolvers<ContextType>;
    TextSearchPreviewOptions?: ITextSearchPreviewOptionsResolvers<ContextType>;
    TextSearchResult?: ITextSearchResultResolvers;
    TextSearchResultPreview?: ITextSearchResultPreviewResolvers<ContextType>;
    TextSearchStats?: ITextSearchStatsResolvers<ContextType>;
    ThemeLabel?: IThemeLabelResolvers<ContextType>;
    TreeItem?: ITreeItemResolvers<ContextType>;
    TreeViewDescriptor?: ITreeViewDescriptorResolvers<ContextType>;
    UntitledEditorInput?: IUntitledEditorInputResolvers<ContextType>;
    UpdateDelayedResource?: IUpdateDelayedResourceResolvers<ContextType>;
    UpdatedResource?: IUpdatedResourceResolvers<ContextType>;
    URI?: GraphQLScalarType;
    URIToOpen?: IURIToOpenResolvers;
    User?: IUserResolvers<ContextType>;
    UserPreferencesRes?: IUserPreferencesResResolvers<ContextType>;
    UserSettings?: IUserSettingsResolvers<ContextType>;
    View?: IViewResolvers<ContextType>;
    ViewContainer?: IViewContainerResolvers<ContextType>;
    ViewDescriptor?: IViewDescriptorResolvers<ContextType>;
    ViewState?: IViewStateResolvers<ContextType>;
    VSBuffer?: GraphQLScalarType;
    VSBufferReadableStream?: GraphQLScalarType;
    WindowConfiguration?: IWindowConfigurationResolvers<ContextType>;
    WorkspaceData?: IWorkspaceDataResolvers<ContextType>;
    WorkspaceFolderData?: IWorkspaceFolderDataResolvers<ContextType>;
    WorkspaceIdentifier?: IWorkspaceIdentifierResolvers<ContextType>;
    WorkspacePreferenceActivityBar?: IWorkspacePreferenceActivityBarResolvers<ContextType>;
    WorkspacePreferenceCommandPalette?: IWorkspacePreferenceCommandPaletteResolvers<ContextType>;
    WorkspacePreferenceEditor?: IWorkspacePreferenceEditorResolvers<ContextType>;
    WorkspacePreferenceExperimental?: IWorkspacePreferenceExperimentalResolvers<ContextType>;
    WorkspacePreferenceList?: IWorkspacePreferenceListResolvers<ContextType>;
    WorkspacePreferencePanel?: IWorkspacePreferencePanelResolvers<ContextType>;
    WorkspacePreferenceQuickOpen?: IWorkspacePreferenceQuickOpenResolvers<ContextType>;
    WorkspacePreferenceSettings?: IWorkspacePreferenceSettingsResolvers<ContextType>;
    WorkspacePreferenceSideBar?: IWorkspacePreferenceSideBarResolvers<ContextType>;
    WorkspacePreferenceStatusBar?: IWorkspacePreferenceStatusBarResolvers<ContextType>;
    WorkspacePreferenceTips?: IWorkspacePreferenceTipsResolvers<ContextType>;
    WorkspacePreferenceView?: IWorkspacePreferenceViewResolvers<ContextType>;
    WorkspacePreferenceWorkbench?: IWorkspacePreferenceWorkbenchResolvers<ContextType>;
    WorkspaceRes?: IWorkspaceResResolvers<ContextType>;
    WorkspaceSettings?: IWorkspaceSettingsResolvers<ContextType>;
    WorkspaceStackSettings?: IWorkspaceStackSettingsResolvers<ContextType>;
    WorkspaceToOpen?: IWorkspaceToOpenResolvers<ContextType>;
};
export declare const DefaultSettingFragmentDoc: import("graphql").DocumentNode;
export declare const SettingRangeFragmentDoc: import("graphql").DocumentNode;
export declare const TerminalConfigurationFragmentDoc: import("graphql").DocumentNode;
export declare const SearchConfigurationFragmentDoc: import("graphql").DocumentNode;
export declare const LanguagesConfigurationFragmentDoc: import("graphql").DocumentNode;
export declare const FilesConfigurationFragmentDoc: import("graphql").DocumentNode;
export declare const GitConfigurationFragmentDoc: import("graphql").DocumentNode;
export declare const WorkspaceConfigurationFragmentDoc: import("graphql").DocumentNode;
export declare const ViewerSettingsFragmentDoc: import("graphql").DocumentNode;
export declare const AllContextFragmentDoc: import("graphql").DocumentNode;
export declare const FinalConfigurationFragmentDoc: import("graphql").DocumentNode;
export declare const KeybindingItemFragmentDoc: import("graphql").DocumentNode;
export declare const KeybindingsFragmentDoc: import("graphql").DocumentNode;
export declare const pickItemFragmentDoc: import("graphql").DocumentNode;
export declare const selectedFragmentDoc: import("graphql").DocumentNode;
export declare const ResourceContextFragmentDoc: import("graphql").DocumentNode;
export declare const statusbarItemFragmentDoc: import("graphql").DocumentNode;
export declare const GetConfigurationDataFragmentDoc: import("graphql").DocumentNode;
export declare const INotificationMessageFragmentDoc: import("graphql").DocumentNode;
export declare const NotificationMessageFragmentDoc: import("graphql").DocumentNode;
export declare const NotifyActionFragmentDoc: import("graphql").DocumentNode;
export declare const NotificationFragmentDoc: import("graphql").DocumentNode;
export declare const WorkspaceFolderFragmentDoc: import("graphql").DocumentNode;
export declare const installDocument: import("graphql").DocumentNode;
export declare type installMutationResult = ApolloReactCommon.MutationResult<IinstallMutation>;
export declare type installMutationOptions = ApolloReactCommon.BaseMutationOptions<IinstallMutation, IinstallMutationVariables>;
export declare const providerDefinitionDocument: import("graphql").DocumentNode;
export declare type providerDefinitionMutationResult = ApolloReactCommon.MutationResult<IproviderDefinitionMutation>;
export declare type providerDefinitionMutationOptions = ApolloReactCommon.BaseMutationOptions<IproviderDefinitionMutation, IproviderDefinitionMutationVariables>;
export declare const removeDocument: import("graphql").DocumentNode;
export declare type removeMutationResult = ApolloReactCommon.MutationResult<IremoveMutation>;
export declare type removeMutationOptions = ApolloReactCommon.BaseMutationOptions<IremoveMutation, IremoveMutationVariables>;
export declare const ExtensionsByLimitDocument: import("graphql").DocumentNode;
export declare type ExtensionsByLimitQueryResult = ApolloReactCommon.QueryResult<IExtensionsByLimitQuery, IExtensionsByLimitQueryVariables>;
export declare const ExtensionsDocument: import("graphql").DocumentNode;
export declare type ExtensionsQueryResult = ApolloReactCommon.QueryResult<IExtensionsQuery, IExtensionsQueryVariables>;
export declare const galleryExtensionDocument: import("graphql").DocumentNode;
export declare type galleryExtensionQueryResult = ApolloReactCommon.QueryResult<IgalleryExtensionQuery, IgalleryExtensionQueryVariables>;
export declare const galleryDocument: import("graphql").DocumentNode;
export declare type galleryQueryResult = ApolloReactCommon.QueryResult<IgalleryQuery, IgalleryQueryVariables>;
export declare const installedExtensionsDocument: import("graphql").DocumentNode;
export declare type installedExtensionsQueryResult = ApolloReactCommon.QueryResult<IinstalledExtensionsQuery, IinstalledExtensionsQueryVariables>;
export declare const ViewerSettingsDocument: import("graphql").DocumentNode;
export declare type ViewerSettingsQueryResult = ApolloReactCommon.QueryResult<IViewerSettingsQuery, IViewerSettingsQueryVariables>;
export declare const GetConfigurationTargetDocument: import("graphql").DocumentNode;
export declare type GetConfigurationTargetMutationResult = ApolloReactCommon.MutationResult<IGetConfigurationTargetMutation>;
export declare type GetConfigurationTargetMutationOptions = ApolloReactCommon.BaseMutationOptions<IGetConfigurationTargetMutation, IGetConfigurationTargetMutationVariables>;
export declare const OpenGlobalKeybindingsSettingsDocument: import("graphql").DocumentNode;
export declare type OpenGlobalKeybindingsSettingsMutationResult = ApolloReactCommon.MutationResult<IOpenGlobalKeybindingsSettingsMutation>;
export declare type OpenGlobalKeybindingsSettingsMutationOptions = ApolloReactCommon.BaseMutationOptions<IOpenGlobalKeybindingsSettingsMutation, IOpenGlobalKeybindingsSettingsMutationVariables>;
export declare const OpenPreferenceSettingsDocument: import("graphql").DocumentNode;
export declare type OpenPreferenceSettingsMutationResult = ApolloReactCommon.MutationResult<IOpenPreferenceSettingsMutation>;
export declare type OpenPreferenceSettingsMutationOptions = ApolloReactCommon.BaseMutationOptions<IOpenPreferenceSettingsMutation, IOpenPreferenceSettingsMutationVariables>;
export declare const ResetSettingDocument: import("graphql").DocumentNode;
export declare type ResetSettingMutationResult = ApolloReactCommon.MutationResult<IResetSettingMutation>;
export declare type ResetSettingMutationOptions = ApolloReactCommon.BaseMutationOptions<IResetSettingMutation, IResetSettingMutationVariables>;
export declare const saveUserSettingsDocument: import("graphql").DocumentNode;
export declare type saveUserSettingsMutationResult = ApolloReactCommon.MutationResult<IsaveUserSettingsMutation>;
export declare type saveUserSettingsMutationOptions = ApolloReactCommon.BaseMutationOptions<IsaveUserSettingsMutation, IsaveUserSettingsMutationVariables>;
export declare const saveWorkspaceSettingsDocument: import("graphql").DocumentNode;
export declare type saveWorkspaceSettingsMutationResult = ApolloReactCommon.MutationResult<IsaveWorkspaceSettingsMutation>;
export declare type saveWorkspaceSettingsMutationOptions = ApolloReactCommon.BaseMutationOptions<IsaveWorkspaceSettingsMutation, IsaveWorkspaceSettingsMutationVariables>;
export declare const SwitchSettingsDocument: import("graphql").DocumentNode;
export declare type SwitchSettingsMutationResult = ApolloReactCommon.MutationResult<ISwitchSettingsMutation>;
export declare type SwitchSettingsMutationOptions = ApolloReactCommon.BaseMutationOptions<ISwitchSettingsMutation, ISwitchSettingsMutationVariables>;
export declare const DefaultPreferencesDocument: import("graphql").DocumentNode;
export declare type DefaultPreferencesQueryResult = ApolloReactCommon.QueryResult<IDefaultPreferencesQuery, IDefaultPreferencesQueryVariables>;
export declare const DefaultSettingsDocument: import("graphql").DocumentNode;
export declare type DefaultSettingsQueryResult = ApolloReactCommon.QueryResult<IDefaultSettingsQuery, IDefaultSettingsQueryVariables>;
export declare const FullConfigurationDocument: import("graphql").DocumentNode;
export declare type FullConfigurationQueryResult = ApolloReactCommon.QueryResult<IFullConfigurationQuery, IFullConfigurationQueryVariables>;
export declare const GetMostCommonlyUsedSettingsDocument: import("graphql").DocumentNode;
export declare type GetMostCommonlyUsedSettingsQueryResult = ApolloReactCommon.QueryResult<IGetMostCommonlyUsedSettingsQuery, IGetMostCommonlyUsedSettingsQueryVariables>;
export declare const WorkspacesDocument: import("graphql").DocumentNode;
export declare type WorkspacesQueryResult = ApolloReactCommon.QueryResult<IWorkspacesQuery, IWorkspacesQueryVariables>;
export declare const UpdateConfigurationValueDocument: import("graphql").DocumentNode;
export declare type UpdateConfigurationValueMutationResult = ApolloReactCommon.MutationResult<IUpdateConfigurationValueMutation>;
export declare type UpdateConfigurationValueMutationOptions = ApolloReactCommon.BaseMutationOptions<IUpdateConfigurationValueMutation, IUpdateConfigurationValueMutationVariables>;
export declare const CopyDocument: import("graphql").DocumentNode;
export declare type CopyMutationResult = ApolloReactCommon.MutationResult<ICopyMutation>;
export declare type CopyMutationOptions = ApolloReactCommon.BaseMutationOptions<ICopyMutation, ICopyMutationVariables>;
export declare const RunMenuActionDocument: import("graphql").DocumentNode;
export declare type RunMenuActionMutationResult = ApolloReactCommon.MutationResult<IRunMenuActionMutation>;
export declare type RunMenuActionMutationOptions = ApolloReactCommon.BaseMutationOptions<IRunMenuActionMutation, IRunMenuActionMutationVariables>;
export declare const HideContextMenuDocument: import("graphql").DocumentNode;
export declare type HideContextMenuMutationResult = ApolloReactCommon.MutationResult<IHideContextMenuMutation>;
export declare type HideContextMenuMutationOptions = ApolloReactCommon.BaseMutationOptions<IHideContextMenuMutation, IHideContextMenuMutationVariables>;
export declare const ShowContextMenuDocument: import("graphql").DocumentNode;
export declare type ShowContextMenuMutationResult = ApolloReactCommon.MutationResult<IShowContextMenuMutation>;
export declare type ShowContextMenuMutationOptions = ApolloReactCommon.BaseMutationOptions<IShowContextMenuMutation, IShowContextMenuMutationVariables>;
export declare const CloseDialogDocument: import("graphql").DocumentNode;
export declare type CloseDialogMutationResult = ApolloReactCommon.MutationResult<ICloseDialogMutation>;
export declare type CloseDialogMutationOptions = ApolloReactCommon.BaseMutationOptions<ICloseDialogMutation, ICloseDialogMutationVariables>;
export declare const ShowDocument: import("graphql").DocumentNode;
export declare type ShowMutationResult = ApolloReactCommon.MutationResult<IShowMutation>;
export declare type ShowMutationOptions = ApolloReactCommon.BaseMutationOptions<IShowMutation, IShowMutationVariables>;
export declare const OpenEditorResourceInputDocument: import("graphql").DocumentNode;
export declare type OpenEditorResourceInputMutationResult = ApolloReactCommon.MutationResult<IOpenEditorResourceInputMutation>;
export declare type OpenEditorResourceInputMutationOptions = ApolloReactCommon.BaseMutationOptions<IOpenEditorResourceInputMutation, IOpenEditorResourceInputMutationVariables>;
export declare const OpenEditorDocument: import("graphql").DocumentNode;
export declare type OpenEditorMutationResult = ApolloReactCommon.MutationResult<IOpenEditorMutation>;
export declare type OpenEditorMutationOptions = ApolloReactCommon.BaseMutationOptions<IOpenEditorMutation, IOpenEditorMutationVariables>;
export declare const GoToLineDocument: import("graphql").DocumentNode;
export declare type GoToLineMutationResult = ApolloReactCommon.MutationResult<IGoToLineMutation>;
export declare type GoToLineMutationOptions = ApolloReactCommon.BaseMutationOptions<IGoToLineMutation, IGoToLineMutationVariables>;
export declare const HighlightLineDocument: import("graphql").DocumentNode;
export declare type HighlightLineMutationResult = ApolloReactCommon.MutationResult<IHighlightLineMutation>;
export declare type HighlightLineMutationOptions = ApolloReactCommon.BaseMutationOptions<IHighlightLineMutation, IHighlightLineMutationVariables>;
export declare const JsonEditingWriteDocument: import("graphql").DocumentNode;
export declare type JsonEditingWriteMutationResult = ApolloReactCommon.MutationResult<IJsonEditingWriteMutation>;
export declare type JsonEditingWriteMutationOptions = ApolloReactCommon.BaseMutationOptions<IJsonEditingWriteMutation, IJsonEditingWriteMutationVariables>;
export declare const ChangeKeybindingDocument: import("graphql").DocumentNode;
export declare type ChangeKeybindingMutationResult = ApolloReactCommon.MutationResult<IChangeKeybindingMutation>;
export declare type ChangeKeybindingMutationOptions = ApolloReactCommon.BaseMutationOptions<IChangeKeybindingMutation, IChangeKeybindingMutationVariables>;
export declare const ChangeWhenExpressionDocument: import("graphql").DocumentNode;
export declare type ChangeWhenExpressionMutationResult = ApolloReactCommon.MutationResult<IChangeWhenExpressionMutation>;
export declare type ChangeWhenExpressionMutationOptions = ApolloReactCommon.BaseMutationOptions<IChangeWhenExpressionMutation, IChangeWhenExpressionMutationVariables>;
export declare const EditKeybindingDocument: import("graphql").DocumentNode;
export declare type EditKeybindingMutationResult = ApolloReactCommon.MutationResult<IEditKeybindingMutation>;
export declare type EditKeybindingMutationOptions = ApolloReactCommon.BaseMutationOptions<IEditKeybindingMutation, IEditKeybindingMutationVariables>;
export declare const HideKeybindingDialogDocument: import("graphql").DocumentNode;
export declare type HideKeybindingDialogMutationResult = ApolloReactCommon.MutationResult<IHideKeybindingDialogMutation>;
export declare type HideKeybindingDialogMutationOptions = ApolloReactCommon.BaseMutationOptions<IHideKeybindingDialogMutation, IHideKeybindingDialogMutationVariables>;
export declare const LookupKeybindingDocument: import("graphql").DocumentNode;
export declare type LookupKeybindingMutationResult = ApolloReactCommon.MutationResult<ILookupKeybindingMutation>;
export declare type LookupKeybindingMutationOptions = ApolloReactCommon.BaseMutationOptions<ILookupKeybindingMutation, ILookupKeybindingMutationVariables>;
export declare const registerKeybindingDocument: import("graphql").DocumentNode;
export declare type registerKeybindingMutationResult = ApolloReactCommon.MutationResult<IregisterKeybindingMutation>;
export declare type registerKeybindingMutationOptions = ApolloReactCommon.BaseMutationOptions<IregisterKeybindingMutation, IregisterKeybindingMutationVariables>;
export declare const RemoveKeybindingDocument: import("graphql").DocumentNode;
export declare type RemoveKeybindingMutationResult = ApolloReactCommon.MutationResult<IRemoveKeybindingMutation>;
export declare type RemoveKeybindingMutationOptions = ApolloReactCommon.BaseMutationOptions<IRemoveKeybindingMutation, IRemoveKeybindingMutationVariables>;
export declare const ResetKeybindingDocument: import("graphql").DocumentNode;
export declare type ResetKeybindingMutationResult = ApolloReactCommon.MutationResult<IResetKeybindingMutation>;
export declare type ResetKeybindingMutationOptions = ApolloReactCommon.BaseMutationOptions<IResetKeybindingMutation, IResetKeybindingMutationVariables>;
export declare const ResolveKeyboardEventDocument: import("graphql").DocumentNode;
export declare type ResolveKeyboardEventMutationResult = ApolloReactCommon.MutationResult<IResolveKeyboardEventMutation>;
export declare type ResolveKeyboardEventMutationOptions = ApolloReactCommon.BaseMutationOptions<IResolveKeyboardEventMutation, IResolveKeyboardEventMutationVariables>;
export declare const SearchKeybindingDocument: import("graphql").DocumentNode;
export declare type SearchKeybindingMutationResult = ApolloReactCommon.MutationResult<ISearchKeybindingMutation>;
export declare type SearchKeybindingMutationOptions = ApolloReactCommon.BaseMutationOptions<ISearchKeybindingMutation, ISearchKeybindingMutationVariables>;
export declare const SetSelectedKeybindingIndexDocument: import("graphql").DocumentNode;
export declare type SetSelectedKeybindingIndexMutationResult = ApolloReactCommon.MutationResult<ISetSelectedKeybindingIndexMutation>;
export declare type SetSelectedKeybindingIndexMutationOptions = ApolloReactCommon.BaseMutationOptions<ISetSelectedKeybindingIndexMutation, ISetSelectedKeybindingIndexMutationVariables>;
export declare const StopEditWhenExpressionDocument: import("graphql").DocumentNode;
export declare type StopEditWhenExpressionMutationResult = ApolloReactCommon.MutationResult<IStopEditWhenExpressionMutation>;
export declare type StopEditWhenExpressionMutationOptions = ApolloReactCommon.BaseMutationOptions<IStopEditWhenExpressionMutation, IStopEditWhenExpressionMutationVariables>;
export declare const AddNotificationDocument: import("graphql").DocumentNode;
export declare type AddNotificationMutationResult = ApolloReactCommon.MutationResult<IAddNotificationMutation>;
export declare type AddNotificationMutationOptions = ApolloReactCommon.BaseMutationOptions<IAddNotificationMutation, IAddNotificationMutationVariables>;
export declare const CloseNotificationDocument: import("graphql").DocumentNode;
export declare type CloseNotificationMutationResult = ApolloReactCommon.MutationResult<ICloseNotificationMutation>;
export declare type CloseNotificationMutationOptions = ApolloReactCommon.BaseMutationOptions<ICloseNotificationMutation, ICloseNotificationMutationVariables>;
export declare const HandlerDocument: import("graphql").DocumentNode;
export declare type HandlerMutationResult = ApolloReactCommon.MutationResult<IHandlerMutation>;
export declare type HandlerMutationOptions = ApolloReactCommon.BaseMutationOptions<IHandlerMutation, IHandlerMutationVariables>;
export declare const OpenEditorFileDocument: import("graphql").DocumentNode;
export declare type OpenEditorFileMutationResult = ApolloReactCommon.MutationResult<IOpenEditorFileMutation>;
export declare type OpenEditorFileMutationOptions = ApolloReactCommon.BaseMutationOptions<IOpenEditorFileMutation, IOpenEditorFileMutationVariables>;
export declare const HideInputModelDocument: import("graphql").DocumentNode;
export declare type HideInputModelMutationResult = ApolloReactCommon.MutationResult<IHideInputModelMutation>;
export declare type HideInputModelMutationOptions = ApolloReactCommon.BaseMutationOptions<IHideInputModelMutation, IHideInputModelMutationVariables>;
export declare const SetSelectedDocument: import("graphql").DocumentNode;
export declare type SetSelectedMutationResult = ApolloReactCommon.MutationResult<ISetSelectedMutation>;
export declare type SetSelectedMutationOptions = ApolloReactCommon.BaseMutationOptions<ISetSelectedMutation, ISetSelectedMutationVariables>;
export declare const ShowInputDocument: import("graphql").DocumentNode;
export declare type ShowInputMutationResult = ApolloReactCommon.MutationResult<IShowInputMutation>;
export declare type ShowInputMutationOptions = ApolloReactCommon.BaseMutationOptions<IShowInputMutation, IShowInputMutationVariables>;
export declare const ShowPickInputDocument: import("graphql").DocumentNode;
export declare type ShowPickInputMutationResult = ApolloReactCommon.MutationResult<IShowPickInputMutation>;
export declare type ShowPickInputMutationOptions = ApolloReactCommon.BaseMutationOptions<IShowPickInputMutation, IShowPickInputMutationVariables>;
export declare const AddEntryDocument: import("graphql").DocumentNode;
export declare type AddEntryMutationResult = ApolloReactCommon.MutationResult<IAddEntryMutation>;
export declare type AddEntryMutationOptions = ApolloReactCommon.BaseMutationOptions<IAddEntryMutation, IAddEntryMutationVariables>;
export declare const RemoveStatusbarEntryDocument: import("graphql").DocumentNode;
export declare type RemoveStatusbarEntryMutationResult = ApolloReactCommon.MutationResult<IRemoveStatusbarEntryMutation>;
export declare type RemoveStatusbarEntryMutationOptions = ApolloReactCommon.BaseMutationOptions<IRemoveStatusbarEntryMutation, IRemoveStatusbarEntryMutationVariables>;
export declare const SetStatusMessageDocument: import("graphql").DocumentNode;
export declare type SetStatusMessageMutationResult = ApolloReactCommon.MutationResult<ISetStatusMessageMutation>;
export declare type SetStatusMessageMutationOptions = ApolloReactCommon.BaseMutationOptions<ISetStatusMessageMutation, ISetStatusMessageMutationVariables>;
export declare const UpdateStatusbarEntryDocument: import("graphql").DocumentNode;
export declare type UpdateStatusbarEntryMutationResult = ApolloReactCommon.MutationResult<IUpdateStatusbarEntryMutation>;
export declare type UpdateStatusbarEntryMutationOptions = ApolloReactCommon.BaseMutationOptions<IUpdateStatusbarEntryMutation, IUpdateStatusbarEntryMutationVariables>;
export declare const AddFoldersDocument: import("graphql").DocumentNode;
export declare type AddFoldersMutationResult = ApolloReactCommon.MutationResult<IAddFoldersMutation>;
export declare type AddFoldersMutationOptions = ApolloReactCommon.BaseMutationOptions<IAddFoldersMutation, IAddFoldersMutationVariables>;
export declare const ChangeWorkspaceDocument: import("graphql").DocumentNode;
export declare type ChangeWorkspaceMutationResult = ApolloReactCommon.MutationResult<IChangeWorkspaceMutation>;
export declare type ChangeWorkspaceMutationOptions = ApolloReactCommon.BaseMutationOptions<IChangeWorkspaceMutation, IChangeWorkspaceMutationVariables>;
export declare const RemoveFoldersDocument: import("graphql").DocumentNode;
export declare type RemoveFoldersMutationResult = ApolloReactCommon.MutationResult<IRemoveFoldersMutation>;
export declare type RemoveFoldersMutationOptions = ApolloReactCommon.BaseMutationOptions<IRemoveFoldersMutation, IRemoveFoldersMutationVariables>;
export declare const UpdateFoldersDocument: import("graphql").DocumentNode;
export declare type UpdateFoldersMutationResult = ApolloReactCommon.MutationResult<IUpdateFoldersMutation>;
export declare type UpdateFoldersMutationOptions = ApolloReactCommon.BaseMutationOptions<IUpdateFoldersMutation, IUpdateFoldersMutationVariables>;
export declare const FinalConfiguration_WSDocument: import("graphql").DocumentNode;
export declare type FinalConfiguration_WSQueryResult = ApolloReactCommon.QueryResult<IFinalConfiguration_WSQuery, IFinalConfiguration_WSQueryVariables>;
export declare const GetContextDocument: import("graphql").DocumentNode;
export declare type GetContextQueryResult = ApolloReactCommon.QueryResult<IGetContextQuery, IGetContextQueryVariables>;
export declare const ContextMenuDocument: import("graphql").DocumentNode;
export declare type ContextMenuQueryResult = ApolloReactCommon.QueryResult<IContextMenuQuery, IContextMenuQueryVariables>;
export declare const DialogDocument: import("graphql").DocumentNode;
export declare type DialogQueryResult = ApolloReactCommon.QueryResult<IDialogQuery, IDialogQueryVariables>;
export declare const showDialogDocument: import("graphql").DocumentNode;
export declare type showDialogQueryResult = ApolloReactCommon.QueryResult<IshowDialogQuery, IshowDialogQueryVariables>;
export declare const GoToLineQuickAccessDocument: import("graphql").DocumentNode;
export declare type GoToLineQuickAccessQueryResult = ApolloReactCommon.QueryResult<IGoToLineQuickAccessQuery, IGoToLineQuickAccessQueryVariables>;
export declare const GetKeybindingsDocument: import("graphql").DocumentNode;
export declare type GetKeybindingsQueryResult = ApolloReactCommon.QueryResult<IGetKeybindingsQuery, IGetKeybindingsQueryVariables>;
export declare const KeybindingContextMenuDocument: import("graphql").DocumentNode;
export declare type KeybindingContextMenuQueryResult = ApolloReactCommon.QueryResult<IKeybindingContextMenuQuery, IKeybindingContextMenuQueryVariables>;
export declare const KeybindingsDocument: import("graphql").DocumentNode;
export declare type KeybindingsQueryResult = ApolloReactCommon.QueryResult<IKeybindingsQuery, IKeybindingsQueryVariables>;
export declare const NotificationsDocument: import("graphql").DocumentNode;
export declare type NotificationsQueryResult = ApolloReactCommon.QueryResult<INotificationsQuery, INotificationsQueryVariables>;
export declare const showNotificationDocument: import("graphql").DocumentNode;
export declare type showNotificationQueryResult = ApolloReactCommon.QueryResult<IshowNotificationQuery, IshowNotificationQueryVariables>;
export declare const GetSelectedValueDocument: import("graphql").DocumentNode;
export declare type GetSelectedValueQueryResult = ApolloReactCommon.QueryResult<IGetSelectedValueQuery, IGetSelectedValueQueryVariables>;
export declare const QuickInputModelDocument: import("graphql").DocumentNode;
export declare type QuickInputModelQueryResult = ApolloReactCommon.QueryResult<IQuickInputModelQuery, IQuickInputModelQueryVariables>;
export declare const StatusbarDocument: import("graphql").DocumentNode;
export declare type StatusbarQueryResult = ApolloReactCommon.QueryResult<IStatusbarQuery, IStatusbarQueryVariables>;
export declare const StatusbarItemDocument: import("graphql").DocumentNode;
export declare type StatusbarItemQueryResult = ApolloReactCommon.QueryResult<IStatusbarItemQuery, IStatusbarItemQueryVariables>;
export declare const GetViewsDocument: import("graphql").DocumentNode;
export declare type GetViewsQueryResult = ApolloReactCommon.QueryResult<IGetViewsQuery, IGetViewsQueryVariables>;
export declare const GetWorkspaceDocument: import("graphql").DocumentNode;
export declare type GetWorkspaceQueryResult = ApolloReactCommon.QueryResult<IGetWorkspaceQuery, IGetWorkspaceQueryVariables>;
export declare const NotifyErrorDocument: import("graphql").DocumentNode;
export declare type NotifyErrorMutationResult = ApolloReactCommon.MutationResult<INotifyErrorMutation>;
export declare type NotifyErrorMutationOptions = ApolloReactCommon.BaseMutationOptions<INotifyErrorMutation, INotifyErrorMutationVariables>;
export declare const NotifyInfoDocument: import("graphql").DocumentNode;
export declare type NotifyInfoMutationResult = ApolloReactCommon.MutationResult<INotifyInfoMutation>;
export declare type NotifyInfoMutationOptions = ApolloReactCommon.BaseMutationOptions<INotifyInfoMutation, INotifyInfoMutationVariables>;
export declare const NotifyPromptDocument: import("graphql").DocumentNode;
export declare type NotifyPromptMutationResult = ApolloReactCommon.MutationResult<INotifyPromptMutation>;
export declare type NotifyPromptMutationOptions = ApolloReactCommon.BaseMutationOptions<INotifyPromptMutation, INotifyPromptMutationVariables>;
export declare const NotifyWarnDocument: import("graphql").DocumentNode;
export declare type NotifyWarnMutationResult = ApolloReactCommon.MutationResult<INotifyWarnMutation>;
export declare type NotifyWarnMutationOptions = ApolloReactCommon.BaseMutationOptions<INotifyWarnMutation, INotifyWarnMutationVariables>;
export declare const NotifyDocument: import("graphql").DocumentNode;
export declare type NotifyMutationResult = ApolloReactCommon.MutationResult<INotifyMutation>;
export declare type NotifyMutationOptions = ApolloReactCommon.BaseMutationOptions<INotifyMutation, INotifyMutationVariables>;
export declare const UpdateWorkspaceContextAddFoldersDocument: import("graphql").DocumentNode;
export declare type UpdateWorkspaceContextAddFoldersMutationResult = ApolloReactCommon.MutationResult<IUpdateWorkspaceContextAddFoldersMutation>;
export declare type UpdateWorkspaceContextAddFoldersMutationOptions = ApolloReactCommon.BaseMutationOptions<IUpdateWorkspaceContextAddFoldersMutation, IUpdateWorkspaceContextAddFoldersMutationVariables>;
export declare const UpdateWorkspaceContextRemoveFoldersDocument: import("graphql").DocumentNode;
export declare type UpdateWorkspaceContextRemoveFoldersMutationResult = ApolloReactCommon.MutationResult<IUpdateWorkspaceContextRemoveFoldersMutation>;
export declare type UpdateWorkspaceContextRemoveFoldersMutationOptions = ApolloReactCommon.BaseMutationOptions<IUpdateWorkspaceContextRemoveFoldersMutation, IUpdateWorkspaceContextRemoveFoldersMutationVariables>;
export declare const UpdateWorkspaceContextUpdateFoldersDocument: import("graphql").DocumentNode;
export declare type UpdateWorkspaceContextUpdateFoldersMutationResult = ApolloReactCommon.MutationResult<IUpdateWorkspaceContextUpdateFoldersMutation>;
export declare type UpdateWorkspaceContextUpdateFoldersMutationOptions = ApolloReactCommon.BaseMutationOptions<IUpdateWorkspaceContextUpdateFoldersMutation, IUpdateWorkspaceContextUpdateFoldersMutationVariables>;
export declare const GetConfiguration_WSDocument: import("graphql").DocumentNode;
export declare type GetConfiguration_WSQueryResult = ApolloReactCommon.QueryResult<IGetConfiguration_WSQuery, IGetConfiguration_WSQueryVariables>;
export declare const GetEnvironment_WSDocument: import("graphql").DocumentNode;
export declare type GetEnvironment_WSQueryResult = ApolloReactCommon.QueryResult<IGetEnvironment_WSQuery, IGetEnvironment_WSQueryVariables>;
export declare const GetWorkspace_WSDocument: import("graphql").DocumentNode;
export declare type GetWorkspace_WSQueryResult = ApolloReactCommon.QueryResult<IGetWorkspace_WSQuery, IGetWorkspace_WSQueryVariables>;
export declare const GetWorkspaceValue_WSDocument: import("graphql").DocumentNode;
export declare type GetWorkspaceValue_WSQueryResult = ApolloReactCommon.QueryResult<IGetWorkspaceValue_WSQuery, IGetWorkspaceValue_WSQueryVariables>;
export declare const AddServerNotificationDocument: import("graphql").DocumentNode;
export declare type AddServerNotificationMutationResult = ApolloReactCommon.MutationResult<IAddServerNotificationMutation>;
export declare type AddServerNotificationMutationOptions = ApolloReactCommon.BaseMutationOptions<IAddServerNotificationMutation, IAddServerNotificationMutationVariables>;
export declare const GetWorkspaceFolderContextDocument: import("graphql").DocumentNode;
export declare type GetWorkspaceFolderContextQueryResult = ApolloReactCommon.QueryResult<IGetWorkspaceFolderContextQuery, IGetWorkspaceFolderContextQueryVariables>;
export declare const CodeLenseProviderDefinitionDocument: import("graphql").DocumentNode;
export declare type CodeLenseProviderDefinitionMutationResult = ApolloReactCommon.MutationResult<ICodeLenseProviderDefinitionMutation>;
export declare type CodeLenseProviderDefinitionMutationOptions = ApolloReactCommon.BaseMutationOptions<ICodeLenseProviderDefinitionMutation, ICodeLenseProviderDefinitionMutationVariables>;
export declare const CompletionProviderDefinitionDocument: import("graphql").DocumentNode;
export declare type CompletionProviderDefinitionMutationResult = ApolloReactCommon.MutationResult<ICompletionProviderDefinitionMutation>;
export declare type CompletionProviderDefinitionMutationOptions = ApolloReactCommon.BaseMutationOptions<ICompletionProviderDefinitionMutation, ICompletionProviderDefinitionMutationVariables>;
export declare const DefinitionDefinitionDocument: import("graphql").DocumentNode;
export declare type DefinitionDefinitionMutationResult = ApolloReactCommon.MutationResult<IDefinitionDefinitionMutation>;
export declare type DefinitionDefinitionMutationOptions = ApolloReactCommon.BaseMutationOptions<IDefinitionDefinitionMutation, IDefinitionDefinitionMutationVariables>;
export declare const DocumentHighLightProviderDefinitionDocument: import("graphql").DocumentNode;
export declare type DocumentHighLightProviderDefinitionMutationResult = ApolloReactCommon.MutationResult<IDocumentHighLightProviderDefinitionMutation>;
export declare type DocumentHighLightProviderDefinitionMutationOptions = ApolloReactCommon.BaseMutationOptions<IDocumentHighLightProviderDefinitionMutation, IDocumentHighLightProviderDefinitionMutationVariables>;
export declare const DocumentFormattingProviderDefinitionDocument: import("graphql").DocumentNode;
export declare type DocumentFormattingProviderDefinitionMutationResult = ApolloReactCommon.MutationResult<IDocumentFormattingProviderDefinitionMutation>;
export declare type DocumentFormattingProviderDefinitionMutationOptions = ApolloReactCommon.BaseMutationOptions<IDocumentFormattingProviderDefinitionMutation, IDocumentFormattingProviderDefinitionMutationVariables>;
export declare const HoverProviderDefinitionDocument: import("graphql").DocumentNode;
export declare type HoverProviderDefinitionMutationResult = ApolloReactCommon.MutationResult<IHoverProviderDefinitionMutation>;
export declare type HoverProviderDefinitionMutationOptions = ApolloReactCommon.BaseMutationOptions<IHoverProviderDefinitionMutation, IHoverProviderDefinitionMutationVariables>;
export declare const OpenLanguageDocumentDocument: import("graphql").DocumentNode;
export declare type OpenLanguageDocumentMutationResult = ApolloReactCommon.MutationResult<IOpenLanguageDocumentMutation>;
export declare type OpenLanguageDocumentMutationOptions = ApolloReactCommon.BaseMutationOptions<IOpenLanguageDocumentMutation, IOpenLanguageDocumentMutationVariables>;
export declare const ReferenceProviderDefinitionDocument: import("graphql").DocumentNode;
export declare type ReferenceProviderDefinitionMutationResult = ApolloReactCommon.MutationResult<IReferenceProviderDefinitionMutation>;
export declare type ReferenceProviderDefinitionMutationOptions = ApolloReactCommon.BaseMutationOptions<IReferenceProviderDefinitionMutation, IReferenceProviderDefinitionMutationVariables>;
export declare const RenameDefinitionDocument: import("graphql").DocumentNode;
export declare type RenameDefinitionMutationResult = ApolloReactCommon.MutationResult<IRenameDefinitionMutation>;
export declare type RenameDefinitionMutationOptions = ApolloReactCommon.BaseMutationOptions<IRenameDefinitionMutation, IRenameDefinitionMutationVariables>;
export declare const DocumentSymbolDefinitionDocument: import("graphql").DocumentNode;
export declare type DocumentSymbolDefinitionMutationResult = ApolloReactCommon.MutationResult<IDocumentSymbolDefinitionMutation>;
export declare type DocumentSymbolDefinitionMutationOptions = ApolloReactCommon.BaseMutationOptions<IDocumentSymbolDefinitionMutation, IDocumentSymbolDefinitionMutationVariables>;
export declare const UpdateModelDocument: import("graphql").DocumentNode;
export declare type UpdateModelMutationResult = ApolloReactCommon.MutationResult<IUpdateModelMutation>;
export declare type UpdateModelMutationOptions = ApolloReactCommon.BaseMutationOptions<IUpdateModelMutation, IUpdateModelMutationVariables>;
