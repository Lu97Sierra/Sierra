import { Event } from '@vscode-alt/monaco-editor/esm/vs/base/common/event';
import { URI } from '@vscode-alt/monaco-editor/esm/vs/base/common/uri';
import { IIEditorInput, IIFileEditorInput as IFileEditorInput, ITextEditorOptions, IEditorGroup, IEditorInput, IEditorIdentifier } from '../generated-model';
import { IEditorModel } from './core-editor';
import { ITextModel } from '@vscode-alt/monaco-editor/esm/vs/editor/common/model';
import { IEditorOptions_Input as IEditorOptions } from '../generated-model';
import { IEditorControl } from './editor-service';
import { interfaces } from 'inversify';
/**
 * Text diff editor id.
 */
export declare const TEXT_DIFF_EDITOR_ID = "workbench.editors.textDiffEditor";
/**
 * Binary diff editor id.
 */
export declare const BINARY_DIFF_EDITOR_ID = "workbench.editors.binaryResourceDiffEditor";
export interface IEditor {
    /**
     * The assigned input of this editor.
     */
    input: IEditorInput | null;
    /**
     * The assigned options of this editor.
     */
    options: IEditorOptions | null;
    /**
     * The assigned group this editor is showing in.
     */
    group: IEditorGroup | undefined;
    /**
     * The minimum width of this editor.
     */
    readonly minimumWidth: number;
    /**
     * The maximum width of this editor.
     */
    readonly maximumWidth: number;
    /**
     * The minimum height of this editor.
     */
    readonly minimumHeight: number;
    /**
     * The maximum height of this editor.
     */
    readonly maximumHeight: number;
    /**
     * An event to notify whenever minimum/maximum width/height changes.
     */
    readonly onDidSizeConstraintsChange: Event<{
        width: number;
        height: number;
    } | undefined>;
    /**
     * Returns the unique identifier of this editor.
     */
    getId(): string;
    /**
     * Returns the underlying control of this editor.
     */
    getControl(): IEditorControl | null;
    /**
     * Asks the underlying control to focus.
     */
    focus(): void;
    /**
     * Finds out if this editor is visible or not.
     */
    isVisible(): boolean;
}
export interface IClientEditor extends Pick<IEditor, Exclude<keyof IEditor, 'getId' | 'getControl' | 'focus' | 'isVisible' | 'onDidSizeConstraintsChange'>> {
}
export interface ITextEditor extends IClientEditor {
}
export interface ITextDiffEditor extends IEditor {
}
export interface ITextSideBySideEditor extends IEditor {
    /**
     * Returns the underlying text editor widget of the master side
     * of this side-by-side editor.
     */
    getMasterEditor(): ITextEditor;
    /**
     * Returns the underlying text editor widget of the details side
     * of this side-by-side editor.
     */
    getDetailsEditor(): ITextEditor;
}
export declare const enum Verbosity {
    SHORT = 0,
    MEDIUM = 1,
    LONG = 2
}
export interface IRevertOptions {
    /**
     *  Forces to load the contents of the editor again even if the editor is not dirty.
     */
    force?: boolean;
    /**
     * A soft revert will clear dirty state of an editor but will not attempt to load it.
     */
    soft?: boolean;
}
export declare const enum ConfirmResult {
    SAVE = 0,
    DONT_SAVE = 1,
    CANCEL = 2
}
export declare const enum EncodingMode {
    /**
     * Instructs the encoding support to encode the current input with the provided encoding
     */
    Encode = 0,
    /**
     * Instructs the encoding support to decode the current input with the provided encoding
     */
    Decode = 1
}
export interface IEncodingSupport {
    /**
     * Gets the encoding of the input if known.
     */
    getEncoding(): string;
    /**
     * Sets the encoding for the input for saving.
     */
    setEncoding(encoding: string, mode: EncodingMode): void;
}
export interface ITextEditorModel extends IEditorModel {
    textEditorModel: ITextModel;
}
export interface IEditorInputWithOptions {
    editor: IEditorInput;
    options?: IEditorOptions | ITextEditorOptions;
}
export interface IEditorCloseEvent extends IEditorIdentifier {
    replaced: boolean;
    index: number;
}
export interface IEditorDescriptor {
    id: string;
    name: string;
}
export declare type IEditorInputTypeName = Pick<IEditorInput, '__typename' | 'typeId' | 'preferredEditorId'>;
export interface IEditorRegistry {
    /**
     * Registers an editor to the platform for the given input type. The second parameter also supports an
     * array of input classes to be passed in. If the more than one editor is registered for the same editor
     * input, the input itself will be asked which editor it prefers if this method is provided. Otherwise
     * the first editor in the list will be returned.
     *
     * @param editorInputDescriptor a constructor function that returns an instance of EditorInput for which the
     * registered editor should be used for.
     */
    registerEditor(descriptor: IEditorDescriptor, editorInputDescriptor: IEditorInputTypeName): void;
    registerEditor(descriptor: IEditorDescriptor, editorInputDescriptor: IEditorInputTypeName[]): void;
    /**
     * Returns the editor descriptor for the given input or null if none.
     */
    getEditor(input: IEditorInputTypeName): IEditorDescriptor | null;
    /**
     * Returns the editor descriptor for the given identifier or null if none.
     */
    getEditorById(editorId: string): IEditorDescriptor | null;
    /**
     * Returns an array of registered editors known to the platform.
     */
    getEditors(): IEditorDescriptor[];
}
export declare type EditorInput = Pick<IIEditorInput, 'resource' | 'fileReference' | 'label' | 'typeId'>;
export interface IFileInputFactory {
    createFileInput(resource: URI, encoding: string | undefined, mode: string | undefined, instantiationService: any): IFileEditorInput;
    isFileInput(obj: any): obj is IFileEditorInput;
}
export interface IFileInputFactory {
    createFileInput(resource: URI, encoding: string | undefined, mode: string | undefined, container: interfaces.Container | undefined): IFileEditorInput & {
        [key: string]: any;
    };
    isFileInput(obj: any): obj is IFileEditorInput & {
        [key: string]: any;
    };
}
export interface IEditorInputFactory {
    createInput(resource: URI, label: string | undefined, encoding: string | undefined, mode: string | undefined, container: interfaces.Container | undefined, additionalProps?: object | undefined): IIEditorInput & {
        [key: string]: any;
    };
}
export interface IEditorInputFactoryRegistry {
    /**
     * Registers the file input factory to use for file inputs.
     */
    registerFileInputFactory(factory: IFileInputFactory): void;
    /**
     * Returns the file input factory to use for file inputs.
     */
    getFileInputFactory(): IFileInputFactory;
    /**
     * Registers a editor input factory for the given editor input to the regsitry. An editor input factory
     * is capable of serializing and deserialzing editor inputs from string data.
     *
     * @param {string} editorInputId the identifier of the editor input
     * @memberof IEditorInputFactoryRegistry
     */
    registerEditorInputFactory(editorInputId: string, IEditorInputFactory: any): void;
    /**
     * Returns the editor input factory for the given editor input.
     *
     * @param {string} editorInputId the identifier of the editor input
     * @returns {IEditorInputFactory}
     * @memberof IEditorInputFactoryRegistry
     */
    getEditorInputFactory(editorInputId: string): IEditorInputFactory;
    getEditorInput(resource: URI, label: string | undefined, encoding: string | undefined, mode: string | undefined, container: interfaces.Container | undefined, additionalProps?: object | undefined): IIEditorInput & {
        [key: string]: any;
    };
    hasEditorInput(resource: URI): boolean;
}
export interface ServiceIdentifier<T> {
    (...args: any[]): void;
    type: T;
}
