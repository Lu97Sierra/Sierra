"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.nullExtensionDescription = exports.ExtensionIdentifier = exports.ExtensionPointContribution = exports.ActivationTimes = void 0;
/* tslint:disable */
const strings = require("@vscode-alt/monaco-editor/esm/vs/base/common/strings");
const uri_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/uri");
class ActivationTimes {
    constructor(startup, codeLoadingTime, activateCallTime, activateResolvedTime, activationEvent) {
        this.startup = startup;
        this.codeLoadingTime = codeLoadingTime;
        this.activateCallTime = activateCallTime;
        this.activateResolvedTime = activateResolvedTime;
        this.activationEvent = activationEvent;
    }
}
exports.ActivationTimes = ActivationTimes;
class ExtensionPointContribution {
    constructor(description, value) {
        this.description = description;
        this.value = value;
    }
}
exports.ExtensionPointContribution = ExtensionPointContribution;
const uiExtensions = new Set();
uiExtensions.add('msjsdiag.debugger-for-chrome');
/**
 * **!Do not construct directly!**
 *
 * **!Only static methods because it gets serialized!**
 *
 * This represents the "canonical" version for an extension identifier. Extension ids
 * have to be case-insensitive (due to the marketplace), but we must ensure case
 * preservation because the extension API is already public at this time.
 *
 * For example, given an extension with the publisher `"Hello"` and the name `"World"`,
 * its canonical extension identifier is `"Hello.World"`. This extension could be
 * referenced in some other extension's dependencies using the string `"hello.world"`.
 *
 * To make matters more complicated, an extension can optionally have an UUID. When two
 * extensions have the same UUID, they are considered equal even if their identifier is different.
 */
class ExtensionIdentifier {
    constructor(value) {
        this.value = value;
        this._lower = value.toLowerCase();
    }
    static equals(a, b) {
        if (typeof a === 'undefined' || a === null) {
            return (typeof b === 'undefined' || b === null);
        }
        if (typeof b === 'undefined' || b === null) {
            return false;
        }
        if (typeof a === 'string' || typeof b === 'string') {
            // At least one of the arguments is an extension id in string form,
            // so we have to use the string comparison which ignores case.
            let aValue = (typeof a === 'string' ? a : a.value);
            let bValue = (typeof b === 'string' ? b : b.value);
            return strings.equalsIgnoreCase(aValue, bValue);
        }
        // Now we know both arguments are ExtensionIdentifier
        return (a._lower === b._lower);
    }
    /**
     * Gives the value by which to index (for equality).
     */
    static toKey(id) {
        if (typeof id === 'string') {
            return id.toLowerCase();
        }
        return id._lower;
    }
}
exports.ExtensionIdentifier = ExtensionIdentifier;
exports.nullExtensionDescription = Object.freeze({
    identifier: new ExtensionIdentifier('nullExtensionDescription'),
    name: 'Null Extension Description',
    version: '0.0.0',
    publisher: 'vscode',
    enableProposedApi: false,
    engines: { vscode: '' },
    extensionLocation: uri_1.URI.parse('void:location'),
    isBuiltin: false,
});
//# sourceMappingURL=extension.js.map