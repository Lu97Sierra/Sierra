"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMigratedSettingValue = exports.keyFromOverrideIdentifier = exports.overrideIdentifierFromKey = exports.merge = exports.getConfigurationValue = exports.removeFromValueTree = exports.addToValueTree = exports.toValuesTree = exports.toOverrides = exports.compare = exports.SettingsTypeToConfiguraitonTarget = exports.ConfigurationTargetToString = exports.isConfigurationOverrides = void 0;
/* tslint:disable */
const objects = require("@vscode-alt/monaco-editor/esm/vs/base/common/objects");
const types = require("@vscode-alt/monaco-editor/esm/vs/base/common/types");
const constants_1 = require("../../../constants");
const uri_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/uri");
// src/vs/platform/configuration/common/configuration.ts
function isConfigurationOverrides(thing) {
    return thing
        && typeof thing === 'object'
        && (!thing.overrideIdentifier || typeof thing.overrideIdentifier === 'string')
        && (!thing.resource || (thing.resource instanceof uri_1.URI || uri_1.URI.isUri(thing.resource))); //@sri added isURI
}
exports.isConfigurationOverrides = isConfigurationOverrides;
/**
 * @SRI modified to match to the union type of graphql type Settings
 */
function ConfigurationTargetToString(configurationTarget) {
    switch (configurationTarget) {
        case 1 /* USER */: return 'UserSettings';
        case 2 /* USER_LOCAL */: return 'LocalUserSettings';
        case 3 /* USER_REMOTE */: return 'RemoteUserSettings';
        case 4 /* WORKSPACE */: return 'WorkspaceSettings';
        case 5 /* WORKSPACE_FOLDER */: return 'FolderSettings';
        case 6 /* DEFAULT */: return 'GlobalSettings';
        case 7 /* MEMORY */: return 'MemorySettings';
    }
}
exports.ConfigurationTargetToString = ConfigurationTargetToString;
function SettingsTypeToConfiguraitonTarget(settings) {
    switch (settings) {
        case 'UserSettings': return 1 /* USER */;
        case 'LocalUserSettings': return 2 /* USER_LOCAL */;
        case 'RemoteUserSettings': return 3 /* USER_REMOTE */;
        case 'WorkspaceSettings': return 4 /* WORKSPACE */;
        case 'FolderSettings': return 5 /* WORKSPACE_FOLDER */;
        case 'DefaultSettings': return 6 /* DEFAULT */;
        case 'MemorySettings': return 7 /* MEMORY */;
    }
}
exports.SettingsTypeToConfiguraitonTarget = SettingsTypeToConfiguraitonTarget;
function compare(from, to) {
    const added = to.keys.filter(key => from.keys.indexOf(key) === -1);
    const removed = from.keys.filter(key => to.keys.indexOf(key) === -1);
    const updated = [];
    for (const key of from.keys) {
        const value1 = getConfigurationValue(from.contents, key);
        const value2 = getConfigurationValue(to.contents, key);
        if (!objects.equals(value1, value2)) {
            updated.push(key);
        }
    }
    return { added, removed, updated };
}
exports.compare = compare;
// not using currently but stays here for future reference
//@sri modified function to take ConfigurationRegistry as second argument input
function toOverrides(raw, configurationProperties, conflictReporter) {
    const overrides = [];
    // const configurationProperties = Registry.Instance.as<IConfigurationRegistry>(Extensions.Configuration).getConfigurationProperties();
    for (const key of Object.keys(raw)) {
        if (constants_1.OVERRIDE_PROPERTY_PATTERN.test(key)) {
            const overrideRaw = {};
            for (const keyInOverrideRaw in raw[key]) {
                if (configurationProperties[keyInOverrideRaw] && configurationProperties[keyInOverrideRaw].overridable) {
                    overrideRaw[keyInOverrideRaw] = raw[key][keyInOverrideRaw];
                }
            }
            overrides.push({
                identifiers: [overrideIdentifierFromKey(key).trim()],
                contents: toValuesTree(overrideRaw, conflictReporter)
            });
        }
    }
    return overrides;
}
exports.toOverrides = toOverrides;
function toValuesTree(properties, conflictReporter) {
    const root = Object.create(null);
    for (let key in properties) {
        addToValueTree(root, key, properties[key], conflictReporter);
    }
    return root;
}
exports.toValuesTree = toValuesTree;
function addToValueTree(settingsTreeRoot, key, value, conflictReporter) {
    const segments = key.split('.');
    const last = segments.pop();
    let curr = settingsTreeRoot;
    for (let i = 0; i < segments.length; i++) {
        let s = segments[i];
        let obj = curr[s];
        switch (typeof obj) {
            case 'undefined':
                obj = curr[s] = Object.create(null);
                break;
            case 'object':
                break;
            default:
                conflictReporter(`Ignoring ${key} as ${segments.slice(0, i + 1).join('.')} is ${JSON.stringify(obj)}`);
                return;
        }
        curr = obj;
    }
    if (typeof curr === 'object') {
        curr[last] = value; // workaround https://github.com/Microsoft/vscode/issues/13606
    }
    else {
        conflictReporter(`Ignoring ${key} as ${segments.join('.')} is ${JSON.stringify(curr)}`);
    }
}
exports.addToValueTree = addToValueTree;
function removeFromValueTree(valueTree, key) {
    const segments = key.split('.');
    doRemoveFromValueTree(valueTree, segments);
}
exports.removeFromValueTree = removeFromValueTree;
function doRemoveFromValueTree(valueTree, segments) {
    const first = segments.shift();
    if (segments.length === 0) {
        // Reached last segment
        delete valueTree[first];
        return;
    }
    if (Object.keys(valueTree).indexOf(first) !== -1) {
        const value = valueTree[first];
        if (typeof value === 'object' && !Array.isArray(value)) {
            doRemoveFromValueTree(value, segments);
            if (Object.keys(value).length === 0) {
                delete valueTree[first];
            }
        }
    }
}
/**
 * A helper function to get the configuration value with a specific settings path (e.g. config.some.setting)
 */
function getConfigurationValue(config, settingPath, defaultValue) {
    function accessSetting(config, path) {
        let current = config;
        for (const component of path) {
            if (typeof current !== 'object' || current === null) {
                return undefined;
            }
            current = current[component];
        }
        return current;
    }
    //@ sri: customized to prevent from failing due to numberic value from settingPath
    let result;
    try {
        const path = settingPath.split('.');
        result = accessSetting(config, path);
    }
    catch (err) {
        console.warn('received path as number', settingPath);
    }
    return typeof result === 'undefined' ? defaultValue : result;
}
exports.getConfigurationValue = getConfigurationValue;
function merge(base, add, overwrite) {
    Object.keys(add).forEach(key => {
        if (key in base) {
            if (types.isObject(base[key]) && types.isObject(add[key])) {
                merge(base[key], add[key], overwrite);
            }
            else if (overwrite) {
                base[key] = add[key];
            }
        }
        else {
            base[key] = add[key];
        }
    });
}
exports.merge = merge;
// getConfigurationKeys() exist in the server-core
// getDefaultValues() exist in the server core
function overrideIdentifierFromKey(key) {
    return key.substring(1, key.length - 1);
}
exports.overrideIdentifierFromKey = overrideIdentifierFromKey;
function keyFromOverrideIdentifier(overrideIdentifier) {
    return `[${overrideIdentifier}]`;
}
exports.keyFromOverrideIdentifier = keyFromOverrideIdentifier;
function getMigratedSettingValue(configurationService, currentSettingName, legacySettingName) {
    const setting = configurationService.inspect(currentSettingName);
    const legacySetting = configurationService.inspect(legacySettingName);
    if (typeof setting.user !== 'undefined' || typeof setting.workspace !== 'undefined' || typeof setting.workspaceFolder !== 'undefined') {
        return setting.value;
    }
    else if (typeof legacySetting.user !== 'undefined' || typeof legacySetting.workspace !== 'undefined' || typeof legacySetting.workspaceFolder !== 'undefined') {
        return legacySetting.value;
    }
    else {
        return setting.default;
    }
}
exports.getMigratedSettingValue = getMigratedSettingValue;
//# sourceMappingURL=configuration.js.map