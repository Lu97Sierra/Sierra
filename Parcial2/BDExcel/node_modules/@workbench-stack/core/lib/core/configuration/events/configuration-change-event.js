"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigurationChangeEvent = void 0;
/* tslint:disable */
const abastract_configuration_change_event_1 = require("./abastract-configuration-change-event");
const configuration_model_1 = require("../models/configuration-model");
const map_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/map");
const arrays = require("@vscode-alt/monaco-editor/esm/vs/base/common/arrays");
// src/vs/platform/configuration/common/configurationModels.ts
class ConfigurationChangeEvent extends abastract_configuration_change_event_1.AbstractConfigurationChangeEvent {
    constructor(_changedConfiguration = new configuration_model_1.ConfigurationModel(), _changedConfigurationByResource = new map_1.ResourceMap()) {
        super();
        this._changedConfiguration = _changedConfiguration;
        this._changedConfigurationByResource = _changedConfigurationByResource;
    }
    get changedConfiguration() {
        return this._changedConfiguration;
    }
    get changedConfigurationByResource() {
        return this._changedConfigurationByResource;
    }
    change(arg1, arg2) {
        if (arg1 instanceof ConfigurationChangeEvent) {
            this._changedConfiguration = this._changedConfiguration.merge(arg1._changedConfiguration);
            for (const resource of arg1._changedConfigurationByResource.keys()) {
                let changedConfigurationByResource = this.getOrSetChangedConfigurationForResource(resource);
                changedConfigurationByResource = changedConfigurationByResource.merge(arg1._changedConfigurationByResource.get(resource));
                this._changedConfigurationByResource.set(resource, changedConfigurationByResource);
            }
        }
        else {
            this.changeWithKeys(arg1, arg2);
        }
        return this;
    }
    telemetryData(source, sourceConfig) {
        this._source = source;
        this._sourceConfig = sourceConfig;
        return this;
    }
    get affectedKeys() {
        const keys = [...this._changedConfiguration.keys];
        this._changedConfigurationByResource.forEach(model => keys.push(...model.keys));
        return arrays.distinct(keys);
    }
    get source() {
        return this._source;
    }
    get sourceConfig() {
        return this._sourceConfig;
    }
    affectsConfiguration(config, resource) {
        let configurationModelsToSearch = [this._changedConfiguration];
        if (resource) {
            let model = this._changedConfigurationByResource.get(resource);
            if (model) {
                configurationModelsToSearch.push(model);
            }
        }
        else {
            configurationModelsToSearch.push(...this._changedConfigurationByResource.values());
        }
        for (const configuration of configurationModelsToSearch) {
            if (this.doesConfigurationContains(configuration, config)) {
                return true;
            }
        }
        return false;
    }
    changeWithKeys(keys, resource) {
        let changedConfiguration = resource ? this.getOrSetChangedConfigurationForResource(resource) : this._changedConfiguration;
        this.updateKeys(changedConfiguration, keys);
    }
    getOrSetChangedConfigurationForResource(resource) {
        let changedConfigurationByResource = this._changedConfigurationByResource.get(resource);
        if (!changedConfigurationByResource) {
            changedConfigurationByResource = new configuration_model_1.ConfigurationModel();
            this._changedConfigurationByResource.set(resource, changedConfigurationByResource);
        }
        return changedConfigurationByResource;
    }
}
exports.ConfigurationChangeEvent = ConfigurationChangeEvent;
//# sourceMappingURL=configuration-change-event.js.map