import './list.css';
import { IDisposable, DisposableStore } from '../../../common/lifecycle';
import { IKeyboardEvent } from '../../keyboardEvent';
import { Event } from '../../../common/event';
import { IListVirtualDelegate, IListRenderer, IListEvent, IListContextMenuEvent, IListMouseEvent, IListTouchEvent, IListGestureEvent, IIdentityProvider, IKeyboardNavigationLabelProvider, IListDragAndDrop, IKeyboardNavigationDelegate } from './list';
import { ListView, IListViewAccessibilityProvider, IListViewOptionsUpdate } from './listView';
import { Color } from '../../../common/color';
import { ScrollbarVisibility, ScrollEvent } from '../../../common/scrollable';
import { ISpliceable } from '../../../common/sequence';
import { IThemable } from '../../../common/styler';
export declare function isInputElement(e: HTMLElement): boolean;
export declare function isMonacoEditor(e: HTMLElement): boolean;
export declare const DefaultKeyboardNavigationDelegate: {
    mightProducePrintableCharacter(event: IKeyboardEvent): boolean;
};
export declare function isSelectionSingleChangeEvent(event: IListMouseEvent<any> | IListTouchEvent<any>): boolean;
export declare function isSelectionRangeChangeEvent(event: IListMouseEvent<any> | IListTouchEvent<any>): boolean;
export declare class MouseController<T> implements IDisposable {
    protected list: List<T>;
    private multipleSelectionSupport;
    readonly multipleSelectionController: IMultipleSelectionController<T> | undefined;
    private mouseSupport;
    private readonly disposables;
    private _onPointer;
    readonly onPointer: Event<IListMouseEvent<T>>;
    constructor(list: List<T>);
    protected isSelectionSingleChangeEvent(event: IListMouseEvent<any> | IListTouchEvent<any>): boolean;
    protected isSelectionRangeChangeEvent(event: IListMouseEvent<any> | IListTouchEvent<any>): boolean;
    private isSelectionChangeEvent;
    private onMouseDown;
    private onContextMenu;
    protected onViewPointer(e: IListMouseEvent<T>): void;
    protected onDoubleClick(e: IListMouseEvent<T>): void;
    private changeSelection;
    dispose(): void;
}
export interface IMultipleSelectionController<T> {
    isSelectionSingleChangeEvent(event: IListMouseEvent<T> | IListTouchEvent<T>): boolean;
    isSelectionRangeChangeEvent(event: IListMouseEvent<T> | IListTouchEvent<T>): boolean;
}
export interface IStyleController {
    style(styles: IListStyles): void;
}
export interface IListAccessibilityProvider<T> extends IListViewAccessibilityProvider<T> {
    getAriaLabel(element: T): string | null;
    getWidgetAriaLabel(): string;
    getWidgetRole?(): string;
    getAriaLevel?(element: T): number | undefined;
    onDidChangeActiveDescendant?: Event<void>;
    getActiveDescendantId?(element: T): string | undefined;
}
export declare class DefaultStyleController implements IStyleController {
    private styleElement;
    private selectorSuffix;
    constructor(styleElement: HTMLStyleElement, selectorSuffix: string);
    style(styles: IListStyles): void;
}
export interface IListOptions<T> {
    readonly identityProvider?: IIdentityProvider<T>;
    readonly dnd?: IListDragAndDrop<T>;
    readonly enableKeyboardNavigation?: boolean;
    readonly automaticKeyboardNavigation?: boolean;
    readonly keyboardNavigationLabelProvider?: IKeyboardNavigationLabelProvider<T>;
    readonly keyboardNavigationDelegate?: IKeyboardNavigationDelegate;
    readonly keyboardSupport?: boolean;
    readonly multipleSelectionSupport?: boolean;
    readonly multipleSelectionController?: IMultipleSelectionController<T>;
    readonly styleController?: (suffix: string) => IStyleController;
    readonly accessibilityProvider?: IListAccessibilityProvider<T>;
    readonly useShadows?: boolean;
    readonly verticalScrollMode?: ScrollbarVisibility;
    readonly setRowLineHeight?: boolean;
    readonly setRowHeight?: boolean;
    readonly supportDynamicHeights?: boolean;
    readonly mouseSupport?: boolean;
    readonly horizontalScrolling?: boolean;
    readonly additionalScrollHeight?: number;
    readonly transformOptimization?: boolean;
    readonly smoothScrolling?: boolean;
}
export interface IListStyles {
    listBackground?: Color;
    listFocusBackground?: Color;
    listFocusForeground?: Color;
    listActiveSelectionBackground?: Color;
    listActiveSelectionForeground?: Color;
    listFocusAndSelectionBackground?: Color;
    listFocusAndSelectionForeground?: Color;
    listInactiveSelectionBackground?: Color;
    listInactiveSelectionForeground?: Color;
    listInactiveFocusBackground?: Color;
    listHoverBackground?: Color;
    listHoverForeground?: Color;
    listDropBackground?: Color;
    listFocusOutline?: Color;
    listInactiveFocusOutline?: Color;
    listSelectionOutline?: Color;
    listHoverOutline?: Color;
    listFilterWidgetBackground?: Color;
    listFilterWidgetOutline?: Color;
    listFilterWidgetNoMatchesOutline?: Color;
    listMatchesShadow?: Color;
    treeIndentGuidesStroke?: Color;
}
export interface IListOptionsUpdate extends IListViewOptionsUpdate {
    readonly enableKeyboardNavigation?: boolean;
    readonly automaticKeyboardNavigation?: boolean;
}
export declare class List<T> implements ISpliceable<T>, IThemable, IDisposable {
    private user;
    private _options;
    private focus;
    private selection;
    private eventBufferer;
    protected view: ListView<T>;
    private spliceable;
    private styleController;
    private typeLabelController?;
    private accessibilityProvider?;
    private mouseController;
    private _ariaLabel;
    protected readonly disposables: DisposableStore;
    get onDidChangeFocus(): Event<IListEvent<T>>;
    get onDidChangeSelection(): Event<IListEvent<T>>;
    get domId(): string;
    get onDidScroll(): Event<ScrollEvent>;
    get onMouseClick(): Event<IListMouseEvent<T>>;
    get onMouseDblClick(): Event<IListMouseEvent<T>>;
    get onMouseMiddleClick(): Event<IListMouseEvent<T>>;
    get onPointer(): Event<IListMouseEvent<T>>;
    get onMouseUp(): Event<IListMouseEvent<T>>;
    get onMouseDown(): Event<IListMouseEvent<T>>;
    get onMouseOver(): Event<IListMouseEvent<T>>;
    get onMouseMove(): Event<IListMouseEvent<T>>;
    get onMouseOut(): Event<IListMouseEvent<T>>;
    get onTouchStart(): Event<IListTouchEvent<T>>;
    get onTap(): Event<IListGestureEvent<T>>;
    private didJustPressContextMenuKey;
    get onContextMenu(): Event<IListContextMenuEvent<T>>;
    get onKeyDown(): Event<KeyboardEvent>;
    get onKeyUp(): Event<KeyboardEvent>;
    get onKeyPress(): Event<KeyboardEvent>;
    readonly onDidFocus: Event<void>;
    readonly onDidBlur: Event<void>;
    private readonly _onDidDispose;
    readonly onDidDispose: Event<void>;
    constructor(user: string, container: HTMLElement, virtualDelegate: IListVirtualDelegate<T>, renderers: IListRenderer<any, any>[], _options?: IListOptions<T>);
    protected createMouseController(options: IListOptions<T>): MouseController<T>;
    updateOptions(optionsUpdate?: IListOptionsUpdate): void;
    get options(): IListOptions<T>;
    splice(start: number, deleteCount: number, elements?: T[]): void;
    updateWidth(index: number): void;
    updateElementHeight(index: number, size: number): void;
    rerender(): void;
    element(index: number): T;
    indexOf(element: T): number;
    get length(): number;
    get contentHeight(): number;
    get onDidChangeContentHeight(): Event<number>;
    get scrollTop(): number;
    set scrollTop(scrollTop: number);
    get scrollLeft(): number;
    set scrollLeft(scrollLeft: number);
    get scrollHeight(): number;
    get renderHeight(): number;
    get firstVisibleIndex(): number;
    get lastVisibleIndex(): number;
    get ariaLabel(): string;
    set ariaLabel(value: string);
    domFocus(): void;
    layout(height?: number, width?: number): void;
    toggleKeyboardNavigation(): void;
    setSelection(indexes: number[], browserEvent?: UIEvent): void;
    getSelection(): number[];
    getSelectedElements(): T[];
    setFocus(indexes: number[], browserEvent?: UIEvent): void;
    focusNext(n?: number, loop?: boolean, browserEvent?: UIEvent, filter?: (element: T) => boolean): void;
    focusPrevious(n?: number, loop?: boolean, browserEvent?: UIEvent, filter?: (element: T) => boolean): void;
    focusNextPage(browserEvent?: UIEvent, filter?: (element: T) => boolean): void;
    focusPreviousPage(browserEvent?: UIEvent, filter?: (element: T) => boolean): void;
    focusLast(browserEvent?: UIEvent, filter?: (element: T) => boolean): void;
    focusFirst(browserEvent?: UIEvent, filter?: (element: T) => boolean): void;
    focusNth(n: number, browserEvent?: UIEvent, filter?: (element: T) => boolean): void;
    private findNextIndex;
    private findPreviousIndex;
    getFocus(): number[];
    getFocusedElements(): T[];
    reveal(index: number, relativeTop?: number): void;
    /**
     * Returns the relative position of an element rendered in the list.
     * Returns `null` if the element isn't *entirely* in the visible viewport.
     */
    getRelativeTop(index: number): number | null;
    isDOMFocused(): boolean;
    getHTMLElement(): HTMLElement;
    style(styles: IListStyles): void;
    private toListEvent;
    private _onFocusChange;
    private onDidChangeActiveDescendant;
    private _onSelectionChange;
    dispose(): void;
}
