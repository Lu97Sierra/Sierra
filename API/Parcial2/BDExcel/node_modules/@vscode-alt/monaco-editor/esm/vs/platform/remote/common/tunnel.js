/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Emitter } from '../../../base/common/event.js';
import { createDecorator } from '../../instantiation/common/instantiation.js';
import { ILogService } from '../../log/common/log.js';
export const ITunnelService = createDecorator('tunnelService');
export function extractLocalHostUriMetaDataForPortMapping(uri) {
    if (uri.scheme !== 'http' && uri.scheme !== 'https') {
        return undefined;
    }
    const localhostMatch = /^(localhost|127\.0\.0\.1|0\.0\.0\.0):(\d+)$/.exec(uri.authority);
    if (!localhostMatch) {
        return undefined;
    }
    return {
        address: localhostMatch[1],
        port: +localhostMatch[2],
    };
}
export const LOCALHOST_ADDRESSES = ['localhost', '127.0.0.1', '0:0:0:0:0:0:0:1', '::1'];
export function isLocalhost(host) {
    return LOCALHOST_ADDRESSES.indexOf(host) >= 0;
}
export const ALL_INTERFACES_ADDRESSES = ['0.0.0.0', '0:0:0:0:0:0:0:0', '::'];
export function isAllInterfaces(host) {
    return ALL_INTERFACES_ADDRESSES.indexOf(host) >= 0;
}
function getOtherLocalhost(host) {
    return (host === 'localhost') ? '127.0.0.1' : ((host === '127.0.0.1') ? 'localhost' : undefined);
}
let AbstractTunnelService = class AbstractTunnelService {
    constructor(logService) {
        this.logService = logService;
        this._onTunnelOpened = new Emitter();
        this.onTunnelOpened = this._onTunnelOpened.event;
        this._onTunnelClosed = new Emitter();
        this.onTunnelClosed = this._onTunnelClosed.event;
        this._tunnels = new Map();
    }
    setTunnelProvider(provider) {
        if (!provider) {
            return {
                dispose: () => { }
            };
        }
        this._tunnelProvider = provider;
        return {
            dispose: () => {
                this._tunnelProvider = undefined;
            }
        };
    }
    get tunnels() {
        const promises = [];
        Array.from(this._tunnels.values()).forEach(portMap => Array.from(portMap.values()).forEach(x => promises.push(x.value)));
        return Promise.all(promises);
    }
    dispose() {
        for (const portMap of this._tunnels.values()) {
            for (const { value } of portMap.values()) {
                value.then(tunnel => tunnel.dispose());
            }
            portMap.clear();
        }
        this._tunnels.clear();
    }
    openTunnel(addressProvider, remoteHost, remotePort, localPort) {
        if (!addressProvider) {
            return undefined;
        }
        if (!remoteHost) {
            remoteHost = 'localhost';
        }
        const resolvedTunnel = this.retainOrCreateTunnel(addressProvider, remoteHost, remotePort, localPort);
        if (!resolvedTunnel) {
            return resolvedTunnel;
        }
        return resolvedTunnel.then(tunnel => {
            const newTunnel = this.makeTunnel(tunnel);
            if (tunnel.tunnelRemoteHost !== remoteHost || tunnel.tunnelRemotePort !== remotePort) {
                this.logService.warn('Created tunnel does not match requirements of requested tunnel. Host or port mismatch.');
            }
            this._onTunnelOpened.fire(newTunnel);
            return newTunnel;
        });
    }
    makeTunnel(tunnel) {
        return {
            tunnelRemotePort: tunnel.tunnelRemotePort,
            tunnelRemoteHost: tunnel.tunnelRemoteHost,
            tunnelLocalPort: tunnel.tunnelLocalPort,
            localAddress: tunnel.localAddress,
            dispose: () => {
                const existingHost = this._tunnels.get(tunnel.tunnelRemoteHost);
                if (existingHost) {
                    const existing = existingHost.get(tunnel.tunnelRemotePort);
                    if (existing) {
                        existing.refcount--;
                        this.tryDisposeTunnel(tunnel.tunnelRemoteHost, tunnel.tunnelRemotePort, existing);
                    }
                }
            }
        };
    }
    tryDisposeTunnel(remoteHost, remotePort, tunnel) {
        return __awaiter(this, void 0, void 0, function* () {
            if (tunnel.refcount <= 0) {
                const disposePromise = tunnel.value.then(tunnel => {
                    tunnel.dispose(true);
                    this._onTunnelClosed.fire({ host: tunnel.tunnelRemoteHost, port: tunnel.tunnelRemotePort });
                });
                if (this._tunnels.has(remoteHost)) {
                    this._tunnels.get(remoteHost).delete(remotePort);
                }
                return disposePromise;
            }
        });
    }
    closeTunnel(remoteHost, remotePort) {
        return __awaiter(this, void 0, void 0, function* () {
            const portMap = this._tunnels.get(remoteHost);
            if (portMap && portMap.has(remotePort)) {
                const value = portMap.get(remotePort);
                value.refcount = 0;
                yield this.tryDisposeTunnel(remoteHost, remotePort, value);
            }
        });
    }
    addTunnelToMap(remoteHost, remotePort, tunnel) {
        if (!this._tunnels.has(remoteHost)) {
            this._tunnels.set(remoteHost, new Map());
        }
        this._tunnels.get(remoteHost).set(remotePort, { refcount: 1, value: tunnel });
    }
    getTunnelFromMap(remoteHost, remotePort) {
        const otherLocalhost = getOtherLocalhost(remoteHost);
        let portMap;
        if (otherLocalhost) {
            const firstMap = this._tunnels.get(remoteHost);
            const secondMap = this._tunnels.get(otherLocalhost);
            if (firstMap && secondMap) {
                portMap = new Map([...Array.from(firstMap.entries()), ...Array.from(secondMap.entries())]);
            }
            else {
                portMap = firstMap !== null && firstMap !== void 0 ? firstMap : secondMap;
            }
        }
        else {
            portMap = this._tunnels.get(remoteHost);
        }
        return portMap ? portMap.get(remotePort) : undefined;
    }
    isPortPrivileged(port) {
        return port < 1024;
    }
};
AbstractTunnelService = __decorate([
    __param(0, ILogService)
], AbstractTunnelService);
export { AbstractTunnelService };
export class TunnelService extends AbstractTunnelService {
    retainOrCreateTunnel(_addressProvider, remoteHost, remotePort, localPort) {
        const existing = this.getTunnelFromMap(remoteHost, remotePort);
        if (existing) {
            ++existing.refcount;
            return existing.value;
        }
        if (this._tunnelProvider) {
            const preferredLocalPort = localPort === undefined ? remotePort : localPort;
            const tunnelOptions = { remoteAddress: { host: remoteHost, port: remotePort }, localAddressPort: localPort };
            const creationInfo = { elevationRequired: this.isPortPrivileged(preferredLocalPort) };
            const tunnel = this._tunnelProvider.forwardPort(tunnelOptions, creationInfo);
            if (tunnel) {
                this.addTunnelToMap(remoteHost, remotePort, tunnel);
            }
            return tunnel;
        }
        return undefined;
    }
}
