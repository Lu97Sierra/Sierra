/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
import * as objects from '../../../base/common/objects.js';
import * as types from '../../../base/common/types.js';
import { URI } from '../../../base/common/uri.js';
import { Registry } from '../../registry/common/platform.js';
import { createDecorator } from '../../instantiation/common/instantiation.js';
import { Extensions, OVERRIDE_PROPERTY_PATTERN, overrideIdentifierFromKey } from './configurationRegistry.js';
export const IConfigurationService = createDecorator('configurationService');
export function isConfigurationOverrides(thing) {
    return thing
        && typeof thing === 'object'
        && (!thing.overrideIdentifier || typeof thing.overrideIdentifier === 'string')
        && (!thing.resource || thing.resource instanceof URI);
}
export function ConfigurationTargetToString(configurationTarget) {
    switch (configurationTarget) {
        case 1 /* USER */: return 'USER';
        case 2 /* USER_LOCAL */: return 'USER_LOCAL';
        case 3 /* USER_REMOTE */: return 'USER_REMOTE';
        case 4 /* WORKSPACE */: return 'WORKSPACE';
        case 5 /* WORKSPACE_FOLDER */: return 'WORKSPACE_FOLDER';
        case 6 /* DEFAULT */: return 'DEFAULT';
        case 7 /* MEMORY */: return 'MEMORY';
    }
}
export function compare(from, to) {
    const added = to
        ? from ? to.keys.filter(key => from.keys.indexOf(key) === -1) : [...to.keys]
        : [];
    const removed = from
        ? to ? from.keys.filter(key => to.keys.indexOf(key) === -1) : [...from.keys]
        : [];
    const updated = [];
    if (to && from) {
        for (const key of from.keys) {
            if (to.keys.indexOf(key) !== -1) {
                const value1 = getConfigurationValue(from.contents, key);
                const value2 = getConfigurationValue(to.contents, key);
                if (!objects.equals(value1, value2)) {
                    updated.push(key);
                }
            }
        }
    }
    const overrides = [];
    const byOverrideIdentifier = (overrides) => {
        const result = {};
        for (const override of overrides) {
            for (const identifier of override.identifiers) {
                result[keyFromOverrideIdentifier(identifier)] = override;
            }
        }
        return result;
    };
    const toOverridesByIdentifier = to ? byOverrideIdentifier(to.overrides) : {};
    const fromOverridesByIdentifier = from ? byOverrideIdentifier(from.overrides) : {};
    if (Object.keys(toOverridesByIdentifier).length) {
        for (const key of added) {
            const override = toOverridesByIdentifier[key];
            if (override) {
                overrides.push([overrideIdentifierFromKey(key), override.keys]);
            }
        }
    }
    if (Object.keys(fromOverridesByIdentifier).length) {
        for (const key of removed) {
            const override = fromOverridesByIdentifier[key];
            if (override) {
                overrides.push([overrideIdentifierFromKey(key), override.keys]);
            }
        }
    }
    if (Object.keys(toOverridesByIdentifier).length && Object.keys(fromOverridesByIdentifier).length) {
        for (const key of updated) {
            const fromOverride = fromOverridesByIdentifier[key];
            const toOverride = toOverridesByIdentifier[key];
            if (fromOverride && toOverride) {
                const result = compare({ contents: fromOverride.contents, keys: fromOverride.keys, overrides: [] }, { contents: toOverride.contents, keys: toOverride.keys, overrides: [] });
                overrides.push([overrideIdentifierFromKey(key), [...result.added, ...result.removed, ...result.updated]]);
            }
        }
    }
    return { added, removed, updated, overrides };
}
export function toOverrides(raw, conflictReporter) {
    const overrides = [];
    for (const key of Object.keys(raw)) {
        if (OVERRIDE_PROPERTY_PATTERN.test(key)) {
            const overrideRaw = {};
            for (const keyInOverrideRaw in raw[key]) {
                overrideRaw[keyInOverrideRaw] = raw[key][keyInOverrideRaw];
            }
            overrides.push({
                identifiers: [overrideIdentifierFromKey(key).trim()],
                keys: Object.keys(overrideRaw),
                contents: toValuesTree(overrideRaw, conflictReporter)
            });
        }
    }
    return overrides;
}
export function toValuesTree(properties, conflictReporter) {
    const root = Object.create(null);
    for (let key in properties) {
        addToValueTree(root, key, properties[key], conflictReporter);
    }
    return root;
}
export function addToValueTree(settingsTreeRoot, key, value, conflictReporter) {
    const segments = key.split('.');
    const last = segments.pop();
    let curr = settingsTreeRoot;
    for (let i = 0; i < segments.length; i++) {
        let s = segments[i];
        let obj = curr[s];
        switch (typeof obj) {
            case 'undefined':
                obj = curr[s] = Object.create(null);
                break;
            case 'object':
                break;
            default:
                conflictReporter(`Ignoring ${key} as ${segments.slice(0, i + 1).join('.')} is ${JSON.stringify(obj)}`);
                return;
        }
        curr = obj;
    }
    if (typeof curr === 'object' && curr !== null) {
        try {
            curr[last] = value; // workaround https://github.com/microsoft/vscode/issues/13606
        }
        catch (e) {
            conflictReporter(`Ignoring ${key} as ${segments.join('.')} is ${JSON.stringify(curr)}`);
        }
    }
    else {
        conflictReporter(`Ignoring ${key} as ${segments.join('.')} is ${JSON.stringify(curr)}`);
    }
}
export function removeFromValueTree(valueTree, key) {
    const segments = key.split('.');
    doRemoveFromValueTree(valueTree, segments);
}
function doRemoveFromValueTree(valueTree, segments) {
    const first = segments.shift();
    if (segments.length === 0) {
        // Reached last segment
        delete valueTree[first];
        return;
    }
    if (Object.keys(valueTree).indexOf(first) !== -1) {
        const value = valueTree[first];
        if (typeof value === 'object' && !Array.isArray(value)) {
            doRemoveFromValueTree(value, segments);
            if (Object.keys(value).length === 0) {
                delete valueTree[first];
            }
        }
    }
}
/**
 * A helper function to get the configuration value with a specific settings path (e.g. config.some.setting)
 */
export function getConfigurationValue(config, settingPath, defaultValue) {
    function accessSetting(config, path) {
        let current = config;
        for (const component of path) {
            if (typeof current !== 'object' || current === null) {
                return undefined;
            }
            current = current[component];
        }
        return current;
    }
    const path = settingPath.split('.');
    const result = accessSetting(config, path);
    return typeof result === 'undefined' ? defaultValue : result;
}
export function merge(base, add, overwrite) {
    Object.keys(add).forEach(key => {
        if (key !== '__proto__') {
            if (key in base) {
                if (types.isObject(base[key]) && types.isObject(add[key])) {
                    merge(base[key], add[key], overwrite);
                }
                else if (overwrite) {
                    base[key] = add[key];
                }
            }
            else {
                base[key] = add[key];
            }
        }
    });
}
export function getConfigurationKeys() {
    const properties = Registry.as(Extensions.Configuration).getConfigurationProperties();
    return Object.keys(properties);
}
export function getDefaultValues() {
    const valueTreeRoot = Object.create(null);
    const properties = Registry.as(Extensions.Configuration).getConfigurationProperties();
    for (let key in properties) {
        let value = properties[key].default;
        addToValueTree(valueTreeRoot, key, value, message => console.error(`Conflict in default settings: ${message}`));
    }
    return valueTreeRoot;
}
export function keyFromOverrideIdentifier(overrideIdentifier) {
    return `[${overrideIdentifier}]`;
}
export function getMigratedSettingValue(configurationService, currentSettingName, legacySettingName) {
    const setting = configurationService.inspect(currentSettingName);
    const legacySetting = configurationService.inspect(legacySettingName);
    if (typeof setting.userValue !== 'undefined' || typeof setting.workspaceValue !== 'undefined' || typeof setting.workspaceFolderValue !== 'undefined') {
        return setting.value;
    }
    else if (typeof legacySetting.userValue !== 'undefined' || typeof legacySetting.workspaceValue !== 'undefined' || typeof legacySetting.workspaceFolderValue !== 'undefined') {
        return legacySetting.value;
    }
    else {
        return setting.defaultValue;
    }
}
