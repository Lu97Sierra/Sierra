import { ReplaceCommandWithOffsetCursorState } from '../commands/replaceCommand';
import { CursorConfiguration, EditOperationResult, EditOperationType, ICursorSimpleModel } from './cursorCommon';
import { Range } from '../core/range';
import { Selection } from '../core/selection';
import { ICommand, ICursorStateComputerData } from '../editorCommon';
import { ITextModel } from '../model';
export declare class TypeOperations {
    static indent(config: CursorConfiguration, model: ICursorSimpleModel | null, selections: Selection[] | null): ICommand[];
    static outdent(config: CursorConfiguration, model: ICursorSimpleModel, selections: Selection[]): ICommand[];
    static shiftIndent(config: CursorConfiguration, indentation: string, count?: number): string;
    static unshiftIndent(config: CursorConfiguration, indentation: string, count?: number): string;
    private static _distributedPaste;
    private static _simplePaste;
    private static _distributePasteToCursors;
    static paste(config: CursorConfiguration, model: ICursorSimpleModel, selections: Selection[], text: string, pasteOnNewLine: boolean, multicursorText: string[]): EditOperationResult;
    private static _goodIndentForLine;
    private static _replaceJumpToNextIndent;
    static tab(config: CursorConfiguration, model: ITextModel, selections: Selection[]): ICommand[];
    static replacePreviousChar(prevEditOperationType: EditOperationType, config: CursorConfiguration, model: ITextModel, selections: Selection[], txt: string, replaceCharCnt: number): EditOperationResult;
    private static _typeCommand;
    private static _enter;
    private static _isAutoIndentType;
    private static _runAutoIndentType;
    private static _isAutoClosingOvertype;
    private static _runAutoClosingOvertype;
    private static _isBeforeClosingBrace;
    private static _findAutoClosingPairOpen;
    private static _findSubAutoClosingPairClose;
    private static _getAutoClosingPairClose;
    private static _runAutoClosingOpenCharType;
    private static _shouldSurroundChar;
    private static _isSurroundSelectionType;
    private static _runSurroundSelectionType;
    private static _isTypeInterceptorElectricChar;
    private static _typeInterceptorElectricChar;
    /**
     * This is very similar with typing, but the character is already in the text buffer!
     */
    static compositionEndWithInterceptors(prevEditOperationType: EditOperationType, config: CursorConfiguration, model: ITextModel, selectionsWhenCompositionStarted: Selection[] | null, selections: Selection[], autoClosedCharacters: Range[]): EditOperationResult | null;
    static typeWithInterceptors(isDoingComposition: boolean, prevEditOperationType: EditOperationType, config: CursorConfiguration, model: ITextModel, selections: Selection[], autoClosedCharacters: Range[], ch: string): EditOperationResult;
    static typeWithoutInterceptors(prevEditOperationType: EditOperationType, config: CursorConfiguration, model: ITextModel, selections: Selection[], str: string): EditOperationResult;
    static lineInsertBefore(config: CursorConfiguration, model: ITextModel | null, selections: Selection[] | null): ICommand[];
    static lineInsertAfter(config: CursorConfiguration, model: ITextModel | null, selections: Selection[] | null): ICommand[];
    static lineBreakInsert(config: CursorConfiguration, model: ITextModel, selections: Selection[]): ICommand[];
}
export declare class TypeWithAutoClosingCommand extends ReplaceCommandWithOffsetCursorState {
    private readonly _openCharacter;
    private readonly _closeCharacter;
    closeCharacterRange: Range | null;
    enclosingRange: Range | null;
    constructor(selection: Selection, openCharacter: string, insertOpenCharacter: boolean, closeCharacter: string);
    computeCursorState(model: ITextModel, helper: ICursorStateComputerData): Selection;
}
