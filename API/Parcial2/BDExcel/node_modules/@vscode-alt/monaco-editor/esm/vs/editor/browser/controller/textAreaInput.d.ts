import { FastDomNode } from '../../../base/browser/fastDomNode';
import { IKeyboardEvent } from '../../../base/browser/keyboardEvent';
import { Event } from '../../../base/common/event';
import { Disposable } from '../../../base/common/lifecycle';
import { ITypeData, TextAreaState } from './textAreaState';
import { Position } from '../../common/core/position';
import { Selection } from '../../common/core/selection';
export interface ICompositionData {
    data: string;
}
export declare const CopyOptions: {
    forceCopyWithSyntaxHighlighting: boolean;
};
export interface IPasteData {
    text: string;
    metadata: ClipboardStoredMetadata | null;
}
export interface ClipboardDataToCopy {
    isFromEmptySelection: boolean;
    multicursorText: string[] | null | undefined;
    text: string;
    html: string | null | undefined;
    mode: string | null;
}
export interface ClipboardStoredMetadata {
    version: 1;
    isFromEmptySelection: boolean | undefined;
    multicursorText: string[] | null | undefined;
    mode: string | null;
}
export interface ITextAreaInputHost {
    getDataToCopy(html: boolean): ClipboardDataToCopy;
    getScreenReaderContent(currentState: TextAreaState): TextAreaState;
    deduceModelPosition(viewAnchorPosition: Position, deltaOffset: number, lineFeedCnt: number): Position;
}
/**
 * Every time we write to the clipboard, we record a bit of extra metadata here.
 * Every time we read from the cipboard, if the text matches our last written text,
 * we can fetch the previous metadata.
 */
export declare class InMemoryClipboardMetadataManager {
    static readonly INSTANCE: InMemoryClipboardMetadataManager;
    private _lastState;
    constructor();
    set(lastCopiedValue: string, data: ClipboardStoredMetadata): void;
    get(pastedText: string): ClipboardStoredMetadata | null;
}
export interface ICompositionStartEvent {
    moveOneCharacterLeft: boolean;
}
/**
 * Writes screen reader content to the textarea and is able to analyze its input events to generate:
 *  - onCut
 *  - onPaste
 *  - onType
 *
 * Composition events are generated for presentation purposes (composition input is reflected in onType).
 */
export declare class TextAreaInput extends Disposable {
    private textArea;
    private _onFocus;
    readonly onFocus: Event<void>;
    private _onBlur;
    readonly onBlur: Event<void>;
    private _onKeyDown;
    readonly onKeyDown: Event<IKeyboardEvent>;
    private _onKeyUp;
    readonly onKeyUp: Event<IKeyboardEvent>;
    private _onCut;
    readonly onCut: Event<void>;
    private _onPaste;
    readonly onPaste: Event<IPasteData>;
    private _onType;
    readonly onType: Event<ITypeData>;
    private _onCompositionStart;
    readonly onCompositionStart: Event<ICompositionStartEvent>;
    private _onCompositionUpdate;
    readonly onCompositionUpdate: Event<ICompositionData>;
    private _onCompositionEnd;
    readonly onCompositionEnd: Event<void>;
    private _onSelectionChangeRequest;
    readonly onSelectionChangeRequest: Event<Selection>;
    private readonly _host;
    private readonly _textArea;
    private readonly _asyncTriggerCut;
    private _textAreaState;
    private _selectionChangeListener;
    private _hasFocus;
    private _isDoingComposition;
    private _nextCommand;
    constructor(host: ITextAreaInputHost, textArea: FastDomNode<HTMLTextAreaElement>);
    private _installSelectionChangeListener;
    dispose(): void;
    focusTextArea(): void;
    isFocused(): boolean;
    refreshFocusState(): void;
    private _setHasFocus;
    private _setAndWriteTextAreaState;
    writeScreenReaderContent(reason: string): void;
    private _ensureClipboardGetsEditorSelection;
    private _firePaste;
}
