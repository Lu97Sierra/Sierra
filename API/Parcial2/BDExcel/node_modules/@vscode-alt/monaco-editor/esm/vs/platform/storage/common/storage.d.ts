import { Event } from '../../../base/common/event';
import { Disposable } from '../../../base/common/lifecycle';
import { IWorkspaceInitializationPayload } from '../../workspaces/common/workspaces';
export declare const IS_NEW_KEY = "__$__isNewStorageMarker";
export declare const IStorageService: import("../../instantiation/common/instantiation").ServiceIdentifier<IStorageService>;
export declare enum WillSaveStateReason {
    /**
     * No specific reason to save state.
     */
    NONE = 0,
    /**
     * A hint that the workbench is about to shutdown.
     */
    SHUTDOWN = 1
}
export interface IWillSaveStateEvent {
    reason: WillSaveStateReason;
}
export interface IStorageService {
    readonly _serviceBrand: undefined;
    /**
     * Emitted whenever data is updated or deleted.
     */
    readonly onDidChangeValue: Event<IStorageValueChangeEvent>;
    /**
     * Emitted whenever target of a storage entry changes.
     */
    readonly onDidChangeTarget: Event<IStorageTargetChangeEvent>;
    /**
     * Emitted when the storage is about to persist. This is the right time
     * to persist data to ensure it is stored before the application shuts
     * down.
     *
     * The will save state event allows to optionally ask for the reason of
     * saving the state, e.g. to find out if the state is saved due to a
     * shutdown.
     *
     * Note: this event may be fired many times, not only on shutdown to prevent
     * loss of state in situations where the shutdown is not sufficient to
     * persist the data properly.
     */
    readonly onWillSaveState: Event<IWillSaveStateEvent>;
    /**
     * Retrieve an element stored with the given key from storage. Use
     * the provided `defaultValue` if the element is `null` or `undefined`.
     *
     * @param scope allows to define the scope of the storage operation
     * to either the current workspace only or all workspaces.
     */
    get(key: string, scope: StorageScope, fallbackValue: string): string;
    get(key: string, scope: StorageScope, fallbackValue?: string): string | undefined;
    /**
     * Retrieve an element stored with the given key from storage. Use
     * the provided `defaultValue` if the element is `null` or `undefined`.
     * The element will be converted to a `boolean`.
     *
     * @param scope allows to define the scope of the storage operation
     * to either the current workspace only or all workspaces.
     */
    getBoolean(key: string, scope: StorageScope, fallbackValue: boolean): boolean;
    getBoolean(key: string, scope: StorageScope, fallbackValue?: boolean): boolean | undefined;
    /**
     * Retrieve an element stored with the given key from storage. Use
     * the provided `defaultValue` if the element is `null` or `undefined`.
     * The element will be converted to a `number` using `parseInt` with a
     * base of `10`.
     *
     * @param scope allows to define the scope of the storage operation
     * to either the current workspace only or all workspaces.
     */
    getNumber(key: string, scope: StorageScope, fallbackValue: number): number;
    getNumber(key: string, scope: StorageScope, fallbackValue?: number): number | undefined;
    /**
     * Store a value under the given key to storage. The value will be
     * converted to a `string`. Storing either `undefined` or `null` will
     * remove the entry under the key.
     *
     * @param scope allows to define the scope of the storage operation
     * to either the current workspace only or all workspaces.
     *
     * @param target allows to define the target of the storage operation
     * to either the current machine or user.
     */
    store(key: string, value: string | boolean | number | undefined | null, scope: StorageScope, target: StorageTarget): void;
    /**
     * Delete an element stored under the provided key from storage.
     *
     * The scope argument allows to define the scope of the storage
     * operation to either the current workspace only or all workspaces.
     */
    remove(key: string, scope: StorageScope): void;
    /**
     * Returns all the keys used in the storage for the provided `scope`
     * and `target`.
     *
     * Note: this will NOT return all keys stored in the storage layer.
     * Some keys may not have an associated `StorageTarget` and thus
     * will be excluded from the results.
     *
     * @param scope allows to define the scope for the keys
     * to either the current workspace only or all workspaces.
     *
     * @param target allows to define the target for the keys
     * to either the current machine or user.
     */
    keys(scope: StorageScope, target: StorageTarget): string[];
    /**
     * Log the contents of the storage to the console.
     */
    logStorage(): void;
    /**
     * Migrate the storage contents to another workspace.
     */
    migrate(toWorkspace: IWorkspaceInitializationPayload): Promise<void>;
    /**
     * Whether the storage for the given scope was created during this session or
     * existed before.
     */
    isNew(scope: StorageScope): boolean;
    /**
     * Allows to flush state, e.g. in cases where a shutdown is
     * imminent. This will send out the `onWillSaveState` to ask
     * everyone for latest state.
     *
     * @returns a `Promise` that can be awaited on when all updates
     * to the underlying storage have been flushed.
     */
    flush(): Promise<void>;
}
export declare const enum StorageScope {
    /**
     * The stored data will be scoped to all workspaces.
     */
    GLOBAL = 0,
    /**
     * The stored data will be scoped to the current workspace.
     */
    WORKSPACE = 1
}
export declare const enum StorageTarget {
    /**
     * The stored data is user specific and applies across machines.
     */
    USER = 0,
    /**
     * The stored data is machine specific.
     */
    MACHINE = 1
}
export interface IStorageValueChangeEvent {
    /**
     * The scope for the storage entry that changed
     * or was removed.
     */
    readonly scope: StorageScope;
    /**
     * The `key` of the storage entry that was changed
     * or was removed.
     */
    readonly key: string;
    /**
     * The `target` can be `undefined` if a key is being
     * removed.
     */
    readonly target: StorageTarget | undefined;
}
export interface IStorageTargetChangeEvent {
    /**
     * The scope for the target that changed. Listeners
     * should use `keys(scope, target)` to get an updated
     * list of keys for the given `scope` and `target`.
     */
    readonly scope: StorageScope;
}
export declare abstract class AbstractStorageService extends Disposable implements IStorageService {
    readonly _serviceBrand: undefined;
    private readonly _onDidChangeValue;
    readonly onDidChangeValue: Event<IStorageValueChangeEvent>;
    private readonly _onDidChangeTarget;
    readonly onDidChangeTarget: Event<IStorageTargetChangeEvent>;
    private readonly _onWillSaveState;
    readonly onWillSaveState: Event<IWillSaveStateEvent>;
    protected emitDidChangeValue(scope: StorageScope, key: string): void;
    protected emitWillSaveState(reason: WillSaveStateReason): void;
    store(key: string, value: string | boolean | number | undefined | null, scope: StorageScope, target: StorageTarget): void;
    remove(key: string, scope: StorageScope): void;
    private withPausedEmitters;
    keys(scope: StorageScope, target: StorageTarget): string[];
    private updateKeyTarget;
    private _workspaceKeyTargets;
    private get workspaceKeyTargets();
    private _globalKeyTargets;
    private get globalKeyTargets();
    private getKeyTargets;
    private loadKeyTargets;
    isNew(scope: StorageScope): boolean;
    flush(): Promise<void>;
    abstract get(key: string, scope: StorageScope, fallbackValue: string): string;
    abstract get(key: string, scope: StorageScope, fallbackValue?: string): string | undefined;
    abstract getBoolean(key: string, scope: StorageScope, fallbackValue: boolean): boolean;
    abstract getBoolean(key: string, scope: StorageScope, fallbackValue?: boolean): boolean | undefined;
    abstract getNumber(key: string, scope: StorageScope, fallbackValue: number): number;
    abstract getNumber(key: string, scope: StorageScope, fallbackValue?: number): number | undefined;
    protected abstract doStore(key: string, value: string | boolean | number, scope: StorageScope): void;
    protected abstract doRemove(key: string, scope: StorageScope): void;
    protected abstract doFlush(): Promise<void>;
    abstract migrate(toWorkspace: IWorkspaceInitializationPayload): Promise<void>;
    abstract logStorage(): void;
}
export declare class InMemoryStorageService extends AbstractStorageService {
    private readonly globalCache;
    private readonly workspaceCache;
    private getCache;
    get(key: string, scope: StorageScope, fallbackValue: string): string;
    getBoolean(key: string, scope: StorageScope, fallbackValue: boolean): boolean;
    getNumber(key: string, scope: StorageScope, fallbackValue: number): number;
    protected doStore(key: string, value: string | boolean | number, scope: StorageScope): void;
    protected doRemove(key: string, scope: StorageScope): void;
    logStorage(): void;
    migrate(toWorkspace: IWorkspaceInitializationPayload): Promise<void>;
    doFlush(): Promise<void>;
    close(): Promise<void>;
}
export declare function logStorage(global: Map<string, string>, workspace: Map<string, string>, globalPath: string, workspacePath: string): Promise<void>;
