/// <reference types="node" />
import { Socket, Server as NetServer } from 'net';
import { IPCServer } from '../common/ipc';
import { IDisposable, Disposable } from '../../../common/lifecycle';
import { VSBuffer } from '../../../common/buffer';
import { ISocket, Client } from '../common/ipc.net';
export declare class NodeSocket implements ISocket {
    readonly socket: Socket;
    constructor(socket: Socket);
    dispose(): void;
    onData(_listener: (e: VSBuffer) => void): IDisposable;
    onClose(listener: () => void): IDisposable;
    onEnd(listener: () => void): IDisposable;
    write(buffer: VSBuffer): void;
    end(): void;
    drain(): Promise<void>;
}
/**
 * See https://tools.ietf.org/html/rfc6455#section-5.2
 */
export declare class WebSocketNodeSocket extends Disposable implements ISocket {
    readonly socket: NodeSocket;
    private readonly _incomingData;
    private readonly _onData;
    private readonly _state;
    constructor(socket: NodeSocket);
    dispose(): void;
    onData(listener: (e: VSBuffer) => void): IDisposable;
    onClose(listener: () => void): IDisposable;
    onEnd(listener: () => void): IDisposable;
    write(buffer: VSBuffer): void;
    end(): void;
    private _acceptChunk;
    drain(): Promise<void>;
}
export declare const XDG_RUNTIME_DIR: string | undefined;
export declare function createRandomIPCHandle(): string;
export declare function createStaticIPCHandle(directoryPath: string, type: string, version: string): string;
export declare class Server extends IPCServer {
    private static toClientConnectionEvent;
    private server;
    constructor(server: NetServer);
    dispose(): void;
}
export declare function serve(port: number): Promise<Server>;
export declare function serve(namedPipe: string): Promise<Server>;
export declare function connect(options: {
    host: string;
    port: number;
}, clientId: string): Promise<Client>;
export declare function connect(port: number, clientId: string): Promise<Client>;
export declare function connect(namedPipe: string, clientId: string): Promise<Client>;
