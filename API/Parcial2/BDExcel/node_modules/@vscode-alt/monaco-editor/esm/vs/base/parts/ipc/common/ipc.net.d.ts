import { Event } from '../../../common/event';
import { IMessagePassingProtocol, IPCClient, IIPCLogger } from './ipc';
import { IDisposable, Disposable } from '../../../common/lifecycle';
import { VSBuffer } from '../../../common/buffer';
export interface ISocket extends IDisposable {
    onData(listener: (e: VSBuffer) => void): IDisposable;
    onClose(listener: () => void): IDisposable;
    onEnd(listener: () => void): IDisposable;
    write(buffer: VSBuffer): void;
    end(): void;
    drain(): Promise<void>;
}
export declare class ChunkStream {
    private _chunks;
    private _totalLength;
    get byteLength(): number;
    constructor();
    acceptChunk(buff: VSBuffer): void;
    read(byteCount: number): VSBuffer;
    peek(byteCount: number): VSBuffer;
    private _read;
}
export declare const enum ProtocolConstants {
    HeaderLength = 13,
    /**
     * Send an Acknowledge message at most 2 seconds later...
     */
    AcknowledgeTime = 2000,
    /**
     * If there is a message that has been unacknowledged for 10 seconds, consider the connection closed...
     */
    AcknowledgeTimeoutTime = 20000,
    /**
     * Send at least a message every 5s for keep alive reasons.
     */
    KeepAliveTime = 5000,
    /**
     * If there is no message received for 10 seconds, consider the connection closed...
     */
    KeepAliveTimeoutTime = 20000,
    /**
     * If there is no reconnection within this time-frame, consider the connection permanently closed...
     */
    ReconnectionGraceTime = 10800000,
    /**
     * Maximal grace time between the first and the last reconnection...
     */
    ReconnectionShortGraceTime = 300000
}
/**
 * A message has the following format:
 * ```
 *     /-------------------------------|------\
 *     |             HEADER            |      |
 *     |-------------------------------| DATA |
 *     | TYPE | ID | ACK | DATA_LENGTH |      |
 *     \-------------------------------|------/
 * ```
 * The header is 9 bytes and consists of:
 *  - TYPE is 1 byte (ProtocolMessageType) - the message type
 *  - ID is 4 bytes (u32be) - the message id (can be 0 to indicate to be ignored)
 *  - ACK is 4 bytes (u32be) - the acknowledged message id (can be 0 to indicate to be ignored)
 *  - DATA_LENGTH is 4 bytes (u32be) - the length in bytes of DATA
 *
 * Only Regular messages are counted, other messages are not counted, nor acknowledged.
 */
export declare class Protocol extends Disposable implements IMessagePassingProtocol {
    private _socket;
    private _socketWriter;
    private _socketReader;
    private readonly _onMessage;
    readonly onMessage: Event<VSBuffer>;
    private readonly _onClose;
    readonly onClose: Event<void>;
    constructor(socket: ISocket);
    drain(): Promise<void>;
    getSocket(): ISocket;
    sendDisconnect(): void;
    send(buffer: VSBuffer): void;
}
export declare class Client<TContext = string> extends IPCClient<TContext> {
    private protocol;
    static fromSocket<TContext = string>(socket: ISocket, id: TContext): Client<TContext>;
    get onClose(): Event<void>;
    constructor(protocol: Protocol | PersistentProtocol, id: TContext, ipcLogger?: IIPCLogger | null);
    dispose(): void;
}
/**
 * Will ensure no messages are lost if there are no event listeners.
 */
export declare class BufferedEmitter<T> {
    private _emitter;
    readonly event: Event<T>;
    private _hasListeners;
    private _isDeliveringMessages;
    private _bufferedMessages;
    constructor();
    private _deliverMessages;
    fire(event: T): void;
    flushBuffer(): void;
}
/**
 * Same as Protocol, but will actually track messages and acks.
 * Moreover, it will ensure no messages are lost if there are no event listeners.
 */
export declare class PersistentProtocol implements IMessagePassingProtocol {
    private _isReconnecting;
    private _outgoingUnackMsg;
    private _outgoingMsgId;
    private _outgoingAckId;
    private _outgoingAckTimeout;
    private _incomingMsgId;
    private _incomingAckId;
    private _incomingMsgLastTime;
    private _incomingAckTimeout;
    private _outgoingKeepAliveTimeout;
    private _incomingKeepAliveTimeout;
    private _lastReplayRequestTime;
    private _socket;
    private _socketWriter;
    private _socketReader;
    private _socketDisposables;
    private readonly _loadEstimator;
    private readonly _onControlMessage;
    readonly onControlMessage: Event<VSBuffer>;
    private readonly _onMessage;
    readonly onMessage: Event<VSBuffer>;
    private readonly _onClose;
    readonly onClose: Event<void>;
    private readonly _onSocketClose;
    readonly onSocketClose: Event<void>;
    private readonly _onSocketTimeout;
    readonly onSocketTimeout: Event<void>;
    get unacknowledgedCount(): number;
    constructor(socket: ISocket, initialChunk?: VSBuffer | null);
    dispose(): void;
    drain(): Promise<void>;
    sendDisconnect(): void;
    private _sendKeepAliveCheck;
    private _recvKeepAliveCheck;
    getSocket(): ISocket;
    beginAcceptReconnection(socket: ISocket, initialDataChunk: VSBuffer | null): void;
    endAcceptReconnection(): void;
    acceptDisconnect(): void;
    private _receiveMessage;
    readEntireBuffer(): VSBuffer;
    flush(): void;
    send(buffer: VSBuffer): void;
    /**
     * Send a message which will not be part of the regular acknowledge flow.
     * Use this for early control messages which are repeated in case of reconnection.
     */
    sendControl(buffer: VSBuffer): void;
    private _sendAckCheck;
    private _recvAckCheck;
    private _sendAck;
}
