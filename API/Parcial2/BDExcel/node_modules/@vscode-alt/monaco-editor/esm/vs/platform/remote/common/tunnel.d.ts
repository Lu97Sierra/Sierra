import { Event } from '../../../base/common/event';
import { IDisposable } from '../../../base/common/lifecycle';
import { URI } from '../../../base/common/uri';
import { ILogService } from '../../log/common/log';
import { IAddressProvider } from './remoteAgentConnection';
export declare const ITunnelService: import("../../instantiation/common/instantiation").ServiceIdentifier<ITunnelService>;
export interface RemoteTunnel {
    readonly tunnelRemotePort: number;
    readonly tunnelRemoteHost: string;
    readonly tunnelLocalPort?: number;
    readonly localAddress: string;
    dispose(silent?: boolean): void;
}
export interface TunnelOptions {
    remoteAddress: {
        port: number;
        host: string;
    };
    localAddressPort?: number;
    label?: string;
}
export interface TunnelCreationOptions {
    elevationRequired?: boolean;
}
export interface ITunnelProvider {
    forwardPort(tunnelOptions: TunnelOptions, tunnelCreationOptions: TunnelCreationOptions): Promise<RemoteTunnel> | undefined;
}
export interface ITunnelService {
    readonly _serviceBrand: undefined;
    readonly tunnels: Promise<readonly RemoteTunnel[]>;
    readonly onTunnelOpened: Event<RemoteTunnel>;
    readonly onTunnelClosed: Event<{
        host: string;
        port: number;
    }>;
    openTunnel(addressProvider: IAddressProvider | undefined, remoteHost: string | undefined, remotePort: number, localPort?: number): Promise<RemoteTunnel> | undefined;
    closeTunnel(remoteHost: string, remotePort: number): Promise<void>;
    setTunnelProvider(provider: ITunnelProvider | undefined): IDisposable;
}
export declare function extractLocalHostUriMetaDataForPortMapping(uri: URI): {
    address: string;
    port: number;
} | undefined;
export declare const LOCALHOST_ADDRESSES: string[];
export declare function isLocalhost(host: string): boolean;
export declare const ALL_INTERFACES_ADDRESSES: string[];
export declare function isAllInterfaces(host: string): boolean;
export declare abstract class AbstractTunnelService implements ITunnelService {
    protected readonly logService: ILogService;
    readonly _serviceBrand: undefined;
    private _onTunnelOpened;
    onTunnelOpened: Event<RemoteTunnel>;
    private _onTunnelClosed;
    onTunnelClosed: Event<{
        host: string;
        port: number;
    }>;
    protected readonly _tunnels: Map<string, Map<number, {
        refcount: number;
        readonly value: Promise<RemoteTunnel>;
    }>>;
    protected _tunnelProvider: ITunnelProvider | undefined;
    constructor(logService: ILogService);
    setTunnelProvider(provider: ITunnelProvider | undefined): IDisposable;
    get tunnels(): Promise<readonly RemoteTunnel[]>;
    dispose(): void;
    openTunnel(addressProvider: IAddressProvider | undefined, remoteHost: string | undefined, remotePort: number, localPort: number): Promise<RemoteTunnel> | undefined;
    private makeTunnel;
    private tryDisposeTunnel;
    closeTunnel(remoteHost: string, remotePort: number): Promise<void>;
    protected addTunnelToMap(remoteHost: string, remotePort: number, tunnel: Promise<RemoteTunnel>): void;
    protected getTunnelFromMap(remoteHost: string, remotePort: number): {
        refcount: number;
        readonly value: Promise<RemoteTunnel>;
    } | undefined;
    protected abstract retainOrCreateTunnel(addressProvider: IAddressProvider, remoteHost: string, remotePort: number, localPort?: number): Promise<RemoteTunnel> | undefined;
    protected isPortPrivileged(port: number): boolean;
}
export declare class TunnelService extends AbstractTunnelService {
    protected retainOrCreateTunnel(_addressProvider: IAddressProvider, remoteHost: string, remotePort: number, localPort?: number | undefined): Promise<RemoteTunnel> | undefined;
}
