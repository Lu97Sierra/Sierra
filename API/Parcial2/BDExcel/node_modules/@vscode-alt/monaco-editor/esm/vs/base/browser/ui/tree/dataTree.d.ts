import { AbstractTree, IAbstractTreeOptions } from './abstractTree';
import { ITreeNode, ITreeModel, ITreeRenderer, ITreeSorter, IDataSource } from './tree';
import { ObjectTreeModel } from './objectTreeModel';
import { IListVirtualDelegate } from '../list/list';
import { IList } from './indexTreeModel';
export interface IDataTreeOptions<T, TFilterData = void> extends IAbstractTreeOptions<T, TFilterData> {
    readonly sorter?: ITreeSorter<T>;
}
export interface IDataTreeViewState {
    readonly focus: string[];
    readonly selection: string[];
    readonly expanded: string[];
    readonly scrollTop: number;
}
export declare class DataTree<TInput, T, TFilterData = void> extends AbstractTree<T | null, TFilterData, T | null> {
    private user;
    private dataSource;
    protected model: ObjectTreeModel<T, TFilterData>;
    private input;
    private identityProvider;
    private nodesByIdentity;
    constructor(user: string, container: HTMLElement, delegate: IListVirtualDelegate<T>, renderers: ITreeRenderer<T, TFilterData, any>[], dataSource: IDataSource<TInput, T>, options?: IDataTreeOptions<T, TFilterData>);
    getInput(): TInput | undefined;
    setInput(input: TInput, viewState?: IDataTreeViewState): void;
    updateChildren(element?: TInput | T): void;
    resort(element?: T | TInput, recursive?: boolean): void;
    refresh(element?: T): void;
    private _refresh;
    private iterate;
    protected createModel(user: string, view: IList<ITreeNode<T, TFilterData>>, options: IDataTreeOptions<T, TFilterData>): ITreeModel<T | null, TFilterData, T | null>;
    getViewState(): IDataTreeViewState;
}
