{"version":3,"file":"index.js","sources":["../../levels/lib/index.m.js","../src/util.js","../../console-raw-stream/lib/index.m.js","../src/logger.js","../../console-formatted-stream/lib/index.m.js","../../console-plain-stream/lib/index.m.js"],"sourcesContent":["var r=10,e=20,t=30,o=40,n=50,a=60,f={trace:10,debug:20,info:30,warn:40,error:50,fatal:60},c={};function i(r){return\"string\"==typeof r?f[r.toLowerCase()]:r}Object.keys(f).forEach(function(r){c[f[r]]=r});export{e as DEBUG,n as ERROR,a as FATAL,t as INFO,r as TRACE,o as WARN,f as levelFromName,c as nameFromLevel,i as resolveLevel};\n//# sourceMappingURL=index.m.js.map\n","export const CALL_STACK_ERROR = 'call-stack-error';\n\n/**\n * A shallow copy of an object. Bunyan logging attempts to never cause\n * exceptions, so this function attempts to handle non-objects gracefully.\n */\nexport function objCopy(obj) {\n    if (typeof  obj === 'undefined' || obj ===  null) {  // null or undefined\n        return obj;\n    } else if (Array.isArray(obj)) {\n        return obj.slice();\n    } else if (typeof (obj) === 'object') {\n        const copy = {};\n        Object.keys(obj).forEach(function (k) {\n            copy[k] = obj[k];\n        });\n        return copy;\n    } else {\n        return obj;\n    }\n}\n\n//---- These are simplified versions of util.format without importing the whole module, which would be bulky when browserified\n\nexport function inspect(obj) {\n    if(typeof obj === 'undefined') {\n        return 'undefined';\n    }\n    if(obj === null) {\n        return 'null';\n    }\n    if(Array.isArray(obj)) {\n        const items = obj.map(obj => inspect(obj));\n        return '[ ' + items.join(', ') + ' ]';\n    }\n    if(typeof obj === 'object') {\n        return JSON.stringify(obj);\n    }\n    if(typeof obj === 'function') {\n        return '[Function: ' + obj.name + ']';\n    }\n    if(typeof obj === 'boolean' || typeof obj === 'number') {\n        return obj;\n    }\n    return '\\'' + obj.toString() + '\\'';\n}\n\nexport function format(f) {\n    if (typeof f !== 'string') {\n        const objects = new Array(arguments.length);\n        for (let i = 0; i < arguments.length; i++) {\n            objects[i] = inspect(arguments[i]);\n        }\n        return objects.join(' ');\n    }\n\n    const formatRegExp = /%[sdj%]/g;\n\n    let i = 1;\n    const args = arguments;\n    const len = args.length;\n    let str = String(f).replace(formatRegExp, x => {\n        if (x === '%%') {\n            return '%';\n        }\n        if (i >= len) {\n            return x;\n        }\n        switch (x) {\n        case '%s': return String(args[i++]);\n        case '%d': return Number(args[i++]);\n        case '%j':\n            try {\n                return JSON.stringify(args[i++]);\n            } catch (_) {\n                return '[Circular]';\n            }\n        default:\n            return x;\n        }\n    });\n    for (let x = args[i]; i < len; x = args[++i]) {\n        if (x === null || typeof (x) !== 'object') {\n            str += ' ' + x;\n        } else {\n            str += ' ' + inspect(x);\n        }\n    }\n    return str;\n}\n\nexport function extractSrcFromStacktrace(stack, level) {\n    const stackLines = stack.split('\\n');\n\n    //chrome starts with error\n    if(stackLines[0] && stackLines[0].indexOf(CALL_STACK_ERROR) >= 0) {\n        stackLines.shift();\n    }\n\n    //the line of the stacktrace\n    const targetLine = stackLines[level];\n    let lineInfo = null;\n    if(targetLine) {\n        const execResult = /^\\s*(at|.*@)\\s*(.+)?$/.exec(targetLine);\n        if(Array.isArray(execResult) && execResult[2]) {\n            lineInfo = execResult[2];\n        } else {\n            lineInfo = targetLine;\n        }\n    }\n    return lineInfo;\n}\n\nexport function _indent(s, indent) {\n    if (!indent) {\n        indent = '    ';\n    }\n    const lines = s.split(/\\r?\\n/g);\n    return indent + lines.join('\\n' + indent);\n}\n\nconst _warned = {};\n\n/**\n * Warn about an bunyan processing error.\n *\n * @param msg {String} Message with which to warn.\n * @param dedupKey {String} Optional. A short string key for this warning to\n *      have its warning only printed once.\n */\nexport function _warn(msg, dedupKey) {\n    if (dedupKey) {\n        if (_warned[dedupKey]) {\n            return;\n        }\n        _warned[dedupKey] = true;\n    }\n    console.error(msg + '\\n');\n}\nexport function _haveWarned(dedupKey) {\n    return _warned[dedupKey];\n}\n\n// A JSON stringifier that handles cycles safely.\n// Usage: JSON.stringify(obj, safeCycles())\nexport function safeCycles() {\n    const seen = [];\n    return (key, val) => {\n        if (!val || typeof (val) !== 'object') {\n            return val;\n        }\n        if (seen.indexOf(val) !== -1) {\n            return '[Circular]';\n        }\n        seen.push(val);\n        return val;\n    };\n}","import{INFO as o,WARN as e,ERROR as r}from\"@browser-bunyan/levels\";var n=/*#__PURE__*/function(){function n(){}return n.prototype.write=function(n){n.level<o?console.log(n):n.level<e?console.info(n):n.level<r?console.warn(n):console.error(n),n.err&&n.err.stack&&console.error(n.err.stack),n.obj&&console.log(n.obj)},n}();export{n as ConsoleRawStream};\n//# sourceMappingURL=index.m.js.map\n","import { TRACE, DEBUG, INFO, WARN, ERROR, FATAL, nameFromLevel, resolveLevel} from '@browser-bunyan/levels';\nimport { format, _haveWarned, _warn, extractSrcFromStacktrace, _indent, objCopy, safeCycles, CALL_STACK_ERROR } from './util';\nimport { ConsoleRawStream } from '@browser-bunyan/console-raw-stream';\n\nconst LOG_VERSION = 1;\n\n//---- Logger class\n\n/**\n * Create a Logger instance.\n *\n * @param options {Object} See documentation for full details. At minimum\n *    this must include a 'name' string key. Configuration keys:\n *      - `streams`: specify the logger output streams. This is an array of\n *        objects with these fields:\n *          - `type`: The stream type. See README.md for full details.\n *            Often this is implied by the other fields. Examples are\n *            'file', 'stream' and \"raw\".\n *          - `level`: Defaults to 'info'.\n *          - `path` or `stream`: The specify the file path or writeable\n *            stream to which log records are written. E.g.\n *            `stream: process.stdout`.\n *        See README.md for full details.\n *      - `level`: set the level for a single output stream (cannot be used\n *        with `streams`)\n *      - `stream`: the output stream for a logger with just one, e.g.\n *        `process.stdout` (cannot be used with `streams`)\n *      - `serializers`: object mapping log record field names to\n *        serializing functions. See README.md for details.\n *      - `src`: Boolean (default false). Set true to enable 'src' automatic\n *        field with log call source info.\n *    All other keys are log record fields.\n *\n * An alternative *internal* call signature is used for creating a child:\n *    new Logger(<parent logger>, <child options>[, <child opts are simple>]);\n *\n * @param _childSimple (Boolean) An assertion that the given `_childOptions`\n *    (a) only add fields (no config) and (b) no serialization handling is\n *    required for them. IOW, this is a fast path for frequent child\n *    creation.\n */\nclass Logger {\n    constructor(options, _childOptions, _childSimple) {\n        if (!(this instanceof Logger)) {\n            return new Logger(options, _childOptions);\n        }\n\n        // Input arg validation.\n        let parent;\n        if (_childOptions !== undefined) {\n            parent = options;\n            options = _childOptions;\n            if (!(parent instanceof Logger)) {\n                throw new TypeError('invalid Logger creation: do not pass a second arg');\n            }\n        }\n        if (!options) {\n            throw new TypeError('options (object) is required');\n        }\n        if (!parent) {\n            if (!options.name) {\n                throw new TypeError('options.name (string) is required');\n            }\n        } else {\n            if (options.name) {\n                throw new TypeError('invalid options.name: child cannot set logger name');\n            }\n        }\n        if (options.stream && options.streams) {\n            throw new TypeError('cannot mix \"streams\" and \"stream\" options');\n        }\n        if (options.streams && !Array.isArray(options.streams)) {\n            throw new TypeError('invalid options.streams: must be an array');\n        }\n        if (options.serializers && (typeof (options.serializers) !== 'object' || Array.isArray(options.serializers))) {\n            throw new TypeError('invalid options.serializers: must be an object');\n        }\n\n        let fields, name, i;\n\n        // Fast path for simple child creation.\n        if (parent && _childSimple) {\n            this._level = parent._level;\n            this.streams = parent.streams;\n            this.serializers = parent.serializers;\n            this.src = parent.src;\n            fields = this.fields = {};\n            const parentFieldNames = Object.keys(parent.fields);\n            for (i = 0; i < parentFieldNames.length; i++) {\n                name = parentFieldNames[i];\n                fields[name] = parent.fields[name];\n            }\n            const names = Object.keys(options);\n            for (i = 0; i < names.length; i++) {\n                name = names[i];\n                fields[name] = options[name];\n            }\n            return;\n        }\n\n        // Null values.\n        if (parent) {\n            this._level = parent._level;\n            this.streams = [];\n            for (i = 0; i < parent.streams.length; i++) {\n                const s = objCopy(parent.streams[i]);\n                this.streams.push(s);\n            }\n            this.serializers = objCopy(parent.serializers);\n            this.src = parent.src;\n            this.fields = objCopy(parent.fields);\n            if (options.level) {\n                this.level(options.level);\n            }\n        } else {\n            this._level = Number.POSITIVE_INFINITY;\n            this.streams = [];\n            this.serializers = null;\n            this.src = false;\n            this.fields = {};\n        }\n\n        // Handle *config* options (i.e. options that are not just plain data\n        // for log records).\n        if (options.stream) {\n            this.addStream({\n                type: 'stream',\n                stream: options.stream,\n                level: options.level,\n            });\n        } else if (options.streams) {\n            options.streams.forEach(s => {\n                this.addStream(s, options.level);\n            });\n        } else if (parent && options.level) {\n            this.level(options.level);\n        } else if (!parent) {\n            /*\n             * In the browser we'll be emitting to console.log by default.\n             * Any console.log worth its salt these days can nicely render\n             * and introspect objects (e.g. the Firefox and Chrome console)\n             * so let's emit the raw log record. Are there browsers for which\n             * that breaks things?\n             */\n            this.addStream({\n                type: 'raw',\n                stream: new ConsoleRawStream(),\n                level: options.level,\n            });\n        }\n        if (options.serializers) {\n            this.addSerializers(options.serializers);\n        }\n        if (options.src) {\n            this.src = true;\n        }\n\n        // Fields.\n        // These are the default fields for log records (minus the attributes\n        // removed in this constructor). To allow storing raw log records\n        // (unrendered), `this.fields` must never be mutated. Create a copy for\n        // any changes.\n        fields = objCopy(options);\n        delete fields.stream;\n        delete fields.level;\n        delete fields.streams;\n        delete fields.serializers;\n        delete fields.src;\n        if (this.serializers) {\n            this._applySerializers(fields);\n        }\n        Object.keys(fields).forEach(k => {\n            this.fields[k] = fields[k];\n        });\n    }\n\n    /**\n     * Add a stream\n     *\n     * @param stream {Object}. Object with these fields:\n     *    - `type`: The stream type. See README.md for full details.\n     *      Often this is implied by the other fields. Examples are\n     *      'file', 'stream' and \"raw\".\n     *    - `path` or `stream`: The specify the file path or writeable\n     *      stream to which log records are written. E.g.\n     *      `stream: process.stdout`.\n     *    - `level`: Optional. Falls back to `defaultLevel`.\n     *    See README.md for full details.\n     * @param defaultLevel {Number|String} Optional. A level to use if\n     *      `stream.level` is not set. If neither is given, this defaults to INFO.\n     */\n    addStream(s, defaultLevel = INFO) {\n        s = objCopy(s);\n\n        //in browser bunyan, streams are always raw\n        s.type = 'raw';\n        s.level = resolveLevel(s.level || defaultLevel);\n\n        if (s.level < this._level) {\n            this._level = s.level;\n        }\n\n        this.streams.push(s);\n        delete this.haveNonRawStreams;  // reset\n    }\n\n    /**\n     * Add serializers\n     *\n     * @param serializers {Object} Optional. Object mapping log record field names\n     *    to serializing functions. See README.md for details.\n     */\n    addSerializers(serializers) {\n        if (!this.serializers) {\n            this.serializers = {};\n        }\n        Object.keys(serializers).forEach(field => {\n            const serializer = serializers[field];\n            if (typeof (serializer) !== 'function') {\n                throw new TypeError(format('invalid serializer for \"%s\" field: must be a function', field));\n            }\n            this.serializers[field] = serializer;\n        });\n    }\n\n    /**\n     * Create a child logger, typically to add a few log record fields.\n     *\n     * This can be useful when passing a logger to a sub-component, e.g. a\n     * 'wuzzle' component of your service:\n     *\n     *    const wuzzleLog = log.child({component: 'wuzzle'})\n     *    const wuzzle = new Wuzzle({..., log: wuzzleLog})\n     *\n     * Then log records from the wuzzle code will have the same structure as\n     * the app log, *plus the component='wuzzle' field*.\n     *\n     * @param options {Object} Optional. Set of options to apply to the child.\n     *    All of the same options for a new Logger apply here. Notes:\n     *      - The parent's streams are inherited and cannot be removed in this\n     *        call. Any given `streams` are *added* to the set inherited from\n     *        the parent.\n     *      - The parent's serializers are inherited, though can effectively be\n     *        overwritten by using duplicate keys.\n     *      - Can use `level` to set the level of the streams inherited from\n     *        the parent. The level for the parent is NOT affected.\n     * @param simple {Boolean} Optional. Set to true to assert that `options`\n     *    (a) only add fields (no config) and (b) no serialization handling is\n     *    required for them. IOW, this is a fast path for frequent child\n     *    creation. See 'tools/timechild.js' for numbers.\n     */\n    child(options, simple) {\n        return new (this.constructor)(this, options || {}, simple);\n    }\n\n    /**\n     * Get/set the level of all streams on this logger.\n     *\n     * Get Usage:\n     *    // Returns the current log level (lowest level of all its streams).\n     *    log.level() -> INFO\n     *\n     * Set Usage:\n     *    log.level(INFO)       // set all streams to level INFO\n     *    log.level('info')     // can use 'info' et al aliases\n     */\n    level(value) {\n        if (value === undefined) {\n            return this._level;\n        }\n        const newLevel = resolveLevel(value);\n        const len = this.streams.length;\n        for (let i = 0; i < len; i++) {\n            this.streams[i].level = newLevel;\n        }\n        this._level = newLevel;\n    }\n\n    /**\n     * Get/set the level of a particular stream on this logger.\n     *\n     * Get Usage:\n     *    // Returns an array of the levels of each stream.\n     *    log.levels() -> [TRACE, INFO]\n     *\n     *    // Returns a level of the identified stream.\n     *    log.levels(0) -> TRACE      // level of stream at index 0\n     *    log.levels('foo')           // level of stream with name 'foo'\n     *\n     * Set Usage:\n     *    log.levels(0, INFO)         // set level of stream 0 to INFO\n     *    log.levels(0, 'info')       // can use 'info' et al aliases\n     *    log.levels('foo', WARN)     // set stream named 'foo' to WARN\n     *\n     * Stream names: When streams are defined, they can optionally be given\n     * a name. For example,\n     *       log = new Logger({\n     *         streams: [\n     *           {\n     *             name: 'foo',\n     *             path: '/const/log/my-service/foo.log'\n     *             level: 'trace'\n     *           },\n     *         ...\n     *\n     * @param name {String|Number} The stream index or name.\n     * @param value {Number|String} The level value (INFO) or alias ('info').\n     *    If not given, this is a 'get' operation.\n     * @throws {Error} If there is no stream with the given name.\n     */\n    levels(name, value) {\n        if (name === undefined) {\n            return this.streams.map(s => s.level);\n        }\n        let stream;\n        if (typeof (name) === 'number') {\n            stream = this.streams[name];\n            if (stream === undefined) {\n                throw new Error('invalid stream index: ' + name);\n            }\n        } else {\n            const len = this.streams.length;\n            for (let i = 0; i < len; i++) {\n                const s = this.streams[i];\n                if (s.name === name) {\n                    stream = s;\n                    break;\n                }\n            }\n            if (!stream) {\n                throw new Error(format('no stream with name \"%s\"', name));\n            }\n        }\n        if (value === undefined) {\n            return stream.level;\n        } else {\n            const newLevel = resolveLevel(value);\n            stream.level = newLevel;\n            if (newLevel < this._level) {\n                this._level = newLevel;\n            }\n        }\n    }\n\n    /**\n     * Apply registered serializers to the appropriate keys in the given fields.\n     *\n     * Pre-condition: This is only called if there is at least one serializer.\n     *\n     * @param fields (Object) The log record fields.\n     * @param excludeFields (Object) Optional mapping of keys to `true` for\n     *    keys to NOT apply a serializer.\n     */\n    _applySerializers(fields, excludeFields) {\n        // Check each serializer against these (presuming number of serializers\n        // is typically less than number of fields).\n        Object.keys(this.serializers).forEach(name => {\n            if (fields[name] === undefined || (excludeFields && excludeFields[name])) {\n                return;\n            }\n            try {\n                fields[name] = this.serializers[name](fields[name]);\n            } catch (err) {\n                _warn(format('bunyan: ERROR: Exception thrown from the \"%s\" ' +\n                    'Bunyan serializer. This should never happen. This is a bug' +\n                    'in that serializer function.\\n%s',\n                name, err.stack || err));\n                fields[name] = format('(Error in Bunyan log \"%s\" serializer broke field. See stderr for details.)', name);\n            }\n        });\n    }\n\n    /**\n     * Emit a log record.\n     *\n     * @param rec {log record}\n     * @param noemit {Boolean} Optional. Set to true to skip emission\n     *      and just return the JSON string.\n     */\n    _emit(rec, noemit) {\n        let i;\n\n        // Lazily determine if this Logger has non-'raw' streams. If there are\n        // any, then we need to stringify the log record.\n        if (this.haveNonRawStreams === undefined) {\n            this.haveNonRawStreams = false;\n            for (i = 0; i < this.streams.length; i++) {\n                if (!this.streams[i].raw) {\n                    this.haveNonRawStreams = true;\n                    break;\n                }\n            }\n        }\n\n        // Stringify the object. Attempt to warn/recover on error.\n        let str;\n        if (noemit || this.haveNonRawStreams) {\n            try {\n                str = JSON.stringify(rec, safeCycles()) + '\\n';\n            } catch (e) {\n                const dedupKey = e.stack.split(/\\n/g, 2).join('\\n');\n                _warn('bunyan: ERROR: Exception in ' +\n                    '`JSON.stringify(rec)`. You can install the ' +\n                    '\"safe-json-stringify\" module to have Bunyan fallback ' +\n                    'to safer stringification. Record:\\n' +\n                    _indent(format('%s\\n%s', rec, e.stack)),\n                dedupKey);\n                str = format('(Exception in JSON.stringify(rec): %j. See stderr for details.)\\n', e.message);\n            }\n        }\n\n        if (noemit) {\n            return str;\n        }\n\n        const level = rec.level;\n        for (i = 0; i < this.streams.length; i++) {\n            const s = this.streams[i];\n            if (s.level <= level) {\n                s.stream.write(rec);\n            }\n        }\n\n        return str;\n    }\n}\n\n/**\n * Build a log emitter function for level minLevel. I.e. this is the\n * creator of `log.info`, `log.error`, etc.\n */\nfunction mkLogEmitter(minLevel) {\n    return function () {\n        const log = this;\n\n        function mkRecord(args) {\n            let excludeFields;\n            if (args[0] instanceof Error) {\n                // `log.<level>(err, ...)`\n                fields = {\n                    // Use this Logger's err serializer, if defined.\n                    err: (log.serializers && log.serializers.err ? log.serializers.err(args[0]) : stdSerializers.err(args[0])),\n                };\n                excludeFields = {err: true};\n                if (args.length === 1) {\n                    msgArgs = [fields.err.message];\n                } else {\n                    msgArgs = Array.prototype.slice.call(args, 1);\n                }\n            } else if (typeof (args[0]) !== 'object' && args[0] !== null || Array.isArray(args[0])) {\n                // `log.<level>(msg, ...)`\n                fields = null;\n                msgArgs = Array.prototype.slice.call(args);\n            } else {\n                // `log.<level>(fields, msg, ...)`\n                fields = args[0];\n                if (args.length === 1 && fields.err && fields.err instanceof Error) {\n                    msgArgs = [fields.err.message];\n                } else {\n                    msgArgs = Array.prototype.slice.call(args, 1);\n                }\n            }\n\n            // Build up the record object.\n            const rec = objCopy(log.fields);\n            rec.level = minLevel;\n            const recFields = (fields ? objCopy(fields) : null);\n            if (recFields) {\n                if (log.serializers) {\n                    log._applySerializers(recFields, excludeFields);\n                }\n                Object.keys(recFields).forEach(k => {\n                    rec[k] = recFields[k];\n                });\n            }\n            rec.levelName = nameFromLevel[minLevel];\n            rec.msg = msgArgs.length ? format.apply(log, msgArgs) : '';\n            if (!rec.time) {\n                rec.time = (new Date());\n            }\n            // Get call source info\n            if (log.src && !rec.src) {\n                try {\n                    //need to throw the error so there is a stack in IE\n                    throw new Error(CALL_STACK_ERROR);\n                } catch (err) {\n                    // in Safari there is missing stack trace sometimes\n                    const src = err.stack ? extractSrcFromStacktrace(err.stack, 2) : '';\n                    if (!src && !_haveWarned('src')) {\n                        _warn('Unable to determine src line info', 'src');\n                    }\n                    rec.src = src || '';\n                }\n            }\n            rec.v = LOG_VERSION;\n            return rec;\n        }\n\n        let fields = null;\n        let msgArgs = arguments;\n        let rec = null;\n        if (arguments.length === 0) {   // `log.<level>()`\n            return (this._level <= minLevel);\n        } else if (this._level > minLevel) {\n            /* pass through */\n        } else {\n            rec = mkRecord(msgArgs);\n            this._emit(rec);\n        }\n    };\n}\n\n/**\n * The functions below log a record at a specific level.\n *\n * Usages:\n *    log.<level>()  -> boolean is-trace-enabled\n *    log.<level>(<Error> err, [<string> msg, ...])\n *    log.<level>(<string> msg, ...)\n *    log.<level>(<object> fields, <string> msg, ...)\n *\n * where <level> is the lowercase version of the log level. E.g.:\n *\n *    log.info()\n *\n * @params fields {Object} Optional set of additional fields to log.\n * @params msg {String} Log message. This can be followed by additional\n *    arguments that are handled like\n *    [util.format](http://nodejs.org/docs/latest/api/all.html#util.format).\n */\nLogger.prototype.trace = mkLogEmitter(TRACE);\nLogger.prototype.debug = mkLogEmitter(DEBUG);\nLogger.prototype.info = mkLogEmitter(INFO);\nLogger.prototype.warn = mkLogEmitter(WARN);\nLogger.prototype.error = mkLogEmitter(ERROR);\nLogger.prototype.fatal = mkLogEmitter(FATAL);\n\n/*\n * This function dumps long stack traces for exceptions having a cause()\n * method. The error classes from\n * [verror](https://github.com/davepacheco/node-verror) and\n * [restify v2.0](https://github.com/mcavage/node-restify) are examples.\n *\n * Based on `dumpException` in\n * https://github.com/davepacheco/node-extsprintf/blob/master/lib/extsprintf.js\n */\nfunction getFullErrorStack(ex) {\n    let ret = ex.stack || ex.toString();\n    if (ex.cause && typeof (ex.cause) === 'function') {\n        const cex = ex.cause();\n        if (cex) {\n            ret += '\\nCaused by: ' + getFullErrorStack(cex);\n        }\n    }\n    return (ret);\n}\n\n//---- Standard serializers\n// A serializer is a function that serializes a JavaScript object to a\n// JSON representation for logging. There is a standard set of presumed\n// interesting objects in node.js-land.\nexport const stdSerializers = {\n    // Serialize an Error object\n    // (Core error properties are enumerable in node 0.4, not in 0.6).\n    err: function(err) {\n        if (!err || !err.stack) {\n            return err;\n        }\n\n        return {\n            message: err.message,\n            name: err.name,\n            stack: getFullErrorStack(err),\n            code: err.code,\n            signal: err.signal,\n        };\n    },\n};\n\nexport { Logger };\n\nexport function createLogger(...args) {\n    return new Logger(...args);\n}\n","import{TRACE as e,FATAL as s,nameFromLevel as l,DEBUG as o,INFO as r,WARN as t,ERROR as c}from\"@browser-bunyan/levels\";var i={levels:{trace:\"color: DeepPink\",debug:\"color: GoldenRod\",info:\"color: DarkTurquoise\",warn:\"color: Purple\",error:\"color: Crimson\",fatal:\"color: Black\"},def:\"color: DimGray\",msg:\"color: SteelBlue\",src:\"color: DimGray; font-style: italic; font-size: 0.9em\"},n=/*#__PURE__*/function(){function n(e){var s=void 0===e?{}:e,l=s.logByLevel,o=s.css,r=void 0===o?i:o;this.logByLevel=void 0!==l&&l,this.css=r}return n.prototype.write=function(i){var n,u,h=this.css.def,a=this.css.msg,p=this.css.src,v=i.childName?i.name+\"/\"+i.childName:i.name,g=l[i.level],f=(Array(6-g.length).join(\" \")+g).toUpperCase();this.logByLevel?(i.level===e?g=\"debug\":i.level===s&&(g=\"error\"),u=\"function\"==typeof console[g]?console[g]:console.log):u=console.log,n=i.level<o?this.css.levels.trace:i.level<r?this.css.levels.debug:i.level<t?this.css.levels.info:i.level<c?this.css.levels.warn:i.level<s?this.css.levels.error:this.css.levels.fatal;var m=function(e,s){return Array(s+1-(e+\"\").length).join(\"0\")+e},d=[];d.push(\"[%s:%s:%s:%s] %c%s%c: %s: %c%s \"+(i.src?\"%c%s\":\"\")),d.push(m(i.time.getHours(),2)),d.push(m(i.time.getMinutes(),2)),d.push(m(i.time.getSeconds(),2)),d.push(m(i.time.getMilliseconds(),4)),d.push(n),d.push(f),d.push(h),d.push(v),d.push(a),d.push(i.msg),i.src&&(d.push(p),d.push(i.src)),i.obj&&(d.push(\"\\n\"),d.push(i.obj)),i.err&&i.err.stack&&(d.push(\"\\n\"),d.push(i.err.stack)),u.apply(console,d)},n.getDefaultCss=function(){return i},n}();export{n as ConsoleFormattedStream};\n//# sourceMappingURL=index.m.js.map\n","import{TRACE as e,FATAL as o,nameFromLevel as l}from\"@browser-bunyan/levels\";var r=/*#__PURE__*/function(){function r(e){var o=(void 0===e?{}:e).logByLevel;this.logByLevel=void 0!==o&&o}return r.prototype.write=function(r){var n,t=r.childName?r.name+\"/\"+r.childName:r.name,c=l[r.level],i=(Array(6-c.length).join(\" \")+c).toUpperCase();this.logByLevel?(r.level===e?c=\"debug\":r.level===o&&(c=\"error\"),n=\"function\"==typeof console[c]?console[c]:console.log):n=console.log;var s=function(e,o){return Array(o+1-(e+\"\").length).join(\"0\")+e},a=\"[\"+s(r.time.getHours(),2)+\":\";a+=s(r.time.getMinutes(),2)+\":\",a+=s(r.time.getSeconds(),2)+\":\",a+=s(r.time.getMilliseconds(),4)+\"] \",a+=i+\": \",a+=t+\": \",a+=r.msg,r.src&&(a+=\" (\"+r.src+\")\"),n.call(console,a),r.err&&r.err.stack&&n.call(console,r.err.stack),r.obj&&n.call(console,r.obj)},r}();export{r as ConsolePlainStream};\n//# sourceMappingURL=index.m.js.map\n"],"names":["TRACE","levelFromName","trace","debug","info","warn","error","fatal","nameFromLevel","resolveLevel","nameOrNum","toLowerCase","objCopy","obj","Array","isArray","slice","copy","Object","keys","forEach","k","inspect","map","join","JSON","stringify","name","toString","format","f","objects","arguments","length","i","formatRegExp","args","len","str","String","replace","x","Number","_","extractSrcFromStacktrace","stack","level","stackLines","split","indexOf","shift","targetLine","lineInfo","execResult","exec","r","_warned","_warn","msg","dedupKey","console","_haveWarned","safeCycles","seen","key","val","push","ConsoleRawStream","write","rec","log","err","Logger","options","_childOptions","_childSimple","parent","fields","this","undefined","TypeError","stream","streams","serializers","_level","src","parentFieldNames","names","s","POSITIVE_INFINITY","addStream","type","_this","addSerializers","_applySerializers","defaultLevel","haveNonRawStreams","field","serializer","_this2","child","simple","constructor","value","newLevel","levels","Error","excludeFields","_this3","_emit","noemit","raw","e","indent","_indent","message","mkLogEmitter","minLevel","mkRecord","stdSerializers","msgArgs","prototype","call","recFields","levelName","apply","time","Date","v","getFullErrorStack","ex","ret","cause","cex","code","signal","DEFAULT_CSS","def","ConsoleFormattedStream","n","l","logByLevel","css","levelCss","consoleMethod","defaultCss","msgCss","srcCss","loggerName","childName","formattedLevelName","toUpperCase","padZeros","number","logArgs","getHours","getMinutes","getSeconds","getMilliseconds","getDefaultCss","ConsolePlainStream","o"],"mappings":"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"}