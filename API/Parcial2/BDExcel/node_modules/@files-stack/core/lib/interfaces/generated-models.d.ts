import { URI } from '@vscode-alt/monaco-editor/esm/vs/base/common/uri';
import { VSBuffer, VSBufferReadableStream } from "@vscode-alt/monaco-editor/esm/vs/base/common/buffer";
import * as ApolloReactCommon from '@apollo/react-common';
import { FileChangeType } from './files';
import { HotExitConfiguration } from './files';
import { SaveReason } from './textfiles';
import { FileContentStatus } from './textfiles';
import { FileType } from './files';
import { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';
import { MyContext } from './context';
export declare type RequireFields<T, K extends keyof T> = {
    [X in Exclude<keyof T, K>]?: T[X];
} & {
    [P in K]-?: NonNullable<T[P]>;
};
export declare type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
export declare type Maybe<T> = T | null;
/** All built-in and custom scalars, mapped to their actual values */
export declare type Scalars = {
    ID: string;
    String: string;
    Boolean: boolean;
    Int: number;
    Float: number;
    AnyObject: any;
    URI: URI;
    JSON: any;
    BigInt: any;
    VSBuffer: VSBuffer;
    JSONObject: any;
    VSBufferReadableStream: VSBufferReadableStream;
};
export declare type IAction = {
    __typename?: 'Action';
    id?: Maybe<Scalars['String']>;
    label?: Maybe<Scalars['String']>;
    tooltip?: Maybe<Scalars['String']>;
    class?: Maybe<Scalars['String']>;
    enabled?: Maybe<Scalars['Boolean']>;
    checked?: Maybe<Scalars['Boolean']>;
    radio?: Maybe<Scalars['Boolean']>;
    run?: Maybe<IActionRun>;
};
export declare type IAction_input = {
    id?: Maybe<Scalars['String']>;
    label?: Maybe<Scalars['String']>;
    tooltip?: Maybe<Scalars['String']>;
    class?: Maybe<Scalars['String']>;
    enabled?: Maybe<Scalars['Boolean']>;
    checked?: Maybe<Scalars['Boolean']>;
    radio?: Maybe<Scalars['Boolean']>;
    run?: Maybe<IActionRun_input>;
};
export declare type IActionItem = {
    __typename?: 'ActionItem';
    label?: Maybe<Scalars['String']>;
    description?: Maybe<Scalars['String']>;
};
export declare type IActionRun = {
    __typename?: 'ActionRun';
    type?: Maybe<IGraphqlCallType>;
    document?: Maybe<Scalars['AnyObject']>;
    variables?: Maybe<Scalars['AnyObject']>;
};
export declare type IActionRun_input = {
    type?: Maybe<IGraphqlCallType>;
    document?: Maybe<Scalars['AnyObject']>;
    variables?: Maybe<Scalars['AnyObject']>;
};
export declare type IActions = {
    __typename?: 'Actions';
    id?: Maybe<Scalars['String']>;
    command?: Maybe<Scalars['String']>;
    title?: Maybe<Scalars['String']>;
    category?: Maybe<Scalars['String']>;
    actionItem?: Maybe<IActionItem>;
};
export declare type IAddEntry_input = {
    id?: Maybe<Scalars['String']>;
    name?: Maybe<Scalars['String']>;
    alignment?: Maybe<Scalars['String']>;
    entry?: Maybe<IStatusbarEntry_input>;
    priority?: Maybe<Scalars['Int']>;
    container?: Maybe<Scalars['String']>;
    labelContainer?: Maybe<Scalars['String']>;
};
export declare type IAddFoldersRequest = {
    __typename?: 'AddFoldersRequest';
    foldersToAdd?: Maybe<Array<Maybe<Scalars['URI']>>>;
};
export declare type IAddGroupOptions_Input = {
    activate?: Maybe<Scalars['Boolean']>;
};
export declare type IAnchor = {
    __typename?: 'Anchor';
    x?: Maybe<Scalars['Int']>;
    y?: Maybe<Scalars['Int']>;
    height?: Maybe<Scalars['Int']>;
    width?: Maybe<Scalars['Int']>;
};
export declare type IAnchor_input = {
    x?: Maybe<Scalars['Int']>;
    y?: Maybe<Scalars['Int']>;
    height?: Maybe<Scalars['Int']>;
    width?: Maybe<Scalars['Int']>;
};
export declare type IAssets = {
    __typename?: 'Assets';
    Type?: Maybe<Scalars['String']>;
    Content?: Maybe<Scalars['String']>;
};
export declare type IAuthor = {
    __typename?: 'Author';
    name?: Maybe<Scalars['String']>;
};
export declare const enum IAutoSaveConfigurationType {
    off = "off",
    afterDelay = "afterDelay",
    onFocusChange = "onFocusChange",
    onWindowChange = "onWindowChange"
}
export declare type IBaseExtension = {
    __typename?: 'BaseExtension';
    type?: Maybe<IExtensionType>;
    identifier?: Maybe<IExtensionIdentifier>;
    /** @deprecated */
    galleryIdentifier?: Maybe<IExtensionIdentifier>;
    manifest?: Maybe<IExtensionManifest>;
    location?: Maybe<Scalars['URI']>;
};
/**
 * Type of input will help to determine what type of editor to be opened in.
 * Varaious Input have following common fields.
 */
export declare type IBaseResourceInput = {
    /** Optional options to use when opening the text input. */
    options?: Maybe<ITextEditorOptions_Input>;
    /** Label to show for the diff editor */
    label?: Maybe<Scalars['String']>;
    /** Description to show for the diff editor */
    description?: Maybe<Scalars['String']>;
    /**
     * Hint to indicate that this input should be treated as a file
     * that opens in an editor capable of showing file content.
     *
     * Without this hint, the editor service will make a guess by
     * looking at the scheme of the resource(s).
     */
    forceFile?: Maybe<Scalars['Boolean']>;
    /**
     * Hint to indicate that this input should be treated as a
     * untitled file
     *
     * Without this hint, the editor service will make a guess by
     * looking at the scheme of the resource(s).
     */
    forceUntitled?: Maybe<Scalars['Boolean']>;
};
export declare type IBundles = {
    __typename?: 'Bundles';
    server?: Maybe<Scalars['String']>;
    browser?: Maybe<Scalars['String']>;
};
export declare type IChangeRange = {
    __typename?: 'ChangeRange';
    startLineNumber?: Maybe<Scalars['Int']>;
    startColumn?: Maybe<Scalars['Int']>;
    endLineNumber?: Maybe<Scalars['Int']>;
    endColumn?: Maybe<Scalars['Int']>;
};
export declare type IChangeRange_Input = {
    startLineNumber?: Maybe<Scalars['Int']>;
    startColumn?: Maybe<Scalars['Int']>;
    endLineNumber?: Maybe<Scalars['Int']>;
    endColumn?: Maybe<Scalars['Int']>;
};
export declare type IChangesChangesChunk_Input = {
    range?: Maybe<IChangeRange_Input>;
    rangeLength?: Maybe<Scalars['Int']>;
    text?: Maybe<Scalars['String']>;
    part?: Maybe<Scalars['Int']>;
};
export declare type IChangesChunk = {
    __typename?: 'ChangesChunk';
    range?: Maybe<IChangeRange>;
    rangeLength?: Maybe<Scalars['Int']>;
    text?: Maybe<Scalars['String']>;
    rangeOffset?: Maybe<Scalars['Int']>;
    forceMoveMarkers?: Maybe<Scalars['Boolean']>;
};
export declare type IChangesChunk_Input = {
    range?: Maybe<IChangeRange_Input>;
    rangeLength?: Maybe<Scalars['Int']>;
    text?: Maybe<Scalars['String']>;
    rangeOffset?: Maybe<Scalars['Int']>;
    forceMoveMarkers?: Maybe<Scalars['Boolean']>;
};
export declare type ICheckboxOptions = {
    __typename?: 'CheckboxOptions';
    label?: Maybe<Scalars['String']>;
    checked?: Maybe<Scalars['Boolean']>;
};
export declare type ICheckboxOptions_input = {
    label?: Maybe<Scalars['String']>;
    checked?: Maybe<Scalars['Boolean']>;
};
export declare type IChunkOptions_Input = {
    piece?: Maybe<IChangesChangesChunk_Input>;
    chunksCount?: Maybe<Scalars['Int']>;
    chunkPosition?: Maybe<Scalars['Int']>;
};
export declare const enum ICloseDirection {
    LEFT = "LEFT",
    RIGHT = "RIGHT"
}
export declare type ICloseEditor_Input = {
    resource: Scalars['String'];
    editorId?: Maybe<Scalars['Int']>;
    name?: Maybe<Scalars['String']>;
};
export declare type ICloseEditorOptions_Input = {
    preserveFocus?: Maybe<Scalars['Boolean']>;
};
export declare type ICloseEditorsFilter = {
    __typename?: 'CloseEditorsFilter';
    direction?: Maybe<ICloseDirection>;
    except?: Maybe<IEditorInput>;
    savedOnly?: Maybe<Scalars['Boolean']>;
};
/** Extension of CloseEditorOptions_Input */
export declare type ICloseOptions_Input = {
    preserveFocus?: Maybe<Scalars['Boolean']>;
    closeEmptyGroups?: Maybe<Scalars['Boolean']>;
};
export declare type ICodeEditorViewState = {
    __typename?: 'CodeEditorViewState';
    cursorState?: Maybe<Scalars['JSON']>;
    viewState?: Maybe<Scalars['JSON']>;
    contributionsState?: Maybe<Scalars['JSON']>;
};
export declare type ICodeEditorViewState_Input = {
    cursorState?: Maybe<Scalars['JSON']>;
    viewState?: Maybe<Scalars['JSON']>;
    contributionsState?: Maybe<Scalars['JSON']>;
};
export declare const enum IcommentThread {
    editable = "editable"
}
export declare type IConfiguration = {
    __typename?: 'Configuration';
    defaultSetting?: Maybe<Array<Maybe<ISettingsGroup>>>;
    files?: Maybe<IFiles>;
    git?: Maybe<IGit>;
    languages?: Maybe<ILanguages>;
    output?: Maybe<IOutput>;
    search?: Maybe<ISearch>;
    terminal?: Maybe<ITerminal>;
    workspace?: Maybe<IWorkspacePreferenceWorkbench>;
};
export declare type IConfigurationData = {
    __typename?: 'ConfigurationData';
    defaults?: Maybe<IConfigurationModel>;
    user?: Maybe<IConfigurationModel>;
    workspace?: Maybe<IConfigurationModel>;
    folders?: Maybe<Array<Maybe<IFolderConfigurationModel>>>;
    isComplete?: Maybe<Scalars['Boolean']>;
};
export declare type IConfigurationExtensionInfo = {
    __typename?: 'ConfigurationExtensionInfo';
    id?: Maybe<Scalars['String']>;
};
export declare type IConfigurationModel = {
    __typename?: 'ConfigurationModel';
    contents?: Maybe<Scalars['AnyObject']>;
    keys?: Maybe<Array<Maybe<Scalars['String']>>>;
    overrides?: Maybe<Array<Maybe<IOverrides>>>;
};
export declare type IConfigurationOverrides = {
    __typename?: 'ConfigurationOverrides';
    resource?: Maybe<Scalars['URI']>;
    overrideIdentifier?: Maybe<Scalars['String']>;
};
export declare type IConfigurationOverrides_Input = {
    resource?: Maybe<Scalars['URI']>;
    overrideIdentifier?: Maybe<Scalars['String']>;
};
/**
 * A configuration settings can have one of the following possible scopes.
 * Configuration scopes determine when a settings is available to the user through the Settings editor and
 * whether the setting is applicable. If no scope is declared, the default is `window`.
 */
export declare const enum IConfigurationScope {
    /** Application specific configuration, which can be configured only in local user settings. */
    APPLICATION = "APPLICATION",
    /** Machine specific configuration, which can be configured only in local and remote user settings. */
    MACHINE = "MACHINE",
    /** Window specific configuration, which can be configured in the user or workspace settings. */
    WINDOW = "WINDOW",
    /** Resource specific configuration, which can be configured in the user, workspace or folder settings. */
    RESOURCE = "RESOURCE"
}
export declare const enum IConfigurationServiceAction {
    getConfigurationData = "getConfigurationData",
    reloadConfiguration = "reloadConfiguration",
    onDidChangeConfiguration = "onDidChangeConfiguration",
    updateValue = "updateValue"
}
export declare const enum IConfigurationTarget {
    /** Targets the user configuration file for writing. */
    USER = "USER",
    USER_LOCAL = "USER_LOCAL",
    USER_REMOTE = "USER_REMOTE",
    /** Targets the workspace configuration file for writing. This only works if a workspace is opened. */
    WORKSPACE = "WORKSPACE",
    /** Targets the folder configuration file for writing. This only works if a workspace is opened. */
    WORKSPACE_FOLDER = "WORKSPACE_FOLDER",
    DEFAULT = "DEFAULT",
    MEMORY = "MEMORY"
}
export declare type IContentChangedEvent = {
    __typename?: 'ContentChangedEvent';
    changes?: Maybe<Array<Maybe<IChangesChunk>>>;
    eol?: Maybe<Scalars['String']>;
    versionId?: Maybe<Scalars['Int']>;
    isUndoing?: Maybe<Scalars['Boolean']>;
    isRedoing?: Maybe<Scalars['Boolean']>;
    isFlush?: Maybe<Scalars['Boolean']>;
};
export declare type IContentChangedEvent_Input = {
    changes?: Maybe<Array<Maybe<IChangesChunk_Input>>>;
    eol?: Maybe<Scalars['String']>;
    versionId?: Maybe<Scalars['Int']>;
    isUndoing?: Maybe<Scalars['Boolean']>;
    isRedoing?: Maybe<Scalars['Boolean']>;
    isFlush?: Maybe<Scalars['Boolean']>;
};
export declare type IContext = {
    __typename?: 'Context';
    originalResourceScheme?: Maybe<IscmResourceGroups>;
    view?: Maybe<Scalars['String']>;
    viewItem?: Maybe<Scalars['String']>;
    gitOpenRepositoryCount?: Maybe<Scalars['Int']>;
    isInDiffEditor?: Maybe<Scalars['Boolean']>;
    isInDiffRightEditor?: Maybe<Scalars['Boolean']>;
    resourceScheme?: Maybe<Scalars['String']>;
    resourceFilename?: Maybe<Scalars['String']>;
    resourceLangId?: Maybe<Scalars['String']>;
    resource?: Maybe<Scalars['URI']>;
    resourceExtName?: Maybe<Scalars['String']>;
    resourceSet?: Maybe<Scalars['Boolean']>;
    isFileSystemResource?: Maybe<Scalars['Boolean']>;
    inputFocus?: Maybe<Scalars['Boolean']>;
    suggestWidgetVisible?: Maybe<Scalars['Boolean']>;
    suggestWidgetMultipleSuggestions?: Maybe<Scalars['Boolean']>;
    suggestionMakesTextEdit?: Maybe<Scalars['Boolean']>;
    acceptSuggestionOnEnter?: Maybe<Scalars['Boolean']>;
    hasOtherSuggestions?: Maybe<Scalars['Boolean']>;
    groupFocusedInOpenEditors?: Maybe<Scalars['Boolean']>;
    dirtyEditor?: Maybe<Scalars['Boolean']>;
    resourceSelectedForCompare?: Maybe<Scalars['Boolean']>;
    fileCopied?: Maybe<Scalars['Boolean']>;
    breadcrumbsPossible?: Maybe<Scalars['Boolean']>;
    breadcrumbsVisible?: Maybe<Scalars['Boolean']>;
    breadcrumbsActive?: Maybe<Scalars['Boolean']>;
    canNavigateBack?: Maybe<Scalars['Boolean']>;
    canNavigateForward?: Maybe<Scalars['Boolean']>;
    canNavigateToLastEditLocation?: Maybe<Scalars['Boolean']>;
    dirtyDiffVisible?: Maybe<Scalars['Boolean']>;
    cancellableOperation?: Maybe<Scalars['Boolean']>;
    parameterHintsVisible?: Maybe<Scalars['Boolean']>;
    parameterHintsMultipleSignatures?: Maybe<Scalars['Boolean']>;
    markdownPreviewFocus?: Maybe<Scalars['Boolean']>;
    isMac?: Maybe<Scalars['Boolean']>;
    isLinux?: Maybe<Scalars['Boolean']>;
    isWindows?: Maybe<Scalars['Boolean']>;
    remoteAuthority?: Maybe<Scalars['String']>;
    remoteConnectionState?: Maybe<IProvidedRemoteConnectionStates>;
    hasMacNativeTabs?: Maybe<Scalars['Boolean']>;
    supportsWorkspaces?: Maybe<Scalars['Boolean']>;
    isDevelopment?: Maybe<Scalars['Boolean']>;
    workbenchState?: Maybe<Scalars['String']>;
    workspaceFolderCount?: Maybe<Scalars['Int']>;
    remoteFileDialogVisible?: Maybe<Scalars['Boolean']>;
    isFullscreen?: Maybe<Scalars['Boolean']>;
    atEndOfWord?: Maybe<Scalars['Boolean']>;
    scmRepository?: Maybe<Scalars['String']>;
    scmProvider?: Maybe<Scalars['String']>;
    scmResourceGroup?: Maybe<IscmResourceGroups>;
    inDiffEditorKey?: Maybe<Scalars['Boolean']>;
    isDominatedByLongLines?: Maybe<Scalars['Boolean']>;
    isWordWrapMinified?: Maybe<Scalars['Boolean']>;
    commentThread?: Maybe<Scalars['String']>;
    commentThreadisEmpty?: Maybe<Scalars['Boolean']>;
    commentIsEmpty?: Maybe<Scalars['Boolean']>;
    commentEditorFocused?: Maybe<Scalars['Boolean']>;
    interfaceOverviewVisible?: Maybe<Scalars['Boolean']>;
    inReferenceSearchEditor?: Maybe<Scalars['Boolean']>;
    referenceSearchVisible?: Maybe<Scalars['Boolean']>;
    listFocus?: Maybe<Scalars['Boolean']>;
    listSupportsMultiSelect?: Maybe<Scalars['Boolean']>;
    listHasSelectionOrFocus?: Maybe<Scalars['Boolean']>;
    listDoubleSelection?: Maybe<Scalars['Boolean']>;
    listMultiSelection?: Maybe<Scalars['Boolean']>;
    listSupportsKeyboardNavigation?: Maybe<Scalars['Boolean']>;
    WorkbenchListAutomaticKeyboardNavigationKey?: Maybe<Scalars['Boolean']>;
    accessibilityHelpWidgetVisible?: Maybe<Scalars['Boolean']>;
    inQuickOpenKey?: Maybe<Scalars['Boolean']>;
    supportedCodeAction?: Maybe<Scalars['String']>;
    hasSymbols?: Maybe<Scalars['Boolean']>;
    hasSnippetCompletions?: Maybe<Scalars['Boolean']>;
    messageVisible?: Maybe<Scalars['Boolean']>;
    editorHasCallHierarchyProvider?: Maybe<Scalars['Boolean']>;
    callHierarchyVisible?: Maybe<Scalars['Boolean']>;
    searchViewletVisible?: Maybe<Scalars['Boolean']>;
    searchViewletFocus?: Maybe<Scalars['Boolean']>;
    inputBoxFocus?: Maybe<Scalars['Boolean']>;
    searchInputBoxFocus?: Maybe<Scalars['Boolean']>;
    replaceInputBoxFocus?: Maybe<Scalars['Boolean']>;
    patternIncludesInputBoxFocus?: Maybe<Scalars['Boolean']>;
    patternExcludesInputBoxFocus?: Maybe<Scalars['Boolean']>;
    replaceActive?: Maybe<Scalars['Boolean']>;
    hasSearchResult?: Maybe<Scalars['Boolean']>;
    firstMatchFocus?: Maybe<Scalars['Boolean']>;
    fileMatchOrMatchFocus?: Maybe<Scalars['Boolean']>;
    fileMatchOrFolderMatchFocus?: Maybe<Scalars['Boolean']>;
    fileMatchFocus?: Maybe<Scalars['Boolean']>;
    folderMatchFocus?: Maybe<Scalars['Boolean']>;
    matchFocus?: Maybe<Scalars['Boolean']>;
    inRecentFilesPicker?: Maybe<Scalars['Boolean']>;
    inWindowsPicker?: Maybe<Scalars['Boolean']>;
    findWidgetVisible?: Maybe<Scalars['Boolean']>;
    findInputFocussed?: Maybe<Scalars['Boolean']>;
    replaceInputFocussed?: Maybe<Scalars['Boolean']>;
    /** A context key that is set when the editor's text has focus (cursor is blinking). */
    editorTextFocus?: Maybe<Scalars['Boolean']>;
    /** A context key that is set when the editor's text or an editor's widget has focus. */
    editorFocus?: Maybe<Scalars['Boolean']>;
    /** A context key that is set when any editor input has focus (regular editor, repl input...). */
    textInputFocus?: Maybe<Scalars['Boolean']>;
    editorReadonly?: Maybe<Scalars['Boolean']>;
    editorHasSelection?: Maybe<Scalars['Boolean']>;
    editorHasMultipleSelections?: Maybe<Scalars['Boolean']>;
    editorTabMoveFocus?: Maybe<Scalars['Boolean']>;
    isInEmbeddedEditor?: Maybe<Scalars['Boolean']>;
    canUndo?: Maybe<Scalars['Boolean']>;
    canRedo?: Maybe<Scalars['Boolean']>;
    editorLangId?: Maybe<Scalars['String']>;
    editorHasCompletionItemProvider?: Maybe<Scalars['Boolean']>;
    editorHasCodeActionsProvider?: Maybe<Scalars['Boolean']>;
    editorHasDefinitionProvider?: Maybe<Scalars['Boolean']>;
    editorHasDeclarationProvider?: Maybe<Scalars['Boolean']>;
    editorHasImplementationProvider?: Maybe<Scalars['Boolean']>;
    editorHasTypeDefinitionProvider?: Maybe<Scalars['Boolean']>;
    editorHasHoverProvider?: Maybe<Scalars['Boolean']>;
    editorHadDocumentHighlightProvider?: Maybe<Scalars['Boolean']>;
    editorHasDocumentSymbolProvider?: Maybe<Scalars['Boolean']>;
    editorHasReferenceProvider?: Maybe<Scalars['Boolean']>;
    editorHasRenameProvider?: Maybe<Scalars['Boolean']>;
    editorHasSignatureHelpProvider?: Maybe<Scalars['Boolean']>;
    editorHasDocumentFormattingProvider?: Maybe<Scalars['Boolean']>;
    editorHasDocumentSelectionFormattingProvider?: Maybe<Scalars['Boolean']>;
    editorHasMultipleDocumentSelectionFormattingProvider?: Maybe<Scalars['Boolean']>;
    activeEditor?: Maybe<Scalars['String']>;
    editorIsOpen?: Maybe<Scalars['Boolean']>;
    editorPinned?: Maybe<Scalars['Boolean']>;
    groupActiveEditorDirty?: Maybe<Scalars['Boolean']>;
    groupEditorsCount?: Maybe<Scalars['Int']>;
    textCompareEditorVisible?: Maybe<Scalars['Boolean']>;
    textCompareEditorActive?: Maybe<Scalars['Boolean']>;
    activeEditorGroupEmpty?: Maybe<Scalars['Boolean']>;
    multipleEditorGroups?: Maybe<Scalars['Boolean']>;
    inZenMode?: Maybe<Scalars['Boolean']>;
    inCenteredLayout?: Maybe<Scalars['Boolean']>;
    splitEditorsVertically?: Maybe<Scalars['Boolean']>;
    sideBarVisible?: Maybe<Scalars['Boolean']>;
    sideBarFocus?: Maybe<Scalars['Boolean']>;
    activeViewlet?: Maybe<Scalars['String']>;
    activePanel?: Maybe<Scalars['String']>;
    panelFocus?: Maybe<Scalars['Boolean']>;
    panelPosition?: Maybe<Scalars['String']>;
    debugType?: Maybe<Scalars['String']>;
    debugConfigurationType?: Maybe<Scalars['String']>;
    debugState?: Maybe<Scalars['String']>;
    inDebugMode?: Maybe<Scalars['Boolean']>;
    inDebugRepl?: Maybe<Scalars['Boolean']>;
    breakpointWidgetVisible?: Maybe<Scalars['Boolean']>;
    watchExpressionsFocused?: Maybe<Scalars['Boolean']>;
    variablesFocused?: Maybe<Scalars['Boolean']>;
    expressionSelected?: Maybe<Scalars['Boolean']>;
    breakpointSelected?: Maybe<Scalars['Boolean']>;
    callStackItemType?: Maybe<Scalars['Boolean']>;
    loadedScriptsSupported?: Maybe<Scalars['Boolean']>;
    loadedScriptsItemType?: Maybe<Scalars['Boolean']>;
    focusedSessionIsAttach?: Maybe<Scalars['Boolean']>;
    stepBackSupported?: Maybe<Scalars['Boolean']>;
    restartFrameSupported?: Maybe<Scalars['Boolean']>;
    inSettingsEditor?: Maybe<Scalars['Boolean']>;
    inSettingsJSONEditor?: Maybe<Scalars['Boolean']>;
    inSettingsSearch?: Maybe<Scalars['Boolean']>;
    settingsTocRowFocus?: Maybe<Scalars['Boolean']>;
    inKeybindings?: Maybe<Scalars['Boolean']>;
    inKeybindingsSearch?: Maybe<Scalars['Boolean']>;
    keybindingFocus?: Maybe<Scalars['Boolean']>;
    explorerViewletVisible?: Maybe<Scalars['Boolean']>;
    explorerResourceIsFolder?: Maybe<Scalars['Boolean']>;
    explorerResourceReadonly?: Maybe<Scalars['Boolean']>;
    explorerResourceIsRoot?: Maybe<Scalars['Boolean']>;
    explorerResourceCut?: Maybe<Scalars['Boolean']>;
    explorerResourceMoveableToTrash?: Maybe<Scalars['Boolean']>;
    filesExplorerFocus?: Maybe<Scalars['Boolean']>;
    openEditorsVisible?: Maybe<Scalars['Boolean']>;
    openEditorsFocus?: Maybe<Scalars['Boolean']>;
    explorerViewletFocus?: Maybe<Scalars['Boolean']>;
    /** A context key that is set when there is at least one opened integrated terminal. */
    terminalIsOpen?: Maybe<Scalars['Boolean']>;
    /** A context key that is set when the integrated terminal has focus. */
    terminalFocus?: Maybe<Scalars['Boolean']>;
    /** A keybinding context key that is set when the integrated terminal has text selected. */
    terminalTextSelected?: Maybe<Scalars['Boolean']>;
    /** A context key that is set when the find widget in integrated terminal is visible. */
    terminalFindWidgetVisible?: Maybe<Scalars['Boolean']>;
    /** A context key that is set when the find widget find input in integrated terminal is focused. */
    terminalFindWidgetInputFocused?: Maybe<Scalars['Boolean']>;
    /** A context key that is set when the find widget in integrated terminal is focused. */
    terminalFindWidgetFocused?: Maybe<Scalars['Boolean']>;
    /** Set when the find widget in a webview is visible */
    webviewFindWidgetVisible?: Maybe<Scalars['Boolean']>;
    taskRunning?: Maybe<Scalars['Boolean']>;
    referenceSearchTreeFocused?: Maybe<Scalars['Boolean']>;
    interactivePlaygroundFocus?: Maybe<Scalars['Boolean']>;
    outlineFiltered?: Maybe<Scalars['Boolean']>;
    outlineFocused?: Maybe<Scalars['Boolean']>;
    problemsViewFocus?: Maybe<Scalars['Boolean']>;
    problemFocus?: Maybe<Scalars['Boolean']>;
    problemsFilterFocus?: Maybe<Scalars['Boolean']>;
    relatedInformationFocus?: Maybe<Scalars['Boolean']>;
    inOutput?: Maybe<Scalars['Boolean']>;
    activeLogOutput?: Maybe<Scalars['Boolean']>;
    multiCursorModifier?: Maybe<Scalars['String']>;
    saveConflictResolutionContext?: Maybe<Scalars['Boolean']>;
    markersNavigationVisible?: Maybe<Scalars['Boolean']>;
    hasWordHighlights?: Maybe<Scalars['Boolean']>;
    profileSessionState?: Maybe<Scalars['String']>;
    extensionHostProfileRecorded?: Maybe<Scalars['Boolean']>;
    historyNavigationEnabled?: Maybe<Scalars['Boolean']>;
    historyNavigationWidget?: Maybe<Scalars['Boolean']>;
    nonEmptyWorkspace?: Maybe<Scalars['Boolean']>;
    defaultExtensionViews?: Maybe<Scalars['Boolean']>;
    searchMarketplaceExtensions?: Maybe<Scalars['Boolean']>;
    searchInstalledExtensions?: Maybe<Scalars['Boolean']>;
    searchOutdatedExtensions?: Maybe<Scalars['Boolean']>;
    searchEnabledExtensions?: Maybe<Scalars['Boolean']>;
    searchDisabledExtensions?: Maybe<Scalars['Boolean']>;
    hasInstalledExtensions?: Maybe<Scalars['Boolean']>;
    searchBuiltInExtensions?: Maybe<Scalars['Boolean']>;
    recommendedExtensions?: Maybe<Scalars['Boolean']>;
    defaultRecommendedExtensions?: Maybe<Scalars['Boolean']>;
    workspaceRecommendations?: Maybe<Scalars['Boolean']>;
    workspaceFolderRecommendations?: Maybe<Scalars['Boolean']>;
    addToWorkspaceRecommendations?: Maybe<Scalars['Boolean']>;
    addToWorkspaceFolderRecommendations?: Maybe<Scalars['Boolean']>;
};
export declare type IContextInput = {
    folder?: Maybe<Scalars['String']>;
    originalResourceScheme?: Maybe<IscmResourceGroups>;
    view?: Maybe<Scalars['String']>;
    viewItem?: Maybe<Scalars['String']>;
    gitOpenRepositoryCount?: Maybe<Scalars['Int']>;
    isInDiffEditor?: Maybe<Scalars['Boolean']>;
    isInDiffRightEditor?: Maybe<Scalars['Boolean']>;
    resourceScheme?: Maybe<Scalars['String']>;
    resourceFilename?: Maybe<Scalars['String']>;
    resourceLangId?: Maybe<Scalars['String']>;
    resource?: Maybe<Scalars['URI']>;
    resourceExtName?: Maybe<Scalars['String']>;
    resourceSet?: Maybe<Scalars['Boolean']>;
    isFileSystemResource?: Maybe<Scalars['Boolean']>;
    inputFocus?: Maybe<Scalars['Boolean']>;
    suggestWidgetVisible?: Maybe<Scalars['Boolean']>;
    suggestWidgetMultipleSuggestions?: Maybe<Scalars['Boolean']>;
    suggestionMakesTextEdit?: Maybe<Scalars['Boolean']>;
    acceptSuggestionOnEnter?: Maybe<Scalars['Boolean']>;
    hasOtherSuggestions?: Maybe<Scalars['Boolean']>;
    groupFocusedInOpenEditors?: Maybe<Scalars['Boolean']>;
    dirtyEditor?: Maybe<Scalars['Boolean']>;
    resourceSelectedForCompare?: Maybe<Scalars['Boolean']>;
    fileCopied?: Maybe<Scalars['Boolean']>;
    breadcrumbsPossible?: Maybe<Scalars['Boolean']>;
    breadcrumbsVisible?: Maybe<Scalars['Boolean']>;
    breadcrumbsActive?: Maybe<Scalars['Boolean']>;
    canNavigateBack?: Maybe<Scalars['Boolean']>;
    canNavigateForward?: Maybe<Scalars['Boolean']>;
    canNavigateToLastEditLocation?: Maybe<Scalars['Boolean']>;
    dirtyDiffVisible?: Maybe<Scalars['Boolean']>;
    cancellableOperation?: Maybe<Scalars['Boolean']>;
    parameterHintsVisible?: Maybe<Scalars['Boolean']>;
    parameterHintsMultipleSignatures?: Maybe<Scalars['Boolean']>;
    markdownPreviewFocus?: Maybe<Scalars['Boolean']>;
    isMac?: Maybe<Scalars['Boolean']>;
    isLinux?: Maybe<Scalars['Boolean']>;
    isWindows?: Maybe<Scalars['Boolean']>;
    remoteAuthority?: Maybe<Scalars['String']>;
    remoteConnectionState?: Maybe<IProvidedRemoteConnectionStates>;
    hasMacNativeTabs?: Maybe<Scalars['Boolean']>;
    supportsWorkspaces?: Maybe<Scalars['Boolean']>;
    isDevelopment?: Maybe<Scalars['Boolean']>;
    workbenchState?: Maybe<Scalars['String']>;
    workspaceFolderCount?: Maybe<Scalars['Int']>;
    remoteFileDialogVisible?: Maybe<Scalars['Boolean']>;
    isFullscreen?: Maybe<Scalars['Boolean']>;
    atEndOfWord?: Maybe<Scalars['Boolean']>;
    scmRepository?: Maybe<Scalars['String']>;
    scmProvider?: Maybe<Scalars['String']>;
    scmResourceGroup?: Maybe<IscmResourceGroups>;
    inDiffEditorKey?: Maybe<Scalars['Boolean']>;
    isDominatedByLongLines?: Maybe<Scalars['Boolean']>;
    isWordWrapMinified?: Maybe<Scalars['Boolean']>;
    commentThread?: Maybe<Scalars['String']>;
    commentThreadisEmpty?: Maybe<Scalars['Boolean']>;
    commentIsEmpty?: Maybe<Scalars['Boolean']>;
    commentEditorFocused?: Maybe<Scalars['Boolean']>;
    interfaceOverviewVisible?: Maybe<Scalars['Boolean']>;
    inReferenceSearchEditor?: Maybe<Scalars['Boolean']>;
    referenceSearchVisible?: Maybe<Scalars['Boolean']>;
    listFocus?: Maybe<Scalars['Boolean']>;
    listSupportsMultiSelect?: Maybe<Scalars['Boolean']>;
    listHasSelectionOrFocus?: Maybe<Scalars['Boolean']>;
    listDoubleSelection?: Maybe<Scalars['Boolean']>;
    listMultiSelection?: Maybe<Scalars['Boolean']>;
    listSupportsKeyboardNavigation?: Maybe<Scalars['Boolean']>;
    WorkbenchListAutomaticKeyboardNavigationKey?: Maybe<Scalars['Boolean']>;
    accessibilityHelpWidgetVisible?: Maybe<Scalars['Boolean']>;
    inQuickOpenKey?: Maybe<Scalars['Boolean']>;
    supportedCodeAction?: Maybe<Scalars['String']>;
    renameInputVisible?: Maybe<Scalars['Boolean']>;
    hasSymbols?: Maybe<Scalars['Boolean']>;
    hasSnippetCompletions?: Maybe<Scalars['Boolean']>;
    messageVisible?: Maybe<Scalars['Boolean']>;
    editorHasCallHierarchyProvider?: Maybe<Scalars['Boolean']>;
    callHierarchyVisible?: Maybe<Scalars['Boolean']>;
    notificationCenterVisible?: Maybe<Scalars['Boolean']>;
    notificationToastsVisible?: Maybe<Scalars['Boolean']>;
    notificationFocus?: Maybe<Scalars['Boolean']>;
    searchViewletVisible?: Maybe<Scalars['Boolean']>;
    searchViewletFocus?: Maybe<Scalars['Boolean']>;
    inputBoxFocus?: Maybe<Scalars['Boolean']>;
    searchInputBoxFocus?: Maybe<Scalars['Boolean']>;
    replaceInputBoxFocus?: Maybe<Scalars['Boolean']>;
    patternIncludesInputBoxFocus?: Maybe<Scalars['Boolean']>;
    patternExcludesInputBoxFocus?: Maybe<Scalars['Boolean']>;
    replaceActive?: Maybe<Scalars['Boolean']>;
    hasSearchResult?: Maybe<Scalars['Boolean']>;
    firstMatchFocus?: Maybe<Scalars['Boolean']>;
    fileMatchOrMatchFocus?: Maybe<Scalars['Boolean']>;
    fileMatchOrFolderMatchFocus?: Maybe<Scalars['Boolean']>;
    fileMatchFocus?: Maybe<Scalars['Boolean']>;
    folderMatchFocus?: Maybe<Scalars['Boolean']>;
    matchFocus?: Maybe<Scalars['Boolean']>;
    inRecentFilesPicker?: Maybe<Scalars['Boolean']>;
    inWindowsPicker?: Maybe<Scalars['Boolean']>;
    findWidgetVisible?: Maybe<Scalars['Boolean']>;
    findInputFocussed?: Maybe<Scalars['Boolean']>;
    replaceInputFocussed?: Maybe<Scalars['Boolean']>;
    /** A context key that is set when the editor's text has focus (cursor is blinking). */
    editorTextFocus?: Maybe<Scalars['Boolean']>;
    /** A context key that is set when the editor's text or an editor's widget has focus. */
    editorFocus?: Maybe<Scalars['Boolean']>;
    /** A context key that is set when any editor input has focus (regular editor, repl input...). */
    textInputFocus?: Maybe<Scalars['Boolean']>;
    editorReadonly?: Maybe<Scalars['Boolean']>;
    editorHasSelection?: Maybe<Scalars['Boolean']>;
    editorHasMultipleSelections?: Maybe<Scalars['Boolean']>;
    editorTabMoveFocus?: Maybe<Scalars['Boolean']>;
    isInEmbeddedEditor?: Maybe<Scalars['Boolean']>;
    canUndo?: Maybe<Scalars['Boolean']>;
    canRedo?: Maybe<Scalars['Boolean']>;
    editorLangId?: Maybe<Scalars['String']>;
    editorHasCompletionItemProvider?: Maybe<Scalars['Boolean']>;
    editorHasCodeActionsProvider?: Maybe<Scalars['Boolean']>;
    editorHasDefinitionProvider?: Maybe<Scalars['Boolean']>;
    editorHasDeclarationProvider?: Maybe<Scalars['Boolean']>;
    editorHasImplementationProvider?: Maybe<Scalars['Boolean']>;
    editorHasTypeDefinitionProvider?: Maybe<Scalars['Boolean']>;
    editorHasHoverProvider?: Maybe<Scalars['Boolean']>;
    editorHadDocumentHighlightProvider?: Maybe<Scalars['Boolean']>;
    editorHasDocumentSymbolProvider?: Maybe<Scalars['Boolean']>;
    editorHasReferenceProvider?: Maybe<Scalars['Boolean']>;
    editorHasRenameProvider?: Maybe<Scalars['Boolean']>;
    editorHasSignatureHelpProvider?: Maybe<Scalars['Boolean']>;
    editorHasDocumentFormattingProvider?: Maybe<Scalars['Boolean']>;
    editorHasDocumentSelectionFormattingProvider?: Maybe<Scalars['Boolean']>;
    editorHasMultipleDocumentSelectionFormattingProvider?: Maybe<Scalars['Boolean']>;
    activeEditor?: Maybe<Scalars['String']>;
    editorIsOpen?: Maybe<Scalars['Boolean']>;
    editorPinned?: Maybe<Scalars['Boolean']>;
    groupActiveEditorDirty?: Maybe<Scalars['Boolean']>;
    groupEditorsCount?: Maybe<Scalars['Int']>;
    textCompareEditorVisible?: Maybe<Scalars['Boolean']>;
    textCompareEditorActive?: Maybe<Scalars['Boolean']>;
    activeEditorGroupEmpty?: Maybe<Scalars['Boolean']>;
    multipleEditorGroups?: Maybe<Scalars['Boolean']>;
    inZenMode?: Maybe<Scalars['Boolean']>;
    inCenteredLayout?: Maybe<Scalars['Boolean']>;
    splitEditorsVertically?: Maybe<Scalars['Boolean']>;
    sideBarVisible?: Maybe<Scalars['Boolean']>;
    sideBarFocus?: Maybe<Scalars['Boolean']>;
    activeViewlet?: Maybe<Scalars['String']>;
    activePanel?: Maybe<Scalars['String']>;
    panelFocus?: Maybe<Scalars['Boolean']>;
    panelPosition?: Maybe<Scalars['String']>;
    debugType?: Maybe<Scalars['String']>;
    debugConfigurationType?: Maybe<Scalars['String']>;
    debugState?: Maybe<Scalars['String']>;
    inDebugMode?: Maybe<Scalars['Boolean']>;
    inDebugRepl?: Maybe<Scalars['Boolean']>;
    breakpointWidgetVisible?: Maybe<Scalars['Boolean']>;
    watchExpressionsFocused?: Maybe<Scalars['Boolean']>;
    variablesFocused?: Maybe<Scalars['Boolean']>;
    expressionSelected?: Maybe<Scalars['Boolean']>;
    breakpointSelected?: Maybe<Scalars['Boolean']>;
    callStackItemType?: Maybe<Scalars['Boolean']>;
    loadedScriptsSupported?: Maybe<Scalars['Boolean']>;
    loadedScriptsItemType?: Maybe<Scalars['Boolean']>;
    focusedSessionIsAttach?: Maybe<Scalars['Boolean']>;
    stepBackSupported?: Maybe<Scalars['Boolean']>;
    restartFrameSupported?: Maybe<Scalars['Boolean']>;
    inSettingsEditor?: Maybe<Scalars['Boolean']>;
    inSettingsJSONEditor?: Maybe<Scalars['Boolean']>;
    inSettingsSearch?: Maybe<Scalars['Boolean']>;
    settingsTocRowFocus?: Maybe<Scalars['Boolean']>;
    inKeybindings?: Maybe<Scalars['Boolean']>;
    inKeybindingsSearch?: Maybe<Scalars['Boolean']>;
    keybindingFocus?: Maybe<Scalars['Boolean']>;
    explorerViewletVisible?: Maybe<Scalars['Boolean']>;
    explorerResourceIsFolder?: Maybe<Scalars['Boolean']>;
    explorerResourceReadonly?: Maybe<Scalars['Boolean']>;
    explorerResourceIsRoot?: Maybe<Scalars['Boolean']>;
    explorerResourceCut?: Maybe<Scalars['Boolean']>;
    explorerResourceMoveableToTrash?: Maybe<Scalars['Boolean']>;
    filesExplorerFocus?: Maybe<Scalars['Boolean']>;
    openEditorsVisible?: Maybe<Scalars['Boolean']>;
    openEditorsFocus?: Maybe<Scalars['Boolean']>;
    explorerViewletFocus?: Maybe<Scalars['Boolean']>;
    /** A context key that is set when there is at least one opened integrated terminal. */
    terminalIsOpen?: Maybe<Scalars['Boolean']>;
    /** A context key that is set when the integrated terminal has focus. */
    terminalFocus?: Maybe<Scalars['Boolean']>;
    /** A keybinding context key that is set when the integrated terminal has text selected. */
    terminalTextSelected?: Maybe<Scalars['Boolean']>;
    /** A context key that is set when the find widget in integrated terminal is visible. */
    terminalFindWidgetVisible?: Maybe<Scalars['Boolean']>;
    /** A context key that is set when the find widget find input in integrated terminal is focused. */
    terminalFindWidgetInputFocused?: Maybe<Scalars['Boolean']>;
    /** A context key that is set when the find widget in integrated terminal is focused. */
    terminalFindWidgetFocused?: Maybe<Scalars['Boolean']>;
    /** Set when the find widget in a webview is visible */
    webviewFindWidgetVisible?: Maybe<Scalars['Boolean']>;
    taskRunning?: Maybe<Scalars['Boolean']>;
    referenceSearchTreeFocused?: Maybe<Scalars['Boolean']>;
    interactivePlaygroundFocus?: Maybe<Scalars['Boolean']>;
    outlineFiltered?: Maybe<Scalars['Boolean']>;
    outlineFocused?: Maybe<Scalars['Boolean']>;
    problemsViewFocus?: Maybe<Scalars['Boolean']>;
    problemFocus?: Maybe<Scalars['Boolean']>;
    problemsFilterFocus?: Maybe<Scalars['Boolean']>;
    relatedInformationFocus?: Maybe<Scalars['Boolean']>;
    inOutput?: Maybe<Scalars['Boolean']>;
    activeLogOutput?: Maybe<Scalars['Boolean']>;
    multiCursorModifier?: Maybe<Scalars['String']>;
    saveConflictResolutionContext?: Maybe<Scalars['Boolean']>;
    markersNavigationVisible?: Maybe<Scalars['Boolean']>;
    hasWordHighlights?: Maybe<Scalars['Boolean']>;
    profileSessionState?: Maybe<Scalars['String']>;
    extensionHostProfileRecorded?: Maybe<Scalars['Boolean']>;
    historyNavigationEnabled?: Maybe<Scalars['Boolean']>;
    historyNavigationWidget?: Maybe<Scalars['Boolean']>;
    nonEmptyWorkspace?: Maybe<Scalars['Boolean']>;
    defaultExtensionViews?: Maybe<Scalars['Boolean']>;
    searchMarketplaceExtensions?: Maybe<Scalars['Boolean']>;
    searchInstalledExtensions?: Maybe<Scalars['Boolean']>;
    searchOutdatedExtensions?: Maybe<Scalars['Boolean']>;
    searchEnabledExtensions?: Maybe<Scalars['Boolean']>;
    searchDisabledExtensions?: Maybe<Scalars['Boolean']>;
    hasInstalledExtensions?: Maybe<Scalars['Boolean']>;
    searchBuiltInExtensions?: Maybe<Scalars['Boolean']>;
    recommendedExtensions?: Maybe<Scalars['Boolean']>;
    defaultRecommendedExtensions?: Maybe<Scalars['Boolean']>;
    workspaceRecommendations?: Maybe<Scalars['Boolean']>;
    workspaceFolderRecommendations?: Maybe<Scalars['Boolean']>;
    addToWorkspaceRecommendations?: Maybe<Scalars['Boolean']>;
    addToWorkspaceFolderRecommendations?: Maybe<Scalars['Boolean']>;
};
export declare type IContextMenu = {
    __typename?: 'ContextMenu';
    id?: Maybe<Scalars['String']>;
    isShow?: Maybe<Scalars['Boolean']>;
    anchor?: Maybe<IAnchor>;
    menuItems?: Maybe<Array<Maybe<IMenuItem>>>;
};
export declare type IContextMenu_input = {
    isShow?: Maybe<Scalars['Boolean']>;
    anchor?: Maybe<IAnchor_input>;
    menuItems?: Maybe<Array<Maybe<IMenuItem_input>>>;
};
/** @deprecated use IExtensionContributions */
export declare type IContributes = {
    __typename?: 'Contributes';
    menus?: Maybe<IMenus>;
    actions?: Maybe<Array<Maybe<IActions>>>;
};
export declare type ICopyEditorOptions_Input = {
    inactive?: Maybe<Scalars['Boolean']>;
    index?: Maybe<Scalars['Int']>;
    preserveFocus?: Maybe<Scalars['Boolean']>;
};
export declare type ICrashReporterStartOptions = {
    __typename?: 'CrashReporterStartOptions';
    companyName?: Maybe<Scalars['String']>;
    submitURL?: Maybe<Scalars['String']>;
    productName?: Maybe<Scalars['String']>;
    uploadToServer?: Maybe<Scalars['Boolean']>;
    ignoreSystemCrashHandler?: Maybe<Scalars['Boolean']>;
    extra?: Maybe<Scalars['AnyObject']>;
    crashesDirectory?: Maybe<Scalars['String']>;
};
export declare type ICreateFileOptions_Input = {
    /**
     * Overwrite the file to create if it already exists on disk. Otherwise
     * an error will be thrown (FILE_MODIFIED_SINCE).
     */
    overwrite?: Maybe<Scalars['Boolean']>;
};
export declare type ICursorState = {
    __typename?: 'CursorState';
    inSelectionMode?: Maybe<Scalars['Boolean']>;
    selectionStart?: Maybe<IPosition>;
    position?: Maybe<IPosition>;
};
export declare type ICursorState_Input = {
    inSelectionMode?: Maybe<Scalars['Boolean']>;
    selectionStart?: Maybe<IPositionInput>;
    position?: Maybe<IPositionInput>;
};
/**
 * An editor input to present data URIs in a binary editor. Data URIs have the form of:
 * data:[mime type];[meta data <key=value>;...];base64,[base64 encoded value]
 */
export declare type IDataUriEditorInput = IIEditorInput & IIEditorInputWithGroupFields & {
    __typename?: 'DataUriEditorInput';
    id?: Maybe<Scalars['String']>;
    resource?: Maybe<Scalars['String']>;
    typeId?: Maybe<IEDITOR_INPUT_ID>;
    description?: Maybe<Scalars['String']>;
    label?: Maybe<Scalars['String']>;
    fileReference?: Maybe<IFileStatWithMetadata>;
    preferredEditorId?: Maybe<Scalars['String']>;
    isSupportsSplitEditor?: Maybe<Scalars['Boolean']>;
    isActive?: Maybe<Scalars['Boolean']>;
    preview?: Maybe<Scalars['Boolean']>;
    isPinned?: Maybe<Scalars['Boolean']>;
    editorId?: Maybe<Scalars['Int']>;
    status?: Maybe<Scalars['String']>;
    closable?: Maybe<Scalars['Boolean']>;
    /** The mime of the binary resource if known. */
    mime?: Maybe<Scalars['String']>;
    /** The etag of the binary resource if known. */
    etag?: Maybe<Scalars['String']>;
    /** The size of the binary resource if known. */
    size?: Maybe<Scalars['Int']>;
};
export declare type IDebugger = {
    __typename?: 'Debugger';
    label?: Maybe<Scalars['String']>;
    type?: Maybe<Scalars['String']>;
    runtime?: Maybe<Scalars['String']>;
};
export declare type IDefaultPreferencesResponse = {
    __typename?: 'DefaultPreferencesResponse';
    preferences?: Maybe<Array<Maybe<IPreferencesType>>>;
};
export declare type IDefaultSettings = IISettingsSubject & {
    __typename?: 'DefaultSettings';
    /**  The ID.  */
    id?: Maybe<Scalars['ID']>;
    /**  The latest settings.  */
    latestSettings?: Maybe<ISettings>;
    /**  The URL to the settings.  */
    settingsURL: Scalars['URI'];
    /**  Whether the viewer can modify the subject's settings. */
    viewerCanAdminister: Scalars['Boolean'];
    /**
     * All settings for this subject, and the individual levels in the settings cascade (global > organization > user)
     * that were merged to produce the final merged settings.
     */
    settingsCascade: ISettingsCascade;
};
export declare type IDeleteFileOptions_Input = {
    useTrash?: Maybe<Scalars['Boolean']>;
    recursive?: Maybe<Scalars['Boolean']>;
};
export declare type IDetail = {
    __typename?: 'Detail';
    inputName?: Maybe<Scalars['String']>;
    inputType?: Maybe<IInputTypeDetail>;
    label?: Maybe<Scalars['String']>;
    placeholder?: Maybe<Scalars['String']>;
    defaultValue?: Maybe<Scalars['String']>;
    required?: Maybe<Scalars['Boolean']>;
};
export declare type IDetail_input = {
    inputName?: Maybe<Scalars['String']>;
    inputType?: Maybe<IInputTypeDetail_input>;
    label?: Maybe<Scalars['String']>;
    placeholder?: Maybe<Scalars['String']>;
    defaultValue?: Maybe<Scalars['String']>;
    required?: Maybe<Scalars['Boolean']>;
};
export declare type IDevToolsOptions = {
    __typename?: 'DevToolsOptions';
    mode?: Maybe<IDevToolsOptionsMode>;
};
export declare const enum IDevToolsOptionsMode {
    right = "right",
    botton = "botton",
    undocked = "undocked",
    detach = "detach"
}
export declare type IDialog = {
    __typename?: 'Dialog';
    dialogType?: Maybe<Scalars['String']>;
    detail?: Maybe<Array<Maybe<IDetail>>>;
    primaryButton?: Maybe<IPrimaryButtonAction>;
    secondaryButton?: Maybe<Scalars['String']>;
    checkbox?: Maybe<ICheckboxOptions>;
};
export declare type IDialog_input = {
    dialogType?: Maybe<Scalars['String']>;
    detail?: Maybe<Array<Maybe<IDetail_input>>>;
    primaryButton?: Maybe<IPrimaryButtonAction_input>;
    secondaryButton?: Maybe<Scalars['String']>;
    checkbox?: Maybe<ICheckboxOptions_input>;
};
export declare type IDialogResult = {
    __typename?: 'DialogResult';
    confirmed?: Maybe<Scalars['Boolean']>;
    checkboxChecked?: Maybe<Scalars['Boolean']>;
};
/**
 * The base editor input for the diff editor. It is made up of two editor inputs, the original version
 * and the modified version.
 */
export declare type IDiffEditorInput = IIEditorInput & IIEditorInputWithGroupFields & {
    __typename?: 'DiffEditorInput';
    id?: Maybe<Scalars['String']>;
    resource?: Maybe<Scalars['String']>;
    typeId?: Maybe<IEDITOR_INPUT_ID>;
    description?: Maybe<Scalars['String']>;
    label?: Maybe<Scalars['String']>;
    fileReference?: Maybe<IFileStatWithMetadata>;
    preferredEditorId?: Maybe<Scalars['String']>;
    isSupportsSplitEditor?: Maybe<Scalars['Boolean']>;
    isActive?: Maybe<Scalars['Boolean']>;
    preview?: Maybe<Scalars['Boolean']>;
    isPinned?: Maybe<Scalars['Boolean']>;
    editorId?: Maybe<Scalars['Int']>;
    status?: Maybe<Scalars['String']>;
    closable?: Maybe<Scalars['Boolean']>;
    originalInput?: Maybe<IEditorInput>;
    modifiedInput?: Maybe<IEditorInput>;
};
/** @deprecated Not sure whether it is needed. */
export declare type IDockLayout = {
    __typename?: 'DockLayout';
    id?: Maybe<Scalars['Int']>;
    size?: Maybe<Scalars['Int']>;
    activeId?: Maybe<Scalars['String']>;
    mode?: Maybe<IGroupOrientation>;
    children?: Maybe<Array<Maybe<IDockLayout>>>;
    tabs?: Maybe<Array<Maybe<IEditorInput>>>;
};
export declare type IEditKeybindingItem = {
    __typename?: 'EditKeybindingItem';
    command?: Maybe<Scalars['String']>;
    key?: Maybe<Scalars['String']>;
    when?: Maybe<Scalars['String']>;
    isDefault?: Maybe<Scalars['Boolean']>;
};
export declare const enum IEDITOR_ID {
    TEXT_RESOURCE_EDITOR = "TEXT_RESOURCE_EDITOR",
    TEXT_DIFF_EDITOR = "TEXT_DIFF_EDITOR",
    BINARY_DIFF_EDITOR = "BINARY_DIFF_EDITOR",
    SIDE_BY_SIDE_EDITOR = "SIDE_BY_SIDE_EDITOR"
}
export declare const enum IEDITOR_INPUT_ID {
    DATA_URI_EDITOR_INPUT = "DATA_URI_EDITOR_INPUT",
    DIFF_EDITOR_INPUT = "DIFF_EDITOR_INPUT",
    FILE_EDITOR_INPUT = "FILE_EDITOR_INPUT",
    KEYBINDINGS_EDITOR_INPUT = "KEYBINDINGS_EDITOR_INPUT",
    RESOURCE_EDITOR_INPUT = "RESOURCE_EDITOR_INPUT",
    SIDE_BY_SIDE_EDITOR_INPUT = "SIDE_BY_SIDE_EDITOR_INPUT",
    file = "file"
}
export declare const enum IEDITOR_INPUT_RESOURCE_TYPE_ID {
    /** If the resource is `file` */
    file = "file"
}
export declare const enum IEditorActionType {
    init = "init",
    add = "add",
    remove = "remove",
    removeAll = "removeAll",
    activateEditor = "activateEditor"
}
export declare type IEditorChildren = IEditorPart | IEditorGroup;
export declare type IEditorChildren_Input = {
    /**
     * A unique identifier of this group that remains identical even if the
     * group is moved to different locations.
     */
    id: Scalars['Int'];
    mode?: Maybe<IGroupOrientation>;
    children?: Maybe<Array<Maybe<IEditorChildren_Input>>>;
    /**
     * Size of the editor group.
     * Width when in `orientation.HORIZONTAL` and height when in `orientation.VERTICAL`
     */
    size?: Maybe<Scalars['Int']>;
    /** the id of current tab */
    activeId?: Maybe<Scalars['String']>;
    tabs?: Maybe<Array<Maybe<IEditorInput_Input>>>;
};
export declare type IEditorGroup = IIEditorGroup & {
    __typename?: 'EditorGroup';
    /** the id of current tab */
    activeId?: Maybe<Scalars['String']>;
    id: Scalars['Int'];
    /** Whether it is an active group. */
    isActive?: Maybe<Scalars['Boolean']>;
    label?: Maybe<Scalars['String']>;
    /**
     * Size of the editor group.
     * Width when in `orientation.HORIZONTAL` and height when in `orientation.VERTICAL`
     */
    size?: Maybe<Scalars['Int']>;
    /** All the Editors that are opened undered this group. */
    tabs?: Maybe<Array<Maybe<IEditorInput>>>;
};
export declare type IEditorGroupLayout = {
    __typename?: 'EditorGroupLayout';
    groups?: Maybe<Array<Maybe<IGroupLayoutArgument>>>;
    orientation?: Maybe<IGroupOrientation>;
};
export declare type IEditorIdentifier = {
    __typename?: 'EditorIdentifier';
    groupId?: Maybe<Scalars['Int']>;
    editor?: Maybe<IEditorInput>;
};
export declare type IEditorInput = IDataUriEditorInput | IDiffEditorInput | IFileEditorInput | IKeybindingEditorInput | IResourceEditorInput | ISideBySideEditorInput | IUntitledEditorInput;
export declare type IEditorInput_Input = {
    id?: Maybe<Scalars['String']>;
    resource: Scalars['String'];
    name?: Maybe<Scalars['String']>;
    label?: Maybe<Scalars['String']>;
    typeId?: Maybe<IEDITOR_INPUT_ID>;
};
export declare type IEditorLayout_Input = {
    /**
     * A unique identifier of this group that remains identical even if the
     * group is moved to different locations.
     */
    id: Scalars['Int'];
    mode?: Maybe<IGroupOrientation>;
    /**
     * Size of the editor group.
     * Width when in `orientation.HORIZONTAL` and height when in `orientation.VERTICAL`
     */
    size?: Maybe<Scalars['Int']>;
    children?: Maybe<Array<Maybe<IEditorChildren_Input>>>;
};
export declare type IEditorOpenOptions_Input = {
    editorOpenPositioning?: Maybe<IEditorOpenPositioning>;
    focusRecentEditorAfterClose?: Maybe<Scalars['Boolean']>;
    pinned?: Maybe<Scalars['Boolean']>;
    active?: Maybe<Scalars['Boolean']>;
    index?: Maybe<Scalars['Int']>;
};
export declare const enum IEditorOpenPositioning {
    LEFT = "LEFT",
    RIGHT = "RIGHT",
    FIRST = "FIRST",
    LAST = "LAST"
}
export declare type IEditorOptions_Input = {
    /**
     * Tells the editor to not receive keyboard focus when the editor is being opened. By default,
     * the editor will receive keyboard focus on open.
     */
    preserveFocus?: Maybe<Scalars['Boolean']>;
    /**
     * Tells the editor to reload the editor input in the editor even if it is identical to the one
     * already showing. By default, the editor will not reload the input if it is identical to the
     * one showing.
     */
    forceReload?: Maybe<Scalars['Boolean']>;
    /**
     * Will reveal the editor if it is already opened and visible in any of the opened editor groups. Note
     * that this option is just a hint that might be ignored if the user wants to open an editor explicitly
     * to the side of another one or into a specific editor group.
     */
    revealIfVisible?: Maybe<Scalars['Boolean']>;
    /**
     * Will reveal the editor if it is already opened (even when not visible) in any of the opened editor groups. Note
     * that this option is just a hint that might be ignored if the user wants to open an editor explicitly
     * to the side of another one or into a specific editor group.
     */
    revealIfOpened?: Maybe<Scalars['Boolean']>;
    /**
     * An editor that is pinned remains in the editor stack even when another editor is being opened.
     * An editor that is not pinned will always get replaced by another editor that is not pinned.
     */
    pinned?: Maybe<Scalars['Boolean']>;
    /** The index in the document stack where to insert the editor into when opening. */
    index?: Maybe<Scalars['Int']>;
    /**
     * An active editor that is opened will show its contents directly. Set to true to open an editor
     * in the background.
     */
    inactive?: Maybe<Scalars['Boolean']>;
    /**
     * Will not show an error in case opening the editor fails and thus allows to show a custom error
     * message as needed. By default, an error will be presented as notification if opening was not possible.
     */
    ignoreError?: Maybe<Scalars['Boolean']>;
};
/** Editor part is an extension with EditorGroup with Tabs */
export declare type IEditorPart = {
    __typename?: 'EditorPart';
    /**
     * A unique identifier of this group that remains identical even if the
     * group is moved to different locations.
     */
    id: Scalars['Int'];
    mode?: Maybe<IGroupOrientation>;
    /** @deprecated use `size` */
    height?: Maybe<Scalars['Int']>;
    /**
     * Size of the editor group.
     * Width when in `orientation.HORIZONTAL` and height when in `orientation.VERTICAL`
     */
    size?: Maybe<Scalars['Int']>;
    children?: Maybe<Array<Maybe<IEditorChildren>>>;
};
export declare type IEditorPartConfiguration_Input = {
    /**
     * @description Controls whether opened editor should show in tabs or not.
     * @default true
     */
    showTabs?: Maybe<Scalars['Boolean']>;
    /**
     * @description Controls whether a top border is drawn on modified (dirty) editor tabs or not.
     * @default false
     */
    highlightModifiedTabs?: Maybe<Scalars['Boolean']>;
    /**
     * @description Controls the position of the editor's tabs close buttons, or disables them when set to 'off'.
     * @default 'right'
     */
    tabCloseButton?: Maybe<ITabCloseButtonType>;
    /**
     * @description Controls the sizing of editor tabs.
     * @default 'fit'
     */
    tabSizing?: Maybe<ITabSizingType>;
    /**
     * @description Controls whether tabs are closed in most recently used order or from left to right.
     * @default true
     */
    focusRecentEditorAfterClose?: Maybe<Scalars['Boolean']>;
    /**
     * @description Controls whether opened editors should show with an icon or not.
     * This requires an icon theme to be enabled as well.
     * @default true
     */
    showIcons?: Maybe<Scalars['Boolean']>;
    /**
     * @description Controls whether opened editors show as preview. Preview editors are reused until they are pinned
     * (e.g. via double click or editing) and show up with an italic font style.
     * @default true
     */
    enablePreview?: Maybe<Scalars['Boolean']>;
    /**
     * @description Controls whether opened editors from Quick Open show as preview.
     * Preview editors are reused until they are pinned
     * (e.g. via double click or editing)
     * @default true
     */
    enablePreviewFromQuickOpen?: Maybe<Scalars['Boolean']>;
    /**
     * @description Controls whether editors showing a file that was opened during
     * the session should close automatically when getting
     * deleted or renamed by some other process. Disabling this will keep the editor
     * open on such an event. Note that deleting from within
     * the application will always close the editor and that dirty files will never close to preserve your data.
     * @default false
     */
    closeOnFileDelete?: Maybe<Scalars['Boolean']>;
    /**
     * @description Controls where editors open. Select `left` or `right` to open
     * editors to the left or right of the currently active one.
     * Select `first` or `last` to open editors independently from the currently active one.
     * @default 'right'
     */
    openPositioning?: Maybe<IOpenPositioningType>;
    /**
     * @description Controls the default direction of editors that are opened side by side (e.g. from the explorer). By default,
     * editors will open on the right hand side of the currently active one. If changed to `down`, the editors will open belwo
     * the currently active one.
     * @default 'right'
     */
    openSideBySideDirection?: Maybe<IOpenSideBySideDirection>;
    /**
     * @description Controls the behavior of empty editor groups when the last tab in
     * the group is closed. When enabeld, empty groups
     * will automatically close. When disabled, empty groups will remain part of the grid.
     * @default true
     */
    closeEmptyGroup?: Maybe<Scalars['Boolean']>;
    /**
     * @description Controls whether an editor is revealed in any of the visible
     * groups if opened. If disabled, an editor will prefer to
     * open in the currently active editor group. If enabled, an already opened
     * editor will be revealed instead of opened again in the
     * currently active editor group. Note that there are some cases where this
     * setting is ignored, e.g. when forcing an editor to open in a
     * specific group or to the side of the currently active group.
     * @default false
     */
    revealIfOpen?: Maybe<Scalars['Boolean']>;
    /**
     * @description: Navigate between open files using three-finger swipe horizontally.
     * @default: false
     */
    swipeToNavigate?: Maybe<Scalars['Boolean']>;
    /**
     * @description Controls the format of the label for an editor
     * @default: true
     */
    labelFormat?: Maybe<ILableFormatType>;
    /**
     * @description Restores the last view state (e.g. scroll position) when re-opening files after they have been closed.
     * @default: true
     */
    restoreViewState?: Maybe<Scalars['Boolean']>;
};
/** Extends EditorPartConfiguration */
export declare type IEditorPartOptions_Input = {
    __typename?: 'EditorPartOptions_Input';
    showTabs?: Maybe<Scalars['Boolean']>;
    highlightModifiedTabs?: Maybe<Scalars['Boolean']>;
    tabCloseButton?: Maybe<ITabCloseButtonType>;
    tabSizing?: Maybe<ITabSizingType>;
    focusRecentEditorAfterClose?: Maybe<Scalars['Boolean']>;
    showIcons?: Maybe<Scalars['Boolean']>;
    enablePreview?: Maybe<Scalars['Boolean']>;
    enablePreviewFromQuickOpen?: Maybe<Scalars['Boolean']>;
    closeOnFileDelete?: Maybe<Scalars['Boolean']>;
    openPositioning?: Maybe<IOpenPositioningType>;
    openSideBySideDirection?: Maybe<IOpenSideBySideDirection>;
    closeEmptyGroup?: Maybe<Scalars['Boolean']>;
    revealIfOpen?: Maybe<Scalars['Boolean']>;
    swipeToNavigate?: Maybe<Scalars['Boolean']>;
    labelFormat?: Maybe<ILableFormatType>;
    restoreViewState?: Maybe<Scalars['Boolean']>;
    iconTheme?: Maybe<Scalars['String']>;
};
export declare type IEditorSettings = {
    __typename?: 'EditorSettings';
    editorOpenPositioning?: Maybe<IEditorOpenPositioning>;
    focusRecentEditorAfterClose?: Maybe<Scalars['Boolean']>;
};
export declare const enum IEditorsOrder {
    /** Editors sorted by most recent activity (most recent active first) */
    MOST_RECENTLY_ACTIVE = "MOST_RECENTLY_ACTIVE",
    /** Editors sorted by sequential order */
    SEQUENTIAL = "SEQUENTIAL"
}
export declare type IEncodingStatus = IIStatusbarItem & {
    __typename?: 'EncodingStatus';
    id?: Maybe<Scalars['String']>;
    name?: Maybe<Scalars['String']>;
    alignment?: Maybe<IStatusbarAlignment>;
    entry?: Maybe<IStatusbarEntry>;
    priority?: Maybe<Scalars['Int']>;
    container?: Maybe<Scalars['String']>;
    labelContainer?: Maybe<Scalars['String']>;
    typeId?: Maybe<ISTATUSBAR_ITEM_ID>;
};
export declare type IEndOfLineSequence = IIStatusbarItem & {
    __typename?: 'EndOfLineSequence';
    id?: Maybe<Scalars['String']>;
    name?: Maybe<Scalars['String']>;
    alignment?: Maybe<IStatusbarAlignment>;
    entry?: Maybe<IStatusbarEntry>;
    priority?: Maybe<Scalars['Int']>;
    container?: Maybe<Scalars['String']>;
    labelContainer?: Maybe<Scalars['String']>;
    typeId?: Maybe<ISTATUSBAR_ITEM_ID>;
};
export declare type IEngines = {
    __typename?: 'Engines';
    node?: Maybe<Scalars['String']>;
    vscode?: Maybe<Scalars['String']>;
};
export declare type IEnterWorkspaceResult = {
    __typename?: 'EnterWorkspaceResult';
    workspace: IWorkspaceIdentifier;
    backupPath?: Maybe<Scalars['String']>;
};
export declare type IEnvironment = {
    __typename?: 'Environment';
    args?: Maybe<Scalars['AnyObject']>;
    execPath?: Maybe<Scalars['String']>;
    cliPath?: Maybe<Scalars['String']>;
    appRoot?: Maybe<Scalars['String']>;
    userHome?: Maybe<Scalars['String']>;
    userDataPath?: Maybe<Scalars['String']>;
    appNameLong?: Maybe<Scalars['String']>;
    appQuality?: Maybe<Scalars['String']>;
    appSettingsHome?: Maybe<Scalars['String']>;
    appSettingsPath?: Maybe<Scalars['String']>;
    appKeybindingsPath?: Maybe<Scalars['String']>;
    settingsSearchBuildId?: Maybe<Scalars['Int']>;
    settingsSearchUrl?: Maybe<Scalars['String']>;
    globalStorageHome?: Maybe<Scalars['String']>;
    workspaceStorageHome?: Maybe<Scalars['String']>;
    backupHome?: Maybe<Scalars['String']>;
    backupWorkspacesPath?: Maybe<Scalars['String']>;
    untitledWorkspacesHome?: Maybe<Scalars['URI']>;
    workspacesHome?: Maybe<Scalars['String']>;
    /** Specific to cdecode, workspaces project */
    workspacesProjectPath?: Maybe<Scalars['String']>;
    /** Specific to cdecode, workspace settings */
    workspaceSettingsPath?: Maybe<Scalars['String']>;
    isExtensionDevelopment?: Maybe<Scalars['Boolean']>;
    disableExtensions?: Maybe<Scalars['AnyObject']>;
    builtinExtensionsPath?: Maybe<Scalars['String']>;
    extensionsPath?: Maybe<Scalars['String']>;
    /**  This seems to be single URI as array was failing  */
    extensionDevelopmentLocationURI?: Maybe<Array<Maybe<Scalars['URI']>>>;
    extensionTestsPath?: Maybe<Scalars['String']>;
    debugExtensionHost?: Maybe<IExtensionHostDebugParams>;
    debugSearch?: Maybe<IIDebugParams>;
    logExtensionHostCommunication?: Maybe<Scalars['Boolean']>;
    isBuilt?: Maybe<Scalars['Boolean']>;
    wait?: Maybe<Scalars['Boolean']>;
    status?: Maybe<Scalars['Boolean']>;
    performance?: Maybe<Scalars['Boolean']>;
    log?: Maybe<Scalars['String']>;
    logsPath?: Maybe<Scalars['String']>;
    verbose?: Maybe<Scalars['Boolean']>;
    logLevel?: Maybe<Scalars['String']>;
    skipGettingStarted?: Maybe<Scalars['Boolean']>;
    skipReleaseNotes?: Maybe<Scalars['Boolean']>;
    skipAddToRecentlyOpened?: Maybe<Scalars['Boolean']>;
    nodeCachedDataDir?: Maybe<Scalars['String']>;
    installSourcePath?: Maybe<Scalars['String']>;
    disableUpdates?: Maybe<Scalars['Boolean']>;
    disableCrashReporter?: Maybe<Scalars['Boolean']>;
    driverHandle?: Maybe<Scalars['String']>;
    driverVerbose?: Maybe<Scalars['Boolean']>;
    keyboardLayoutResource?: Maybe<Scalars['URI']>;
    keybindingsResource?: Maybe<Scalars['URI']>;
};
export declare const enum IEnvironmentServiceAction {
    environment = "environment"
}
export declare type IExtensionColor = {
    __typename?: 'ExtensionColor';
    id?: Maybe<Scalars['ID']>;
    description?: Maybe<Scalars['String']>;
    defaults?: Maybe<IExtensionColorTypes>;
};
export declare type IExtensionColorTypes = {
    __typename?: 'ExtensionColorTypes';
    light?: Maybe<Scalars['String']>;
    dark?: Maybe<Scalars['String']>;
    highContrast?: Maybe<Scalars['String']>;
};
export declare type IExtensionConfiguration = {
    __typename?: 'ExtensionConfiguration';
    properties?: Maybe<Scalars['JSON']>;
};
export declare type IExtensionConfigurationProperty = {
    __typename?: 'ExtensionConfigurationProperty';
    description?: Maybe<Scalars['String']>;
    type?: Maybe<Array<Maybe<Scalars['String']>>>;
    defaults?: Maybe<Scalars['JSON']>;
};
export declare type IExtensionContributions = {
    __typename?: 'ExtensionContributions';
    /** @deprecated use commands */
    actions?: Maybe<Array<Maybe<IActions>>>;
    /**
     * @title contributes.commands
     * @description Contribute the UI for a command consisting of a title and (optionally) an icon, category,
     * and enabled state. Enablement is expressed with `when` clauses. By default, commands show in the
     * Command Pallette but they can also show in other menus.
     *
     * Presentation of contributed commands depends on the containing menu. The Command Pallette, for instance, prefixes
     * commands with their `category`, allowing for easy grouping. However, the Command Pallette doesn't show icons nor disabled
     * commands. The editor context menu, on the other hand, show disabled items but doesn't show the category label.
     *
     * Note: When a command is invoked (from a key binding, from the Command Palette,
     * any other menu, or programmatically), VS Code will emit an activationEvent
     * onCommand:${command}.
     *
     * @example
     * ```
     *    "contributes": {
     *        "commands": [{
     *            "command": "extension.sayHello",
     *            "title": "Hello World",
     *            "category": "Hello"
     *        }]
     *    }
     * ```
     */
    commands?: Maybe<Array<Maybe<IActions>>>;
    /**
     * @title contributes.configuration
     * @description Contribute configuration keys that will be exposed to the user.
     * The user will be able to set these configuration options either from User
     * Settings or from the Workspace Settings.
     * When contributing configuration keys, a JSON schema describing these keys is
     * actually contributed. This ensures the user gets great tooling support when
     * authoring VS Code settings files.
     * You can read these values from your extension using vscode.workspace.getConfiguration('myExtension').
     *
     * Note: If you use markdownDescription instead of description, your setting
     * description will be rendered as Markdown in the settings UI.
     *
     * @example
     * ```
     * "contributes": {
     *     "configuration": {
     *         "type": "object",
     *         "title": "TypeScript configuration",
     *         "properties": {
     *             "typescript.useCodeSnippetsOnMethodSuggest": {
     *                 "type": "boolean",
     *                 "default": false,
     *                 "description": "Complete functions with their parameter signature."
     *             },
     *             "typescript.tsdk": {
     *                 "type": ["string", "null"],
     *                 "default": null,
     *                 "description": "Specifies the folder path containing the tsserver and lib*.d.ts files to use."
     *             }
     *         }
     *     }
     * }
     * ```
     */
    configuration?: Maybe<Array<Maybe<IExtensionConfiguration>>>;
    debuggers?: Maybe<Array<Maybe<IDebugger>>>;
    /**
     *      @title contributes.grammars
     *      @description Contribute a TextMate grammar to a language. You must provide
     * the language this grammar applies to, the TextMate scopeName for the grammar
     * and the file path.
     *
     *      Note: The file containing the grammar can be in JSON (filenames ending in
     * .json) or in XML plist format (all other files).
     *
     *      @example
     *         ```json
     *         "contributes": {
     *             "grammars": [{
     *                 "language": "markdown",
     *                 "scopeName": "text.html.markdown",
     *                 "path": "./syntaxes/markdown.tmLanguage.json",
     *                 "embeddedLanguages": {
     *                     "meta.embedded.block.frontmatter": "yaml",
     *                     ...
     *                 }
     *             }]
     *         }
     * ```
     */
    grammars?: Maybe<Array<Maybe<IGrammar>>>;
    /**
     * @title contributes.jsonValidation
     * @description Contribute a validation schema for a specific type of json file.
     * The url value can be either a local path to a schema file included in the
     * extension or a remote server URL such as a json schema store.
     *
     * @example
     *    "contributes": {
     *        "jsonValidation": [{
     *            "fileMatch": ".jshintrc",
     *            "url": "http://json.schemastore.org/jshintrc"
     *        }]
     *    }
     */
    jsonValidation?: Maybe<Array<Maybe<IExtensionJSONValidation>>>;
    /**
     * @title contributes.keybindings
     * @description Contribute a key binding rule defining what command should be
     * invoked when the user presses a key combination. See the Key Bindings topic
     * where key bindings are explained in detail.
     *
     * Contributing a key binding will cause the Default Keyboard Shortcuts to
     * display your rule, and every UI representation of the command will now show
     * the key binding you have added. And, of course, when the user presses the key
     * combination the command will be invoked.
     *
     * Note: Because VS Code runs on Windows, macOS and Linux, where modifiers
     * differ, you can use "key" to set the default key combination and overwrite it
     * with a specific platform.
     *
     * Note: When a command is invoked (from a key binding or from the Command
     * Palette), VS Code will emit an activationEvent onCommand:${command}.
     *
     * @example
     * Defining that Ctrl+F1 under Windows and Linux and Cmd+F1 under macOS trigger the "extension.sayHello" command:
     *
     * ```json
     * "contributes": {
     *     "keybindings": [{
     *         "command": "extension.sayHello",
     *         "key": "ctrl+f1",
     *         "mac": "cmd+f1",
     *         "when": "editorTextFocus"
     *     }]
     * }
     * ```
     */
    keybindings?: Maybe<Array<Maybe<IKeyBinding>>>;
    /**
     * @title contributes.languages
     * @description Contribute definition of a language. This will introduce a new
     * language or enrich the knowledge VS Code has about a language.
     *
     * The main effects of contributes.languages are:
     *
     * Define a languageId that can be reused in other parts of VS Code API, such as
     * vscode.TextDocument.getLanguageId() and the onLanguage Activation Events.
     * You can contribute a human-readable using the aliases field. The first item in
     * the list will be used as the human-readable label.
     * Associate file name extensions, file name patterns, files that begin with a
     * specific line (such as hashbang), mimetypes to that languageId.
     * Contribute a set of Declarative Language Features for the contributed
     * language. Learn more about the configurable editing features in the Language
     * Configuration Guide.
     *
     * @example
     * ```
     *    "contributes": {
     *        "languages": [{
     *            "id": "python",
     *            "extensions": [ ".py" ],
     *            "aliases": [ "Python", "py" ],
     *            "filenames": [ ... ],
     *            "firstLine": "^#!/.*\\bpython[0-9.-]*\\b",
     *            "configuration": "./language-configuration.json"
     *        }]
     *    }
     * ```
     */
    languages?: Maybe<Array<Maybe<IExtensionLanguage>>>;
    /**
     * @title contributes.menus
     * @description Contribute a menu item for a command to the editor or Explorer.
     * The menu item definition contains the command that should be invoked when
     * selected and the condition under which the item should show. The latter is
     * defined with the when clause, which uses the key bindings when clause contexts.
     *
     * In addition to the mandatory command property, an alternative command can be
     * defined using the alt-property. It will be shown and invoked when pressing Alt
     * while opening a menu.
     *
     * Last, a group property defines sorting and grouping of menu items. The
     * navigation group is special as it will always be sorted to the top/beginning of a menu.
     *
     * Note that when clauses apply to menus and enablement clauses to commands. The
     * enablement applies to all menus and even keybindings while the when only
     * applies to a single menu.
     *
     * Currently extension writers can contribute to:
     *
     * The global Command Palette - commandPalette
     * The Explorer context menu - explorer/context
     * The editor context menu - editor/context
     * The editor title menu bar - editor/title
     * The editor title context menu - editor/title/context
     * The debug callstack view context menu - debug/callstack/context
     * The debug toolbar - debug/toolbar
     * The SCM title menu - scm/title
     * SCM resource groups menus - scm/resourceGroup/context
     * SCM resources menus - scm/resource/context
     * SCM change title menus - scm/change/title
     * The View title menu - view/title
     * The View item menu - view/item/context
     * The macOS Touch Bar - touchBar
     * The comment thread title - comments/commentThread/title
     * The comment thread actions - comments/commentThread/context
     * The comment title - comments/comment/title
     * The comment actions - comments/comment/context
     * Note: When a command is invoked from a (context) menu, VS Code tries to infer
     * the currently selected resource and passes that as a parameter when invoking
     * the command. For instance, a menu item inside the Explorer is passed the URI
     * of the selected resource and a menu item inside an editor is passed the URI of the document.
     *
     * In addition to a title, commands can also define icons which VS Code will show in the editor title menu bar.
     *
     * @example
     * "contributes": {
     *     "menus": {
     *         "editor/title": [{
     *             "when": "resourceLangId == markdown",
     *             "command": "markdown.showPreview",
     *             "alt": "markdown.showPreviewToSide",
     *             "group": "navigation"
     *         }]
     *     }
     * }
     */
    menus?: Maybe<IMenus>;
    /**
     * @title contributes.snippets
     * @description Contribute snippets for a specific language. The language
     * attribute is the language identifier and the path is the relative path to the
     * snippet file, which defines snippets in the VS Code snippet format.
     *
     * @example
     *
     * ```json
     * "contributes": {
     *     "snippets": [{
     *         "language": "go",
     *         "path": "./snippets/go.json"
     *     }]
     * }
     * ```
     */
    snippets?: Maybe<Array<Maybe<ISnippet>>>;
    /**
     * @title contributes.themes
     * @description Contribute a TextMate theme to VS Code. You must specify a label,
     * whether the theme is a dark theme or a light theme (such that the rest of VS
     * Code changes to match your theme) and the path to the file (XML plist format).
     *
     * @example
     *    ```json
     *    "contributes": {
     *        "themes": [{
     *            "label": "Monokai",
     *            "uiTheme": "vs-dark",
     *            "path": "./themes/Monokai.tmTheme"
     *        }]
     *    }
     *    ```
     */
    themes?: Maybe<Array<Maybe<IThemeLabel>>>;
    iconThemes?: Maybe<Array<Maybe<IThemeLabel>>>;
    /**
     *  @title contributes.viewsContainers
     *  @description Contribute a view container into which Custom views can be
     * contributed. You must specify an identifier, title, and an icon for the view
     * container. At present, you can contribute them to the Activity Bar
     * (activitybar) only. Below example shows how the Package Explorer view
     * container is contributed to the Activity Bar and how views are contributed to it.
     *
     *  @example
     *     ```json
     *     "contributes": {
     *             "viewsContainers": {
     *                 "activitybar": [
     *                     {
     *                         "id": "package-explorer",
     *                         "title": "Package Explorer",
     *                         "icon": "resources/package-explorer.svg"
     *                     }
     *                 ]
     *             },
     *             "views": {
     *                 "package-explorer": [
     *                     {
     *                         "id": "package-dependencies",
     *                         "name": "Dependencies"
     *                     },
     *                     {
     *                         "id": "package-outline",
     *                         "name": "Outline"
     *                     }
     *                 ]
     *             }
     *     }
     * ```
     */
    viewsContainers?: Maybe<Scalars['JSON']>;
    /**
     * @title contributes.viewsContainers
     * @description Contribute a view container into which Custom views can be
     * contributed. You must specify an identifier, title, and an icon for the view
     * container. At present, you can contribute them to the Activity Bar
     * (activitybar) only. Below example shows how the Package Explorer view
     * container is contributed to the Activity Bar and how views are contributed to it.
     *
     * @example
     * ```json
     *    "contributes": {
     *            "viewsContainers": {
     *                "activitybar": [
     *                    {
     *                        "id": "package-explorer",
     *                        "title": "Package Explorer",
     *                        "icon": "resources/package-explorer.svg"
     *                    }
     *                ]
     *            },
     *            "views": {
     *                "package-explorer": [
     *                    {
     *                        "id": "package-dependencies",
     *                        "name": "Dependencies"
     *                    },
     *                    {
     *                        "id": "package-outline",
     *                        "name": "Outline"
     *                    }
     *                ]
     *            }
     *    }
     * ```
     */
    views?: Maybe<Scalars['JSON']>;
    /**
     * @title contributes.colors
     * @description Contributes new themable colors. These colors can be used by the
     * extension in editor decorators and in the status bar. Once defined, users can
     * customize the color in the workspace.colorCustomization setting and user
     * themes can set the color value.
     *
     * @example
     * ```json
     *    "contributes": {
     *      "colors": [{
     *          "id": "superstatus.error",
     *          "description": "Color for error message in the status bar.",
     *          "defaults": {
     *              "dark": "errorForeground",
     *              "light": "errorForeground",
     *              "highContrast": "#010203"
     *          }
     *      }]
     *    }
     * ```
     * Color default values can be defined for light, dark and high contrast theme
     * and can either be a reference to an existing color or a Color Hex Value.
     */
    colors?: Maybe<Array<Maybe<IExtensionColor>>>;
    localizations?: Maybe<Array<Maybe<ILocalization>>>;
};
export declare type IExtensionHostDebugParams = IIDebugParams & {
    __typename?: 'ExtensionHostDebugParams';
    port?: Maybe<Scalars['Int']>;
    break?: Maybe<Scalars['Boolean']>;
    debugId?: Maybe<Scalars['String']>;
};
/**
 * **!Do not construct directly!**
 * **!Only static methods because it gets serialized!**
 *
 * This represents the "canonical" version for an extension identifier. Exntension ids
 * have to be case-insensitive (due to the marketplace), but we must ensure case
 * preservation because the extension API is already public at this time.
 *
 * For example, given an extension with the publisher `"Hello` and the name `"World"`,
 * its canonical extension identifier is `"Hello.World"`. This extension could be
 * referenced in some other extension's dependencies using the string `"hello.world"`.
 *
 * To make matter more complicated, an extension can optionally have an UUID. When two
 * extensions have the same UUID, they are considered equal even if their identifier is different.
 */
export declare type IExtensionIdentifier = {
    __typename?: 'ExtensionIdentifier';
    id?: Maybe<Scalars['String']>;
    uuid?: Maybe<Scalars['String']>;
};
export declare type IExtensionJSONValidation = {
    __typename?: 'ExtensionJSONValidation';
    fileMatch?: Maybe<Scalars['String']>;
    url?: Maybe<Scalars['String']>;
};
export declare const enum IExtensionKind {
    ui = "ui",
    workspace = "workspace"
}
export declare type IExtensionLanguage = {
    __typename?: 'ExtensionLanguage';
    id?: Maybe<Scalars['ID']>;
    extensions?: Maybe<Array<Maybe<Scalars['String']>>>;
    aliases?: Maybe<Array<Maybe<Scalars['String']>>>;
};
export declare type IExtensionManifest = {
    __typename?: 'ExtensionManifest';
    /**  The name of the extension - should be all lowercase with no spaces  */
    name?: Maybe<Scalars['String']>;
    /**  SemVer compatible version.  */
    version?: Maybe<Scalars['String']>;
    /**  The entry point to your extension  */
    main?: Maybe<Scalars['String']>;
    /**
     *  Array of approved badges to display in the sidebar of the Marketplace's
     * extension page. Each badge is an object containing 3 properties: url for the
     * badge's image URL, href for the link users will follow when clicking the badge
     * and description.
     */
    badges?: Maybe<Array<Maybe<Scalars['String']>>>;
    /**  Sets the extension to be flagged as a Preview in the Marketplace.  */
    preview?: Maybe<Scalars['Boolean']>;
    /**
     *  An array of keywords to make it easier to find the extension. These are
     * included with other extension Tags on the Marketplace. This list is currently
     * limited to 5 keywords.
     */
    keywords?: Maybe<Array<Maybe<Scalars['String']>>>;
    /**
     *  Refer to npm's documentation. If you do have a LICENSE file in the root of
     * your extension, the value for license should be "SEE LICENSE IN <filename>".
     */
    license?: Maybe<Scalars['String']>;
    homepage?: Maybe<Scalars['String']>;
    /**  The publisher name  */
    publisher?: Maybe<Scalars['String']>;
    /**
     *  the categories you want to use for the extensions allowed values: [Programming
     * Languages, Snippets, Linters, Themes, Debuggers, Formatters, Keymaps, SCM
     * Providers, Other, Extension Packs, Language Packs]
     */
    categories?: Maybe<Scalars['String']>;
    /**  A short description of what your extension is and does.  */
    description?: Maybe<Scalars['String']>;
    extensionID?: Maybe<Scalars['String']>;
    /**  The display name for the extension used in the Marketplace.  */
    displayName?: Maybe<Scalars['String']>;
    /**  Any runtime Node.js dependencies your extensions needs. Exactly the same as npm's dependencies.  */
    dependencies?: Maybe<Scalars['JSON']>;
    /** Any development Node.js dependencies your extension needs. Exactly the same as npm's devDependencies.  */
    devDependencies?: Maybe<Scalars['JSON']>;
    /**
     * An array with the ids of extensions bundled with this extension. These other
     * extensions will be installed when the primary extension is installed. The id
     * of an extension is always
     * `${publisher}.${name}`. For example: vscode.csharp.
     */
    extensionPack?: Maybe<Array<Maybe<Scalars['String']>>>;
    /** An extension can be of 'ui' | 'workspace' */
    extensionKind?: Maybe<IExtensionKind>;
    /**
     * An array with the ids of extensions that this extension depends on. These
     * other extensions will be installed when the primary extension is installed.
     * The id of an extension is always
     * `${publisher}.${name}`. For example: vscode.csharp.
     */
    extensionDependencies?: Maybe<Array<Maybe<Scalars['String']>>>;
    bundle?: Maybe<Scalars['String']>;
    raw?: Maybe<Scalars['String']>;
    assets?: Maybe<Array<Maybe<IAssets>>>;
    /**  Exactly the same as npm's scripts but with extra VS Code specific fields such as vscode:prepublish or vscode:uninstall.  */
    scripts?: Maybe<IScripts>;
    bundles?: Maybe<IBundles>;
    bundleURL?: Maybe<Scalars['String']>;
    extension?: Maybe<IExtensionPackageType>;
    /**
     *  An object containing at least the vscode key matching
     * the versions of VS Code that the extension
     * is compatible with. Cannot be *.
     * For example: ^0.10.5 indicates compatibility with a minimum VS Code version of 0.10.5.
     */
    engines?: Maybe<IEngines>;
    /**  Controls the Markdown rendering engine used in the Marketplace. Either github (default) or standard.  */
    makrdown?: Maybe<Scalars['String']>;
    /**
     *  Controls the Q & A link in the Marketplace. Set to marketplace to enable the
     * default Marketplace Q & A site. Set to a string to provide the URL of a custom
     * Q & A site. Set to false to disable Q & A altogether.
     */
    qna?: Maybe<Scalars['String']>;
    author?: Maybe<IAuthor>;
    /**  Helps format the Marketplace header to match your icon. See details below.  */
    galleryBanner?: Maybe<IGalleryBanner>;
    /**  An array of the activation events for this extension.  */
    activationEvents?: Maybe<Array<Maybe<Scalars['String']>>>;
    /**  An object describing the extension's contributions.  */
    contributes?: Maybe<IExtensionContributions>;
    /**  The path to the icon of at least 128x128 pixels (256x256 for Retina screens).  */
    icon?: Maybe<Scalars['String']>;
    /**
     * @description Any development Node.js bugs reporting location of your extension.
     * @example
     *    "bugs": {
     *        "url": "https://github.com/Microsoft/vscode-wordcount/issues",
     *        "email": "smcbreen@microsoft.com"
     *    },
     */
    bugs?: Maybe<IExtensionManifestBugs>;
    /**
     * Any development Node.js repository location of your extension.
     * @example
     *   "repository": {
     *        "type": "git",
     *        "url": "https://github.com/Microsoft/vscode-wordcount.git"
     *    }
     */
    repository?: Maybe<IExtensionManifestRepository>;
    /** To enable proposed Api's */
    enableProposedApi?: Maybe<Scalars['Boolean']>;
    /** Add support for api:none */
    api?: Maybe<Scalars['String']>;
};
export declare type IExtensionManifestBugs = {
    __typename?: 'ExtensionManifestBugs';
    url?: Maybe<Scalars['String']>;
    email?: Maybe<Scalars['String']>;
};
export declare type IExtensionManifestRepository = {
    __typename?: 'ExtensionManifestRepository';
    type?: Maybe<Scalars['String']>;
    url?: Maybe<Scalars['String']>;
};
export declare type IExtensionPackageType = {
    __typename?: 'ExtensionPackageType';
    type?: Maybe<Scalars['String']>;
};
export declare const enum IExtensionType {
    System = "System",
    User = "User"
}
export declare type IFieldError = {
    __typename?: 'FieldError';
    field: Scalars['String'];
    message: Scalars['String'];
};
export declare type IFileChange = {
    __typename?: 'FileChange';
    /** The type of change that occurred to the file */
    type?: Maybe<FileChangeType>;
    /** The unified resource identifier of the file that changed. */
    resource?: Maybe<Scalars['URI']>;
};
export { FileChangeType };
export declare type IFileContent = IIBaseStatWithMetadata & IIBaseStat & {
    __typename?: 'FileContent';
    resource: Scalars['URI'];
    name: Scalars['String'];
    mtime: Scalars['BigInt'];
    etag: Scalars['String'];
    size: Scalars['Int'];
    isReadonly?: Maybe<Scalars['Boolean']>;
    /**  The content of a file as buffer.  */
    value?: Maybe<Scalars['VSBuffer']>;
};
export { FileContentStatus };
export declare type IFileDeleteOptions = {
    __typename?: 'FileDeleteOptions';
    recursive: Scalars['Boolean'];
    useTrash: Scalars['Boolean'];
};
export declare type IFileEditorInput = IIFileEditorInput & IIEditorInput & IIEditorInputWithGroupFields & IIEncodingSupport & IIModeSupport & {
    __typename?: 'FileEditorInput';
    id?: Maybe<Scalars['String']>;
    resource?: Maybe<Scalars['String']>;
    typeId?: Maybe<IEDITOR_INPUT_ID>;
    description?: Maybe<Scalars['String']>;
    label?: Maybe<Scalars['String']>;
    fileReference?: Maybe<IFileStatWithMetadata>;
    preferredEditorId?: Maybe<Scalars['String']>;
    isSupportsSplitEditor?: Maybe<Scalars['Boolean']>;
    isActive?: Maybe<Scalars['Boolean']>;
    preview?: Maybe<Scalars['Boolean']>;
    isPinned?: Maybe<Scalars['Boolean']>;
    editorId?: Maybe<Scalars['Int']>;
    status?: Maybe<Scalars['String']>;
    closable?: Maybe<Scalars['Boolean']>;
    preferredEncoding?: Maybe<Scalars['String']>;
    preferredMode?: Maybe<Scalars['String']>;
    forceOpenAsBinary?: Maybe<Scalars['Boolean']>;
    encoding?: Maybe<Scalars['String']>;
    mode?: Maybe<Scalars['String']>;
};
export declare type IFileFilter = {
    __typename?: 'FileFilter';
    extensions?: Maybe<Array<Maybe<Scalars['String']>>>;
    name?: Maybe<Scalars['String']>;
};
export declare const enum IFileLoadReason {
    EDITOR = "EDITOR",
    REFERENCE = "REFERENCE",
    OTHER = "OTHER"
}
/** same as ModelState as in vscode */
export declare const enum IFileModelState {
    /**  A model is saved.  */
    SAVED = "SAVED",
    /**  A model is dirty.  */
    DIRTY = "DIRTY",
    /**  A model is transitioning from dirty to saved.  */
    PENDING_SAVE = "PENDING_SAVE",
    /**
     * A model is in conflict mode when changes cannot be saved because the
     * underlying file has changed. Models in conflict mode are always dirty.
     */
    CONFLICT = "CONFLICT",
    /**  A model is in orphan state when the underlying file has been deleted.  */
    ORPHAN = "ORPHAN",
    /**
     * Any error that happens during a save that is not causing the CONFLICT state.
     * Models in error mode are always dirty.
     */
    ERROR = "ERROR",
    /**  Loading  */
    PENDING_LOAD = "PENDING_LOAD",
    /**  Unkown  */
    UNKNOWN = "UNKNOWN"
}
export declare type IFileOpenOptions = {
    __typename?: 'FileOpenOptions';
    create: Scalars['Boolean'];
};
export declare const enum IFileOperation {
    CREATE = "CREATE",
    DELETE = "DELETE",
    MOVE = "MOVE",
    COPY = "COPY"
}
export declare type IFileOperationOutput = {
    __typename?: 'FileOperationOutput';
    resource?: Maybe<Scalars['URI']>;
    target?: Maybe<IFileStatWithMetadata>;
    operation?: Maybe<IFileOperation>;
};
export declare const enum IFileOperationResult {
    FILE_IS_DIRECTORY = "FILE_IS_DIRECTORY",
    FILE_NOT_FOUND = "FILE_NOT_FOUND",
    FILE_NOT_MODIFIED_SINCE = "FILE_NOT_MODIFIED_SINCE",
    FILE_MODIFIED_SINCE = "FILE_MODIFIED_SINCE",
    FILE_MOVE_CONFLICT = "FILE_MOVE_CONFLICT",
    FILE_READ_ONLY = "FILE_READ_ONLY",
    FILE_PERMISSION_DENIED = "FILE_PERMISSION_DENIED",
    FILE_TOO_LARGE = "FILE_TOO_LARGE",
    FILE_INVALID_PATH = "FILE_INVALID_PATH",
    FILE_EXCEED_MEMORY_LIMIT = "FILE_EXCEED_MEMORY_LIMIT",
    FILE_OTHER_ERROR = "FILE_OTHER_ERROR"
}
export declare type IFileOverwriteOptions = {
    __typename?: 'FileOverwriteOptions';
    overwrite: Scalars['Boolean'];
};
export declare type IFileResult = {
    __typename?: 'FileResult';
    source?: Maybe<Scalars['URI']>;
    target?: Maybe<Scalars['URI']>;
    success?: Maybe<Scalars['Boolean']>;
};
export declare type IFiles = {
    __typename?: 'Files';
    eol?: Maybe<Scalars['String']>;
    hotExit?: Maybe<Scalars['String']>;
    encoding?: Maybe<Scalars['String']>;
    autoSave?: Maybe<IAutoSaveConfigurationType>;
    autoSaveDelay?: Maybe<Scalars['Int']>;
    defaultLanguage?: Maybe<Scalars['String']>;
    autoGuessEncoding?: Maybe<Scalars['Boolean']>;
    insertFinalNewline?: Maybe<Scalars['Boolean']>;
    trimTrailingWhitespace?: Maybe<Scalars['Boolean']>;
    useExperimentalFileWatcher?: Maybe<Scalars['Boolean']>;
    watcherExclude?: Maybe<Scalars['JSON']>;
    exclude?: Maybe<Scalars['JSON']>;
};
export declare type IFiles_Stat = {
    __typename?: 'Files_Stat';
    type?: Maybe<FileType>;
    mtime?: Maybe<Scalars['BigInt']>;
    ctime?: Maybe<Scalars['BigInt']>;
    size?: Maybe<Scalars['Int']>;
};
export declare const enum IFileServiceAction {
    onDidChangeFileSystemProviderRegistrations = "onDidChangeFileSystemProviderRegistrations",
    onWillActivateFileSystemProvider = "onWillActivateFileSystemProvider",
    registerProvider = "registerProvider",
    onError = "onError",
    activateProvder = "activateProvder",
    canHandleResource = "canHandleResource",
    hasCapability = "hasCapability",
    onFileChanges = "onFileChanges",
    onAfterOperation = "onAfterOperation",
    resolve = "resolve",
    resolveAll = "resolveAll",
    exists = "exists",
    readFile = "readFile",
    readFileStream = "readFileStream",
    writeFile = "writeFile",
    move = "move",
    copy = "copy",
    createFile = "createFile",
    createFolder = "createFolder",
    del = "del",
    watch = "watch",
    unwatch = "unwatch",
    dispose = "dispose"
}
export declare type IFileStat = IIBaseStat & {
    __typename?: 'FileStat';
    resource: Scalars['URI'];
    name: Scalars['String'];
    size?: Maybe<Scalars['Int']>;
    mtime?: Maybe<Scalars['BigInt']>;
    etag?: Maybe<Scalars['String']>;
    isReadonly?: Maybe<Scalars['Boolean']>;
    /**  The resource is a directory  */
    isDirectory?: Maybe<Scalars['Boolean']>;
    /**  The resource is a symbolic link.  */
    isSymbolicLink?: Maybe<Scalars['Boolean']>;
    /**  The children of the file stat or undefined if none.  */
    children?: Maybe<Array<Maybe<IFileStat>>>;
};
export declare const enum IFileStateChange {
    DIRTY = "DIRTY",
    SAVING = "SAVING",
    SAVE_ERROR = "SAVE_ERROR",
    SAVED = "SAVED",
    REVERTED = "REVERTED",
    ENCODING = "ENCODING",
    CONTENT_CHANGE = "CONTENT_CHANGE",
    ORPHANED_CHANGE = "ORPHANED_CHANGE"
}
/** Its extension of IFileStat and IBaseStatWithMetadata */
export declare type IFileStatWithMetadata = IIBaseStat & IIBaseStatWithMetadata & IIContentChangedEvent & IIFileClientMetadata & IITreeItem & IIUntitledFileValue & {
    __typename?: 'FileStatWithMetadata';
    active?: Maybe<Scalars['Boolean']>;
    changes?: Maybe<Scalars['JSON']>;
    /**  The children of the file stat or undefined if none.  */
    children?: Maybe<Array<Maybe<IFileStatWithMetadata>>>;
    childrenGen?: Maybe<Array<Maybe<IFileStatWithMetadata>>>;
    /** Content of the file is modified */
    dirty?: Maybe<Scalars['Boolean']>;
    /** encoding as reported from disk if the file is text */
    encoding?: Maybe<Scalars['String']>;
    eol?: Maybe<Scalars['String']>;
    etag: Scalars['String'];
    expanded?: Maybe<Scalars['Boolean']>;
    hasChildren?: Maybe<Scalars['Boolean']>;
    /** File is in conflict with storage. */
    inConflictMode?: Maybe<Scalars['Boolean']>;
    /** File is in Error */
    inErrorMode?: Maybe<Scalars['Boolean']>;
    /** File doesn't exist in the storage */
    inOrphanMode?: Maybe<Scalars['Boolean']>;
    /** Pending Save */
    inPendingSave?: Maybe<Scalars['Boolean']>;
    isDirectory?: Maybe<Scalars['Boolean']>;
    isEmpty?: Maybe<Scalars['Boolean']>;
    isFlush?: Maybe<Scalars['Boolean']>;
    isReadonly?: Maybe<Scalars['Boolean']>;
    isRedoing?: Maybe<Scalars['Boolean']>;
    /**  The resource is a symbolic link.  */
    isSymbolicLink?: Maybe<Scalars['Boolean']>;
    isUndoing?: Maybe<Scalars['Boolean']>;
    mtime: Scalars['BigInt'];
    name: Scalars['String'];
    path?: Maybe<Scalars['String']>;
    preferredEncoding?: Maybe<Scalars['String']>;
    preferredMode?: Maybe<Scalars['String']>;
    resource: Scalars['URI'];
    resourcePath?: Maybe<Scalars['String']>;
    size: Scalars['Int'];
    state?: Maybe<IFileModelState>;
    subtitle?: Maybe<Scalars['String']>;
    title?: Maybe<Scalars['String']>;
    value?: Maybe<Scalars['String']>;
    versionId?: Maybe<Scalars['Int']>;
};
export declare type IFileStreamContent = IIBaseStatWithMetadata & IIBaseStat & {
    __typename?: 'FileStreamContent';
    resource: Scalars['URI'];
    name: Scalars['String'];
    mtime: Scalars['BigInt'];
    etag: Scalars['String'];
    size: Scalars['Int'];
    isReadonly?: Maybe<Scalars['Boolean']>;
    value?: Maybe<Scalars['VSBufferReadableStream']>;
};
export declare type IFileToOpen = {
    __typename?: 'FileToOpen';
    fileUri?: Maybe<Scalars['URI']>;
    label?: Maybe<Scalars['String']>;
};
export { FileType };
export declare type IFileWriteOptions = {
    __typename?: 'FileWriteOptions';
    overwrite: Scalars['Boolean'];
    create: Scalars['Boolean'];
};
export declare type IFolderConfigurationModel = {
    __typename?: 'FolderConfigurationModel';
    id: Scalars['String'];
    contents?: Maybe<Scalars['AnyObject']>;
    keys?: Maybe<Array<Maybe<Scalars['String']>>>;
    overrides?: Maybe<IConfigurationOverrides>;
};
export declare type IFolderSettings = IISettingsSubject & {
    __typename?: 'FolderSettings';
    /**  The ID.  */
    id?: Maybe<Scalars['ID']>;
    /**  The latest settings.  */
    latestSettings?: Maybe<ISettings>;
    /**  The URL to the settings.  */
    settingsURL: Scalars['URI'];
    /**  Whether the viewer can modify the subject's settings. */
    viewerCanAdminister: Scalars['Boolean'];
    /**
     * All settings for this subject, and the individual levels in the settings cascade (global > organization > user)
     * that were merged to produce the final merged settings.
     */
    settingsCascade: ISettingsCascade;
};
export declare type IFolderToOpen = {
    __typename?: 'FolderToOpen';
    folderUri?: Maybe<Scalars['URI']>;
    label?: Maybe<Scalars['String']>;
};
export declare type IGalleryBanner = {
    __typename?: 'GalleryBanner';
    color?: Maybe<Scalars['String']>;
    theme?: Maybe<Scalars['String']>;
};
export declare type IGit = {
    __typename?: 'Git';
    path?: Maybe<Scalars['String']>;
    enabled?: Maybe<Scalars['Boolean']>;
    autofetch?: Maybe<Scalars['Boolean']>;
    countBadge?: Maybe<Scalars['String']>;
    autorefresh?: Maybe<Scalars['Boolean']>;
    confirmSync?: Maybe<Scalars['Boolean']>;
    checkoutType?: Maybe<Scalars['String']>;
    inputValidation?: Maybe<Scalars['String']>;
    detectSubmodules?: Maybe<Scalars['Boolean']>;
    enableSmartCommit?: Maybe<Scalars['Boolean']>;
    ignoreLimitWarning?: Maybe<Scalars['Boolean']>;
    ignoreLegacyWarning?: Maybe<Scalars['Boolean']>;
    enableCommitSigning?: Maybe<Scalars['Boolean']>;
    defaultCloneDirectory?: Maybe<Scalars['String']>;
    autoRepositoryDetection?: Maybe<Scalars['Boolean']>;
    ignoreMissingGitWarning?: Maybe<Scalars['Boolean']>;
    showInlineOpenFileAction?: Maybe<Scalars['Boolean']>;
    promptToSaveFilesBeforeCommit?: Maybe<Scalars['Boolean']>;
    decorations?: Maybe<IGitDecorations>;
};
export declare type IGitDecorations = {
    __typename?: 'GitDecorations';
    enabled?: Maybe<Scalars['Boolean']>;
};
export declare type IGlobalSettings = IISettingsSubject & {
    __typename?: 'GlobalSettings';
    /**  The ID.  */
    id?: Maybe<Scalars['ID']>;
    /**  The latest settings.  */
    latestSettings?: Maybe<ISettings>;
    /**  The URL to the settings.  */
    settingsURL: Scalars['URI'];
    /**  Whether the viewer can modify the subject's settings.  */
    viewerCanAdminister: Scalars['Boolean'];
    /**
     * All settings for this subject, and the individual levels in the settings cascade (global > organization > user)
     * that were merged to produce the final merged settings.
     */
    settingsCascade: ISettingsCascade;
};
export declare type IGoToLineQuickAccess = {
    __typename?: 'GoToLineQuickAccess';
    range?: Maybe<ILineRange>;
    highlight?: Maybe<Scalars['Boolean']>;
    focus?: Maybe<Scalars['Boolean']>;
};
export declare type IGrammar = {
    __typename?: 'Grammar';
    language?: Maybe<Scalars['String']>;
};
export declare const enum IGraphqlCallType {
    mutation = "mutation",
    query = "query"
}
export declare const enum IGroupDirection {
    DOWN = "DOWN",
    LEFT = "LEFT",
    RIGHT = "RIGHT",
    UP = "UP"
}
export declare type IGroupLayoutArgument = {
    __typename?: 'GroupLayoutArgument';
    groups?: Maybe<Array<Maybe<IGroupLayoutArgument>>>;
    size?: Maybe<Scalars['Int']>;
};
export declare const enum IGroupLocation {
    FIRST = "FIRST",
    LAST = "LAST",
    NEXT = "NEXT",
    PREVIOUS = "PREVIOUS"
}
export declare const enum IGroupOrientation {
    HORIZONTAL = "HORIZONTAL",
    VERTICAL = "VERTICAL"
}
export declare const enum IGroupsArrangement {
    /** Size all groups evenly. */
    EVEN = "EVEN",
    /**
     * Make the current active group consume the maximum
     * amount of space possible.
     */
    MINIMIZE_OTHERS = "MINIMIZE_OTHERS"
}
export declare const enum IGroupsOrder {
    /** Groups sorted by creation order (oldest one first) */
    CREATION_TIME = "CREATION_TIME",
    /** Groups sorted by grid widget order */
    GRID_APPEARANCE = "GRID_APPEARANCE",
    /** Groups sorted by most recent activity (most recent active first) */
    MOST_RECENTLY_ACTIVE = "MOST_RECENTLY_ACTIVE"
}
export { HotExitConfiguration };
export declare type IIBaseStat = {
    /**  The unified resource identifier of this file or folder  */
    resource: Scalars['URI'];
    /**
     * The name which is the last segement
     * of the {{path}}
     */
    name: Scalars['String'];
    /**
     * The size of the file.
     *
     * The value may or may not be resolved as
     * it is optional.
     */
    size?: Maybe<Scalars['Int']>;
    /**
     * The last modification date represented
     * as millis from unix epoch.
     *
     * The value may or may not be resolved as
     * it is optional.
     */
    mtime?: Maybe<Scalars['BigInt']>;
    /**
     * A unique identifier that represents the
     * current state of the file or directory.
     *
     * The value may or may not be resolved as
     * it is optional
     */
    etag?: Maybe<Scalars['String']>;
    /**  The resource is readonly.  */
    isReadonly?: Maybe<Scalars['Boolean']>;
};
/** Extension of IBaseStat with few more fields */
export declare type IIBaseStatWithMetadata = {
    mtime: Scalars['BigInt'];
    etag: Scalars['String'];
    size: Scalars['Int'];
};
/** # extension of IBaseStatWithMetadata */
export declare type IIBaseTextFileContent = {
    /** The encoding of the content if known. */
    encoding?: Maybe<Scalars['String']>;
};
export declare type IIConfigurationChangeEvent = {
    __typename?: 'IConfigurationChangeEvent';
    source?: Maybe<IConfigurationTarget>;
    affectedKeys?: Maybe<Array<Maybe<Scalars['String']>>>;
    sourceConfig?: Maybe<Scalars['AnyObject']>;
    changedConfiguration?: Maybe<IConfigurationModel>;
    changedConfigurationByResource?: Maybe<IResourceMapConfigurationModel>;
};
export declare type IIContentChangedEvent = {
    changes?: Maybe<Scalars['JSON']>;
    eol?: Maybe<Scalars['String']>;
    versionId?: Maybe<Scalars['Int']>;
    isUndoing?: Maybe<Scalars['Boolean']>;
    isRedoing?: Maybe<Scalars['Boolean']>;
    isFlush?: Maybe<Scalars['Boolean']>;
};
export declare type IIDebugParams = {
    port?: Maybe<Scalars['Int']>;
    break?: Maybe<Scalars['Boolean']>;
};
/** EditorGroup that has fields borrowed from vscode. */
export declare type IIEditorGroup = {
    /**
     * A unique identifier of this group that remains identical even if the
     * group is moved to different locations.
     */
    id: Scalars['Int'];
    /**
     * A human readable lable for the group. This label can change depending
     * on the layout of all editor groups. Clients should listen to this event
     * to react to that.
     */
    label?: Maybe<Scalars['String']>;
};
export declare type IIEditorInput = {
    /** Returns the associated resource of this input. */
    resource?: Maybe<Scalars['String']>;
    /** Unique type identifier for this input. */
    typeId?: Maybe<IEDITOR_INPUT_ID>;
    /** Returns the display title of this input. */
    label?: Maybe<Scalars['String']>;
    /**
     * Returns the display description of this input that can be shown to the user. Examples include showing the desciption of
     * the input about the editor area to the side of the name of the input.
     */
    description?: Maybe<Scalars['String']>;
    /**
     * File referenced in the Editor Input to provide
     * `isDirty`, `name`
     */
    fileReference?: Maybe<IFileStatWithMetadata>;
    /**
     * Returns the preferred editor for this input. A list of candidate editors is passed in that we registered
     * for the input. This allows subclasses to decide later which editor to use for the input on a case by case basis.
     */
    preferredEditorId?: Maybe<Scalars['String']>;
    /** Set this to false if it does not make sense to split the editor input. */
    isSupportsSplitEditor?: Maybe<Scalars['Boolean']>;
};
/**
 * Additional details to EditorInput to help to resolve fields that
 * helps IEditorGroup
 */
export declare type IIEditorInputWithGroupFields = {
    /**
     * File is currently active.
     * Note: An editor can be opened but not actively visible.
     */
    isActive?: Maybe<Scalars['Boolean']>;
    /**
     * The editor is pinned in the group. A pinned editor is not replaced
     * when another editor opens at the same location.
     */
    isPinned?: Maybe<Scalars['Boolean']>;
    /**
     * The editor in the group that is in preview mode if any. There can
     * only ever be one editor in preview mode.
     */
    preview?: Maybe<Scalars['Boolean']>;
    /** custom id to map to the EditorGroup it belongs */
    editorId?: Maybe<Scalars['Int']>;
    /**
     * File loading status
     * @deprecated - We can use IFileStat to have it.
     */
    status?: Maybe<Scalars['String']>;
    /**
     * @docklayout
     * Whether this tab is closable
     */
    closable?: Maybe<Scalars['Boolean']>;
};
export declare type IIEncodingSupport = {
    /** encoding for the input for saving. */
    encoding?: Maybe<Scalars['String']>;
};
export declare type IIFileClientMetadata = {
    /** Content of the file is modified */
    dirty?: Maybe<Scalars['Boolean']>;
    /** File is in conflict with storage. */
    inConflictMode?: Maybe<Scalars['Boolean']>;
    /** File doesn't exist in the storage */
    inOrphanMode?: Maybe<Scalars['Boolean']>;
    /** File is in Error */
    inErrorMode?: Maybe<Scalars['Boolean']>;
    /** Pending Save */
    inPendingSave?: Maybe<Scalars['Boolean']>;
    preferredMode?: Maybe<Scalars['String']>;
    encoding?: Maybe<Scalars['String']>;
    preferredEncoding?: Maybe<Scalars['String']>;
    state?: Maybe<IFileModelState>;
};
/**
 * This is a tagging interface to declare an editor input being capable of dealing
 * with files. It is only used in the editor registry
 * to register this kind of input to the platform.
 *
 * As a workaround to https://github.com/graphql/graphql-spec/pull/373, we will be add additional interfaces as sub-fields.
 */
export declare type IIFileEditorInput = {
    /** Preferred encoding to use for this input. */
    preferredEncoding?: Maybe<Scalars['String']>;
    /** Preferred mode to use for this input. */
    preferredMode?: Maybe<Scalars['String']>;
    /** Forces the file input to open as binary instead of text. */
    forceOpenAsBinary?: Maybe<Scalars['Boolean']>;
};
export declare type IIJSONValue_input = {
    key?: Maybe<Scalars['String']>;
    value?: Maybe<Scalars['AnyObject']>;
};
export declare type IIModeSupport = {
    /** language mode of the input. */
    mode?: Maybe<Scalars['String']>;
};
export declare type IImportResult = {
    __typename?: 'ImportResult';
    stat?: Maybe<IFileStat>;
    isNew?: Maybe<Scalars['Boolean']>;
};
export declare type IIndentation = IIStatusbarItem & {
    __typename?: 'Indentation';
    id?: Maybe<Scalars['String']>;
    name?: Maybe<Scalars['String']>;
    alignment?: Maybe<IStatusbarAlignment>;
    entry?: Maybe<IStatusbarEntry>;
    priority?: Maybe<Scalars['Int']>;
    container?: Maybe<Scalars['String']>;
    labelContainer?: Maybe<Scalars['String']>;
    typeId?: Maybe<ISTATUSBAR_ITEM_ID>;
};
export declare type IInputOptions = {
    title?: Maybe<Scalars['String']>;
    value?: Maybe<Scalars['String']>;
    prompt?: Maybe<Scalars['String']>;
    placeHolder?: Maybe<Scalars['String']>;
    password?: Maybe<Scalars['Boolean']>;
    validationMessage?: Maybe<Scalars['String']>;
};
export declare type IInputTypeDetail = {
    __typename?: 'InputTypeDetail';
    type?: Maybe<Scalars['String']>;
    options?: Maybe<Array<Maybe<Scalars['String']>>>;
};
export declare type IInputTypeDetail_input = {
    type?: Maybe<Scalars['String']>;
    options?: Maybe<Array<Maybe<Scalars['String']>>>;
};
export declare type IIntegrated = {
    __typename?: 'Integrated';
    setLocaleVariables?: Maybe<Scalars['Boolean']>;
    shellArgs?: Maybe<IShellArgs>;
    shell?: Maybe<IShell>;
};
export declare type IIPathData = {
    /**  the file path to open within the instance  */
    fileUri?: Maybe<Scalars['URI']>;
    /**  the line number in the file path to open  */
    lineNumber?: Maybe<Scalars['Int']>;
    /**  the column number in the file path to open  */
    columnNumber?: Maybe<Scalars['Int']>;
    /**
     * a hint that the file exists. If true, the file exists, if false it does not. within
     * undefined the state is uknown.
     */
    exists?: Maybe<Scalars['Boolean']>;
};
export declare type IIPathsToWaitForData = {
    paths?: Maybe<Array<Maybe<IIPathData>>>;
    waitMarkerFileUri?: Maybe<Scalars['URI']>;
};
/**
 * ISettingsSubject is something that can have settings: a site ("global settings", which is different from "site
 * configuration"), an organization, or a user.
 */
export declare type IISettingsSubject = {
    /**  The ID.  */
    id?: Maybe<Scalars['ID']>;
    /**  The latest settings.  */
    latestSettings?: Maybe<ISettings>;
    /**  The URL to the settings.  */
    settingsURL: Scalars['URI'];
    /**  Whether the viewer can modify the subject's settings.  */
    viewerCanAdminister: Scalars['Boolean'];
    /**
     * All settings for this subject, and the individual levels in the settings cascade (global > organization > user)
     * that were merged to produce the final merged settings.
     */
    settingsCascade: ISettingsCascade;
};
export declare type IISideBySideEditorInput = {
    master?: Maybe<IEditorInput>;
    details?: Maybe<IEditorInput>;
};
export declare type IIStaticWorkspaceData = {
    id: Scalars['String'];
    name?: Maybe<Scalars['String']>;
    configuration?: Maybe<Scalars['URI']>;
    isUntitled?: Maybe<Scalars['Boolean']>;
};
export declare type IIStatusbarItem = {
    id?: Maybe<Scalars['String']>;
    name?: Maybe<Scalars['String']>;
    alignment?: Maybe<IStatusbarAlignment>;
    entry?: Maybe<IStatusbarEntry>;
    priority?: Maybe<Scalars['Int']>;
    container?: Maybe<Scalars['String']>;
    labelContainer?: Maybe<Scalars['String']>;
    typeId?: Maybe<ISTATUSBAR_ITEM_ID>;
};
/** Tree data that compatible with `react-sortable-tree` package */
export declare type IITreeItem = {
    path?: Maybe<Scalars['String']>;
    title?: Maybe<Scalars['String']>;
    subtitle?: Maybe<Scalars['String']>;
    isDirectory?: Maybe<Scalars['Boolean']>;
    active?: Maybe<Scalars['Boolean']>;
    expanded?: Maybe<Scalars['Boolean']>;
    hasChildren?: Maybe<Scalars['Boolean']>;
    /** Helps to populate data before the directory or file created. */
    isEmpty?: Maybe<Scalars['Boolean']>;
};
export declare type IIUntitledFileValue = {
    value?: Maybe<Scalars['String']>;
};
export declare type IIUserPreferences = {
    __typename?: 'IUserPreferences';
    content?: Maybe<Scalars['String']>;
    user?: Maybe<Scalars['String']>;
};
export declare type IIUserSettings = {
    __typename?: 'IUserSettings';
    data?: Maybe<Scalars['String']>;
};
export declare type IKeepOpen_Input = {
    resource: Scalars['String'];
    editorId?: Maybe<Scalars['Int']>;
    name?: Maybe<Scalars['String']>;
};
export declare type IKeyBinding = {
    __typename?: 'KeyBinding';
    command?: Maybe<Scalars['String']>;
    key?: Maybe<Scalars['String']>;
    when?: Maybe<Scalars['String']>;
    mac?: Maybe<Scalars['String']>;
    linux?: Maybe<Scalars['String']>;
    win?: Maybe<Scalars['String']>;
};
export declare type IKeybinding_input = {
    command?: Maybe<Scalars['String']>;
    key?: Maybe<Scalars['String']>;
    when?: Maybe<Scalars['String']>;
    source?: Maybe<Scalars['String']>;
    run?: Maybe<IActionRun_input>;
};
export declare type IKeybindingContextMenu = {
    __typename?: 'KeybindingContextMenu';
    editItem?: Maybe<IEditKeybindingItem>;
    selectedItemIndex?: Maybe<Scalars['Int']>;
    editWhenIndex?: Maybe<Scalars['Int']>;
    newWhen?: Maybe<Scalars['String']>;
    isOpenDialog?: Maybe<Scalars['Boolean']>;
    search?: Maybe<Scalars['String']>;
};
export declare type IKeybindingEditorInput = IIEditorInput & IIEditorInputWithGroupFields & {
    __typename?: 'KeybindingEditorInput';
    id?: Maybe<Scalars['String']>;
    resource?: Maybe<Scalars['String']>;
    typeId?: Maybe<IEDITOR_INPUT_ID>;
    description?: Maybe<Scalars['String']>;
    label?: Maybe<Scalars['String']>;
    fileReference?: Maybe<IFileStatWithMetadata>;
    preferredEditorId?: Maybe<Scalars['String']>;
    isSupportsSplitEditor?: Maybe<Scalars['Boolean']>;
    isActive?: Maybe<Scalars['Boolean']>;
    preview?: Maybe<Scalars['Boolean']>;
    isPinned?: Maybe<Scalars['Boolean']>;
    editorId?: Maybe<Scalars['Int']>;
    status?: Maybe<Scalars['String']>;
    closable?: Maybe<Scalars['Boolean']>;
};
export declare type IKeybindingItem = {
    __typename?: 'KeybindingItem';
    command?: Maybe<Scalars['String']>;
    key?: Maybe<Scalars['String']>;
    when?: Maybe<Scalars['String']>;
    source?: Maybe<IKeybindingSource>;
    run?: Maybe<IActionRun>;
};
export declare type IKeybindingItem_input = {
    command?: Maybe<Scalars['String']>;
    key?: Maybe<Scalars['String']>;
    when?: Maybe<Scalars['String']>;
    isDefault?: Maybe<Scalars['Boolean']>;
};
export declare type IKeybindings = {
    __typename?: 'Keybindings';
    items?: Maybe<Array<Maybe<IKeybindingItem>>>;
};
export declare const enum IKeybindingSource {
    Default = "Default",
    User = "User"
}
export declare type IKeyboardEvent_input = {
    ctrlKey?: Maybe<Scalars['Boolean']>;
    shiftKey?: Maybe<Scalars['Boolean']>;
    altKey?: Maybe<Scalars['Boolean']>;
    metaKey?: Maybe<Scalars['Boolean']>;
    keyCode?: Maybe<Scalars['Int']>;
    code?: Maybe<Scalars['String']>;
    browserEvent?: Maybe<Scalars['AnyObject']>;
};
export declare type IKeyboardEvent_output = {
    __typename?: 'KeyboardEvent_output';
    label?: Maybe<Scalars['String']>;
    key?: Maybe<Array<Maybe<Scalars['String']>>>;
};
/**
 * A segment of a key path that locates a nested JSON value in a root JSON value. Exactly one field in each
 * KeyPathSegment must be non-null.
 *
 * For example, in {"a": [0, {"b": 3}]}, the value 3 is located at the key path ["a", 1, "b"].
 */
export declare type IKeyPathSegment = {
    /**  The name of the property in the object at this location to descend into.  */
    property?: Maybe<Scalars['String']>;
    /**  The index of the array at this location to descend into.  */
    index?: Maybe<Scalars['Int']>;
};
export declare const enum ILableFormatType {
    default = "default",
    short = "short",
    medium = "medium",
    long = "long"
}
export declare type ILanguageMode = IIStatusbarItem & {
    __typename?: 'LanguageMode';
    id?: Maybe<Scalars['String']>;
    name?: Maybe<Scalars['String']>;
    alignment?: Maybe<IStatusbarAlignment>;
    entry?: Maybe<IStatusbarEntry>;
    priority?: Maybe<Scalars['Int']>;
    container?: Maybe<Scalars['String']>;
    labelContainer?: Maybe<Scalars['String']>;
    typeId?: Maybe<ISTATUSBAR_ITEM_ID>;
};
export declare type ILanguages = {
    __typename?: 'Languages';
    go?: Maybe<Scalars['Boolean']>;
    css?: Maybe<Scalars['Boolean']>;
    html?: Maybe<Scalars['Boolean']>;
    json?: Maybe<Scalars['Boolean']>;
    yaml?: Maybe<Scalars['Boolean']>;
    typescript?: Maybe<Scalars['Boolean']>;
    javascript?: Maybe<Scalars['Boolean']>;
};
export declare type ILineRange = {
    __typename?: 'LineRange';
    endColumn?: Maybe<Scalars['Int']>;
    endLine?: Maybe<Scalars['Int']>;
    startColumn?: Maybe<Scalars['Int']>;
    startLine?: Maybe<Scalars['Int']>;
};
export declare type ILineRange_input = {
    startLine?: Maybe<Scalars['Int']>;
    startColumn?: Maybe<Scalars['Int']>;
    endLine?: Maybe<Scalars['Int']>;
    endColumn?: Maybe<Scalars['Int']>;
};
export declare type ILoadOptions_Input = {
    /**  Go to disk bypassing any cahce of the model if any. */
    forceReadFromDisk?: Maybe<Scalars['Boolean']>;
    /**  Allow to load a model even if we think it is a binary file. */
    allowBinary?: Maybe<Scalars['Boolean']>;
    /**  Context why the model is being loaded. */
    reason?: Maybe<IFileLoadReason>;
};
export declare type ILocalization = {
    __typename?: 'Localization';
    languageId?: Maybe<Scalars['String']>;
    languageName?: Maybe<Scalars['String']>;
    localizedLanguageName?: Maybe<Scalars['String']>;
    translations?: Maybe<Array<Maybe<ILocalizationTranslation>>>;
    minimalTranslations?: Maybe<Scalars['JSON']>;
};
export declare type ILocalizationTranslation = {
    __typename?: 'LocalizationTranslation';
    id?: Maybe<Scalars['ID']>;
    path?: Maybe<Scalars['String']>;
};
export declare type ILocalUserSettings = IISettingsSubject & {
    __typename?: 'LocalUserSettings';
    /**  The ID.  */
    id?: Maybe<Scalars['ID']>;
    /**  The latest settings.  */
    latestSettings?: Maybe<ISettings>;
    /**  The URL to the settings.  */
    settingsURL: Scalars['URI'];
    /**  Whether the viewer can modify the subject's settings. */
    viewerCanAdminister: Scalars['Boolean'];
    /**
     * All settings for this subject, and the individual levels in the settings cascade (global > organization > user)
     * that were merged to produce the final merged settings.
     */
    settingsCascade: ISettingsCascade;
};
export declare type IMatch = {
    __typename?: 'Match';
    start?: Maybe<Scalars['Int']>;
    end?: Maybe<Scalars['Int']>;
};
export declare type IMatch_input = {
    start?: Maybe<Scalars['Int']>;
    end?: Maybe<Scalars['Int']>;
};
export declare type IMemorySettings = IISettingsSubject & {
    __typename?: 'MemorySettings';
    /**  The ID.  */
    id?: Maybe<Scalars['ID']>;
    /**  The latest settings.  */
    latestSettings?: Maybe<ISettings>;
    /**  The URL to the settings.  */
    settingsURL: Scalars['URI'];
    /**  Whether the viewer can modify the subject's settings. */
    viewerCanAdminister: Scalars['Boolean'];
    /**
     * All settings for this subject, and the individual levels in the settings cascade (global > organization > user)
     * that were merged to produce the final merged settings.
     */
    settingsCascade: ISettingsCascade;
};
export declare const enum IMenuId {
    CommandPalette = "CommandPalette",
    DebugBreakpointsContext = "DebugBreakpointsContext",
    DebugCallStackContext = "DebugCallStackContext",
    DebugConsoleContext = "DebugConsoleContext",
    DebugVariablesContext = "DebugVariablesContext",
    DebugWatchContext = "DebugWatchContext",
    DebugTooBar = "DebugTooBar",
    EditorContext = "EditorContext",
    EditorTitle = "EditorTitle",
    EditorTitleContext = "EditorTitleContext",
    EmptyEditorGroupContext = "EmptyEditorGroupContext",
    ExplorerContext = "ExplorerContext",
    MenubarAppearanceMenu = "MenubarAppearanceMenu",
    MenubarDebugMenu = "MenubarDebugMenu",
    MenubarEditMenu = "MenubarEditMenu",
    MenubarFileMenu = "MenubarFileMenu",
    MenubarGoMenu = "MenubarGoMenu",
    MenubarNewBreakpointMenu = "MenubarNewBreakpointMenu",
    MenubarPreferencesMenu = "MenubarPreferencesMenu",
    MenubarRecentMenu = "MenubarRecentMenu",
    MenubarSelectionMenu = "MenubarSelectionMenu",
    MenubarSwitchEditorMenu = "MenubarSwitchEditorMenu",
    MenubarSwitchGroupMenu = "MenubarSwitchGroupMenu",
    MenubarTerminalMenu = "MenubarTerminalMenu",
    MenubarViewMenu = "MenubarViewMenu",
    OpenEditorContext = "OpenEditorContext",
    ProblemsPanelContext = "ProblemsPanelContext",
    SCMChangeContext = "SCMChangeContext",
    SCMResourceContext = "SCMResourceContext",
    SCMResourceGroupContext = "SCMResourceGroupContext",
    SCMResourceControl = "SCMResourceControl",
    SCMTitle = "SCMTitle",
    SearchContext = "SearchContext",
    StatusBarWindowIndicatorMenu = "StatusBarWindowIndicatorMenu",
    TouchBarContext = "TouchBarContext",
    ViewItemContext = "ViewItemContext",
    ViewTitle = "ViewTitle",
    CommentThreadTitle = "CommentThreadTitle",
    CommentThreadActions = "CommentThreadActions",
    CommentTitle = "CommentTitle",
    CommentActions = "CommentActions"
}
export declare type IMenuItem = {
    __typename?: 'MenuItem';
    id?: Maybe<Scalars['String']>;
    label?: Maybe<Scalars['String']>;
    enabled?: Maybe<Scalars['Boolean']>;
    run?: Maybe<IActionRun>;
};
export declare type IMenuItem_input = {
    id?: Maybe<Scalars['String']>;
    label?: Maybe<Scalars['String']>;
    enabled?: Maybe<Scalars['Boolean']>;
    run?: Maybe<IActionRun_input>;
};
export declare type IMenuItemAction = {
    __typename?: 'MenuItemAction';
    action?: Maybe<Scalars['String']>;
    when?: Maybe<Scalars['String']>;
};
export declare type IMenuItemActionContext = {
    __typename?: 'MenuItemActionContext';
    context?: Maybe<Array<Maybe<IMenuItemAction>>>;
};
export declare type IMenuItemActionDebug = {
    __typename?: 'MenuItemActionDebug';
    callstack?: Maybe<IMenuItemActionContext>;
    toolbar?: Maybe<Array<Maybe<IMenuItemAction>>>;
};
export declare type IMenuItemActionEditor = {
    __typename?: 'MenuItemActionEditor';
    context?: Maybe<Array<Maybe<IMenuItemAction>>>;
    title?: Maybe<IMenuItemActionEditorTitle>;
};
export declare type IMenuItemActionEditorTitle = {
    __typename?: 'MenuItemActionEditorTitle';
    own?: Maybe<Array<Maybe<IMenuItemAction>>>;
    context?: Maybe<Array<Maybe<IMenuItemAction>>>;
};
export declare type IMenuItemActionScm = {
    __typename?: 'MenuItemActionScm';
    /**  The Source Control title menu  */
    title?: Maybe<Array<Maybe<IMenuItemAction>>>;
    /**  The Source Control resource group context menu  */
    resourceGroup?: Maybe<IMenuItemActionContext>;
    resource?: Maybe<IMenuItemActionContext>;
    change?: Maybe<IMenuItemActionScmChange>;
};
export declare type IMenuItemActionScmChange = {
    __typename?: 'MenuItemActionScmChange';
    title?: Maybe<Array<Maybe<IMenuItemAction>>>;
};
export declare type IMenuItemActionView = {
    __typename?: 'MenuItemActionView';
    /**  The contributed view title menu  */
    title?: Maybe<Array<Maybe<IMenuItemAction>>>;
    /**  The contributed view item context menu  */
    item?: Maybe<IMenuItemActionContext>;
};
export declare type IMenus = {
    __typename?: 'Menus';
    /**  The Command Palette  */
    commandPalette?: Maybe<Array<Maybe<IMenuItemAction>>>;
    /**  The file explorer  */
    explorer?: Maybe<IMenuItemActionContext>;
    /**  The editor  */
    editor?: Maybe<IMenuItemActionEditor>;
    /**  The debug  */
    debug?: Maybe<IMenuItemActionDebug>;
    /**  The Source Control  */
    scm?: Maybe<IMenuItemActionScm>;
    /**  The contributed view  */
    view?: Maybe<IMenuItemActionView>;
    /**  The touch bar (macOS only)  */
    touchBar?: Maybe<Array<Maybe<IMenuItemAction>>>;
};
export declare const enum IMergeGroupMode {
    COPY_EDITORS = "COPY_EDITORS",
    MOVE_EDITORS = "MOVE_EDITORS"
}
export declare type IMergeGroupOptions_Input = {
    index?: Maybe<Scalars['Int']>;
    mode?: Maybe<IMergeGroupMode>;
};
export declare type IMessageBoxOptions = {
    __typename?: 'MessageBoxOptions';
    type?: Maybe<Scalars['String']>;
    buttons?: Maybe<Array<Maybe<Scalars['String']>>>;
    defaultId?: Maybe<Scalars['Int']>;
    title?: Maybe<Scalars['String']>;
    message?: Maybe<Scalars['String']>;
    detail?: Maybe<Scalars['String']>;
    checkboxLabel?: Maybe<Scalars['String']>;
    checkboxChecked?: Maybe<Scalars['Boolean']>;
    cancelId?: Maybe<Scalars['Int']>;
    noLink?: Maybe<Scalars['Boolean']>;
    normalizeAccessKeys?: Maybe<Scalars['Boolean']>;
};
export declare type IMessageBoxResult = {
    __typename?: 'MessageBoxResult';
    button?: Maybe<Scalars['Int']>;
    checkboxChecked?: Maybe<Scalars['Boolean']>;
};
export declare type IMessageLink = {
    __typename?: 'MessageLink';
    name?: Maybe<Scalars['String']>;
    href?: Maybe<Scalars['String']>;
    offset?: Maybe<Scalars['Int']>;
    length?: Maybe<Scalars['Int']>;
};
export declare type IMessageLink_input = {
    name?: Maybe<Scalars['String']>;
    href?: Maybe<Scalars['String']>;
    offset?: Maybe<Scalars['Int']>;
    length?: Maybe<Scalars['Int']>;
};
export declare type IModelLoadOrCreateOptions_Input = {
    /**  Context why the model is being loaded or created. */
    reason?: Maybe<IFileLoadReason>;
    /**  The language mode to use for the model text content. */
    mode?: Maybe<Scalars['String']>;
    /**  The encoding to use when resolving the model text content. */
    encoding?: Maybe<Scalars['String']>;
    /**
     * If the model was already loaded before, allows to trigger
     * a reload of it to fetch the latest contents:
     * - async: loadOrCreate() will return immediately and trigger
     * a reload that will run in the background.
     * - sync: loadOrCreate() will only return resolved when the
     * model was finished reloading.
     */
    reload?: Maybe<IModelLoadOrCreateOptions_Input_reload>;
    /**  Allow to load a model even if we think it is a binary file. */
    allowBinary?: Maybe<Scalars['Boolean']>;
};
export declare type IModelLoadOrCreateOptions_Input_reload = {
    async?: Maybe<Scalars['Boolean']>;
};
/**  All Moleculer Topic names are extended from this. */
export declare const enum IMoleculerServiceName {
    ConfigurationClientService = "ConfigurationClientService",
    ConfigurationService = "ConfigurationService",
    EnvironmentService = "EnvironmentService",
    FileClientService = "FileClientService",
    FileService = "FileService",
    LifecycleService = "LifecycleService",
    TextFileClientService = "TextFileClientService",
    TextFileService = "TextFileService",
    WorkbenchLifecycleEmitter = "WorkbenchLifecycleEmitter",
    WorkbenchLifecycleListener = "WorkbenchLifecycleListener",
    WorkspaceClientContextService = "WorkspaceClientContextService",
    WorkspaceContextService = "WorkspaceContextService",
    WorkspaceEventually = "WorkspaceEventually",
    /**  Following services will help to wait other services  */
    WorkspaceReady = "WorkspaceReady",
    WorkspaceRestore = "WorkspaceRestore",
    dummy = "dummy"
}
export declare type IMoveEditor_Input = {
    resource: Scalars['String'];
    editorId?: Maybe<Scalars['Int']>;
    name?: Maybe<Scalars['String']>;
};
export declare type IMoveEditorOptions_Input = {
    inactive?: Maybe<Scalars['Boolean']>;
    index?: Maybe<Scalars['Int']>;
    preserveFocus?: Maybe<Scalars['Boolean']>;
};
export declare type IMutation = {
    __typename?: 'Mutation';
    activateEditor?: Maybe<Scalars['Boolean']>;
    addEntry?: Maybe<Scalars['Boolean']>;
    addNotification?: Maybe<Scalars['Boolean']>;
    canHandleResource?: Maybe<Scalars['Boolean']>;
    changeEdit?: Maybe<Scalars['Boolean']>;
    changeKeybinding?: Maybe<Scalars['Boolean']>;
    changeWhenExpression?: Maybe<Scalars['Boolean']>;
    closeAllEditors?: Maybe<Scalars['Boolean']>;
    closeDialog?: Maybe<Scalars['Boolean']>;
    closeEditor?: Maybe<Scalars['Boolean']>;
    closeEditors?: Maybe<Scalars['Boolean']>;
    closeNotification?: Maybe<Scalars['Boolean']>;
    copy?: Maybe<Scalars['Boolean']>;
    copyFile?: Maybe<IFileStatWithMetadata>;
    createFile?: Maybe<IFileStatWithMetadata>;
    createFolder?: Maybe<IFileStatWithMetadata>;
    /**
     * Create a file. If the file exists it will be overwritten with the contents if
     * the options enable to overwrite.
     */
    createTextFile?: Maybe<IFileStatWithMetadata>;
    createUntitledFile?: Maybe<IFileStatWithMetadata>;
    del?: Maybe<Scalars['Boolean']>;
    /** Delete a file. If the file is dirty, it will get reverted and then deleted from disk. */
    deleteTextFile?: Maybe<Scalars['Boolean']>;
    dummy?: Maybe<Scalars['Int']>;
    editKeybinding?: Maybe<Scalars['Boolean']>;
    findFileStat?: Maybe<IFileStatWithMetadata>;
    getEditorState?: Maybe<ICodeEditorViewState>;
    getFilesTreeData?: Maybe<Array<Maybe<IFileStatWithMetadata>>>;
    gotoLine?: Maybe<Scalars['Boolean']>;
    handler?: Maybe<Scalars['Boolean']>;
    hideContextMenu?: Maybe<Scalars['Boolean']>;
    hideInputModel?: Maybe<Scalars['Boolean']>;
    hideKeybindingDialog?: Maybe<Scalars['Boolean']>;
    highlightLine?: Maybe<Scalars['Boolean']>;
    jsonWrite?: Maybe<Scalars['Boolean']>;
    keepOpen?: Maybe<Scalars['Boolean']>;
    loadFile?: Maybe<IFileStatWithMetadata>;
    loadFileContent?: Maybe<IFileContent>;
    loadFileWithContent?: Maybe<ITextFileContent>;
    loadFilesTreeData?: Maybe<Array<Maybe<IFileStatWithMetadata>>>;
    lookupKeybinding?: Maybe<Scalars['String']>;
    makePinEditor?: Maybe<Scalars['Boolean']>;
    moveEditorInsideGroup?: Maybe<Scalars['Boolean']>;
    moveFile?: Maybe<IFileStatWithMetadata>;
    /** Move a file. If the file is dirty, its contents will be preserved and restored. */
    moveTextFile?: Maybe<IFileStatWithMetadata>;
    notify?: Maybe<Scalars['Boolean']>;
    notifyError?: Maybe<Scalars['Boolean']>;
    notifyInfo?: Maybe<Scalars['Boolean']>;
    notifyPrompt?: Maybe<Scalars['Boolean']>;
    notifyWarn?: Maybe<Scalars['Boolean']>;
    /**
     * Open an editor or file in an EditorGroup.
     * If no EditorGroup exist, it creates one.
     */
    openEditor?: Maybe<Scalars['Boolean']>;
    /**
     * Open an editor in an editor group.
     *
     * @param editor the editor to open
     * @param group the target group. If unspecified, the editor will open in the currently
     * active group. Use `SIDE_GROUP_TYPE` to open the editor in a new editor group to the side
     * of the currently active group.
     */
    openEditorWithResourceDiffInput?: Maybe<Scalars['Boolean']>;
    /**
     * Open an editor in an editor group.
     *
     * @param editor the editor to open
     * @param group the target group. If unspecified, the editor will open in the currently
     * active group. Use `SIDE_GROUP_TYPE` to open the editor in a new editor group to the side
     * of the currently active group.
     */
    openEditorWithResourceInput?: Maybe<Scalars['Boolean']>;
    /**
     * Open an editor in an editor group.
     *
     * @param editor the editor to open
     * @param group the target group. If unspecified, the editor will open in the currently
     * active group. Use `SIDE_GROUP_TYPE` to open the editor in a new editor group to the side
     * of the currently active group.
     */
    openEditorWithResourceSideBySideInput?: Maybe<Scalars['Boolean']>;
    /**
     * Open an editor in an editor group.
     *
     * @param editor the editor to open
     * @param group the target group. If unspecified, the editor will open in the currently
     * active group. Use `SIDE_GROUP_TYPE` to open the editor in a new editor group to the side
     * of the currently active group.
     */
    openEditorWithUntitledResourceInput?: Maybe<Scalars['Boolean']>;
    /** @deprecated use openEditor */
    openFile?: Maybe<Scalars['Boolean']>;
    /**
     * Read the contents of a file identified by the resource.
     *
     * Added inaddition to the query as we want to manipulate the cache with `update` option available in `mutation`.
     * However, with apollo-client v3.0 we can start using it as `Query` as they support custom `merge`.
     */
    readTextFile?: Maybe<ITextFileContent>;
    registerKeybinding?: Maybe<Scalars['Boolean']>;
    removeChangedContent?: Maybe<Scalars['Boolean']>;
    removeEdit?: Maybe<Scalars['Boolean']>;
    removeKeybinding?: Maybe<Scalars['Boolean']>;
    removeStatusbarEntry?: Maybe<Scalars['Boolean']>;
    rename?: Maybe<IFileStatWithMetadata>;
    resetKeybinding?: Maybe<Scalars['Boolean']>;
    resolveKeyboardEvent?: Maybe<IKeyboardEvent_output>;
    runMenuAction?: Maybe<Scalars['Boolean']>;
    saveAllEditor?: Maybe<Scalars['Boolean']>;
    saveFile?: Maybe<IFileStat>;
    saveFileAs?: Maybe<Scalars['URI']>;
    saveUserSettings?: Maybe<ISaveWorkspaceRes>;
    saveWorkspaceSettings?: Maybe<ISaveWorkspaceRes>;
    searchKeybinding?: Maybe<Scalars['Boolean']>;
    selectEdit?: Maybe<Scalars['Boolean']>;
    setEncoding?: Maybe<Scalars['Boolean']>;
    setFilesTreeData?: Maybe<Scalars['Boolean']>;
    setSelected?: Maybe<Scalars['Boolean']>;
    setSelectedKeybindingIndex?: Maybe<Scalars['Boolean']>;
    setStatusMessage?: Maybe<Scalars['String']>;
    show?: Maybe<Scalars['Boolean']>;
    showContextMenu?: Maybe<Scalars['Boolean']>;
    showInput?: Maybe<Scalars['Boolean']>;
    showPickInput?: Maybe<Scalars['Boolean']>;
    stopEditWhenExpression?: Maybe<Scalars['Boolean']>;
    testNotification?: Maybe<Scalars['Boolean']>;
    unwatch?: Maybe<Scalars['Boolean']>;
    unwatchFileChanges?: Maybe<Scalars['Boolean']>;
    updateChangedContent?: Maybe<Scalars['Boolean']>;
    updateConfigurationValue?: Maybe<Scalars['Boolean']>;
    updateContent?: Maybe<IFileStatWithMetadata>;
    updateContext?: Maybe<Scalars['Boolean']>;
    updateEditorState?: Maybe<Scalars['Boolean']>;
    updateFileDirtyState?: Maybe<Scalars['Boolean']>;
    updateLayout?: Maybe<Scalars['Boolean']>;
    updateSelectedResource?: Maybe<Scalars['Boolean']>;
    updateStatusbarEntry?: Maybe<Scalars['Boolean']>;
    watchFile?: Maybe<Scalars['String']>;
    /**
     * Allows to start a watcher that reports file change events on the provided resource.
     *
     * Note: watching a folder does not report events recursively for child folders yet.
     */
    watchFileChanges?: Maybe<Scalars['Boolean']>;
    writeChunk?: Maybe<IUpdatedResource>;
    writeChunkWithDelay?: Maybe<IUpdateDelayedResource>;
    writeContent?: Maybe<Scalars['Boolean']>;
    /** Update a file with given contents. */
    writeTextFile?: Maybe<IFileStatWithMetadata>;
};
export declare type IMutationactivateEditorArgs = {
    editorId?: Maybe<Scalars['Int']>;
};
export declare type IMutationaddEntryArgs = {
    arg?: Maybe<IAddEntry_input>;
};
export declare type IMutationaddNotificationArgs = {
    notification?: Maybe<INotification_input>;
};
export declare type IMutationcanHandleResourceArgs = {
    resource: Scalars['URI'];
};
export declare type IMutationchangeEditArgs = {
    changed?: Maybe<Scalars['Boolean']>;
    resource?: Maybe<Scalars['String']>;
};
export declare type IMutationchangeKeybindingArgs = {
    editItem?: Maybe<IKeybindingItem_input>;
    selectedIndex?: Maybe<Scalars['Int']>;
    isOpenDialog?: Maybe<Scalars['Boolean']>;
};
export declare type IMutationchangeWhenExpressionArgs = {
    editItem?: Maybe<IKeybindingItem_input>;
    editWhenIndex?: Maybe<Scalars['Int']>;
    newWhen?: Maybe<Scalars['String']>;
};
export declare type IMutationcloseEditorArgs = {
    content?: Maybe<ICloseEditor_Input>;
    layoutId?: Maybe<Scalars['String']>;
};
export declare type IMutationcloseEditorsArgs = {
    editors?: Maybe<Array<Maybe<ICloseEditor_Input>>>;
    editorGroupId?: Maybe<Scalars['Int']>;
    options?: Maybe<ICloseEditorOptions_Input>;
};
export declare type IMutationcloseNotificationArgs = {
    index?: Maybe<Scalars['Int']>;
};
export declare type IMutationcopyArgs = {
    value?: Maybe<Scalars['String']>;
};
export declare type IMutationcopyFileArgs = {
    source: Scalars['URI'];
    target: Scalars['URI'];
    overwrite?: Maybe<Scalars['Boolean']>;
};
export declare type IMutationcreateFileArgs = {
    resource: Scalars['URI'];
    bufferOrReadable?: Maybe<Scalars['VSBuffer']>;
    options?: Maybe<ICreateFileOptions_Input>;
};
export declare type IMutationcreateFolderArgs = {
    resource: Scalars['URI'];
};
export declare type IMutationcreateTextFileArgs = {
    resource: Scalars['URI'];
    content?: Maybe<Scalars['String']>;
    overwrite?: Maybe<Scalars['Boolean']>;
};
export declare type IMutationcreateUntitledFileArgs = {
    resource?: Maybe<Scalars['URI']>;
    mode?: Maybe<Scalars['String']>;
    initialValue?: Maybe<Scalars['String']>;
    encoding?: Maybe<Scalars['String']>;
    hasAssociatedFilePath?: Maybe<Scalars['Boolean']>;
};
export declare type IMutationdelArgs = {
    resource: Scalars['URI'];
    options?: Maybe<IDeleteFileOptions_Input>;
};
export declare type IMutationdeleteTextFileArgs = {
    resource: Scalars['URI'];
    useTrash?: Maybe<Scalars['Boolean']>;
};
export declare type IMutationeditKeybindingArgs = {
    keybindingItem?: Maybe<IKeybindingItem_input>;
    key?: Maybe<Scalars['String']>;
    when?: Maybe<Scalars['String']>;
};
export declare type IMutationfindFileStatArgs = {
    resource: Scalars['URI'];
};
export declare type IMutationgetEditorStateArgs = {
    editorId: Scalars['String'];
    resource: Scalars['URI'];
};
export declare type IMutationgetFilesTreeDataArgs = {
    resource: Scalars['URI'];
};
export declare type IMutationgotoLineArgs = {
    range?: Maybe<ILineRange_input>;
};
export declare type IMutationhandlerArgs = {
    arg?: Maybe<IActionRun_input>;
};
export declare type IMutationhighlightLineArgs = {
    range?: Maybe<ILineRange_input>;
};
export declare type IMutationjsonWriteArgs = {
    resource?: Maybe<Scalars['URI']>;
    value?: Maybe<IIJSONValue_input>;
    save?: Maybe<Scalars['Boolean']>;
};
export declare type IMutationkeepOpenArgs = {
    content?: Maybe<IKeepOpen_Input>;
};
export declare type IMutationloadFileArgs = {
    resource: Scalars['URI'];
    options?: Maybe<IResolveMetadataFileOptions_Input>;
};
export declare type IMutationloadFileContentArgs = {
    resource: Scalars['URI'];
    options?: Maybe<IReadFileOptions_Input>;
};
export declare type IMutationloadFileWithContentArgs = {
    resource: Scalars['URI'];
    options?: Maybe<ILoadOptions_Input>;
};
export declare type IMutationloadFilesTreeDataArgs = {
    resource: Scalars['URI'];
};
export declare type IMutationlookupKeybindingArgs = {
    commandId?: Maybe<Scalars['String']>;
};
export declare type IMutationmakePinEditorArgs = {
    tabId?: Maybe<Scalars['String']>;
    editorId?: Maybe<Scalars['Int']>;
};
export declare type IMutationmoveEditorInsideGroupArgs = {
    content?: Maybe<IMoveEditor_Input>;
    moveOptions?: Maybe<IMoveEditorOptions_Input>;
};
export declare type IMutationmoveFileArgs = {
    source: Scalars['URI'];
    target: Scalars['URI'];
    overwrite?: Maybe<Scalars['Boolean']>;
};
export declare type IMutationmoveTextFileArgs = {
    source: Scalars['URI'];
    target: Scalars['URI'];
    overwrite?: Maybe<Scalars['Boolean']>;
};
export declare type IMutationnotifyArgs = {
    notification?: Maybe<INotification_input>;
};
export declare type IMutationnotifyErrorArgs = {
    message?: Maybe<Array<Maybe<INotificationMessage_input>>>;
};
export declare type IMutationnotifyInfoArgs = {
    message?: Maybe<Array<Maybe<INotificationMessage_input>>>;
};
export declare type IMutationnotifyPromptArgs = {
    severity?: Maybe<INotificationSeverity>;
    message?: Maybe<Scalars['String']>;
    choices?: Maybe<Array<Maybe<IPromptChoice_input>>>;
    options?: Maybe<IPromptOptions_input>;
};
export declare type IMutationnotifyWarnArgs = {
    message?: Maybe<Array<Maybe<INotificationMessage_input>>>;
};
export declare type IMutationopenEditorArgs = {
    content: IOpenEditor_Input;
    options?: Maybe<IEditorOpenOptions_Input>;
};
export declare type IMutationopenEditorWithResourceDiffInputArgs = {
    editor: IResourceDiff_Input;
    group?: Maybe<Scalars['Int']>;
};
export declare type IMutationopenEditorWithResourceInputArgs = {
    editor: IResource_Input;
    group?: Maybe<Scalars['Int']>;
};
export declare type IMutationopenEditorWithResourceSideBySideInputArgs = {
    editor: IResourceSideBySide_Input;
    group?: Maybe<Scalars['Int']>;
};
export declare type IMutationopenEditorWithUntitledResourceInputArgs = {
    editor: IUntitledResource_Input;
    group?: Maybe<Scalars['Int']>;
};
export declare type IMutationopenFileArgs = {
    content: IOpenEditor_Input;
    options?: Maybe<IEditorOpenOptions_Input>;
};
export declare type IMutationreadTextFileArgs = {
    resource: Scalars['URI'];
    options?: Maybe<IReadTextFileOptions_Input>;
};
export declare type IMutationregisterKeybindingArgs = {
    keybinding?: Maybe<IKeybinding_input>;
};
export declare type IMutationremoveChangedContentArgs = {
    resource: Scalars['URI'];
    reset?: Maybe<Scalars['Boolean']>;
};
export declare type IMutationremoveEditArgs = {
    content?: Maybe<IRemoveEditor_Input>;
};
export declare type IMutationremoveKeybindingArgs = {
    keybindingItem?: Maybe<IKeybindingItem_input>;
};
export declare type IMutationremoveStatusbarEntryArgs = {
    id: Scalars['ID'];
};
export declare type IMutationrenameArgs = {
    resource: Scalars['URI'];
    target: Scalars['URI'];
    overwrite?: Maybe<Scalars['Boolean']>;
};
export declare type IMutationresetKeybindingArgs = {
    keybindingItem?: Maybe<IKeybindingItem_input>;
};
export declare type IMutationresolveKeyboardEventArgs = {
    keyboardEvent?: Maybe<IKeyboardEvent_input>;
};
export declare type IMutationrunMenuActionArgs = {
    argument?: Maybe<IActionRun_input>;
};
export declare type IMutationsaveAllEditorArgs = {
    allSave?: Maybe<Scalars['Boolean']>;
};
export declare type IMutationsaveFileArgs = {
    resource: Scalars['URI'];
    versionId?: Maybe<Scalars['Int']>;
    options: ISaveOptions_Input;
};
export declare type IMutationsaveFileAsArgs = {
    resource: Scalars['String'];
    versionId?: Maybe<Scalars['Int']>;
    options: ISaveOptions_Input;
    target?: Maybe<Scalars['String']>;
};
export declare type IMutationsaveUserSettingsArgs = {
    content?: Maybe<Scalars['String']>;
};
export declare type IMutationsearchKeybindingArgs = {
    value?: Maybe<Scalars['String']>;
};
export declare type IMutationselectEditArgs = {
    content?: Maybe<ISelectEditor_Input>;
};
export declare type IMutationsetEncodingArgs = {
    resource: Scalars['URI'];
    encoding?: Maybe<Scalars['String']>;
};
export declare type IMutationsetFilesTreeDataArgs = {
    treeData?: Maybe<Array<Maybe<ITreeData_Input>>>;
    originalData?: Maybe<ITreeData_Input>;
};
export declare type IMutationsetSelectedArgs = {
    selectedValue?: Maybe<Array<Maybe<IPickItem>>>;
    inputValue?: Maybe<Scalars['String']>;
};
export declare type IMutationsetSelectedKeybindingIndexArgs = {
    index?: Maybe<Scalars['Int']>;
};
export declare type IMutationsetStatusMessageArgs = {
    arg?: Maybe<ISetStatusMsg_input>;
};
export declare type IMutationshowArgs = {
    dialog?: Maybe<IDialog_input>;
};
export declare type IMutationshowContextMenuArgs = {
    delegate?: Maybe<IContextMenu_input>;
};
export declare type IMutationshowInputArgs = {
    options?: Maybe<IInputOptions>;
};
export declare type IMutationshowPickInputArgs = {
    items?: Maybe<Array<Maybe<IPickItem>>>;
    options?: Maybe<IPickInputOptions>;
};
export declare type IMutationunwatchArgs = {
    resource: Scalars['URI'];
    session: Scalars['String'];
};
export declare type IMutationunwatchFileChangesArgs = {
    resource: Scalars['URI'];
    session: Scalars['String'];
};
export declare type IMutationupdateChangedContentArgs = {
    resource: Scalars['URI'];
    changedEvent: IContentChangedEvent_Input;
};
export declare type IMutationupdateConfigurationValueArgs = {
    key: Scalars['String'];
    value: Scalars['AnyObject'];
    overrides?: Maybe<IConfigurationOverrides_Input>;
    target?: Maybe<Scalars['Int']>;
    donotNotifyError?: Maybe<Scalars['Boolean']>;
};
export declare type IMutationupdateContentArgs = {
    resource: Scalars['URI'];
    value: Scalars['VSBuffer'];
    options: IWriteFileOptions_Input;
};
export declare type IMutationupdateContextArgs = {
    key?: Maybe<Scalars['String']>;
    value?: Maybe<Scalars['AnyObject']>;
};
export declare type IMutationupdateEditorStateArgs = {
    editorId: Scalars['String'];
    resource: Scalars['URI'];
    state: ICodeEditorViewState_Input;
};
export declare type IMutationupdateFileDirtyStateArgs = {
    resource: Scalars['URI'];
    isFileDirty: Scalars['Boolean'];
};
export declare type IMutationupdateLayoutArgs = {
    changedLayout?: Maybe<IEditorLayout_Input>;
};
export declare type IMutationupdateSelectedResourceArgs = {
    resource: Scalars['URI'];
};
export declare type IMutationupdateStatusbarEntryArgs = {
    arg?: Maybe<IUpdateEntry_input>;
};
export declare type IMutationwatchFileArgs = {
    resource: Scalars['URI'];
};
export declare type IMutationwatchFileChangesArgs = {
    resource: Scalars['URI'];
    options: IWatchOptions_Input;
};
export declare type IMutationwriteChunkArgs = {
    resource: Scalars['URI'];
    changes: Array<Maybe<IChangesChunk_Input>>;
    options: IWriteTextFileOptions_Input;
};
export declare type IMutationwriteChunkWithDelayArgs = {
    resource: Scalars['URI'];
    changes: Array<Maybe<IChangesChunk_Input>>;
    options: IWriteTextFileOptions_Input;
};
export declare type IMutationwriteTextFileArgs = {
    resource: Scalars['URI'];
    value: Scalars['String'];
    options: IWriteTextFileOptions_Input;
};
export declare type INativeOpenDialogOptions = {
    __typename?: 'NativeOpenDialogOptions';
    windowId?: Maybe<Scalars['Int']>;
    forceNewWindow?: Maybe<Scalars['Boolean']>;
    defaultPath?: Maybe<Scalars['String']>;
    telemetryEventName?: Maybe<Scalars['String']>;
};
export declare type INewWindowOptions = {
    __typename?: 'NewWindowOptions';
    remoteAuthority?: Maybe<Scalars['String']>;
    reuseWindow?: Maybe<Scalars['Boolean']>;
};
export declare type INotification = {
    __typename?: 'Notification';
    index?: Maybe<Scalars['Boolean']>;
    /** The severity of the notification. Either `Info`, `Warning` or `Error`. */
    severity?: Maybe<INotificationSeverity>;
    /**
     * The message of the notification. This can either be a `string` or `Error`. Messages
     * can optionally include links in the format: `[text](link)`
     */
    message?: Maybe<Scalars['String']>;
    /** The source of the notification appears as additional information. */
    source?: Maybe<Scalars['String']>;
    /**
     * Actions to show as part of the notification. Primary actions show up as
     * buttons as part of the message and will clost the notification once clicked.
     *
     * Secondary actions are meant to provide additional configuration or context
     * for the notification and will show up less prominent. A notification does not
     * close automatically when invoking a secondary action.
     *
     * **Note:** If you intent is to show a message with actions to the user, consider
     * the `INotificationService.prompt()` method instead which are optimized for
     * this usecase and much easier to use!
     */
    actions?: Maybe<INotificationActions>;
    /**
     * Sticky notifications are not automatically removed after a certain timeout. By
     * default, notifications with primary actions and severity error are always sticky.
     */
    sticky?: Maybe<Scalars['Boolean']>;
};
export declare type INotification_input = {
    severity?: Maybe<INotificationSeverity>;
    message?: Maybe<INotificationMessage_input>;
    source?: Maybe<Scalars['String']>;
    actions?: Maybe<INotificationActions_input>;
    sticky?: Maybe<Scalars['Boolean']>;
};
export declare type INotificationActions = {
    __typename?: 'NotificationActions';
    /**
     * Primary actions show up as buttons as part of the message and will close
     * the notification once clicked.
     */
    primary?: Maybe<Array<Maybe<IAction>>>;
    /**
     * Secondary actions are meant to provide additional configuration or context
     * for the notification and will show up less prominent. A notification does not
     * close automatically when invoking a secondary action.
     */
    secondary?: Maybe<Array<Maybe<IAction>>>;
};
export declare type INotificationActions_input = {
    primary?: Maybe<Array<Maybe<IAction_input>>>;
    secondary?: Maybe<Array<Maybe<IAction_input>>>;
};
export declare type INotificationChangeEvent = {
    __typename?: 'NotificationChangeEvent';
    /** The index this notification has in the list of notifications. */
    index?: Maybe<Scalars['Int']>;
    /** The notification this change is about. */
    item?: Maybe<INotificationViewItem>;
    /** The kind of notification change. */
    kind?: Maybe<INotificationChangeType>;
};
export declare const enum INotificationChangeType {
    ADD = "ADD",
    CHANGE = "CHANGE",
    REMOVE = "REMOVE"
}
export declare type INotificationMessage = {
    __typename?: 'NotificationMessage';
    raw?: Maybe<Scalars['String']>;
    original?: Maybe<INotificationMessage>;
    value?: Maybe<Scalars['String']>;
    links?: Maybe<Array<Maybe<IMessageLink>>>;
};
export declare type INotificationMessage_input = {
    raw?: Maybe<Scalars['String']>;
    original?: Maybe<INotificationMessage_input>;
    value?: Maybe<Scalars['String']>;
    links?: Maybe<Array<Maybe<IMessageLink_input>>>;
};
export declare type INotifications = {
    __typename?: 'Notifications';
    notifications?: Maybe<Array<Maybe<INotification>>>;
};
export declare const enum INotificationSeverity {
    Ignore = "Ignore",
    Info = "Info",
    Warning = "Warning",
    Error = "Error"
}
export declare type INotificationViewItem = {
    __typename?: 'NotificationViewItem';
    severity?: Maybe<INotificationSeverity>;
    sticky?: Maybe<Scalars['Boolean']>;
    silent?: Maybe<Scalars['Boolean']>;
    message?: Maybe<INotificationMessage>;
    source?: Maybe<Scalars['String']>;
    action?: Maybe<INotificationActions>;
    progress?: Maybe<INotificationViewItemProgress>;
    expanded?: Maybe<Scalars['Boolean']>;
    canCollapse?: Maybe<Scalars['Boolean']>;
};
export declare const enum INotificationViewItemLabelKind {
    SEVERITY = "SEVERITY",
    MESSAGE = "MESSAGE",
    ACTIONS = "ACTIONS",
    PROGRESS = "PROGRESS"
}
export declare type INotificationViewItemProgress = {
    __typename?: 'NotificationViewItemProgress';
    state?: Maybe<INotificationViewItemProgressState>;
};
export declare type INotificationViewItemProgressState = {
    __typename?: 'NotificationViewItemProgressState';
    /** Causes the progress bar to spin infinitely. */
    infinite?: Maybe<Scalars['Boolean']>;
    /** Indicate the total amount of work. */
    total?: Maybe<Scalars['Int']>;
    /** Indicate that a specific chunk of work is done. */
    worked?: Maybe<Scalars['Int']>;
    /** Indicate that the long running operation is done. */
    done?: Maybe<Scalars['Boolean']>;
};
export declare type IOpenConfiguration = {
    __typename?: 'OpenConfiguration';
    context?: Maybe<IOpenContext>;
    contextWindowId?: Maybe<Scalars['Int']>;
    cli?: Maybe<Scalars['AnyObject']>;
    userEnv?: Maybe<Scalars['AnyObject']>;
    urisToOpen?: Maybe<Array<Maybe<IURIToOpen>>>;
    waitMarkerFileURI?: Maybe<Scalars['URI']>;
    preferNewWindow?: Maybe<Scalars['Boolean']>;
    forceNewWindow?: Maybe<Scalars['Boolean']>;
    forceNewTabbedWindow?: Maybe<Scalars['Boolean']>;
    forceReuseWindow?: Maybe<Scalars['Boolean']>;
    forceEmpty?: Maybe<Scalars['Boolean']>;
    diffMode?: Maybe<Scalars['Boolean']>;
    addMode?: Maybe<Scalars['Boolean']>;
    initialStartup?: Maybe<Scalars['Boolean']>;
    noRecentEntry?: Maybe<Scalars['Boolean']>;
};
export declare const enum IOpenContext {
    /** opening when running from the command line */
    CLI = "CLI",
    /** macOS only: opening from the dock (also when opening files to a running instance from desktop) */
    DOCK = "DOCK",
    /** opening from the main application window */
    MENU = "MENU",
    /** opening from a file or folder dialog */
    DIALOG = "DIALOG",
    /** opening from the OS's UI  */
    DESKTOP = "DESKTOP",
    /** opening through the API */
    API = "API"
}
export declare type IOpenDialogOptions = {
    __typename?: 'OpenDialogOptions';
    title?: Maybe<Scalars['String']>;
    defaultPath?: Maybe<Scalars['String']>;
    buttonLabel?: Maybe<Scalars['String']>;
    filters?: Maybe<Array<Maybe<IFileFilter>>>;
    properties?: Maybe<Array<Maybe<IOpenDialogOptionsProperties>>>;
    message?: Maybe<Scalars['String']>;
};
export declare const enum IOpenDialogOptionsProperties {
    openFile = "openFile",
    openDirectory = "openDirectory",
    multiSelections = "multiSelections",
    showHiddenFiles = "showHiddenFiles",
    createDirectory = "createDirectory",
    promptToCreate = "promptToCreate",
    noResolveAliases = "noResolveAliases",
    treatPackageAsDirectory = "treatPackageAsDirectory"
}
export declare type IOpenDiff_Input = {
    resource?: Maybe<Scalars['String']>;
    editorId?: Maybe<Scalars['Int']>;
    name?: Maybe<Scalars['String']>;
};
export declare type IOpenEditor_Input = {
    resource: Scalars['String'];
    name: Scalars['String'];
    editorId?: Maybe<Scalars['Int']>;
    isPinned?: Maybe<Scalars['Boolean']>;
    size?: Maybe<Scalars['Int']>;
    deleted?: Maybe<Scalars['Boolean']>;
};
export declare type IOpenFileRequest = {
    __typename?: 'OpenFileRequest';
    filesToOpenOrCreate?: Maybe<Array<Maybe<IIPathData>>>;
    filesToDiff?: Maybe<Array<Maybe<IIPathData>>>;
    filesToWait?: Maybe<IIPathsToWaitForData>;
    termProgram?: Maybe<Scalars['String']>;
};
export declare const enum IOpenPositioningType {
    left = "left",
    right = "right",
    first = "first",
    last = "last"
}
export declare type IOpenSettings = {
    __typename?: 'OpenSettings';
    forceNewWindow?: Maybe<Scalars['Boolean']>;
    forceReuseWindow?: Maybe<Scalars['Boolean']>;
    diffMode?: Maybe<Scalars['Boolean']>;
    addMode?: Maybe<Scalars['Boolean']>;
    noRecentEntry?: Maybe<Scalars['Boolean']>;
    waitMarkerFileURI?: Maybe<Scalars['URI']>;
    args?: Maybe<Scalars['AnyObject']>;
};
export declare const enum IOpenSideBySideDirection {
    right = "right",
    down = "down"
}
export declare type IOutput = {
    __typename?: 'Output';
    maxChannelHistory?: Maybe<Scalars['Int']>;
};
export declare type IOverrides = {
    __typename?: 'Overrides';
    contents?: Maybe<Scalars['AnyObject']>;
    identifiers?: Maybe<Array<Maybe<Scalars['String']>>>;
};
export declare type IPath = IIPathData & {
    __typename?: 'Path';
    lineNumber?: Maybe<Scalars['Int']>;
    columnNumber?: Maybe<Scalars['Int']>;
    exists?: Maybe<Scalars['Boolean']>;
    /**  the file path to open within the instance  */
    fileUri?: Maybe<Scalars['URI']>;
};
export declare type IPathsToWaitFor = IIPathsToWaitForData & {
    __typename?: 'PathsToWaitFor';
    paths?: Maybe<Array<Maybe<IPath>>>;
    waitMarkerFileUri?: Maybe<Scalars['URI']>;
};
export declare type IPendingStatusbarEntry = {
    __typename?: 'PendingStatusbarEntry';
    id?: Maybe<Scalars['String']>;
    name?: Maybe<Scalars['String']>;
    alignment?: Maybe<IStatusbarAlignment>;
    priority?: Maybe<Scalars['Int']>;
};
export declare type IPickInputOptions = {
    title?: Maybe<Scalars['String']>;
    placeHolder?: Maybe<Scalars['String']>;
    matchOnDescription?: Maybe<Scalars['Boolean']>;
    matchOnDetail?: Maybe<Scalars['Boolean']>;
    matchOnLabel?: Maybe<Scalars['Boolean']>;
    canPickMany?: Maybe<Scalars['Boolean']>;
    activeItem?: Maybe<IPickItem>;
};
export declare type IPickItem = {
    id?: Maybe<Scalars['String']>;
    label?: Maybe<Scalars['String']>;
    description?: Maybe<Scalars['String']>;
    detail?: Maybe<Scalars['String']>;
    keybinding?: Maybe<IKeybindingItem_input>;
    italic?: Maybe<Scalars['Boolean']>;
    highlights?: Maybe<IQuickPickItemHighlights_input>;
    picked?: Maybe<Scalars['Boolean']>;
    alwaysShow?: Maybe<Scalars['Boolean']>;
};
/**
 * @lsp - Position in a text document expressed as zero-based line and character offset.
 * The offsets are based on UTF-16 string representation. So a string of the form
 * `a𐐀b` the character offset of b is 3 since `𐐀` is represented using two code
 * untis in UTF-16.
 *
 * Positions are line end character agnostic. So you can not specify a position that
 * denotes `\r|\n` or `\n"` where `|` represents the character offset.
 *
 *
 * @editor - A position in the editor.
 */
export declare type IPosition = {
    __typename?: 'Position';
    /** @editor - line number (starts at 1) */
    lineNumber?: Maybe<Scalars['Int']>;
    /** @editor - column (the first character in a line is between column 1 and column 2) */
    column?: Maybe<Scalars['Int']>;
    /**
     * @lsp - Line position in a document (zero-based).
     * If a line number is greater than the number of lines in a document, it
     * defaults back to the number of lines in the document.
     * If a line number is negative, it defaults to 0.
     */
    line?: Maybe<Scalars['Int']>;
    /**
     * @lsp - Character offset on a line in a document (zer-based). Assuming that the line is represented as a string, the
     * `character` value represents the gap between the `character` and `character+1`.
     *
     * If the character value is greater than the line length it defaults back to the
     * line length.
     * If a line number is negative, it defaults to 0.
     */
    character?: Maybe<Scalars['Int']>;
};
export declare type IPositionInput = {
    line?: Maybe<Scalars['Int']>;
    character?: Maybe<Scalars['Int']>;
    lineNumber?: Maybe<Scalars['Int']>;
    column?: Maybe<Scalars['Int']>;
};
export declare type IPreferenceItem = {
    __typename?: 'PreferenceItem';
    name?: Maybe<Scalars['String']>;
    type?: Maybe<Scalars['String']>;
    default?: Maybe<Scalars['String']>;
    description?: Maybe<Scalars['String']>;
    categoryType?: Maybe<Scalars['String']>;
    settings?: Maybe<Scalars['String']>;
    enum?: Maybe<Array<Maybe<Scalars['String']>>>;
    enumDescriptions?: Maybe<Array<Maybe<Scalars['String']>>>;
};
export declare type IPreferencesType = {
    __typename?: 'PreferencesType';
    type?: Maybe<Scalars['String']>;
    data?: Maybe<Array<Maybe<ISetting>>>;
};
export declare type IPrimaryButtonAction = {
    __typename?: 'PrimaryButtonAction';
    label?: Maybe<Scalars['String']>;
    run?: Maybe<IActionRun>;
};
export declare type IPrimaryButtonAction_input = {
    label?: Maybe<Scalars['String']>;
    run?: Maybe<IActionRun_input>;
};
export declare type IPromptChoice_input = {
    /** Label to show for the choice to the user. */
    label?: Maybe<Scalars['String']>;
    /**
     * Primary choices show up as buttons in the notification below the message.
     * Secondary choices show up under the gear icon in the header of the notification.
     */
    isSecondary?: Maybe<Scalars['Boolean']>;
    /**
     * Whether to keep the notification open after the choice was selected
     * by the user. By default, will close the notification upon click.
     */
    keepOpen?: Maybe<Scalars['Boolean']>;
    /** Triggered when the user selects the choice. */
    run?: Maybe<IPromptChoiceRun>;
};
export declare type IPromptChoiceRun = {
    type?: Maybe<IGraphqlCallType>;
    document?: Maybe<Scalars['AnyObject']>;
    variables?: Maybe<Scalars['AnyObject']>;
};
export declare type IPromptOptions_input = {
    /**
     * Sticky prompts are not automatically removed after a certain timeout.
     *
     * Note: Prompts of severity ERROR are always sticky.
     */
    sticky?: Maybe<Scalars['Boolean']>;
    /**
     * Silent notifications are not shown to the user unless the notification center is opened.
     * The status bar will still indicate all number of notifications to
     * catch some attention.
     */
    silent?: Maybe<Scalars['Boolean']>;
    /**
     * Will be called if the user closed the notification without picking
     * any  of the provided choices.
     */
    onCancel?: Maybe<IPromptOptionsCancel>;
};
export declare type IPromptOptionsCancel = {
    type?: Maybe<IGraphqlCallType>;
    document?: Maybe<Scalars['AnyObject']>;
    variables?: Maybe<Scalars['AnyObject']>;
};
export declare const enum IProvidedRemoteConnectionStates {
    initializing = "initializing",
    disconnected = "disconnected",
    connected = "connected"
}
export declare type IQuery = {
    __typename?: 'Query';
    contextMenu?: Maybe<IContextMenu>;
    /**  Default Preferences  */
    defaultPreferences?: Maybe<IDefaultPreferencesResponse>;
    defaultSetting?: Maybe<ISetting>;
    /**
     * The default settings for the requested ConfigurationTarget
     * Note: Due to bug in graphql we using  `target: Int` argument instead of  `target:ConfigurationTarget`
     * https://github.com/apollographql/apollo-server/issues/2556
     */
    defaultViewerSettingsSubject: IDefaultSettings;
    dialog?: Maybe<IDialog>;
    dummy?: Maybe<Scalars['Int']>;
    editorPart?: Maybe<IEditorPart>;
    editorState?: Maybe<ICodeEditorViewState>;
    existsFile?: Maybe<Scalars['Boolean']>;
    getChangedEvent?: Maybe<IIContentChangedEvent>;
    getConfigurationData?: Maybe<IConfigurationData>;
    getConfigurationTarget?: Maybe<IConfigurationScope>;
    getContextData?: Maybe<IContext>;
    getContextProperty?: Maybe<IContext>;
    /**  Default settings  */
    getDefaultSettings?: Maybe<Scalars['String']>;
    /**  Default Settings Resources  */
    getDefaultSettingsResource?: Maybe<Scalars['URI']>;
    getEnvironment?: Maybe<IEnvironment>;
    getKeybindings?: Maybe<IKeybindings>;
    getSelectedValue?: Maybe<ISelectedOutput>;
    getWorkspace?: Maybe<IWorkspaceData>;
    getWorkspaceValue?: Maybe<Scalars['AnyObject']>;
    gotoLineQuickAccess?: Maybe<IGoToLineQuickAccess>;
    keybindingContextMenu?: Maybe<IKeybindingContextMenu>;
    keybindings?: Maybe<IKeybindings>;
    notifications?: Maybe<INotifications>;
    quickInputModel?: Maybe<IQuickInputModel>;
    /** Read the contents of a file identified by the resource as stream. */
    readStreamTextFile?: Maybe<ITextFileStreamContent>;
    readStringStreamTextFile?: Maybe<ITextFilePublishContent>;
    /** Read the contents of a file identified by the resource. */
    readTextFile?: Maybe<ITextFileContent>;
    resolveContent?: Maybe<IFileContent>;
    resolveContents?: Maybe<Array<Maybe<IResolveFileResultWithMetadata>>>;
    resolveFile?: Maybe<IFileStatWithMetadata>;
    resolveFileContent?: Maybe<ITextFileContent>;
    resolveUntitledFileContent?: Maybe<ITextFileContent>;
    selectedResource?: Maybe<IContext>;
    /**
     * Looks up an instance of a type that implements ISettingsSubject (i.e., something that has settings). This can
     * can be a site (which has global settings), an organization, or a user
     */
    settingsSubject?: Maybe<IISettingsSubject>;
    showDialog?: Maybe<IDialogResult>;
    showNotification?: Maybe<Scalars['Boolean']>;
    statusbar?: Maybe<IStatusbar>;
    statusbarItem?: Maybe<IStatusbarItem>;
    untitledResources?: Maybe<Array<Maybe<Scalars['String']>>>;
    userPreferences?: Maybe<IUserPreferencesRes>;
    /**
     * The settings for the viewer. The viewer is either an anonymous visitor (in which case viewer settings is
     * global settings) or an authenticated user (in which case viewer settings are the user's settings).
     */
    viewerSettings: ISettingsCascade;
    workspaces?: Maybe<Array<Maybe<IWorkspaceRes>>>;
};
export declare type IQuerydefaultViewerSettingsSubjectArgs = {
    target?: Maybe<Scalars['Int']>;
};
export declare type IQueryeditorStateArgs = {
    editorId: Scalars['String'];
    resource: Scalars['URI'];
};
export declare type IQueryexistsFileArgs = {
    resource: Scalars['URI'];
};
export declare type IQuerygetChangedEventArgs = {
    resource: Scalars['URI'];
};
export declare type IQuerygetContextPropertyArgs = {
    keys?: Maybe<Array<Maybe<Scalars['String']>>>;
};
export declare type IQuerygetDefaultSettingsArgs = {
    target?: Maybe<IConfigurationTarget>;
};
export declare type IQuerygetDefaultSettingsResourceArgs = {
    configurationTarget?: Maybe<IConfigurationTarget>;
};
export declare type IQuerygetWorkspaceValueArgs = {
    value?: Maybe<IWorkspaceValue_Input>;
};
export declare type IQueryreadStreamTextFileArgs = {
    resource: Scalars['URI'];
    options?: Maybe<IReadTextFileOptions_Input>;
};
export declare type IQueryreadStringStreamTextFileArgs = {
    resource: Scalars['URI'];
    options?: Maybe<IReadTextFileOptions_Input>;
};
export declare type IQueryreadTextFileArgs = {
    resource: Scalars['URI'];
    options?: Maybe<IReadTextFileOptions_Input>;
};
export declare type IQueryresolveContentArgs = {
    resource: Scalars['URI'];
    options?: Maybe<IReadFileOptions_Input>;
};
export declare type IQueryresolveContentsArgs = {
    toResolve?: Maybe<Array<Maybe<IResolveAll_toResolveWithMetadata_Input>>>;
};
export declare type IQueryresolveFileArgs = {
    resource: Scalars['URI'];
    options?: Maybe<IResolveMetadataFileOptions_Input>;
};
export declare type IQueryresolveFileContentArgs = {
    resource: Scalars['URI'];
    options?: Maybe<ILoadOptions_Input>;
};
export declare type IQueryresolveUntitledFileContentArgs = {
    resource: Scalars['URI'];
};
export declare type IQuerysettingsSubjectArgs = {
    id: Scalars['ID'];
};
export declare type IQueryshowDialogArgs = {
    dialog?: Maybe<IDialog_input>;
};
export declare type IQueryshowNotificationArgs = {
    notification?: Maybe<INotification_input>;
};
export declare type IQuerystatusbarItemArgs = {
    id?: Maybe<Scalars['String']>;
};
export declare type IQueryuserPreferencesArgs = {
    user?: Maybe<Scalars['String']>;
};
export declare type IQuickInput = {
    __typename?: 'QuickInput';
    title?: Maybe<Scalars['String']>;
    description?: Maybe<Scalars['String']>;
    step?: Maybe<Scalars['Int']>;
    totalSteps?: Maybe<Scalars['Int']>;
    enabled?: Maybe<Scalars['Boolean']>;
    ignoreFocusOut?: Maybe<Scalars['Boolean']>;
    value?: Maybe<Scalars['String']>;
    placeholder?: Maybe<Scalars['String']>;
    prompt?: Maybe<Scalars['String']>;
    validationMessage?: Maybe<Scalars['String']>;
};
export declare type IQuickInputModel = {
    __typename?: 'QuickInputModel';
    show?: Maybe<Scalars['Boolean']>;
    title?: Maybe<Scalars['String']>;
    input?: Maybe<IQuickInput>;
    quickPick?: Maybe<IQuickPick>;
    inputValue?: Maybe<Scalars['String']>;
    selectedValue?: Maybe<Array<Maybe<IQuickPickItem>>>;
};
export declare type IQuickPick = {
    __typename?: 'QuickPick';
    placeholder?: Maybe<Scalars['String']>;
    canSelectMany?: Maybe<Scalars['Boolean']>;
    autoFocusOnList?: Maybe<Scalars['Boolean']>;
    items?: Maybe<Array<Maybe<IQuickPickItem>>>;
    activeItem?: Maybe<IQuickPickItem>;
    selectedItems?: Maybe<Array<Maybe<IQuickPickItem>>>;
};
export declare type IQuickPickItem = {
    __typename?: 'QuickPickItem';
    id?: Maybe<Scalars['String']>;
    label?: Maybe<Scalars['String']>;
    description?: Maybe<Scalars['String']>;
    detail?: Maybe<Scalars['String']>;
    keybinding?: Maybe<IKeybindingItem>;
    italic?: Maybe<Scalars['Boolean']>;
    highlights?: Maybe<IQuickPickItemHighlights>;
    picked?: Maybe<Scalars['Boolean']>;
    alwaysShow?: Maybe<Scalars['Boolean']>;
};
export declare type IQuickPickItemHighlights = {
    __typename?: 'QuickPickItemHighlights';
    label?: Maybe<Array<Maybe<IMatch>>>;
    description?: Maybe<Array<Maybe<IMatch>>>;
    detail?: Maybe<Array<Maybe<IMatch>>>;
};
export declare type IQuickPickItemHighlights_input = {
    label?: Maybe<Array<Maybe<IMatch_input>>>;
    description?: Maybe<Array<Maybe<IMatch_input>>>;
    detail?: Maybe<Array<Maybe<IMatch_input>>>;
};
/**
 * @lsp - A range in a text document expressed as (zero-based) start and end positions. A range is comparable to a
 * section in an editor. Therefore the end position is exclusive. If you want to specify a range that contains a line
 * including the line ending character(s) then use an end pisition denoting the start of the next line. For example:
 * ```
 * {
 *    start: { line: 5, character: 23 },
 *    end : { line 6, character : 0 }
 * }
 * ```
 *
 * @editor - A range in the editor. This interface is suitable for serialization.
 */
export declare type IRange = {
    __typename?: 'Range';
    /**
     * @lsp
     * The range's start position.
     */
    start?: Maybe<IPosition>;
    /**
     * @lsp
     * The range's end position.
     */
    end?: Maybe<IPosition>;
    /** @editor - Line number on which the range starts (starts at 1). */
    startLineNumber?: Maybe<Scalars['Int']>;
    /** @editor - Column on which the range starts in the line `startLineNumber` (starts at 1). */
    startColumn?: Maybe<Scalars['Int']>;
    /** @editor - Line number on which the range ends. */
    endLineNumber?: Maybe<Scalars['Int']>;
    /** @editor - Column on which the range ends in the line `endLineNumber` */
    endColumn?: Maybe<Scalars['Int']>;
};
export declare type IRangeInput = {
    endColumn?: Maybe<Scalars['Int']>;
    endLineNumber?: Maybe<Scalars['Int']>;
    startColumn?: Maybe<Scalars['Int']>;
    startLineNumber?: Maybe<Scalars['Int']>;
};
export declare type IReadFileOptions_Input = {
    /**
     * The optional etag parameter allows to return early from resolving the resource if
     * the contents on disk match the etag. This prevents accumulated reading of resources
     * that have been read already with the same etag.
     * It is the task of the caller to makes sure to handle this error case from the promise.
     */
    etag?: Maybe<Scalars['String']>;
    /**
     * Is an integer specifying where to begin reading from in the file. If position is null,
     * data will be read from the current file position.
     */
    position?: Maybe<Scalars['Int']>;
    /**
     * Is an integer specifying how many bytes to read from the file. By default, all bytes
     * will be read.
     */
    length?: Maybe<Scalars['Int']>;
    /** If provided, the size of the file will be checked agains the limits. */
    limits?: Maybe<IReadFileOptions_Input_limits>;
};
export declare type IReadFileOptions_Input_limits = {
    size?: Maybe<Scalars['Int']>;
    memory?: Maybe<Scalars['Int']>;
};
/** It is a extension to ReadFileOptions_Input with few more options. */
export declare type IReadTextFileOptions_Input = {
    etag?: Maybe<Scalars['String']>;
    Position?: Maybe<Scalars['Int']>;
    length?: Maybe<Scalars['Int']>;
    limits?: Maybe<IReadFileOptions_Input_limits>;
    /**
     * The optional acceptTextOnly parameters allows to fail this request early if the file
     * contents are not textual.
     */
    acceptTextOnly?: Maybe<Scalars['Boolean']>;
    /**
     * The optional encoding parameter allows to specify the desired encoding when resolving
     * the contents of the file.
     */
    encoding?: Maybe<Scalars['String']>;
    /** The ioptional guessEncoding parameter allows to guess encoding from content of the file. */
    autoGuessEncoding?: Maybe<Scalars['Boolean']>;
};
export declare const enum IReadyState {
    /** This window has  not loaded any HTML yet */
    NONE = "NONE",
    /** This window is loading HTML */
    LOADING = "LOADING",
    /** This window is navigating to another HTML */
    NAVIGATING = "NAVIGATING",
    /** This window is done loading HTML */
    READY = "READY"
}
export declare type IRemoteUserSettings = IISettingsSubject & {
    __typename?: 'RemoteUserSettings';
    /**  The ID.  */
    id?: Maybe<Scalars['ID']>;
    /**  The latest settings.  */
    latestSettings?: Maybe<ISettings>;
    /**  The URL to the settings.  */
    settingsURL: Scalars['URI'];
    /**  Whether the viewer can modify the subject's settings. */
    viewerCanAdminister: Scalars['Boolean'];
    /**
     * All settings for this subject, and the individual levels in the settings cascade (global > organization > user)
     * that were merged to produce the final merged settings.
     */
    settingsCascade: ISettingsCascade;
};
export declare type IRemoveEditor_Input = {
    editorId?: Maybe<Scalars['Int']>;
    resource?: Maybe<Scalars['String']>;
    name?: Maybe<Scalars['String']>;
};
export declare type IResolveAll_toResolve_Input = {
    resource?: Maybe<Scalars['URI']>;
    options?: Maybe<IResolveFileOptions_Input>;
};
export declare type IResolveAll_toResolveWithMetadata_Input = {
    resource?: Maybe<Scalars['URI']>;
    options?: Maybe<IResolveMetadataFileOptions_Input>;
};
export declare type IResolveFileOptions_Input = {
    /**
     * Automatically continue resolving children of a directory until the provided resources
     * are found.
     */
    resolveTo?: Maybe<Array<Maybe<Scalars['URI']>>>;
    /** Automatically continue resolving children of a directory if the number of children as 1. */
    resolveSingleChildDescendants?: Maybe<Scalars['Boolean']>;
    /**
     * Will resolve mtime, size and etag of files if enabled. Ths can have a negative impact
     * on performance and thus should only be used when these values are required.
     */
    resolveMetadata?: Maybe<Scalars['Boolean']>;
};
export declare type IResolveFileResult = {
    __typename?: 'ResolveFileResult';
    stat?: Maybe<IFileStat>;
    success: Scalars['Boolean'];
    /**  The content of a file as stream  */
    value?: Maybe<Scalars['VSBufferReadableStream']>;
};
export declare type IResolveFileResultWithMetadata = {
    __typename?: 'ResolveFileResultWithMetadata';
    stat?: Maybe<IFileStatWithMetadata>;
    success: Scalars['Boolean'];
};
/** Extension of `ResolveFileOptions_Input` with defined `resolveMedata` */
export declare type IResolveMetadataFileOptions_Input = {
    resolveTo?: Maybe<Array<Maybe<Scalars['URI']>>>;
    resolveSingleChildDescendants?: Maybe<Scalars['Boolean']>;
    resolveMetadata?: Maybe<Scalars['Boolean']>;
};
/** Resource_Input is extension of BaseResourceInput */
export declare type IResource_Input = {
    options?: Maybe<ITextEditorOptions_Input>;
    label?: Maybe<Scalars['String']>;
    description?: Maybe<Scalars['String']>;
    forceFile?: Maybe<Scalars['Boolean']>;
    forceUntitled?: Maybe<Scalars['Boolean']>;
    /** The resource URL of the resource to open. */
    resource: Scalars['URI'];
    /** The encoding of the text input if known. */
    encoding?: Maybe<Scalars['String']>;
    /**
     * The identifier of the language mode of the text input
     * if known to use when displaying the contents.
     */
    mode?: Maybe<Scalars['String']>;
};
/** Extends BaseResource_Input */
export declare type IResourceDiff_Input = {
    options?: Maybe<ITextEditorOptions_Input>;
    label?: Maybe<Scalars['String']>;
    description?: Maybe<Scalars['String']>;
    forceFile?: Maybe<Scalars['Boolean']>;
    forceUntitled?: Maybe<Scalars['Boolean']>;
    /** The left hand side URI to open inside a diff editor. */
    leftResource: Scalars['URI'];
    /** The right hand side URI to open inside a diff editor. */
    rightResource: Scalars['URI'];
};
/**
 * A read-only text editor input whoes content are made of the provided resource that points to an existing
 * code editor model.
 */
export declare type IResourceEditorInput = IIEditorInput & IIEditorInputWithGroupFields & {
    __typename?: 'ResourceEditorInput';
    id?: Maybe<Scalars['String']>;
    resource?: Maybe<Scalars['String']>;
    typeId?: Maybe<IEDITOR_INPUT_ID>;
    description?: Maybe<Scalars['String']>;
    label?: Maybe<Scalars['String']>;
    fileReference?: Maybe<IFileStatWithMetadata>;
    preferredEditorId?: Maybe<Scalars['String']>;
    isSupportsSplitEditor?: Maybe<Scalars['Boolean']>;
    isActive?: Maybe<Scalars['Boolean']>;
    preview?: Maybe<Scalars['Boolean']>;
    isPinned?: Maybe<Scalars['Boolean']>;
    editorId?: Maybe<Scalars['Int']>;
    status?: Maybe<Scalars['String']>;
    closable?: Maybe<Scalars['Boolean']>;
    mode?: Maybe<Scalars['String']>;
    preferredMode?: Maybe<Scalars['String']>;
};
export declare type IResourceEncoding = {
    __typename?: 'ResourceEncoding';
    encoding?: Maybe<Scalars['String']>;
    hasBOM?: Maybe<Scalars['Boolean']>;
};
export declare type IResourceMapConfigurationModel = {
    __typename?: 'ResourceMapConfigurationModel';
    resource?: Maybe<Scalars['URI']>;
    contents?: Maybe<Scalars['AnyObject']>;
    keys?: Maybe<Array<Maybe<Scalars['String']>>>;
    overrides?: Maybe<IConfigurationOverrides>;
};
/** Extends BaseResource_Input */
export declare type IResourceSideBySide_Input = {
    options?: Maybe<ITextEditorOptions_Input>;
    label?: Maybe<Scalars['String']>;
    description?: Maybe<Scalars['String']>;
    forceFile?: Maybe<Scalars['Boolean']>;
    forceUntitled?: Maybe<Scalars['Boolean']>;
    /** The right hand side URI to open inside a side by side editor. */
    masterResource: Scalars['URI'];
    /** The left hand side URI to open inside a side by side editor. */
    detailResource: Scalars['URI'];
};
export declare type IRunActionInWindowRequest = {
    __typename?: 'RunActionInWindowRequest';
    id: Scalars['String'];
    from?: Maybe<IRunActionInWindowRequestFrom>;
    args?: Maybe<Array<Maybe<Scalars['AnyObject']>>>;
};
export declare const enum IRunActionInWindowRequestFrom {
    menu = "menu",
    touchbar = "touchbar",
    mouse = "mouse"
}
export declare type IRunKeybindingInWindowRequest = {
    __typename?: 'RunKeybindingInWindowRequest';
    userSettingsLabel?: Maybe<Scalars['String']>;
};
export declare type ISaveDialogOptions = {
    __typename?: 'SaveDialogOptions';
    title?: Maybe<Scalars['String']>;
    defaultPath?: Maybe<Scalars['String']>;
    buttonLabel?: Maybe<Scalars['String']>;
    filters?: Maybe<Array<Maybe<IFileFilter>>>;
    message?: Maybe<Scalars['String']>;
    nameFieldLabel?: Maybe<Scalars['String']>;
    showTagField?: Maybe<Scalars['Boolean']>;
};
export declare type ISaveOptions_Input = {
    force?: Maybe<Scalars['Boolean']>;
    reason?: Maybe<SaveReason>;
    overwriteReadonly?: Maybe<Scalars['Boolean']>;
    overwriteEncoding?: Maybe<Scalars['Boolean']>;
    skipSaveParticipants?: Maybe<Scalars['Boolean']>;
    writeElevated?: Maybe<Scalars['Boolean']>;
};
export { SaveReason };
export declare type ISaveWorkspaceRes = {
    __typename?: 'SaveWorkspaceRes';
    updated?: Maybe<Scalars['Boolean']>;
    id?: Maybe<Scalars['String']>;
};
export declare const enum IscmProviders {
    git = "git"
}
export declare const enum IscmResourceGroups {
    workingTree = "workingTree",
    merge = "merge",
    index = "index"
}
export declare type IScripts = {
    __typename?: 'Scripts';
    cdebasebuild?: Maybe<Scalars['String']>;
    cdebasepublish?: Maybe<Scalars['String']>;
};
export declare type ISearch = {
    __typename?: 'Search';
    location?: Maybe<Scalars['String']>;
    smartCase?: Maybe<Scalars['Boolean']>;
    useRipgrep?: Maybe<Scalars['Boolean']>;
    useIgnoreFiles?: Maybe<Scalars['Boolean']>;
    followSymlinks?: Maybe<Scalars['Boolean']>;
    globalFindClipboard?: Maybe<Scalars['Boolean']>;
    quickOpen?: Maybe<ISearchQuickOpen>;
    exclude?: Maybe<Scalars['JSON']>;
};
export declare type ISearchQuickOpen = {
    __typename?: 'SearchQuickOpen';
    includeSymbols?: Maybe<Scalars['Boolean']>;
};
export declare type ISelectEditor_Input = {
    resource: Scalars['String'];
    editorId?: Maybe<Scalars['Int']>;
    name?: Maybe<Scalars['String']>;
};
export declare type ISelectedOutput = {
    __typename?: 'SelectedOutput';
    title?: Maybe<Scalars['String']>;
    inputValue?: Maybe<Scalars['String']>;
    selectedValue?: Maybe<Array<Maybe<IQuickPickItem>>>;
};
export declare type ISelectionStatus = IIStatusbarItem & {
    __typename?: 'SelectionStatus';
    id?: Maybe<Scalars['String']>;
    name?: Maybe<Scalars['String']>;
    alignment?: Maybe<IStatusbarAlignment>;
    entry?: Maybe<IStatusbarEntry>;
    priority?: Maybe<Scalars['Int']>;
    container?: Maybe<Scalars['String']>;
    labelContainer?: Maybe<Scalars['String']>;
    typeId?: Maybe<ISTATUSBAR_ITEM_ID>;
};
export declare type ISetStatusMsg_input = {
    id: Scalars['String'];
    message: Scalars['String'];
};
export declare type ISetting = {
    __typename?: 'Setting';
    /**  name of the settings */
    name?: Maybe<Scalars['String']>;
    range?: Maybe<IRange>;
    key?: Maybe<Scalars['String']>;
    keyRange?: Maybe<IRange>;
    /**  @deprecated  */
    default?: Maybe<Scalars['String']>;
    value?: Maybe<Scalars['AnyObject']>;
    valueRange?: Maybe<IRange>;
    description?: Maybe<Array<Maybe<Scalars['String']>>>;
    descriptionIsMarkdown?: Maybe<Scalars['Boolean']>;
    descriptionRanges?: Maybe<Array<Maybe<IRange>>>;
    overrides?: Maybe<Array<Maybe<ISetting>>>;
    overrideOf?: Maybe<ISetting>;
    deprecationMessage?: Maybe<Scalars['String']>;
    scope?: Maybe<IConfigurationScope>;
    type?: Maybe<Array<Maybe<Scalars['String']>>>;
    enum?: Maybe<Array<Maybe<Scalars['String']>>>;
    enumDescriptions?: Maybe<Array<Maybe<Scalars['String']>>>;
    enumDescriptionsAreMarkdown?: Maybe<Scalars['Boolean']>;
    tags?: Maybe<Array<Maybe<Scalars['String']>>>;
    extensionInfo?: Maybe<IConfigurationExtensionInfo>;
};
/** Settings is a version of a configuration settings file. */
export declare type ISettings = {
    __typename?: 'Settings';
    /** The time when this was created.  */
    createdAt?: Maybe<Scalars['String']>;
    /**
     * The stringified JSON contents of the settings. The contents may include "//"-style comments and trailing
     * commas in the JSON.
     */
    contents: Scalars['String'];
};
/** The configuration for all of the relevant settings subjects, plus the merged settings. */
export declare type ISettingsCascade = {
    __typename?: 'SettingsCascade';
    /**
     * The other settings subjects that are applied with lower precedence that this subject to
     * form the final merged settings. For example, a user in 2 organizations would have the following
     * settings subjects: site (global settings), org 1, org 2 and the user.
     */
    subjects?: Maybe<Array<Maybe<ISettingsSubject>>>;
    /** The effective final merged settings as (stringified) JSON, merged from all of the subjects. */
    final?: Maybe<Scalars['String']>;
    /** The effective final merged settings as Object, merged from all of the subjects. */
    finalConfiguration?: Maybe<IConfiguration>;
};
export declare type ISettingsGroup = {
    __typename?: 'SettingsGroup';
    id?: Maybe<Scalars['String']>;
    range?: Maybe<IRange>;
    title?: Maybe<Scalars['String']>;
    titleRange?: Maybe<IRange>;
    sections?: Maybe<Array<Maybe<ISettingsSection>>>;
    contributedByExtension?: Maybe<Scalars['Boolean']>;
};
export declare type ISettingsSection = {
    __typename?: 'SettingsSection';
    titleRange?: Maybe<IRange>;
    title?: Maybe<Scalars['String']>;
    settings?: Maybe<Array<Maybe<ISetting>>>;
};
export declare type ISettingsSubject = IUserSettings | ILocalUserSettings | IRemoteUserSettings | IFolderSettings | IGlobalSettings | IWorkspaceSettings | IMemorySettings | IDefaultSettings;
export declare const enum ISettingValueType {
    Null = "Null",
    Enum = "Enum",
    String = "String",
    Integer = "Integer",
    Number = "Number",
    Boolean = "Boolean",
    Exclude = "Exclude",
    Complex = "Complex",
    NullableInteger = "NullableInteger",
    NullableNumber = "NullableNumber"
}
export declare type IShell = {
    __typename?: 'Shell';
    osx?: Maybe<Scalars['String']>;
    linux?: Maybe<Scalars['String']>;
    windows?: Maybe<Scalars['String']>;
    container?: Maybe<Scalars['String']>;
};
export declare type IShellArgs = {
    __typename?: 'ShellArgs';
    container?: Maybe<Array<Maybe<Scalars['String']>>>;
    windows?: Maybe<Array<Maybe<Scalars['String']>>>;
    linux?: Maybe<Array<Maybe<Scalars['String']>>>;
    osx?: Maybe<Array<Maybe<Scalars['String']>>>;
};
export declare const enum ISideBySideEditor {
    /** Usually Right Side of the side-by-side editor */
    MASTER = "MASTER",
    /** Usually Left Side of the side-by-side editor */
    DETAILS = "DETAILS"
}
/** Side by side editor inputs that have a master and details side. */
export declare type ISideBySideEditorInput = IIEditorInput & IIEditorInputWithGroupFields & IISideBySideEditorInput & {
    __typename?: 'SideBySideEditorInput';
    id?: Maybe<Scalars['String']>;
    resource?: Maybe<Scalars['String']>;
    typeId?: Maybe<IEDITOR_INPUT_ID>;
    description?: Maybe<Scalars['String']>;
    label?: Maybe<Scalars['String']>;
    fileReference?: Maybe<IFileStatWithMetadata>;
    preferredEditorId?: Maybe<Scalars['String']>;
    isSupportsSplitEditor?: Maybe<Scalars['Boolean']>;
    isActive?: Maybe<Scalars['Boolean']>;
    preview?: Maybe<Scalars['Boolean']>;
    isPinned?: Maybe<Scalars['Boolean']>;
    editorId?: Maybe<Scalars['Int']>;
    status?: Maybe<Scalars['String']>;
    closable?: Maybe<Scalars['Boolean']>;
    master?: Maybe<IEditorInput>;
    details?: Maybe<IEditorInput>;
};
export declare type ISnippet = {
    __typename?: 'Snippet';
    language?: Maybe<Scalars['String']>;
};
export declare type IStatusbar = {
    __typename?: 'Statusbar';
    items?: Maybe<Array<Maybe<IStatusbarItem>>>;
};
export declare const enum ISTATUSBAR_ITEM_ID {
    TERMINAL = "TERMINAL",
    SELECTION_STATUS = "SELECTION_STATUS",
    INDENTATION_STATUS = "INDENTATION_STATUS",
    ENCODING_STATUS = "ENCODING_STATUS",
    EOL_STATUS = "EOL_STATUS",
    LANGUAGE_MODE_STATUS = "LANGUAGE_MODE_STATUS"
}
export declare const enum IStatusbarAlignment {
    LEFT = "LEFT",
    RIGHT = "RIGHT"
}
export declare type IStatusbarEntry = {
    __typename?: 'StatusbarEntry';
    showTabsButtons?: Maybe<Scalars['Boolean']>;
    showIcons?: Maybe<Scalars['Boolean']>;
    showStatusbar?: Maybe<Scalars['Boolean']>;
    text: Scalars['String'];
    ariaLabel?: Maybe<Scalars['String']>;
    tooltip?: Maybe<Scalars['String']>;
    color?: Maybe<Scalars['String']>;
    backgroundColor?: Maybe<Scalars['String']>;
    command?: Maybe<Scalars['String']>;
    arguments?: Maybe<Array<Maybe<Scalars['String']>>>;
    showBeak?: Maybe<Scalars['Boolean']>;
};
export declare type IStatusbarEntry_input = {
    showTabsButtons?: Maybe<Scalars['Boolean']>;
    showIcons?: Maybe<Scalars['Boolean']>;
    showStatusbar?: Maybe<Scalars['Boolean']>;
    text: Scalars['String'];
    ariaLabel?: Maybe<Scalars['String']>;
    tooltip?: Maybe<Scalars['String']>;
    color?: Maybe<Scalars['String']>;
    backgroundColor?: Maybe<Scalars['String']>;
    command?: Maybe<Scalars['String']>;
    arguments?: Maybe<Array<Maybe<Scalars['String']>>>;
    showBeak?: Maybe<Scalars['Boolean']>;
};
export declare type IStatusbarItem = ITerminal | ISelectionStatus | IIndentation | IEncodingStatus | IEndOfLineSequence | ILanguageMode;
export declare const enum IStorageScope {
    /** The stored data will be scoped to all workspaces of this domain. */
    GLOBAL = "GLOBAL",
    /** The stored data will be scoped to the current workspace. */
    WORKSPACE = "WORKSPACE"
}
export declare type IStreamContent = {
    __typename?: 'StreamContent';
    resource?: Maybe<Scalars['String']>;
    name?: Maybe<Scalars['String']>;
    mtime?: Maybe<Scalars['BigInt']>;
    etag?: Maybe<Scalars['String']>;
    value?: Maybe<Scalars['String']>;
    status?: Maybe<Scalars['String']>;
    encoding?: Maybe<Scalars['String']>;
    linesRange?: Maybe<ILineRange>;
};
export declare type ISubscription = {
    __typename?: 'Subscription';
    dummy?: Maybe<Scalars['Int']>;
    fileData?: Maybe<Array<Maybe<IFileChange>>>;
    fileOperation?: Maybe<IFileOperationOutput>;
    onDidChangeConfiguration?: Maybe<IIConfigurationChangeEvent>;
    /** Doesn't work yet */
    readStreamTextFile?: Maybe<ITextFileStreamContent>;
    /** Streams content in string chunks */
    readStreamTextString?: Maybe<ITextFilePublishContent>;
};
export declare type ISubscriptionfileDataArgs = {
    resource: Scalars['URI'];
};
export declare type ISubscriptionfileOperationArgs = {
    resource: Scalars['URI'];
};
export declare type ISubscriptionreadStreamTextFileArgs = {
    resource: Scalars['URI'];
};
export declare type ISubscriptionreadStreamTextStringArgs = {
    resource: Scalars['URI'];
};
export declare const enum ITabCloseButtonType {
    left = "left",
    right = "right",
    off = "off"
}
export declare const enum ITabSizingType {
    fit = "fit",
    shrink = "shrink"
}
export declare type ITerminal = IIStatusbarItem & {
    __typename?: 'Terminal';
    alignment?: Maybe<IStatusbarAlignment>;
    container?: Maybe<Scalars['String']>;
    entry?: Maybe<IStatusbarEntry>;
    id?: Maybe<Scalars['String']>;
    integrated?: Maybe<IIntegrated>;
    labelContainer?: Maybe<Scalars['String']>;
    name?: Maybe<Scalars['String']>;
    priority?: Maybe<Scalars['Int']>;
    typeId?: Maybe<ISTATUSBAR_ITEM_ID>;
};
export declare type ITextBufferData = {
    __typename?: 'TextBufferData';
    EOL?: Maybe<Scalars['String']>;
    lines?: Maybe<Array<Maybe<Scalars['String']>>>;
    containsRTL?: Maybe<Scalars['Boolean']>;
    isBasicASCII?: Maybe<Scalars['Boolean']>;
};
/** Extension of EditorOptions_Input */
export declare type ITextEditorOptions_Input = {
    /**
     * Tells the editor to not receive keyboard focus when the editor is being opened. By default,
     * the editor will receive keyboard focus on open.
     */
    preserveFocus?: Maybe<Scalars['Boolean']>;
    /**
     * Tells the editor to reload the editor input in the editor even if it is identical to the one
     * already showing. By default, the editor will not reload the input if it is identical to the
     * one showing.
     */
    forceReload?: Maybe<Scalars['Boolean']>;
    /**
     * Will reveal the editor if it is already opened and visible in any of the opened editor groups. Note
     * that this option is just a hint that might be ignored if the user wants to open an editor explicitly
     * to the side of another one or into a specific editor group.
     */
    revealIfVisible?: Maybe<Scalars['Boolean']>;
    /**
     * Will reveal the editor if it is already opened (even when not visible) in any of the opened editor groups. Note
     * that this option is just a hint that might be ignored if the user wants to open an editor explicitly
     * to the side of another one or into a specific editor group.
     */
    revealIfOpened?: Maybe<Scalars['Boolean']>;
    /**
     * An editor that is pinned remains in the editor stack even when another editor is being opened.
     * An editor that is not pinned will always get replaced by another editor that is not pinned.
     */
    pinned?: Maybe<Scalars['Boolean']>;
    /** The index in the document stack where to insert the editor into when opening. */
    index?: Maybe<Scalars['Int']>;
    /**
     * An active editor that is opened will show its contents directly. Set to true to open an editor
     * in the background.
     */
    inactive?: Maybe<Scalars['Boolean']>;
    /**
     * Will not show an error in case opening the editor fails and thus allows to show a custom error
     * message as needed. By default, an error will be presented as notification if opening was not possible.
     */
    ignoreError?: Maybe<Scalars['Boolean']>;
    /** Text editor selection. */
    selection?: Maybe<ITextEditorSelection_Input>;
    /** Text editor view state. */
    viewState?: Maybe<Scalars['AnyObject']>;
    /**
     * Option to scroll vertically or horizontally as necessary and reveal a range
     * centered vertically only if it lies outside the viewport.
     */
    revealInCenterIfOutsideViewPort?: Maybe<Scalars['Boolean']>;
};
export declare type ITextEditorSelection_Input = {
    startLineNumber: Scalars['Int'];
    startColumn: Scalars['Int'];
    endLineNumber?: Maybe<Scalars['Int']>;
    endColumn?: Maybe<Scalars['Int']>;
};
export declare type ITextFileContent = IIBaseStat & IIBaseStatWithMetadata & IIBaseTextFileContent & IIFileClientMetadata & {
    __typename?: 'TextFileContent';
    /** Content of the file is modified */
    dirty?: Maybe<Scalars['Boolean']>;
    /** Encoding as reported from disk */
    encoding?: Maybe<Scalars['String']>;
    etag: Scalars['String'];
    /** File is in conflict with storage. */
    inConflictMode?: Maybe<Scalars['Boolean']>;
    /** File is in Error */
    inErrorMode?: Maybe<Scalars['Boolean']>;
    /** File doesn't exist in the storage */
    inOrphanMode?: Maybe<Scalars['Boolean']>;
    /** Pending Save */
    inPendingSave?: Maybe<Scalars['Boolean']>;
    isReadonly?: Maybe<Scalars['Boolean']>;
    mtime: Scalars['BigInt'];
    name: Scalars['String'];
    /** Encoding as chosen by the user */
    preferredEncoding?: Maybe<Scalars['String']>;
    preferredMode?: Maybe<Scalars['String']>;
    resource: Scalars['URI'];
    size: Scalars['Int'];
    /** States the text file editor model can be in. */
    state?: Maybe<IFileModelState>;
    /** The content of a text file. */
    value?: Maybe<Scalars['String']>;
};
export declare const enum ITextFileOperationResult {
    FILE_IS_BINARY = "FILE_IS_BINARY"
}
export declare type ITextFilePublishContent = IIBaseTextFileContent & IIBaseStat & {
    __typename?: 'TextFilePublishContent';
    resource: Scalars['URI'];
    name: Scalars['String'];
    mtime?: Maybe<Scalars['BigInt']>;
    etag?: Maybe<Scalars['String']>;
    size?: Maybe<Scalars['Int']>;
    isReadonly?: Maybe<Scalars['Boolean']>;
    streamSeq?: Maybe<Scalars['Int']>;
    encoding?: Maybe<Scalars['String']>;
    /** The content of the file in parts */
    value?: Maybe<Scalars['String']>;
    status?: Maybe<FileContentStatus>;
};
export declare const enum ITextFileServiceAction {
    onWillMove = "onWillMove",
    onAutoSaveConfigurationChange = "onAutoSaveConfigurationChange",
    onFilesAssociationChange = "onFilesAssociationChange",
    isHotExistEnabled = "isHotExistEnabled",
    encoding = "encoding",
    isDirty = "isDirty",
    getDirty = "getDirty",
    save = "save",
    saveAs = "saveAs",
    saveAll = "saveAll",
    revert = "revert",
    revertAll = "revertAll",
    create = "create",
    read = "read",
    readStream = "readStream",
    readStringStream = "readStringStream",
    write = "write",
    writeChunkWithDelay = "writeChunkWithDelay",
    writeChunk = "writeChunk",
    writeStream = "writeStream",
    delete = "delete",
    move = "move",
    confirmSave = "confirmSave",
    getAutoSaveMode = "getAutoSaveMode",
    getAutoSaveConfiguration = "getAutoSaveConfiguration"
}
export declare type ITextFileStreamContent = IIBaseTextFileContent & IIBaseStatWithMetadata & IIBaseStat & {
    __typename?: 'TextFileStreamContent';
    resource: Scalars['URI'];
    name: Scalars['String'];
    size: Scalars['Int'];
    mtime: Scalars['BigInt'];
    etag: Scalars['String'];
    isReadonly?: Maybe<Scalars['Boolean']>;
    encoding?: Maybe<Scalars['String']>;
    /** The line grouped content of a text file. */
    value?: Maybe<ITextBufferData>;
};
export declare type IThemeLabel = {
    __typename?: 'ThemeLabel';
    label?: Maybe<Scalars['String']>;
    uiTheme?: Maybe<Scalars['String']>;
    path?: Maybe<Scalars['String']>;
};
export declare type ITreeData_Input = {
    path?: Maybe<Scalars['String']>;
    title?: Maybe<Scalars['String']>;
    subtitle?: Maybe<Scalars['String']>;
    isDirectory?: Maybe<Scalars['Boolean']>;
    active?: Maybe<Scalars['Boolean']>;
    expanded?: Maybe<Scalars['Boolean']>;
    hasChildren?: Maybe<Scalars['Boolean']>;
    childrenGen?: Maybe<Scalars['JSON']>;
};
/** An editor input to be used for untitled text buffers. */
export declare type IUntitledEditorInput = IIEditorInput & IIEditorInputWithGroupFields & {
    __typename?: 'UntitledEditorInput';
    id?: Maybe<Scalars['String']>;
    resource?: Maybe<Scalars['String']>;
    typeId?: Maybe<IEDITOR_INPUT_ID>;
    description?: Maybe<Scalars['String']>;
    label?: Maybe<Scalars['String']>;
    fileReference?: Maybe<IFileStatWithMetadata>;
    preferredEditorId?: Maybe<Scalars['String']>;
    isSupportsSplitEditor?: Maybe<Scalars['Boolean']>;
    isActive?: Maybe<Scalars['Boolean']>;
    preview?: Maybe<Scalars['Boolean']>;
    isPinned?: Maybe<Scalars['Boolean']>;
    editorId?: Maybe<Scalars['Int']>;
    status?: Maybe<Scalars['String']>;
    closable?: Maybe<Scalars['Boolean']>;
    hasAssociatedFilePath?: Maybe<Scalars['Boolean']>;
    shortDescription?: Maybe<Scalars['String']>;
    mediumDescription?: Maybe<Scalars['String']>;
    longDescription?: Maybe<Scalars['String']>;
    shortTitle?: Maybe<Scalars['String']>;
    mediumTitle?: Maybe<Scalars['String']>;
    longTitle?: Maybe<Scalars['String']>;
    suggestFileName?: Maybe<Scalars['String']>;
    enconding?: Maybe<Scalars['String']>;
    mode?: Maybe<Scalars['String']>;
};
/** Extension of BaseResource_Input */
export declare type IUntitledResource_Input = {
    options?: Maybe<ITextEditorOptions_Input>;
    label?: Maybe<Scalars['String']>;
    description?: Maybe<Scalars['String']>;
    forceFile?: Maybe<Scalars['Boolean']>;
    forceUntitled?: Maybe<Scalars['Boolean']>;
    /**
     * Optional resource. If the resource is not provided a new untitled file is created (e.g. Untitled-1).
     * Otherwise the untitled editor will have an associated path and use that when saving.
     */
    resource?: Maybe<Scalars['URI']>;
    /**
     * Optional file path. Using the file resource will associate the file to the untitled resource.
     *    @deprecated
     */
    filePath?: Maybe<Scalars['String']>;
    /** Optional language of the untitled resource. */
    mode?: Maybe<Scalars['String']>;
    /** Optional contents of the untitled resource. */
    contents?: Maybe<Scalars['String']>;
    /** Optional encoding of the untitled resource. */
    encoding?: Maybe<Scalars['String']>;
};
export declare type IUpdateDelayedResource = {
    __typename?: 'UpdateDelayedResource';
    resource?: Maybe<Scalars['URI']>;
};
export declare type IUpdatedResource = {
    __typename?: 'UpdatedResource';
    resource?: Maybe<Scalars['URI']>;
    etag?: Maybe<Scalars['String']>;
};
export declare type IUpdateEntry_input = {
    id?: Maybe<Scalars['String']>;
    alignment?: Maybe<Scalars['String']>;
    entry?: Maybe<IStatusbarEntry_input>;
    priority?: Maybe<Scalars['Int']>;
    container?: Maybe<Scalars['String']>;
    labelContainer?: Maybe<Scalars['String']>;
};
export declare type IURIInput = {
    path?: Maybe<Scalars['String']>;
    scheme?: Maybe<Scalars['String']>;
    authority?: Maybe<Scalars['String']>;
    query?: Maybe<Scalars['String']>;
    fragment?: Maybe<Scalars['String']>;
    fsPath?: Maybe<Scalars['String']>;
};
export declare type IURIToOpen = IWorkspaceToOpen | IFolderToOpen | IFileToOpen;
export declare type IUserPreferencesRes = {
    __typename?: 'UserPreferencesRes';
    prefs?: Maybe<IIUserPreferences>;
};
/** UserSettings is a combination of LocalUserSettings and RemoteUserSettings */
export declare type IUserSettings = IISettingsSubject & {
    __typename?: 'UserSettings';
    /**  The ID.  */
    id?: Maybe<Scalars['ID']>;
    /**
     * The latest settings for the user.
     *
     * Only the user and site admins can access this field.
     */
    latestSettings?: Maybe<ISettings>;
    /** The URL to the user's settings. */
    settingsURL: Scalars['URI'];
    /**
     * Whether the viewer has admin privileges on this user. The user has admin privileges on their own user, and
     * site admins have admin privileges on all users.
     */
    viewerCanAdminister: Scalars['Boolean'];
    /**
     * All settings for this user, and the individual levels in the settings cascade (global > organization > user)
     * that were merged to produce the final merged settings.
     *
     * Only the user and site admins can access this field.
     */
    settingsCascade: ISettingsCascade;
};
export declare type IView = {
    __typename?: 'View';
    id?: Maybe<Scalars['ID']>;
    name?: Maybe<Scalars['String']>;
};
export declare type IViewContainer = {
    __typename?: 'ViewContainer';
    id?: Maybe<Scalars['ID']>;
    title?: Maybe<Scalars['String']>;
};
export declare type IViewState = {
    __typename?: 'ViewState';
    scrollTop?: Maybe<Scalars['Int']>;
    scrollTopWithoutViewZones?: Maybe<Scalars['Int']>;
    scrollLeft?: Maybe<Scalars['Int']>;
    firstPosition?: Maybe<IPosition>;
    firstPositionDeltaTop?: Maybe<Scalars['Int']>;
};
export declare type IViewState_Input = {
    scrollTop?: Maybe<Scalars['Int']>;
    scrollTopWithoutViewZones?: Maybe<Scalars['Int']>;
    scrollLeft?: Maybe<Scalars['Int']>;
    firstPosition?: Maybe<IPositionInput>;
    firstPositionDeltaTop?: Maybe<Scalars['Int']>;
};
export declare type IWatchOptions_Input = {
    recursive?: Maybe<Scalars['Boolean']>;
    excludes?: Maybe<Array<Maybe<Scalars['String']>>>;
    session?: Maybe<Scalars['String']>;
};
export declare type IWindowConfiguration = {
    __typename?: 'WindowConfiguration';
    machineId?: Maybe<Scalars['String']>;
    windowId?: Maybe<Scalars['Int']>;
    logLevel?: Maybe<Scalars['String']>;
    mainPid?: Maybe<Scalars['String']>;
    appRoot?: Maybe<Scalars['String']>;
    execPath?: Maybe<Scalars['String']>;
    isInitialStartup?: Maybe<Scalars['Boolean']>;
    nodeCacheDataDir?: Maybe<Scalars['String']>;
    backupPath?: Maybe<Scalars['String']>;
    workspace?: Maybe<IWorkspaceIdentifier>;
    /** A single folder workspace identifier is just the path to the folder. */
    folderUri?: Maybe<Scalars['URI']>;
    remoteAuthority?: Maybe<Scalars['String']>;
    zoomLevel?: Maybe<Scalars['Int']>;
    fullscreen?: Maybe<Scalars['Boolean']>;
    maximized?: Maybe<Scalars['Boolean']>;
    highContrast?: Maybe<Scalars['Boolean']>;
    frameless?: Maybe<Scalars['Boolean']>;
    accessibilitySupport?: Maybe<Scalars['Boolean']>;
    partsSplashPath?: Maybe<Scalars['String']>;
    perfStartTime?: Maybe<Scalars['Int']>;
    perfAppReady?: Maybe<Scalars['Int']>;
    perfWindowLoadTime?: Maybe<Scalars['Int']>;
    perfEntries?: Maybe<Scalars['AnyObject']>;
    filesToOpenOrCreate?: Maybe<Array<Maybe<IPath>>>;
    filesToDiff?: Maybe<Array<Maybe<IPath>>>;
    filesToWait?: Maybe<IPathsToWaitFor>;
    termProgram?: Maybe<Scalars['String']>;
};
export declare const enum IWorkspaceContextServiceAction {
    getWorkspace = "getWorkspace",
    onDidChangeWorkbenchState = "onDidChangeWorkbenchState",
    onDidChangeWorkspaceName = "onDidChangeWorkspaceName",
    onDidChangeWorkspaceFolders = "onDidChangeWorkspaceFolders",
    addFolders = "addFolders",
    removeFolders = "removeFolders",
    updateFolders = "updateFolders"
}
export declare type IWorkspaceData = IIStaticWorkspaceData & {
    __typename?: 'WorkspaceData';
    /** The unique identifier of the workspace. */
    id: Scalars['String'];
    /** Folders in the workspace. */
    folders: Array<Maybe<IWorkspaceFolderData>>;
    /** The location of the workspace configuration */
    configuration?: Maybe<Scalars['URI']>;
    name?: Maybe<Scalars['String']>;
    isUntitled?: Maybe<Scalars['Boolean']>;
};
export declare type IWorkspaceFolderData = {
    __typename?: 'WorkspaceFolderData';
    /** The associated URI for this workspace folder. */
    uri?: Maybe<Scalars['URI']>;
    /** The name of this workspace folder. Defaults to the basename its [uri-path](#Uri.path) */
    name: Scalars['String'];
    /** The ordinal number of this workspace folder. */
    index: Scalars['Int'];
};
export declare type IWorkspaceIdentifier = {
    __typename?: 'WorkspaceIdentifier';
    id?: Maybe<Scalars['String']>;
    configPath?: Maybe<Scalars['URI']>;
};
export declare type IWorkspacePreferenceActivityBar = {
    __typename?: 'WorkspacePreferenceActivityBar';
    visible?: Maybe<Scalars['Boolean']>;
};
export declare type IWorkspacePreferenceCommandPalette = {
    __typename?: 'WorkspacePreferenceCommandPalette';
    history?: Maybe<Scalars['Int']>;
    preserveInput?: Maybe<Scalars['Boolean']>;
};
export declare type IWorkspacePreferenceEditor = {
    __typename?: 'WorkspacePreferenceEditor';
    centeredLayoutAutoResize?: Maybe<Scalars['Boolean']>;
    closeEmptyGroups?: Maybe<Scalars['Boolean']>;
    closeOnFileDelete?: Maybe<Scalars['Boolean']>;
    enablePreview?: Maybe<Scalars['Boolean']>;
    enablePreviewFromQuickOpen?: Maybe<Scalars['Boolean']>;
    focusRecentEditorAfterClose?: Maybe<Scalars['Boolean']>;
    highlightModifiedTabs?: Maybe<Scalars['Boolean']>;
    labelFormat?: Maybe<Scalars['String']>;
    openPositioning?: Maybe<Scalars['String']>;
    openSideBySideDirection?: Maybe<Scalars['String']>;
    restoreViewState?: Maybe<Scalars['Boolean']>;
    revealIfOpen?: Maybe<Scalars['Boolean']>;
    showIcons?: Maybe<Scalars['Boolean']>;
    showTabs?: Maybe<Scalars['Boolean']>;
    splitSizing?: Maybe<Scalars['String']>;
    tabCloseButton?: Maybe<Scalars['String']>;
    tabSizing?: Maybe<Scalars['String']>;
};
export declare type IWorkspacePreferenceExperimental = {
    __typename?: 'WorkspacePreferenceExperimental';
    editorAssociations?: Maybe<Array<Maybe<Scalars['String']>>>;
};
export declare type IWorkspacePreferenceList = {
    __typename?: 'WorkspacePreferenceList';
    automaticKeyboardNavigation?: Maybe<Scalars['Boolean']>;
    horizontalScrolling?: Maybe<Scalars['Boolean']>;
    keyboardNavigation?: Maybe<Scalars['String']>;
    multiSelectModifier?: Maybe<Scalars['String']>;
    openMode?: Maybe<Scalars['String']>;
};
export declare type IWorkspacePreferencePanel = {
    __typename?: 'WorkspacePreferencePanel';
    defaultLocation?: Maybe<Scalars['String']>;
};
export declare type IWorkspacePreferenceQuickOpen = {
    __typename?: 'WorkspacePreferenceQuickOpen';
    closeOnFocusLost?: Maybe<Scalars['Boolean']>;
    preserveInput?: Maybe<Scalars['Boolean']>;
};
export declare type IWorkspacePreferenceSettings = {
    __typename?: 'WorkspacePreferenceSettings';
    editor?: Maybe<Scalars['String']>;
    enableNaturalLanguageSearch?: Maybe<Scalars['Boolean']>;
    openDefaultKeybindings?: Maybe<Scalars['Boolean']>;
    settingsSearchTocBehavior?: Maybe<Scalars['String']>;
    useSplitJSON?: Maybe<Scalars['Boolean']>;
};
export declare type IWorkspacePreferenceSideBar = {
    __typename?: 'WorkspacePreferenceSideBar';
    location?: Maybe<Scalars['String']>;
};
export declare type IWorkspacePreferenceStatusBar = {
    __typename?: 'WorkspacePreferenceStatusBar';
    visible?: Maybe<Scalars['Boolean']>;
};
export declare type IWorkspacePreferenceTips = {
    __typename?: 'WorkspacePreferenceTips';
    enabled?: Maybe<Scalars['Boolean']>;
    horizontalScrolling?: Maybe<Scalars['Boolean']>;
    indent?: Maybe<Scalars['Int']>;
    renderIndentGuides?: Maybe<Scalars['String']>;
};
export declare type IWorkspacePreferenceView = {
    __typename?: 'WorkspacePreferenceView';
    alwaysShowHeaderActions?: Maybe<Scalars['Boolean']>;
};
export declare type IWorkspacePreferenceWorkbench = {
    __typename?: 'WorkspacePreferenceWorkbench';
    colorTheme?: Maybe<Scalars['String']>;
    enableExperiments?: Maybe<Scalars['Boolean']>;
    fontAliasing?: Maybe<Scalars['String']>;
    iconTheme?: Maybe<Scalars['String']>;
    startupEditor?: Maybe<Scalars['String']>;
    view?: Maybe<IWorkspacePreferenceView>;
    tips?: Maybe<IWorkspacePreferenceTips>;
    statusBar?: Maybe<IWorkspacePreferenceStatusBar>;
    sideBar?: Maybe<IWorkspacePreferenceSideBar>;
    settings?: Maybe<IWorkspacePreferenceSettings>;
    quickOpen?: Maybe<IWorkspacePreferenceQuickOpen>;
    panel?: Maybe<IWorkspacePreferencePanel>;
    list?: Maybe<IWorkspacePreferenceList>;
    experimental?: Maybe<IWorkspacePreferenceExperimental>;
    editor?: Maybe<IWorkspacePreferenceEditor>;
    commandPalette?: Maybe<IWorkspacePreferenceCommandPalette>;
    activityBar?: Maybe<IWorkspacePreferenceActivityBar>;
};
export declare type IWorkspaceRes = {
    __typename?: 'WorkspaceRes';
    uri?: Maybe<Scalars['String']>;
};
export declare type IWorkspaceSettings = IISettingsSubject & {
    __typename?: 'WorkspaceSettings';
    /**  The ID.  */
    id?: Maybe<Scalars['ID']>;
    /**  The latest settings.  */
    latestSettings?: Maybe<ISettings>;
    /**  The URL to the settings.  */
    settingsURL: Scalars['URI'];
    /**  Whether the viewer can modify the subject's settings. */
    viewerCanAdminister: Scalars['Boolean'];
    /**
     * All settings for this subject, and the individual levels in the settings cascade (global > organization > user)
     * that were merged to produce the final merged settings.
     */
    settingsCascade: ISettingsCascade;
};
export declare type IWorkspaceStackSettings = {
    __typename?: 'WorkspaceStackSettings';
    dummy?: Maybe<Scalars['Int']>;
};
export declare type IWorkspaceToOpen = {
    __typename?: 'WorkspaceToOpen';
    workspaceUri: Scalars['URI'];
    label?: Maybe<Scalars['String']>;
};
export declare type IWorkspaceValue_Input = {
    section?: Maybe<Scalars['String']>;
    overrides?: Maybe<IConfigurationOverrides_Input>;
};
export declare type IWriteFileOptions_Input = {
    /** The last known modification time of the file. This can be used to prevent dirty writes. */
    mtime?: Maybe<Scalars['BigInt']>;
    /** The etag of the file. This can be used to prevent dirty writes. */
    etag?: Maybe<Scalars['String']>;
};
/** It is an extension to WriteFileOptions_Input with few more options. */
export declare type IWriteTextFileOptions_Input = {
    mtime?: Maybe<Scalars['BigInt']>;
    etag?: Maybe<Scalars['String']>;
    /** The encoding to use when updating a file. */
    encoding?: Maybe<Scalars['String']>;
    /** If set to true, will enforce the selected encoding and not perform any detection using BOM's. */
    overwriteEncoding?: Maybe<Scalars['Boolean']>;
    /** Whether to overwrite a file even if is readonly. */
    overwriteReadonly?: Maybe<Scalars['Boolean']>;
    /**
     * Whether to write to the file as elevated (admin) user. When setting this option a prompt will
     * ask the user to authenticate as super user.
     */
    writeElevated?: Maybe<Scalars['Boolean']>;
};
export declare type IEditorsFileRefFragment = ({
    __typename?: 'FileStatWithMetadata';
} & Pick<IFileStatWithMetadata, 'resource' | 'name' | 'isDirectory' | 'isSymbolicLink' | 'isReadonly' | 'dirty' | 'size' | 'state' | 'preferredMode' | 'encoding'> & {
    title: IFileStatWithMetadata['name'];
});
export declare type IChangeDirtyStateOnFileStatFragment = ({
    __typename?: 'FileStatWithMetadata';
} & Pick<IFileStatWithMetadata, 'dirty'>);
export declare type IchangedEventFragment = ({
    __typename?: 'FileStatWithMetadata';
} & Pick<IFileStatWithMetadata, 'changes' | 'eol' | 'versionId' | 'isUndoing' | 'isRedoing' | 'isFlush'>);
export declare type IChangesOnChangedEventFragment = ({
    __typename?: 'FileStatWithMetadata';
} & Pick<IFileStatWithMetadata, 'changes'>);
export declare type IFileContentFragment = ({
    __typename?: 'FileContent';
} & Pick<IFileContent, 'resource' | 'name' | 'size' | 'mtime' | 'etag' | 'value' | 'isReadonly'>);
export declare type ITextContentFragment = ({
    __typename?: 'TextFileContent';
} & Pick<ITextFileContent, 'resource' | 'name' | 'size' | 'mtime' | 'etag' | 'value' | 'encoding' | 'isReadonly'>);
export declare type IEditorStateFragment = ({
    __typename?: 'CodeEditorViewState';
} & Pick<ICodeEditorViewState, 'cursorState' | 'viewState' | 'contributionsState'>);
export declare type IFileParentChildRefFragment = ({
    __typename?: 'FileStatWithMetadata';
} & {
    children?: Maybe<Array<Maybe<({
        __typename?: 'FileStatWithMetadata';
    } & Pick<IFileStatWithMetadata, 'resource'>)>>>;
});
export declare type IFileSaveConfigFragment = ({
    __typename?: 'Configuration';
} & {
    files?: Maybe<({
        __typename?: 'Files';
    } & Pick<IFiles, 'autoSave' | 'autoSaveDelay'>)>;
});
export declare type IFileSelfStatFragment = ({
    __typename?: 'FileStatWithMetadata';
} & Pick<IFileStatWithMetadata, 'resourcePath' | 'resource' | 'name' | 'isDirectory' | 'isSymbolicLink' | 'isReadonly' | 'size' | 'mtime' | 'etag' | 'expanded' | 'hasChildren' | 'dirty' | 'inConflictMode' | 'inOrphanMode' | 'inErrorMode' | 'inPendingSave' | 'preferredMode' | 'preferredEncoding' | 'encoding' | 'state'> & {
    title: IFileStatWithMetadata['name'];
});
export declare type IFileStatNestedChildFragment = ({
    __typename?: 'FileStatWithMetadata';
} & {
    children?: Maybe<Array<Maybe<({
        __typename?: 'FileStatWithMetadata';
    } & {
        children?: Maybe<Array<Maybe<({
            __typename?: 'FileStatWithMetadata';
        } & {
            children?: Maybe<Array<Maybe<({
                __typename?: 'FileStatWithMetadata';
            } & {
                children?: Maybe<Array<Maybe<({
                    __typename?: 'FileStatWithMetadata';
                } & {
                    children?: Maybe<Array<Maybe<({
                        __typename?: 'FileStatWithMetadata';
                    } & {
                        children?: Maybe<Array<Maybe<({
                            __typename?: 'FileStatWithMetadata';
                        } & {
                            children?: Maybe<Array<Maybe<({
                                __typename?: 'FileStatWithMetadata';
                            } & {
                                children?: Maybe<Array<Maybe<({
                                    __typename?: 'FileStatWithMetadata';
                                } & IFileSelfStatFragment)>>>;
                            } & IFileSelfStatFragment)>>>;
                        } & IFileSelfStatFragment)>>>;
                    } & IFileSelfStatFragment)>>>;
                } & IFileSelfStatFragment)>>>;
            } & IFileSelfStatFragment)>>>;
        } & IFileSelfStatFragment)>>>;
    } & IFileSelfStatFragment)>>>;
});
export declare type IFilesTreeDataFragment = ({
    __typename?: 'FileStatWithMetadata';
} & {
    children?: Maybe<Array<Maybe<({
        __typename?: 'FileStatWithMetadata';
    } & {
        children?: Maybe<Array<Maybe<({
            __typename?: 'FileStatWithMetadata';
        } & {
            children?: Maybe<Array<Maybe<({
                __typename?: 'FileStatWithMetadata';
            } & {
                children?: Maybe<Array<Maybe<({
                    __typename?: 'FileStatWithMetadata';
                } & {
                    children?: Maybe<Array<Maybe<({
                        __typename?: 'FileStatWithMetadata';
                    } & {
                        children?: Maybe<Array<Maybe<({
                            __typename?: 'FileStatWithMetadata';
                        } & {
                            children?: Maybe<Array<Maybe<({
                                __typename?: 'FileStatWithMetadata';
                            } & {
                                children?: Maybe<Array<Maybe<({
                                    __typename?: 'FileStatWithMetadata';
                                } & IFilesTreeItemFragment)>>>;
                            } & IFilesTreeItemFragment)>>>;
                        } & IFilesTreeItemFragment)>>>;
                    } & IFilesTreeItemFragment)>>>;
                } & IFilesTreeItemFragment)>>>;
            } & IFilesTreeItemFragment)>>>;
        } & IFilesTreeItemFragment)>>>;
    } & IFilesTreeItemFragment)>>>;
} & IFilesTreeItemFragment);
export declare type IFilesTreeDataMiniFragment = ({
    __typename?: 'FileStatWithMetadata';
} & {
    children?: Maybe<Array<Maybe<({
        __typename?: 'FileStatWithMetadata';
    } & {
        children?: Maybe<Array<Maybe<({
            __typename?: 'FileStatWithMetadata';
        } & {
            children?: Maybe<Array<Maybe<({
                __typename?: 'FileStatWithMetadata';
            } & {
                children?: Maybe<Array<Maybe<({
                    __typename?: 'FileStatWithMetadata';
                } & {
                    children?: Maybe<Array<Maybe<({
                        __typename?: 'FileStatWithMetadata';
                    } & {
                        children?: Maybe<Array<Maybe<({
                            __typename?: 'FileStatWithMetadata';
                        } & {
                            children?: Maybe<Array<Maybe<({
                                __typename?: 'FileStatWithMetadata';
                            } & {
                                children?: Maybe<Array<Maybe<({
                                    __typename?: 'FileStatWithMetadata';
                                } & IFilesTreeItemMiniFragment)>>>;
                            } & IFilesTreeItemMiniFragment)>>>;
                        } & IFilesTreeItemMiniFragment)>>>;
                    } & IFilesTreeItemMiniFragment)>>>;
                } & IFilesTreeItemMiniFragment)>>>;
            } & IFilesTreeItemMiniFragment)>>>;
        } & IFilesTreeItemMiniFragment)>>>;
    } & IFilesTreeItemMiniFragment)>>>;
} & IFilesTreeItemMiniFragment);
export declare type IFilesTreeItemMiniFragment = ({
    __typename?: 'FileStatWithMetadata';
} & Pick<IFileStatWithMetadata, 'expanded'>);
export declare type IFilesTreeItemFragment = ({
    __typename?: 'FileStatWithMetadata';
} & Pick<IFileStatWithMetadata, 'name' | 'resourcePath' | 'path' | 'mtime' | 'etag' | 'isDirectory' | 'hasChildren' | 'expanded' | 'size'> & {
    title: IFileStatWithMetadata['name'];
});
export declare type ISelectedResourceFragment = ({
    __typename?: 'Context';
} & Pick<IContext, 'resource' | 'isFileSystemResource'>);
export declare type ITextFileOnFileStatFragment = ({
    __typename?: 'FileStatWithMetadata';
} & Pick<IFileStatWithMetadata, 'resource' | 'name' | 'mtime' | 'etag' | 'size' | 'isReadonly' | 'dirty' | 'inConflictMode' | 'inOrphanMode' | 'inErrorMode' | 'inPendingSave' | 'versionId' | 'preferredMode' | 'preferredEncoding'> & {
    contentEncoding: IFileStatWithMetadata['encoding'];
});
export declare type ITextFileOnFileStatLiteFragment = ({
    __typename?: 'FileStatWithMetadata';
} & Pick<IFileStatWithMetadata, 'resource' | 'name' | 'mtime' | 'etag' | 'size' | 'isReadonly' | 'dirty' | 'inConflictMode' | 'inOrphanMode' | 'inErrorMode' | 'inPendingSave' | 'preferredMode' | 'preferredEncoding'> & {
    contentEncoding: IFileStatWithMetadata['encoding'];
});
export declare type IUntitledFileOnFileStatFragment = ({
    __typename?: 'FileStatWithMetadata';
} & Pick<IFileStatWithMetadata, 'resource' | 'name' | 'dirty'>);
export declare type IUntitledFileStatFragment = ({
    __typename?: 'FileStatWithMetadata';
} & Pick<IFileStatWithMetadata, 'value'> & IFileSelfStatFragment);
export declare type IUpdateErrorFileOnFileStatFragment = ({
    __typename?: 'FileStatWithMetadata';
} & Pick<IFileStatWithMetadata, 'inConflictMode' | 'inErrorMode' | 'state'>);
export declare type ICanHandleResource_WSMutationVariables = {
    resource: Scalars['URI'];
};
export declare type ICanHandleResource_WSMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'canHandleResource'>);
export declare type ICopyFile_WSMutationVariables = {
    source: Scalars['URI'];
    target: Scalars['URI'];
    overwrite?: Maybe<Scalars['Boolean']>;
};
export declare type ICopyFile_WSMutation = ({
    __typename?: 'Mutation';
} & {
    copyFile?: Maybe<({
        __typename?: 'FileStatWithMetadata';
    } & IFileSelfStatFragment)>;
});
export declare type ICreateFile_WSMutationVariables = {
    resource: Scalars['URI'];
};
export declare type ICreateFile_WSMutation = ({
    __typename?: 'Mutation';
} & {
    createFile?: Maybe<({
        __typename?: 'FileStatWithMetadata';
    } & IFileSelfStatFragment)>;
});
export declare type ICreateFolder_WSMutationVariables = {
    resource: Scalars['URI'];
};
export declare type ICreateFolder_WSMutation = ({
    __typename?: 'Mutation';
} & {
    createFolder?: Maybe<({
        __typename?: 'FileStatWithMetadata';
    } & IFileSelfStatFragment)>;
});
export declare type ICreateUntitledFileMutationVariables = {
    resource?: Maybe<Scalars['URI']>;
    mode?: Maybe<Scalars['String']>;
    initialValue?: Maybe<Scalars['String']>;
    encoding?: Maybe<Scalars['String']>;
    hasAssociatedFilePath?: Maybe<Scalars['Boolean']>;
};
export declare type ICreateUntitledFileMutation = ({
    __typename?: 'Mutation';
} & {
    createUntitledFile?: Maybe<({
        __typename?: 'FileStatWithMetadata';
    } & IFileSelfStatFragment)>;
});
export declare type IDeleteFile_WSMutationVariables = {
    resource: Scalars['URI'];
    options?: Maybe<IDeleteFileOptions_Input>;
};
export declare type IDeleteFile_WSMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'del'>);
export declare type IFindFileStatMutationVariables = {
    resource: Scalars['URI'];
};
export declare type IFindFileStatMutation = ({
    __typename?: 'Mutation';
} & {
    findFileStat?: Maybe<({
        __typename?: 'FileStatWithMetadata';
    } & IFileSelfStatFragment)>;
});
export declare type IGetEditorStateMutationVariables = {
    resource: Scalars['URI'];
    editorId: Scalars['String'];
};
export declare type IGetEditorStateMutation = ({
    __typename?: 'Mutation';
} & {
    getEditorState?: Maybe<({
        __typename?: 'CodeEditorViewState';
    } & IEditorStateFragment)>;
});
export declare type IGetFilesTreeDataMutationVariables = {
    resource: Scalars['URI'];
};
export declare type IGetFilesTreeDataMutation = ({
    __typename?: 'Mutation';
} & {
    getFilesTreeData?: Maybe<Array<Maybe<({
        __typename?: 'FileStatWithMetadata';
    } & IFilesTreeItemFragment)>>>;
});
export declare type ILoadFile_WSMutationVariables = {
    resource: Scalars['URI'];
    options?: Maybe<IResolveMetadataFileOptions_Input>;
};
export declare type ILoadFile_WSMutation = ({
    __typename?: 'Mutation';
} & {
    loadFile?: Maybe<({
        __typename?: 'FileStatWithMetadata';
    } & {
        children?: Maybe<Array<Maybe<({
            __typename?: 'FileStatWithMetadata';
        } & IFileSelfStatFragment)>>>;
    } & IFileSelfStatFragment)>;
});
export declare type ILoadFileContent_WSMutationVariables = {
    resource: Scalars['URI'];
    options?: Maybe<IReadFileOptions_Input>;
};
export declare type ILoadFileContent_WSMutation = ({
    __typename?: 'Mutation';
} & {
    loadFileContent?: Maybe<({
        __typename?: 'FileContent';
    } & IFileContentFragment)>;
});
export declare type ILoadFileWithContentMutationVariables = {
    resource: Scalars['URI'];
    options?: Maybe<ILoadOptions_Input>;
};
export declare type ILoadFileWithContentMutation = ({
    __typename?: 'Mutation';
} & {
    loadFileWithContent?: Maybe<({
        __typename?: 'TextFileContent';
    } & Pick<ITextFileContent, 'resource' | 'name' | 'value' | 'encoding'>)>;
});
export declare type ILoadTreeDataMutationVariables = {
    resource: Scalars['URI'];
};
export declare type ILoadTreeDataMutation = ({
    __typename?: 'Mutation';
} & {
    loadFilesTreeData?: Maybe<Array<Maybe<({
        __typename?: 'FileStatWithMetadata';
    } & IFilesTreeItemFragment)>>>;
});
export declare type IMoveFile_WSMutationVariables = {
    source: Scalars['URI'];
    target: Scalars['URI'];
    overwrite?: Maybe<Scalars['Boolean']>;
};
export declare type IMoveFile_WSMutation = ({
    __typename?: 'Mutation';
} & {
    moveFile?: Maybe<({
        __typename?: 'FileStatWithMetadata';
    } & IFileSelfStatFragment)>;
});
export declare type IRemoveChangedEventMutationVariables = {
    resource: Scalars['URI'];
};
export declare type IRemoveChangedEventMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'removeChangedContent'>);
export declare type IRenameFile_WSMutationVariables = {
    resource: Scalars['URI'];
    target: Scalars['URI'];
    overwrite?: Maybe<Scalars['Boolean']>;
};
export declare type IRenameFile_WSMutation = ({
    __typename?: 'Mutation';
} & {
    rename?: Maybe<({
        __typename?: 'FileStatWithMetadata';
    } & IFileSelfStatFragment)>;
});
export declare type ISaveDelayFileChanges_WSMutationVariables = {
    resource: Scalars['URI'];
    changes: Array<Maybe<IChangesChunk_Input>>;
    options: IWriteTextFileOptions_Input;
};
export declare type ISaveDelayFileChanges_WSMutation = ({
    __typename?: 'Mutation';
} & {
    writeChunkWithDelay?: Maybe<({
        __typename?: 'UpdateDelayedResource';
    } & Pick<IUpdateDelayedResource, 'resource'>)>;
});
export declare type ISaveFileMutationVariables = {
    resource: Scalars['URI'];
    versionId?: Maybe<Scalars['Int']>;
    options: ISaveOptions_Input;
};
export declare type ISaveFileMutation = ({
    __typename?: 'Mutation';
} & {
    saveFile?: Maybe<({
        __typename?: 'FileStat';
    } & Pick<IFileStat, 'resource'>)>;
});
export declare type ISaveFile_WSMutationVariables = {
    resource: Scalars['URI'];
    value: Scalars['String'];
    options: IWriteTextFileOptions_Input;
};
export declare type ISaveFile_WSMutation = ({
    __typename?: 'Mutation';
} & {
    writeTextFile?: Maybe<({
        __typename?: 'FileStatWithMetadata';
    } & IFileSelfStatFragment)>;
});
export declare type ISaveFileAsMutationVariables = {
    resource: Scalars['String'];
    versionId?: Maybe<Scalars['Int']>;
    options: ISaveOptions_Input;
    target?: Maybe<Scalars['String']>;
};
export declare type ISaveFileAsMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'saveFileAs'>);
export declare type ISaveFileChanges_WSMutationVariables = {
    resource: Scalars['URI'];
    changes: Array<Maybe<IChangesChunk_Input>>;
    options: IWriteTextFileOptions_Input;
};
export declare type ISaveFileChanges_WSMutation = ({
    __typename?: 'Mutation';
} & {
    writeChunk?: Maybe<({
        __typename?: 'UpdatedResource';
    } & Pick<IUpdatedResource, 'resource'>)>;
});
export declare type ISetEncodingMutationVariables = {
    resource: Scalars['URI'];
    encoding?: Maybe<Scalars['String']>;
};
export declare type ISetEncodingMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'setEncoding'>);
export declare type ISetTreeDataMutationVariables = {
    treeData?: Maybe<Array<Maybe<ITreeData_Input>>>;
    originalData?: Maybe<ITreeData_Input>;
};
export declare type ISetTreeDataMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'setFilesTreeData'>);
export declare type IUnwatchFileMutationVariables = {
    resource: Scalars['URI'];
    session: Scalars['String'];
};
export declare type IUnwatchFileMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'unwatch'>);
export declare type IUnwatchFile_WSMutationVariables = {
    resource: Scalars['URI'];
    session: Scalars['String'];
};
export declare type IUnwatchFile_WSMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'unwatchFileChanges'>);
export declare type IUpdateFileDirtyStateMutationVariables = {
    resource: Scalars['URI'];
    isFileDirty: Scalars['Boolean'];
};
export declare type IUpdateFileDirtyStateMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'updateFileDirtyState'>);
export declare type IUpdateContentByChangesMutationVariables = {
    resource: Scalars['URI'];
    changedEvent: IContentChangedEvent_Input;
};
export declare type IUpdateContentByChangesMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'updateChangedContent'>);
export declare type IUpdateEditorStateMutationVariables = {
    resource: Scalars['URI'];
    editorId: Scalars['String'];
    state: ICodeEditorViewState_Input;
};
export declare type IUpdateEditorStateMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'updateEditorState'>);
export declare type IUpdateFileContent_WSMutationVariables = {
    resource: Scalars['URI'];
    options?: Maybe<IReadTextFileOptions_Input>;
};
export declare type IUpdateFileContent_WSMutation = ({
    __typename?: 'Mutation';
} & {
    readTextFile?: Maybe<({
        __typename?: 'TextFileContent';
    } & ITextContentFragment)>;
});
export declare type IUpdateSelectedResourceMutationVariables = {
    resource: Scalars['URI'];
};
export declare type IUpdateSelectedResourceMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'updateSelectedResource'>);
export declare type IWatchFileMutationVariables = {
    resource: Scalars['URI'];
};
export declare type IWatchFileMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'watchFile'>);
export declare type IWatchFile_WSMutationVariables = {
    resource: Scalars['URI'];
    options: IWatchOptions_Input;
};
export declare type IWatchFile_WSMutation = ({
    __typename?: 'Mutation';
} & Pick<IMutation, 'watchFileChanges'>);
export declare type IChangedContentQueryVariables = {
    resource: Scalars['URI'];
};
export declare type IChangedContentQuery = ({
    __typename?: 'Query';
} & {
    getChangedEvent?: Maybe<({
        __typename?: 'FileStatWithMetadata';
    } & Pick<IFileStatWithMetadata, 'changes' | 'eol' | 'versionId' | 'isUndoing' | 'isRedoing' | 'isFlush'>)>;
});
export declare type IEditorStateQueryVariables = {
    resource: Scalars['URI'];
    editorId: Scalars['String'];
};
export declare type IEditorStateQuery = ({
    __typename?: 'Query';
} & {
    editorState?: Maybe<({
        __typename?: 'CodeEditorViewState';
    } & IEditorStateFragment)>;
});
export declare type IFileExistsQueryVariables = {
    resource: Scalars['URI'];
};
export declare type IFileExistsQuery = ({
    __typename?: 'Query';
} & Pick<IQuery, 'existsFile'>);
export declare type IFileExists_WSQueryVariables = {
    resource: Scalars['URI'];
};
export declare type IFileExists_WSQuery = ({
    __typename?: 'Query';
} & Pick<IQuery, 'existsFile'>);
export declare type IFileContent_WSQueryVariables = {
    resource: Scalars['URI'];
};
export declare type IFileContent_WSQuery = ({
    __typename?: 'Query';
} & {
    resolveContent?: Maybe<({
        __typename?: 'FileContent';
    } & IFileContentFragment)>;
});
export declare type IFileStat_WSQueryVariables = {
    resource: Scalars['URI'];
    options?: Maybe<IResolveMetadataFileOptions_Input>;
};
export declare type IFileStat_WSQuery = ({
    __typename?: 'Query';
} & {
    resolveFile?: Maybe<({
        __typename?: 'FileStatWithMetadata';
    } & {
        children?: Maybe<Array<Maybe<({
            __typename?: 'FileStatWithMetadata';
        } & {
            children?: Maybe<Array<Maybe<({
                __typename?: 'FileStatWithMetadata';
            } & {
                children?: Maybe<Array<Maybe<({
                    __typename?: 'FileStatWithMetadata';
                } & {
                    children?: Maybe<Array<Maybe<({
                        __typename?: 'FileStatWithMetadata';
                    } & {
                        children?: Maybe<Array<Maybe<({
                            __typename?: 'FileStatWithMetadata';
                        } & {
                            children?: Maybe<Array<Maybe<({
                                __typename?: 'FileStatWithMetadata';
                            } & {
                                children?: Maybe<Array<Maybe<({
                                    __typename?: 'FileStatWithMetadata';
                                } & {
                                    children?: Maybe<Array<Maybe<({
                                        __typename?: 'FileStatWithMetadata';
                                    } & IFileSelfStatFragment)>>>;
                                } & IFileSelfStatFragment)>>>;
                            } & IFileSelfStatFragment)>>>;
                        } & IFileSelfStatFragment)>>>;
                    } & IFileSelfStatFragment)>>>;
                } & IFileSelfStatFragment)>>>;
            } & IFileSelfStatFragment)>>>;
        } & IFileSelfStatFragment)>>>;
    } & IFileSelfStatFragment)>;
});
export declare type IResolveFileContentQueryVariables = {
    resource: Scalars['URI'];
    options?: Maybe<ILoadOptions_Input>;
};
export declare type IResolveFileContentQuery = ({
    __typename?: 'Query';
} & {
    resolveFileContent?: Maybe<({
        __typename?: 'TextFileContent';
    } & Pick<ITextFileContent, 'resource' | 'name' | 'value' | 'encoding'>)>;
});
export declare type IResolveUntitledFileContentQueryVariables = {
    resource: Scalars['URI'];
};
export declare type IResolveUntitledFileContentQuery = ({
    __typename?: 'Query';
} & {
    resolveUntitledFileContent?: Maybe<({
        __typename?: 'TextFileContent';
    } & Pick<ITextFileContent, 'resource' | 'name' | 'value' | 'dirty'>)>;
});
export declare type ISelectedResourceQueryVariables = {};
export declare type ISelectedResourceQuery = ({
    __typename?: 'Query';
} & {
    selectedResource?: Maybe<({
        __typename?: 'Context';
    } & ISelectedResourceFragment)>;
});
export declare type ITextContent_WSQueryVariables = {
    resource: Scalars['URI'];
    options?: Maybe<IReadTextFileOptions_Input>;
};
export declare type ITextContent_WSQuery = ({
    __typename?: 'Query';
} & {
    readTextFile?: Maybe<({
        __typename?: 'TextFileContent';
    } & ITextContentFragment)>;
});
export declare type IFileStreamContent_WSQueryVariables = {
    resource: Scalars['URI'];
    options?: Maybe<IReadTextFileOptions_Input>;
};
export declare type IFileStreamContent_WSQuery = ({
    __typename?: 'Query';
} & {
    readStringStreamTextFile?: Maybe<({
        __typename?: 'TextFilePublishContent';
    } & Pick<ITextFilePublishContent, 'resource' | 'name' | 'value' | 'encoding' | 'status' | 'streamSeq'>)>;
});
export declare type IUntitledResourcesQueryVariables = {};
export declare type IUntitledResourcesQuery = ({
    __typename?: 'Query';
} & Pick<IQuery, 'untitledResources'>);
export declare type IFileDataSubscriptionVariables = {
    resource: Scalars['URI'];
};
export declare type IFileDataSubscription = ({
    __typename?: 'Subscription';
} & {
    fileData?: Maybe<Array<Maybe<({
        __typename?: 'FileChange';
    } & Pick<IFileChange, 'type' | 'resource'>)>>>;
});
export declare type IFileOperationSubscriptionVariables = {
    resource: Scalars['URI'];
};
export declare type IFileOperationSubscription = ({
    __typename?: 'Subscription';
} & {
    fileOperation?: Maybe<({
        __typename?: 'FileOperationOutput';
    } & Pick<IFileOperationOutput, 'resource' | 'operation'> & {
        target?: Maybe<({
            __typename?: 'FileStatWithMetadata';
        } & IFileSelfStatFragment)>;
    })>;
});
export declare type IReadStreamTextFileSubscriptionVariables = {
    resource: Scalars['URI'];
};
export declare type IReadStreamTextFileSubscription = ({
    __typename?: 'Subscription';
} & {
    readStreamTextString?: Maybe<({
        __typename?: 'TextFilePublishContent';
    } & Pick<ITextFilePublishContent, 'resource' | 'name' | 'encoding' | 'value' | 'status' | 'streamSeq'>)>;
});
export declare type ResolverTypeWrapper<T> = Promise<T> | T;
export declare type StitchingResolver<TResult, TParent, TContext, TArgs> = {
    fragment: string;
    resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export declare type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> = ResolverFn<TResult, TParent, TContext, TArgs> | StitchingResolver<TResult, TParent, TContext, TArgs>;
export declare type ResolverFn<TResult, TParent, TContext, TArgs> = (parent: TParent, args: TArgs, context: TContext, info: GraphQLResolveInfo) => Promise<TResult> | TResult;
export declare type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (parent: TParent, args: TArgs, context: TContext, info: GraphQLResolveInfo) => AsyncIterator<TResult> | Promise<AsyncIterator<TResult>>;
export declare type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (parent: TParent, args: TArgs, context: TContext, info: GraphQLResolveInfo) => TResult | Promise<TResult>;
export interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {
    subscribe: SubscriptionSubscribeFn<{
        [key in TKey]: TResult;
    }, TParent, TContext, TArgs>;
    resolve?: SubscriptionResolveFn<TResult, {
        [key in TKey]: TResult;
    }, TContext, TArgs>;
}
export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
    subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
    resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}
export declare type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> = SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs> | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;
export declare type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> = ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>) | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;
export declare type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (parent: TParent, context: TContext, info: GraphQLResolveInfo) => Maybe<TTypes> | Promise<Maybe<TTypes>>;
export declare type isTypeOfResolverFn<T = {}> = (obj: T, info: GraphQLResolveInfo) => boolean | Promise<boolean>;
export declare type NextResolverFn<T> = () => Promise<T>;
export declare type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (next: NextResolverFn<TResult>, parent: TParent, args: TArgs, context: TContext, info: GraphQLResolveInfo) => TResult | Promise<TResult>;
/** Mapping between all available schema types and the resolvers types */
export declare type IResolversTypes = {
    Query: ResolverTypeWrapper<{}>;
    ContextMenu: ResolverTypeWrapper<IContextMenu>;
    String: ResolverTypeWrapper<Scalars['String']>;
    Boolean: ResolverTypeWrapper<Scalars['Boolean']>;
    Anchor: ResolverTypeWrapper<IAnchor>;
    Int: ResolverTypeWrapper<Scalars['Int']>;
    MenuItem: ResolverTypeWrapper<IMenuItem>;
    ActionRun: ResolverTypeWrapper<IActionRun>;
    GraphqlCallType: IGraphqlCallType;
    AnyObject: ResolverTypeWrapper<Scalars['AnyObject']>;
    DefaultPreferencesResponse: ResolverTypeWrapper<IDefaultPreferencesResponse>;
    PreferencesType: ResolverTypeWrapper<IPreferencesType>;
    Setting: ResolverTypeWrapper<ISetting>;
    Range: ResolverTypeWrapper<IRange>;
    Position: ResolverTypeWrapper<IPosition>;
    ConfigurationScope: IConfigurationScope;
    ConfigurationExtensionInfo: ResolverTypeWrapper<IConfigurationExtensionInfo>;
    DefaultSettings: ResolverTypeWrapper<IDefaultSettings>;
    ISettingsSubject: IResolversTypes['DefaultSettings'] | IResolversTypes['UserSettings'] | IResolversTypes['LocalUserSettings'] | IResolversTypes['RemoteUserSettings'] | IResolversTypes['FolderSettings'] | IResolversTypes['GlobalSettings'] | IResolversTypes['WorkspaceSettings'] | IResolversTypes['MemorySettings'];
    ID: ResolverTypeWrapper<Scalars['ID']>;
    Settings: ResolverTypeWrapper<ISettings>;
    URI: ResolverTypeWrapper<Scalars['URI']>;
    SettingsCascade: ResolverTypeWrapper<Omit<ISettingsCascade, 'subjects'> & {
        subjects?: Maybe<Array<Maybe<IResolversTypes['SettingsSubject']>>>;
    }>;
    SettingsSubject: IResolversTypes['UserSettings'] | IResolversTypes['LocalUserSettings'] | IResolversTypes['RemoteUserSettings'] | IResolversTypes['FolderSettings'] | IResolversTypes['GlobalSettings'] | IResolversTypes['WorkspaceSettings'] | IResolversTypes['MemorySettings'] | IResolversTypes['DefaultSettings'];
    UserSettings: ResolverTypeWrapper<IUserSettings>;
    LocalUserSettings: ResolverTypeWrapper<ILocalUserSettings>;
    RemoteUserSettings: ResolverTypeWrapper<IRemoteUserSettings>;
    FolderSettings: ResolverTypeWrapper<IFolderSettings>;
    GlobalSettings: ResolverTypeWrapper<IGlobalSettings>;
    WorkspaceSettings: ResolverTypeWrapper<IWorkspaceSettings>;
    MemorySettings: ResolverTypeWrapper<IMemorySettings>;
    Configuration: ResolverTypeWrapper<IConfiguration>;
    SettingsGroup: ResolverTypeWrapper<ISettingsGroup>;
    SettingsSection: ResolverTypeWrapper<ISettingsSection>;
    Files: ResolverTypeWrapper<IFiles>;
    AutoSaveConfigurationType: IAutoSaveConfigurationType;
    JSON: ResolverTypeWrapper<Scalars['JSON']>;
    Git: ResolverTypeWrapper<IGit>;
    GitDecorations: ResolverTypeWrapper<IGitDecorations>;
    Languages: ResolverTypeWrapper<ILanguages>;
    Output: ResolverTypeWrapper<IOutput>;
    Search: ResolverTypeWrapper<ISearch>;
    SearchQuickOpen: ResolverTypeWrapper<ISearchQuickOpen>;
    Terminal: ResolverTypeWrapper<ITerminal>;
    IStatusbarItem: IResolversTypes['Terminal'] | IResolversTypes['SelectionStatus'] | IResolversTypes['Indentation'] | IResolversTypes['EncodingStatus'] | IResolversTypes['EndOfLineSequence'] | IResolversTypes['LanguageMode'];
    StatusbarAlignment: IStatusbarAlignment;
    StatusbarEntry: ResolverTypeWrapper<IStatusbarEntry>;
    STATUSBAR_ITEM_ID: ISTATUSBAR_ITEM_ID;
    Integrated: ResolverTypeWrapper<IIntegrated>;
    ShellArgs: ResolverTypeWrapper<IShellArgs>;
    Shell: ResolverTypeWrapper<IShell>;
    WorkspacePreferenceWorkbench: ResolverTypeWrapper<IWorkspacePreferenceWorkbench>;
    WorkspacePreferenceView: ResolverTypeWrapper<IWorkspacePreferenceView>;
    WorkspacePreferenceTips: ResolverTypeWrapper<IWorkspacePreferenceTips>;
    WorkspacePreferenceStatusBar: ResolverTypeWrapper<IWorkspacePreferenceStatusBar>;
    WorkspacePreferenceSideBar: ResolverTypeWrapper<IWorkspacePreferenceSideBar>;
    WorkspacePreferenceSettings: ResolverTypeWrapper<IWorkspacePreferenceSettings>;
    WorkspacePreferenceQuickOpen: ResolverTypeWrapper<IWorkspacePreferenceQuickOpen>;
    WorkspacePreferencePanel: ResolverTypeWrapper<IWorkspacePreferencePanel>;
    WorkspacePreferenceList: ResolverTypeWrapper<IWorkspacePreferenceList>;
    WorkspacePreferenceExperimental: ResolverTypeWrapper<IWorkspacePreferenceExperimental>;
    WorkspacePreferenceEditor: ResolverTypeWrapper<IWorkspacePreferenceEditor>;
    WorkspacePreferenceCommandPalette: ResolverTypeWrapper<IWorkspacePreferenceCommandPalette>;
    WorkspacePreferenceActivityBar: ResolverTypeWrapper<IWorkspacePreferenceActivityBar>;
    Dialog: ResolverTypeWrapper<IDialog>;
    Detail: ResolverTypeWrapper<IDetail>;
    InputTypeDetail: ResolverTypeWrapper<IInputTypeDetail>;
    PrimaryButtonAction: ResolverTypeWrapper<IPrimaryButtonAction>;
    CheckboxOptions: ResolverTypeWrapper<ICheckboxOptions>;
    EditorPart: ResolverTypeWrapper<Omit<IEditorPart, 'children'> & {
        children?: Maybe<Array<Maybe<IResolversTypes['EditorChildren']>>>;
    }>;
    GroupOrientation: IGroupOrientation;
    EditorChildren: IResolversTypes['EditorPart'] | IResolversTypes['EditorGroup'];
    EditorGroup: ResolverTypeWrapper<Omit<IEditorGroup, 'tabs'> & {
        tabs?: Maybe<Array<Maybe<IResolversTypes['EditorInput']>>>;
    }>;
    IEditorGroup: IResolversTypes['EditorGroup'];
    EditorInput: IResolversTypes['DataUriEditorInput'] | IResolversTypes['DiffEditorInput'] | IResolversTypes['FileEditorInput'] | IResolversTypes['KeybindingEditorInput'] | IResolversTypes['ResourceEditorInput'] | IResolversTypes['SideBySideEditorInput'] | IResolversTypes['UntitledEditorInput'];
    DataUriEditorInput: ResolverTypeWrapper<IDataUriEditorInput>;
    IEditorInput: IResolversTypes['DataUriEditorInput'] | IResolversTypes['DiffEditorInput'] | IResolversTypes['FileEditorInput'] | IResolversTypes['KeybindingEditorInput'] | IResolversTypes['ResourceEditorInput'] | IResolversTypes['SideBySideEditorInput'] | IResolversTypes['UntitledEditorInput'];
    EDITOR_INPUT_ID: IEDITOR_INPUT_ID;
    FileStatWithMetadata: ResolverTypeWrapper<IFileStatWithMetadata>;
    IBaseStat: IResolversTypes['FileStatWithMetadata'] | IResolversTypes['TextFileStreamContent'] | IResolversTypes['TextFilePublishContent'] | IResolversTypes['TextFileContent'] | IResolversTypes['FileContent'] | IResolversTypes['FileStat'] | IResolversTypes['FileStreamContent'];
    BigInt: ResolverTypeWrapper<Scalars['BigInt']>;
    IBaseStatWithMetadata: IResolversTypes['FileStatWithMetadata'] | IResolversTypes['TextFileStreamContent'] | IResolversTypes['TextFileContent'] | IResolversTypes['FileContent'] | IResolversTypes['FileStreamContent'];
    IContentChangedEvent: IResolversTypes['FileStatWithMetadata'];
    IFileClientMetadata: IResolversTypes['FileStatWithMetadata'] | IResolversTypes['TextFileContent'];
    FileModelState: IFileModelState;
    ITreeItem: IResolversTypes['FileStatWithMetadata'];
    IUntitledFileValue: IResolversTypes['FileStatWithMetadata'];
    IEditorInputWithGroupFields: IResolversTypes['DataUriEditorInput'] | IResolversTypes['DiffEditorInput'] | IResolversTypes['FileEditorInput'] | IResolversTypes['KeybindingEditorInput'] | IResolversTypes['ResourceEditorInput'] | IResolversTypes['SideBySideEditorInput'] | IResolversTypes['UntitledEditorInput'];
    DiffEditorInput: ResolverTypeWrapper<Omit<IDiffEditorInput, 'originalInput' | 'modifiedInput'> & {
        originalInput?: Maybe<IResolversTypes['EditorInput']>;
        modifiedInput?: Maybe<IResolversTypes['EditorInput']>;
    }>;
    FileEditorInput: ResolverTypeWrapper<IFileEditorInput>;
    IFileEditorInput: IResolversTypes['FileEditorInput'];
    IEncodingSupport: IResolversTypes['FileEditorInput'];
    IModeSupport: IResolversTypes['FileEditorInput'];
    KeybindingEditorInput: ResolverTypeWrapper<IKeybindingEditorInput>;
    ResourceEditorInput: ResolverTypeWrapper<IResourceEditorInput>;
    SideBySideEditorInput: ResolverTypeWrapper<Omit<ISideBySideEditorInput, 'master' | 'details'> & {
        master?: Maybe<IResolversTypes['EditorInput']>;
        details?: Maybe<IResolversTypes['EditorInput']>;
    }>;
    ISideBySideEditorInput: IResolversTypes['SideBySideEditorInput'];
    UntitledEditorInput: ResolverTypeWrapper<IUntitledEditorInput>;
    CodeEditorViewState: ResolverTypeWrapper<ICodeEditorViewState>;
    ConfigurationData: ResolverTypeWrapper<IConfigurationData>;
    ConfigurationModel: ResolverTypeWrapper<IConfigurationModel>;
    Overrides: ResolverTypeWrapper<IOverrides>;
    FolderConfigurationModel: ResolverTypeWrapper<IFolderConfigurationModel>;
    ConfigurationOverrides: ResolverTypeWrapper<IConfigurationOverrides>;
    Context: ResolverTypeWrapper<IContext>;
    scmResourceGroups: IscmResourceGroups;
    ProvidedRemoteConnectionStates: IProvidedRemoteConnectionStates;
    ConfigurationTarget: IConfigurationTarget;
    Environment: ResolverTypeWrapper<IEnvironment>;
    ExtensionHostDebugParams: ResolverTypeWrapper<IExtensionHostDebugParams>;
    IDebugParams: IResolversTypes['ExtensionHostDebugParams'];
    Keybindings: ResolverTypeWrapper<IKeybindings>;
    KeybindingItem: ResolverTypeWrapper<IKeybindingItem>;
    KeybindingSource: IKeybindingSource;
    SelectedOutput: ResolverTypeWrapper<ISelectedOutput>;
    QuickPickItem: ResolverTypeWrapper<IQuickPickItem>;
    QuickPickItemHighlights: ResolverTypeWrapper<IQuickPickItemHighlights>;
    Match: ResolverTypeWrapper<IMatch>;
    WorkspaceData: ResolverTypeWrapper<IWorkspaceData>;
    IStaticWorkspaceData: IResolversTypes['WorkspaceData'];
    WorkspaceFolderData: ResolverTypeWrapper<IWorkspaceFolderData>;
    WorkspaceValue_Input: IWorkspaceValue_Input;
    ConfigurationOverrides_Input: IConfigurationOverrides_Input;
    GoToLineQuickAccess: ResolverTypeWrapper<IGoToLineQuickAccess>;
    LineRange: ResolverTypeWrapper<ILineRange>;
    KeybindingContextMenu: ResolverTypeWrapper<IKeybindingContextMenu>;
    EditKeybindingItem: ResolverTypeWrapper<IEditKeybindingItem>;
    Notifications: ResolverTypeWrapper<INotifications>;
    Notification: ResolverTypeWrapper<INotification>;
    NotificationSeverity: INotificationSeverity;
    NotificationActions: ResolverTypeWrapper<INotificationActions>;
    Action: ResolverTypeWrapper<IAction>;
    QuickInputModel: ResolverTypeWrapper<IQuickInputModel>;
    QuickInput: ResolverTypeWrapper<IQuickInput>;
    QuickPick: ResolverTypeWrapper<IQuickPick>;
    ReadTextFileOptions_Input: IReadTextFileOptions_Input;
    ReadFileOptions_Input_limits: IReadFileOptions_Input_limits;
    TextFileStreamContent: ResolverTypeWrapper<ITextFileStreamContent>;
    IBaseTextFileContent: IResolversTypes['TextFileStreamContent'] | IResolversTypes['TextFilePublishContent'] | IResolversTypes['TextFileContent'];
    TextBufferData: ResolverTypeWrapper<ITextBufferData>;
    TextFilePublishContent: ResolverTypeWrapper<ITextFilePublishContent>;
    FileContentStatus: FileContentStatus;
    TextFileContent: ResolverTypeWrapper<ITextFileContent>;
    ReadFileOptions_Input: IReadFileOptions_Input;
    FileContent: ResolverTypeWrapper<IFileContent>;
    VSBuffer: ResolverTypeWrapper<Scalars['VSBuffer']>;
    ResolveAll_toResolveWithMetadata_Input: IResolveAll_toResolveWithMetadata_Input;
    ResolveMetadataFileOptions_Input: IResolveMetadataFileOptions_Input;
    ResolveFileResultWithMetadata: ResolverTypeWrapper<IResolveFileResultWithMetadata>;
    LoadOptions_Input: ILoadOptions_Input;
    FileLoadReason: IFileLoadReason;
    Dialog_input: IDialog_input;
    Detail_input: IDetail_input;
    InputTypeDetail_input: IInputTypeDetail_input;
    PrimaryButtonAction_input: IPrimaryButtonAction_input;
    ActionRun_input: IActionRun_input;
    CheckboxOptions_input: ICheckboxOptions_input;
    DialogResult: ResolverTypeWrapper<IDialogResult>;
    Notification_input: INotification_input;
    NotificationMessage_input: INotificationMessage_input;
    MessageLink_input: IMessageLink_input;
    NotificationActions_input: INotificationActions_input;
    Action_input: IAction_input;
    Statusbar: ResolverTypeWrapper<Omit<IStatusbar, 'items'> & {
        items?: Maybe<Array<Maybe<IResolversTypes['StatusbarItem']>>>;
    }>;
    StatusbarItem: IResolversTypes['Terminal'] | IResolversTypes['SelectionStatus'] | IResolversTypes['Indentation'] | IResolversTypes['EncodingStatus'] | IResolversTypes['EndOfLineSequence'] | IResolversTypes['LanguageMode'];
    SelectionStatus: ResolverTypeWrapper<ISelectionStatus>;
    Indentation: ResolverTypeWrapper<IIndentation>;
    EncodingStatus: ResolverTypeWrapper<IEncodingStatus>;
    EndOfLineSequence: ResolverTypeWrapper<IEndOfLineSequence>;
    LanguageMode: ResolverTypeWrapper<ILanguageMode>;
    UserPreferencesRes: ResolverTypeWrapper<IUserPreferencesRes>;
    IUserPreferences: ResolverTypeWrapper<IIUserPreferences>;
    WorkspaceRes: ResolverTypeWrapper<IWorkspaceRes>;
    Mutation: ResolverTypeWrapper<{}>;
    AddEntry_input: IAddEntry_input;
    StatusbarEntry_input: IStatusbarEntry_input;
    KeybindingItem_input: IKeybindingItem_input;
    CloseEditor_Input: ICloseEditor_Input;
    CloseEditorOptions_Input: ICloseEditorOptions_Input;
    CreateFileOptions_Input: ICreateFileOptions_Input;
    DeleteFileOptions_Input: IDeleteFileOptions_Input;
    LineRange_input: ILineRange_input;
    IJSONValue_input: IIJSONValue_input;
    KeepOpen_Input: IKeepOpen_Input;
    MoveEditor_Input: IMoveEditor_Input;
    MoveEditorOptions_Input: IMoveEditorOptions_Input;
    PromptChoice_input: IPromptChoice_input;
    PromptChoiceRun: IPromptChoiceRun;
    PromptOptions_input: IPromptOptions_input;
    PromptOptionsCancel: IPromptOptionsCancel;
    OpenEditor_Input: IOpenEditor_Input;
    EditorOpenOptions_Input: IEditorOpenOptions_Input;
    EditorOpenPositioning: IEditorOpenPositioning;
    ResourceDiff_Input: IResourceDiff_Input;
    TextEditorOptions_Input: ITextEditorOptions_Input;
    TextEditorSelection_Input: ITextEditorSelection_Input;
    Resource_Input: IResource_Input;
    ResourceSideBySide_Input: IResourceSideBySide_Input;
    UntitledResource_Input: IUntitledResource_Input;
    Keybinding_input: IKeybinding_input;
    RemoveEditor_Input: IRemoveEditor_Input;
    KeyboardEvent_input: IKeyboardEvent_input;
    KeyboardEvent_output: ResolverTypeWrapper<IKeyboardEvent_output>;
    SaveOptions_Input: ISaveOptions_Input;
    SaveReason: SaveReason;
    FileStat: ResolverTypeWrapper<IFileStat>;
    SaveWorkspaceRes: ResolverTypeWrapper<ISaveWorkspaceRes>;
    SelectEditor_Input: ISelectEditor_Input;
    TreeData_Input: ITreeData_Input;
    PickItem: IPickItem;
    QuickPickItemHighlights_input: IQuickPickItemHighlights_input;
    Match_input: IMatch_input;
    SetStatusMsg_input: ISetStatusMsg_input;
    ContextMenu_input: IContextMenu_input;
    Anchor_input: IAnchor_input;
    MenuItem_input: IMenuItem_input;
    InputOptions: IInputOptions;
    PickInputOptions: IPickInputOptions;
    ContentChangedEvent_Input: IContentChangedEvent_Input;
    ChangesChunk_Input: IChangesChunk_Input;
    ChangeRange_Input: IChangeRange_Input;
    WriteFileOptions_Input: IWriteFileOptions_Input;
    CodeEditorViewState_Input: ICodeEditorViewState_Input;
    EditorLayout_Input: IEditorLayout_Input;
    EditorChildren_Input: IEditorChildren_Input;
    EditorInput_Input: IEditorInput_Input;
    UpdateEntry_input: IUpdateEntry_input;
    WatchOptions_Input: IWatchOptions_Input;
    WriteTextFileOptions_Input: IWriteTextFileOptions_Input;
    UpdatedResource: ResolverTypeWrapper<IUpdatedResource>;
    UpdateDelayedResource: ResolverTypeWrapper<IUpdateDelayedResource>;
    Subscription: ResolverTypeWrapper<{}>;
    FileChange: ResolverTypeWrapper<IFileChange>;
    FileChangeType: FileChangeType;
    FileOperationOutput: ResolverTypeWrapper<IFileOperationOutput>;
    FileOperation: IFileOperation;
    IConfigurationChangeEvent: ResolverTypeWrapper<IIConfigurationChangeEvent>;
    ResourceMapConfigurationModel: ResolverTypeWrapper<IResourceMapConfigurationModel>;
    JSONObject: ResolverTypeWrapper<Scalars['JSONObject']>;
    VSBufferReadableStream: ResolverTypeWrapper<Scalars['VSBufferReadableStream']>;
    FieldError: ResolverTypeWrapper<IFieldError>;
    WorkspaceStackSettings: ResolverTypeWrapper<IWorkspaceStackSettings>;
    MoleculerServiceName: IMoleculerServiceName;
    Assets: ResolverTypeWrapper<IAssets>;
    Scripts: ResolverTypeWrapper<IScripts>;
    Bundles: ResolverTypeWrapper<IBundles>;
    ExtensionPackageType: ResolverTypeWrapper<IExtensionPackageType>;
    Engines: ResolverTypeWrapper<IEngines>;
    Author: ResolverTypeWrapper<IAuthor>;
    GalleryBanner: ResolverTypeWrapper<IGalleryBanner>;
    ExtensionManifestBugs: ResolverTypeWrapper<IExtensionManifestBugs>;
    ExtensionManifestRepository: ResolverTypeWrapper<IExtensionManifestRepository>;
    ExtensionKind: IExtensionKind;
    ExtensionType: IExtensionType;
    ExtensionManifest: ResolverTypeWrapper<IExtensionManifest>;
    ExtensionContributions: ResolverTypeWrapper<IExtensionContributions>;
    Actions: ResolverTypeWrapper<IActions>;
    ActionItem: ResolverTypeWrapper<IActionItem>;
    ExtensionConfiguration: ResolverTypeWrapper<IExtensionConfiguration>;
    Debugger: ResolverTypeWrapper<IDebugger>;
    Grammar: ResolverTypeWrapper<IGrammar>;
    ExtensionJSONValidation: ResolverTypeWrapper<IExtensionJSONValidation>;
    KeyBinding: ResolverTypeWrapper<IKeyBinding>;
    ExtensionLanguage: ResolverTypeWrapper<IExtensionLanguage>;
    Menus: ResolverTypeWrapper<IMenus>;
    MenuItemAction: ResolverTypeWrapper<IMenuItemAction>;
    MenuItemActionContext: ResolverTypeWrapper<IMenuItemActionContext>;
    MenuItemActionEditor: ResolverTypeWrapper<IMenuItemActionEditor>;
    MenuItemActionEditorTitle: ResolverTypeWrapper<IMenuItemActionEditorTitle>;
    MenuItemActionDebug: ResolverTypeWrapper<IMenuItemActionDebug>;
    MenuItemActionScm: ResolverTypeWrapper<IMenuItemActionScm>;
    MenuItemActionScmChange: ResolverTypeWrapper<IMenuItemActionScmChange>;
    MenuItemActionView: ResolverTypeWrapper<IMenuItemActionView>;
    Snippet: ResolverTypeWrapper<ISnippet>;
    ThemeLabel: ResolverTypeWrapper<IThemeLabel>;
    ExtensionColor: ResolverTypeWrapper<IExtensionColor>;
    ExtensionColorTypes: ResolverTypeWrapper<IExtensionColorTypes>;
    Localization: ResolverTypeWrapper<ILocalization>;
    LocalizationTranslation: ResolverTypeWrapper<ILocalizationTranslation>;
    ExtensionIdentifier: ResolverTypeWrapper<IExtensionIdentifier>;
    BaseExtension: ResolverTypeWrapper<IBaseExtension>;
    ExtensionConfigurationProperty: ResolverTypeWrapper<IExtensionConfigurationProperty>;
    Contributes: ResolverTypeWrapper<IContributes>;
    PositionInput: IPositionInput;
    RangeInput: IRangeInput;
    WorkspaceIdentifier: ResolverTypeWrapper<IWorkspaceIdentifier>;
    ViewContainer: ResolverTypeWrapper<IViewContainer>;
    View: ResolverTypeWrapper<IView>;
    MenuId: IMenuId;
    URIInput: IURIInput;
    NativeOpenDialogOptions: ResolverTypeWrapper<INativeOpenDialogOptions>;
    EnterWorkspaceResult: ResolverTypeWrapper<IEnterWorkspaceResult>;
    CrashReporterStartOptions: ResolverTypeWrapper<ICrashReporterStartOptions>;
    OpenDialogOptions: ResolverTypeWrapper<IOpenDialogOptions>;
    FileFilter: ResolverTypeWrapper<IFileFilter>;
    OpenDialogOptionsProperties: IOpenDialogOptionsProperties;
    MessageBoxResult: ResolverTypeWrapper<IMessageBoxResult>;
    OpenSettings: ResolverTypeWrapper<IOpenSettings>;
    URIToOpen: IResolversTypes['WorkspaceToOpen'] | IResolversTypes['FolderToOpen'] | IResolversTypes['FileToOpen'];
    WorkspaceToOpen: ResolverTypeWrapper<IWorkspaceToOpen>;
    FolderToOpen: ResolverTypeWrapper<IFolderToOpen>;
    FileToOpen: ResolverTypeWrapper<IFileToOpen>;
    MessageBoxOptions: ResolverTypeWrapper<IMessageBoxOptions>;
    SaveDialogOptions: ResolverTypeWrapper<ISaveDialogOptions>;
    NewWindowOptions: ResolverTypeWrapper<INewWindowOptions>;
    DevToolsOptionsMode: IDevToolsOptionsMode;
    DevToolsOptions: ResolverTypeWrapper<IDevToolsOptions>;
    OpenContext: IOpenContext;
    ReadyState: IReadyState;
    IPathData: IResolversTypes['Path'];
    Path: ResolverTypeWrapper<IPath>;
    IPathsToWaitForData: IResolversTypes['PathsToWaitFor'];
    PathsToWaitFor: ResolverTypeWrapper<IPathsToWaitFor>;
    WindowConfiguration: ResolverTypeWrapper<IWindowConfiguration>;
    OpenFileRequest: ResolverTypeWrapper<IOpenFileRequest>;
    AddFoldersRequest: ResolverTypeWrapper<IAddFoldersRequest>;
    RunActionInWindowRequestFrom: IRunActionInWindowRequestFrom;
    RunActionInWindowRequest: ResolverTypeWrapper<IRunActionInWindowRequest>;
    RunKeybindingInWindowRequest: ResolverTypeWrapper<IRunKeybindingInWindowRequest>;
    OpenConfiguration: ResolverTypeWrapper<Omit<IOpenConfiguration, 'urisToOpen'> & {
        urisToOpen?: Maybe<Array<Maybe<IResolversTypes['URIToOpen']>>>;
    }>;
    MessageLink: ResolverTypeWrapper<IMessageLink>;
    NotificationChangeType: INotificationChangeType;
    NotificationChangeEvent: ResolverTypeWrapper<INotificationChangeEvent>;
    NotificationViewItem: ResolverTypeWrapper<INotificationViewItem>;
    NotificationMessage: ResolverTypeWrapper<INotificationMessage>;
    NotificationViewItemProgress: ResolverTypeWrapper<INotificationViewItemProgress>;
    NotificationViewItemProgressState: ResolverTypeWrapper<INotificationViewItemProgressState>;
    NotificationViewItemLabelKind: INotificationViewItemLabelKind;
    StorageScope: IStorageScope;
    ConfigurationServiceAction: IConfigurationServiceAction;
    WorkspaceContextServiceAction: IWorkspaceContextServiceAction;
    EnvironmentServiceAction: IEnvironmentServiceAction;
    KeyPathSegment: IKeyPathSegment;
    IUserSettings: ResolverTypeWrapper<IIUserSettings>;
    PreferenceItem: ResolverTypeWrapper<IPreferenceItem>;
    SettingValueType: ISettingValueType;
    CloseOptions_Input: ICloseOptions_Input;
    EditorActionType: IEditorActionType;
    EditorIdentifier: ResolverTypeWrapper<Omit<IEditorIdentifier, 'editor'> & {
        editor?: Maybe<IResolversTypes['EditorInput']>;
    }>;
    EditorSettings: ResolverTypeWrapper<IEditorSettings>;
    OpenDiff_Input: IOpenDiff_Input;
    DockLayout: ResolverTypeWrapper<Omit<IDockLayout, 'tabs'> & {
        tabs?: Maybe<Array<Maybe<IResolversTypes['EditorInput']>>>;
    }>;
    EDITOR_ID: IEDITOR_ID;
    BaseResourceInput: IBaseResourceInput;
    GroupDirection: IGroupDirection;
    GroupLocation: IGroupLocation;
    GroupsArrangement: IGroupsArrangement;
    GroupLayoutArgument: ResolverTypeWrapper<IGroupLayoutArgument>;
    EditorGroupLayout: ResolverTypeWrapper<IEditorGroupLayout>;
    CopyEditorOptions_Input: ICopyEditorOptions_Input;
    AddGroupOptions_Input: IAddGroupOptions_Input;
    MergeGroupMode: IMergeGroupMode;
    MergeGroupOptions_Input: IMergeGroupOptions_Input;
    CloseDirection: ICloseDirection;
    CloseEditorsFilter: ResolverTypeWrapper<Omit<ICloseEditorsFilter, 'except'> & {
        except?: Maybe<IResolversTypes['EditorInput']>;
    }>;
    GroupsOrder: IGroupsOrder;
    EditorsOrder: IEditorsOrder;
    SideBySideEditor: ISideBySideEditor;
    EditorPartConfiguration_Input: IEditorPartConfiguration_Input;
    TabCloseButtonType: ITabCloseButtonType;
    TabSizingType: ITabSizingType;
    OpenPositioningType: IOpenPositioningType;
    OpenSideBySideDirection: IOpenSideBySideDirection;
    LableFormatType: ILableFormatType;
    EditorPartOptions_Input: ResolverTypeWrapper<IEditorPartOptions_Input>;
    EditorOptions_Input: IEditorOptions_Input;
    ContextInput: IContextInput;
    scmProviders: IscmProviders;
    commentThread: IcommentThread;
    PendingStatusbarEntry: ResolverTypeWrapper<IPendingStatusbarEntry>;
    FileOverwriteOptions: ResolverTypeWrapper<IFileOverwriteOptions>;
    FileWriteOptions: ResolverTypeWrapper<IFileWriteOptions>;
    FileOpenOptions: ResolverTypeWrapper<IFileOpenOptions>;
    FileDeleteOptions: ResolverTypeWrapper<IFileDeleteOptions>;
    FileType: FileType;
    Files_Stat: ResolverTypeWrapper<IFiles_Stat>;
    ResolveFileResult: ResolverTypeWrapper<IResolveFileResult>;
    FileStreamContent: ResolverTypeWrapper<IFileStreamContent>;
    StreamContent: ResolverTypeWrapper<IStreamContent>;
    ResolveFileOptions_Input: IResolveFileOptions_Input;
    FileOperationResult: IFileOperationResult;
    HotExitConfiguration: HotExitConfiguration;
    ImportResult: ResolverTypeWrapper<IImportResult>;
    ChangesChangesChunk_Input: IChangesChangesChunk_Input;
    ChunkOptions_Input: IChunkOptions_Input;
    ChangeRange: ResolverTypeWrapper<IChangeRange>;
    ContentChangedEvent: ResolverTypeWrapper<IContentChangedEvent>;
    ChangesChunk: ResolverTypeWrapper<IChangesChunk>;
    ResolveAll_toResolve_Input: IResolveAll_toResolve_Input;
    FileServiceAction: IFileServiceAction;
    TextFileServiceAction: ITextFileServiceAction;
    TextFileOperationResult: ITextFileOperationResult;
    ResourceEncoding: ResolverTypeWrapper<IResourceEncoding>;
    FileStateChange: IFileStateChange;
    FileResult: ResolverTypeWrapper<IFileResult>;
    ModelLoadOrCreateOptions_Input_reload: IModelLoadOrCreateOptions_Input_reload;
    ModelLoadOrCreateOptions_Input: IModelLoadOrCreateOptions_Input;
    CursorState: ResolverTypeWrapper<ICursorState>;
    ViewState: ResolverTypeWrapper<IViewState>;
    CursorState_Input: ICursorState_Input;
    ViewState_Input: IViewState_Input;
    EDITOR_INPUT_RESOURCE_TYPE_ID: IEDITOR_INPUT_RESOURCE_TYPE_ID;
};
/** Mapping between all available schema types and the resolvers parents */
export declare type IResolversParentTypes = {
    Query: {};
    ContextMenu: IContextMenu;
    String: Scalars['String'];
    Boolean: Scalars['Boolean'];
    Anchor: IAnchor;
    Int: Scalars['Int'];
    MenuItem: IMenuItem;
    ActionRun: IActionRun;
    GraphqlCallType: IGraphqlCallType;
    AnyObject: Scalars['AnyObject'];
    DefaultPreferencesResponse: IDefaultPreferencesResponse;
    PreferencesType: IPreferencesType;
    Setting: ISetting;
    Range: IRange;
    Position: IPosition;
    ConfigurationScope: IConfigurationScope;
    ConfigurationExtensionInfo: IConfigurationExtensionInfo;
    DefaultSettings: IDefaultSettings;
    ISettingsSubject: IResolversParentTypes['DefaultSettings'] | IResolversParentTypes['UserSettings'] | IResolversParentTypes['LocalUserSettings'] | IResolversParentTypes['RemoteUserSettings'] | IResolversParentTypes['FolderSettings'] | IResolversParentTypes['GlobalSettings'] | IResolversParentTypes['WorkspaceSettings'] | IResolversParentTypes['MemorySettings'];
    ID: Scalars['ID'];
    Settings: ISettings;
    URI: Scalars['URI'];
    SettingsCascade: Omit<ISettingsCascade, 'subjects'> & {
        subjects?: Maybe<Array<Maybe<IResolversParentTypes['SettingsSubject']>>>;
    };
    SettingsSubject: IResolversParentTypes['UserSettings'] | IResolversParentTypes['LocalUserSettings'] | IResolversParentTypes['RemoteUserSettings'] | IResolversParentTypes['FolderSettings'] | IResolversParentTypes['GlobalSettings'] | IResolversParentTypes['WorkspaceSettings'] | IResolversParentTypes['MemorySettings'] | IResolversParentTypes['DefaultSettings'];
    UserSettings: IUserSettings;
    LocalUserSettings: ILocalUserSettings;
    RemoteUserSettings: IRemoteUserSettings;
    FolderSettings: IFolderSettings;
    GlobalSettings: IGlobalSettings;
    WorkspaceSettings: IWorkspaceSettings;
    MemorySettings: IMemorySettings;
    Configuration: IConfiguration;
    SettingsGroup: ISettingsGroup;
    SettingsSection: ISettingsSection;
    Files: IFiles;
    AutoSaveConfigurationType: IAutoSaveConfigurationType;
    JSON: Scalars['JSON'];
    Git: IGit;
    GitDecorations: IGitDecorations;
    Languages: ILanguages;
    Output: IOutput;
    Search: ISearch;
    SearchQuickOpen: ISearchQuickOpen;
    Terminal: ITerminal;
    IStatusbarItem: IResolversParentTypes['Terminal'] | IResolversParentTypes['SelectionStatus'] | IResolversParentTypes['Indentation'] | IResolversParentTypes['EncodingStatus'] | IResolversParentTypes['EndOfLineSequence'] | IResolversParentTypes['LanguageMode'];
    StatusbarAlignment: IStatusbarAlignment;
    StatusbarEntry: IStatusbarEntry;
    STATUSBAR_ITEM_ID: ISTATUSBAR_ITEM_ID;
    Integrated: IIntegrated;
    ShellArgs: IShellArgs;
    Shell: IShell;
    WorkspacePreferenceWorkbench: IWorkspacePreferenceWorkbench;
    WorkspacePreferenceView: IWorkspacePreferenceView;
    WorkspacePreferenceTips: IWorkspacePreferenceTips;
    WorkspacePreferenceStatusBar: IWorkspacePreferenceStatusBar;
    WorkspacePreferenceSideBar: IWorkspacePreferenceSideBar;
    WorkspacePreferenceSettings: IWorkspacePreferenceSettings;
    WorkspacePreferenceQuickOpen: IWorkspacePreferenceQuickOpen;
    WorkspacePreferencePanel: IWorkspacePreferencePanel;
    WorkspacePreferenceList: IWorkspacePreferenceList;
    WorkspacePreferenceExperimental: IWorkspacePreferenceExperimental;
    WorkspacePreferenceEditor: IWorkspacePreferenceEditor;
    WorkspacePreferenceCommandPalette: IWorkspacePreferenceCommandPalette;
    WorkspacePreferenceActivityBar: IWorkspacePreferenceActivityBar;
    Dialog: IDialog;
    Detail: IDetail;
    InputTypeDetail: IInputTypeDetail;
    PrimaryButtonAction: IPrimaryButtonAction;
    CheckboxOptions: ICheckboxOptions;
    EditorPart: Omit<IEditorPart, 'children'> & {
        children?: Maybe<Array<Maybe<IResolversParentTypes['EditorChildren']>>>;
    };
    GroupOrientation: IGroupOrientation;
    EditorChildren: IResolversParentTypes['EditorPart'] | IResolversParentTypes['EditorGroup'];
    EditorGroup: Omit<IEditorGroup, 'tabs'> & {
        tabs?: Maybe<Array<Maybe<IResolversParentTypes['EditorInput']>>>;
    };
    IEditorGroup: IResolversParentTypes['EditorGroup'];
    EditorInput: IResolversParentTypes['DataUriEditorInput'] | IResolversParentTypes['DiffEditorInput'] | IResolversParentTypes['FileEditorInput'] | IResolversParentTypes['KeybindingEditorInput'] | IResolversParentTypes['ResourceEditorInput'] | IResolversParentTypes['SideBySideEditorInput'] | IResolversParentTypes['UntitledEditorInput'];
    DataUriEditorInput: IDataUriEditorInput;
    IEditorInput: IResolversParentTypes['DataUriEditorInput'] | IResolversParentTypes['DiffEditorInput'] | IResolversParentTypes['FileEditorInput'] | IResolversParentTypes['KeybindingEditorInput'] | IResolversParentTypes['ResourceEditorInput'] | IResolversParentTypes['SideBySideEditorInput'] | IResolversParentTypes['UntitledEditorInput'];
    EDITOR_INPUT_ID: IEDITOR_INPUT_ID;
    FileStatWithMetadata: IFileStatWithMetadata;
    IBaseStat: IResolversParentTypes['FileStatWithMetadata'] | IResolversParentTypes['TextFileStreamContent'] | IResolversParentTypes['TextFilePublishContent'] | IResolversParentTypes['TextFileContent'] | IResolversParentTypes['FileContent'] | IResolversParentTypes['FileStat'] | IResolversParentTypes['FileStreamContent'];
    BigInt: Scalars['BigInt'];
    IBaseStatWithMetadata: IResolversParentTypes['FileStatWithMetadata'] | IResolversParentTypes['TextFileStreamContent'] | IResolversParentTypes['TextFileContent'] | IResolversParentTypes['FileContent'] | IResolversParentTypes['FileStreamContent'];
    IContentChangedEvent: IResolversParentTypes['FileStatWithMetadata'];
    IFileClientMetadata: IResolversParentTypes['FileStatWithMetadata'] | IResolversParentTypes['TextFileContent'];
    FileModelState: IFileModelState;
    ITreeItem: IResolversParentTypes['FileStatWithMetadata'];
    IUntitledFileValue: IResolversParentTypes['FileStatWithMetadata'];
    IEditorInputWithGroupFields: IResolversParentTypes['DataUriEditorInput'] | IResolversParentTypes['DiffEditorInput'] | IResolversParentTypes['FileEditorInput'] | IResolversParentTypes['KeybindingEditorInput'] | IResolversParentTypes['ResourceEditorInput'] | IResolversParentTypes['SideBySideEditorInput'] | IResolversParentTypes['UntitledEditorInput'];
    DiffEditorInput: Omit<IDiffEditorInput, 'originalInput' | 'modifiedInput'> & {
        originalInput?: Maybe<IResolversParentTypes['EditorInput']>;
        modifiedInput?: Maybe<IResolversParentTypes['EditorInput']>;
    };
    FileEditorInput: IFileEditorInput;
    IFileEditorInput: IResolversParentTypes['FileEditorInput'];
    IEncodingSupport: IResolversParentTypes['FileEditorInput'];
    IModeSupport: IResolversParentTypes['FileEditorInput'];
    KeybindingEditorInput: IKeybindingEditorInput;
    ResourceEditorInput: IResourceEditorInput;
    SideBySideEditorInput: Omit<ISideBySideEditorInput, 'master' | 'details'> & {
        master?: Maybe<IResolversParentTypes['EditorInput']>;
        details?: Maybe<IResolversParentTypes['EditorInput']>;
    };
    ISideBySideEditorInput: IResolversParentTypes['SideBySideEditorInput'];
    UntitledEditorInput: IUntitledEditorInput;
    CodeEditorViewState: ICodeEditorViewState;
    ConfigurationData: IConfigurationData;
    ConfigurationModel: IConfigurationModel;
    Overrides: IOverrides;
    FolderConfigurationModel: IFolderConfigurationModel;
    ConfigurationOverrides: IConfigurationOverrides;
    Context: IContext;
    scmResourceGroups: IscmResourceGroups;
    ProvidedRemoteConnectionStates: IProvidedRemoteConnectionStates;
    ConfigurationTarget: IConfigurationTarget;
    Environment: IEnvironment;
    ExtensionHostDebugParams: IExtensionHostDebugParams;
    IDebugParams: IResolversParentTypes['ExtensionHostDebugParams'];
    Keybindings: IKeybindings;
    KeybindingItem: IKeybindingItem;
    KeybindingSource: IKeybindingSource;
    SelectedOutput: ISelectedOutput;
    QuickPickItem: IQuickPickItem;
    QuickPickItemHighlights: IQuickPickItemHighlights;
    Match: IMatch;
    WorkspaceData: IWorkspaceData;
    IStaticWorkspaceData: IResolversParentTypes['WorkspaceData'];
    WorkspaceFolderData: IWorkspaceFolderData;
    WorkspaceValue_Input: IWorkspaceValue_Input;
    ConfigurationOverrides_Input: IConfigurationOverrides_Input;
    GoToLineQuickAccess: IGoToLineQuickAccess;
    LineRange: ILineRange;
    KeybindingContextMenu: IKeybindingContextMenu;
    EditKeybindingItem: IEditKeybindingItem;
    Notifications: INotifications;
    Notification: INotification;
    NotificationSeverity: INotificationSeverity;
    NotificationActions: INotificationActions;
    Action: IAction;
    QuickInputModel: IQuickInputModel;
    QuickInput: IQuickInput;
    QuickPick: IQuickPick;
    ReadTextFileOptions_Input: IReadTextFileOptions_Input;
    ReadFileOptions_Input_limits: IReadFileOptions_Input_limits;
    TextFileStreamContent: ITextFileStreamContent;
    IBaseTextFileContent: IResolversParentTypes['TextFileStreamContent'] | IResolversParentTypes['TextFilePublishContent'] | IResolversParentTypes['TextFileContent'];
    TextBufferData: ITextBufferData;
    TextFilePublishContent: ITextFilePublishContent;
    FileContentStatus: FileContentStatus;
    TextFileContent: ITextFileContent;
    ReadFileOptions_Input: IReadFileOptions_Input;
    FileContent: IFileContent;
    VSBuffer: Scalars['VSBuffer'];
    ResolveAll_toResolveWithMetadata_Input: IResolveAll_toResolveWithMetadata_Input;
    ResolveMetadataFileOptions_Input: IResolveMetadataFileOptions_Input;
    ResolveFileResultWithMetadata: IResolveFileResultWithMetadata;
    LoadOptions_Input: ILoadOptions_Input;
    FileLoadReason: IFileLoadReason;
    Dialog_input: IDialog_input;
    Detail_input: IDetail_input;
    InputTypeDetail_input: IInputTypeDetail_input;
    PrimaryButtonAction_input: IPrimaryButtonAction_input;
    ActionRun_input: IActionRun_input;
    CheckboxOptions_input: ICheckboxOptions_input;
    DialogResult: IDialogResult;
    Notification_input: INotification_input;
    NotificationMessage_input: INotificationMessage_input;
    MessageLink_input: IMessageLink_input;
    NotificationActions_input: INotificationActions_input;
    Action_input: IAction_input;
    Statusbar: Omit<IStatusbar, 'items'> & {
        items?: Maybe<Array<Maybe<IResolversParentTypes['StatusbarItem']>>>;
    };
    StatusbarItem: IResolversParentTypes['Terminal'] | IResolversParentTypes['SelectionStatus'] | IResolversParentTypes['Indentation'] | IResolversParentTypes['EncodingStatus'] | IResolversParentTypes['EndOfLineSequence'] | IResolversParentTypes['LanguageMode'];
    SelectionStatus: ISelectionStatus;
    Indentation: IIndentation;
    EncodingStatus: IEncodingStatus;
    EndOfLineSequence: IEndOfLineSequence;
    LanguageMode: ILanguageMode;
    UserPreferencesRes: IUserPreferencesRes;
    IUserPreferences: IIUserPreferences;
    WorkspaceRes: IWorkspaceRes;
    Mutation: {};
    AddEntry_input: IAddEntry_input;
    StatusbarEntry_input: IStatusbarEntry_input;
    KeybindingItem_input: IKeybindingItem_input;
    CloseEditor_Input: ICloseEditor_Input;
    CloseEditorOptions_Input: ICloseEditorOptions_Input;
    CreateFileOptions_Input: ICreateFileOptions_Input;
    DeleteFileOptions_Input: IDeleteFileOptions_Input;
    LineRange_input: ILineRange_input;
    IJSONValue_input: IIJSONValue_input;
    KeepOpen_Input: IKeepOpen_Input;
    MoveEditor_Input: IMoveEditor_Input;
    MoveEditorOptions_Input: IMoveEditorOptions_Input;
    PromptChoice_input: IPromptChoice_input;
    PromptChoiceRun: IPromptChoiceRun;
    PromptOptions_input: IPromptOptions_input;
    PromptOptionsCancel: IPromptOptionsCancel;
    OpenEditor_Input: IOpenEditor_Input;
    EditorOpenOptions_Input: IEditorOpenOptions_Input;
    EditorOpenPositioning: IEditorOpenPositioning;
    ResourceDiff_Input: IResourceDiff_Input;
    TextEditorOptions_Input: ITextEditorOptions_Input;
    TextEditorSelection_Input: ITextEditorSelection_Input;
    Resource_Input: IResource_Input;
    ResourceSideBySide_Input: IResourceSideBySide_Input;
    UntitledResource_Input: IUntitledResource_Input;
    Keybinding_input: IKeybinding_input;
    RemoveEditor_Input: IRemoveEditor_Input;
    KeyboardEvent_input: IKeyboardEvent_input;
    KeyboardEvent_output: IKeyboardEvent_output;
    SaveOptions_Input: ISaveOptions_Input;
    SaveReason: SaveReason;
    FileStat: IFileStat;
    SaveWorkspaceRes: ISaveWorkspaceRes;
    SelectEditor_Input: ISelectEditor_Input;
    TreeData_Input: ITreeData_Input;
    PickItem: IPickItem;
    QuickPickItemHighlights_input: IQuickPickItemHighlights_input;
    Match_input: IMatch_input;
    SetStatusMsg_input: ISetStatusMsg_input;
    ContextMenu_input: IContextMenu_input;
    Anchor_input: IAnchor_input;
    MenuItem_input: IMenuItem_input;
    InputOptions: IInputOptions;
    PickInputOptions: IPickInputOptions;
    ContentChangedEvent_Input: IContentChangedEvent_Input;
    ChangesChunk_Input: IChangesChunk_Input;
    ChangeRange_Input: IChangeRange_Input;
    WriteFileOptions_Input: IWriteFileOptions_Input;
    CodeEditorViewState_Input: ICodeEditorViewState_Input;
    EditorLayout_Input: IEditorLayout_Input;
    EditorChildren_Input: IEditorChildren_Input;
    EditorInput_Input: IEditorInput_Input;
    UpdateEntry_input: IUpdateEntry_input;
    WatchOptions_Input: IWatchOptions_Input;
    WriteTextFileOptions_Input: IWriteTextFileOptions_Input;
    UpdatedResource: IUpdatedResource;
    UpdateDelayedResource: IUpdateDelayedResource;
    Subscription: {};
    FileChange: IFileChange;
    FileChangeType: FileChangeType;
    FileOperationOutput: IFileOperationOutput;
    FileOperation: IFileOperation;
    IConfigurationChangeEvent: IIConfigurationChangeEvent;
    ResourceMapConfigurationModel: IResourceMapConfigurationModel;
    JSONObject: Scalars['JSONObject'];
    VSBufferReadableStream: Scalars['VSBufferReadableStream'];
    FieldError: IFieldError;
    WorkspaceStackSettings: IWorkspaceStackSettings;
    MoleculerServiceName: IMoleculerServiceName;
    Assets: IAssets;
    Scripts: IScripts;
    Bundles: IBundles;
    ExtensionPackageType: IExtensionPackageType;
    Engines: IEngines;
    Author: IAuthor;
    GalleryBanner: IGalleryBanner;
    ExtensionManifestBugs: IExtensionManifestBugs;
    ExtensionManifestRepository: IExtensionManifestRepository;
    ExtensionKind: IExtensionKind;
    ExtensionType: IExtensionType;
    ExtensionManifest: IExtensionManifest;
    ExtensionContributions: IExtensionContributions;
    Actions: IActions;
    ActionItem: IActionItem;
    ExtensionConfiguration: IExtensionConfiguration;
    Debugger: IDebugger;
    Grammar: IGrammar;
    ExtensionJSONValidation: IExtensionJSONValidation;
    KeyBinding: IKeyBinding;
    ExtensionLanguage: IExtensionLanguage;
    Menus: IMenus;
    MenuItemAction: IMenuItemAction;
    MenuItemActionContext: IMenuItemActionContext;
    MenuItemActionEditor: IMenuItemActionEditor;
    MenuItemActionEditorTitle: IMenuItemActionEditorTitle;
    MenuItemActionDebug: IMenuItemActionDebug;
    MenuItemActionScm: IMenuItemActionScm;
    MenuItemActionScmChange: IMenuItemActionScmChange;
    MenuItemActionView: IMenuItemActionView;
    Snippet: ISnippet;
    ThemeLabel: IThemeLabel;
    ExtensionColor: IExtensionColor;
    ExtensionColorTypes: IExtensionColorTypes;
    Localization: ILocalization;
    LocalizationTranslation: ILocalizationTranslation;
    ExtensionIdentifier: IExtensionIdentifier;
    BaseExtension: IBaseExtension;
    ExtensionConfigurationProperty: IExtensionConfigurationProperty;
    Contributes: IContributes;
    PositionInput: IPositionInput;
    RangeInput: IRangeInput;
    WorkspaceIdentifier: IWorkspaceIdentifier;
    ViewContainer: IViewContainer;
    View: IView;
    MenuId: IMenuId;
    URIInput: IURIInput;
    NativeOpenDialogOptions: INativeOpenDialogOptions;
    EnterWorkspaceResult: IEnterWorkspaceResult;
    CrashReporterStartOptions: ICrashReporterStartOptions;
    OpenDialogOptions: IOpenDialogOptions;
    FileFilter: IFileFilter;
    OpenDialogOptionsProperties: IOpenDialogOptionsProperties;
    MessageBoxResult: IMessageBoxResult;
    OpenSettings: IOpenSettings;
    URIToOpen: IResolversParentTypes['WorkspaceToOpen'] | IResolversParentTypes['FolderToOpen'] | IResolversParentTypes['FileToOpen'];
    WorkspaceToOpen: IWorkspaceToOpen;
    FolderToOpen: IFolderToOpen;
    FileToOpen: IFileToOpen;
    MessageBoxOptions: IMessageBoxOptions;
    SaveDialogOptions: ISaveDialogOptions;
    NewWindowOptions: INewWindowOptions;
    DevToolsOptionsMode: IDevToolsOptionsMode;
    DevToolsOptions: IDevToolsOptions;
    OpenContext: IOpenContext;
    ReadyState: IReadyState;
    IPathData: IResolversParentTypes['Path'];
    Path: IPath;
    IPathsToWaitForData: IResolversParentTypes['PathsToWaitFor'];
    PathsToWaitFor: IPathsToWaitFor;
    WindowConfiguration: IWindowConfiguration;
    OpenFileRequest: IOpenFileRequest;
    AddFoldersRequest: IAddFoldersRequest;
    RunActionInWindowRequestFrom: IRunActionInWindowRequestFrom;
    RunActionInWindowRequest: IRunActionInWindowRequest;
    RunKeybindingInWindowRequest: IRunKeybindingInWindowRequest;
    OpenConfiguration: Omit<IOpenConfiguration, 'urisToOpen'> & {
        urisToOpen?: Maybe<Array<Maybe<IResolversParentTypes['URIToOpen']>>>;
    };
    MessageLink: IMessageLink;
    NotificationChangeType: INotificationChangeType;
    NotificationChangeEvent: INotificationChangeEvent;
    NotificationViewItem: INotificationViewItem;
    NotificationMessage: INotificationMessage;
    NotificationViewItemProgress: INotificationViewItemProgress;
    NotificationViewItemProgressState: INotificationViewItemProgressState;
    NotificationViewItemLabelKind: INotificationViewItemLabelKind;
    StorageScope: IStorageScope;
    ConfigurationServiceAction: IConfigurationServiceAction;
    WorkspaceContextServiceAction: IWorkspaceContextServiceAction;
    EnvironmentServiceAction: IEnvironmentServiceAction;
    KeyPathSegment: IKeyPathSegment;
    IUserSettings: IIUserSettings;
    PreferenceItem: IPreferenceItem;
    SettingValueType: ISettingValueType;
    CloseOptions_Input: ICloseOptions_Input;
    EditorActionType: IEditorActionType;
    EditorIdentifier: Omit<IEditorIdentifier, 'editor'> & {
        editor?: Maybe<IResolversParentTypes['EditorInput']>;
    };
    EditorSettings: IEditorSettings;
    OpenDiff_Input: IOpenDiff_Input;
    DockLayout: Omit<IDockLayout, 'tabs'> & {
        tabs?: Maybe<Array<Maybe<IResolversParentTypes['EditorInput']>>>;
    };
    EDITOR_ID: IEDITOR_ID;
    BaseResourceInput: IBaseResourceInput;
    GroupDirection: IGroupDirection;
    GroupLocation: IGroupLocation;
    GroupsArrangement: IGroupsArrangement;
    GroupLayoutArgument: IGroupLayoutArgument;
    EditorGroupLayout: IEditorGroupLayout;
    CopyEditorOptions_Input: ICopyEditorOptions_Input;
    AddGroupOptions_Input: IAddGroupOptions_Input;
    MergeGroupMode: IMergeGroupMode;
    MergeGroupOptions_Input: IMergeGroupOptions_Input;
    CloseDirection: ICloseDirection;
    CloseEditorsFilter: Omit<ICloseEditorsFilter, 'except'> & {
        except?: Maybe<IResolversParentTypes['EditorInput']>;
    };
    GroupsOrder: IGroupsOrder;
    EditorsOrder: IEditorsOrder;
    SideBySideEditor: ISideBySideEditor;
    EditorPartConfiguration_Input: IEditorPartConfiguration_Input;
    TabCloseButtonType: ITabCloseButtonType;
    TabSizingType: ITabSizingType;
    OpenPositioningType: IOpenPositioningType;
    OpenSideBySideDirection: IOpenSideBySideDirection;
    LableFormatType: ILableFormatType;
    EditorPartOptions_Input: IEditorPartOptions_Input;
    EditorOptions_Input: IEditorOptions_Input;
    ContextInput: IContextInput;
    scmProviders: IscmProviders;
    commentThread: IcommentThread;
    PendingStatusbarEntry: IPendingStatusbarEntry;
    FileOverwriteOptions: IFileOverwriteOptions;
    FileWriteOptions: IFileWriteOptions;
    FileOpenOptions: IFileOpenOptions;
    FileDeleteOptions: IFileDeleteOptions;
    FileType: FileType;
    Files_Stat: IFiles_Stat;
    ResolveFileResult: IResolveFileResult;
    FileStreamContent: IFileStreamContent;
    StreamContent: IStreamContent;
    ResolveFileOptions_Input: IResolveFileOptions_Input;
    FileOperationResult: IFileOperationResult;
    HotExitConfiguration: HotExitConfiguration;
    ImportResult: IImportResult;
    ChangesChangesChunk_Input: IChangesChangesChunk_Input;
    ChunkOptions_Input: IChunkOptions_Input;
    ChangeRange: IChangeRange;
    ContentChangedEvent: IContentChangedEvent;
    ChangesChunk: IChangesChunk;
    ResolveAll_toResolve_Input: IResolveAll_toResolve_Input;
    FileServiceAction: IFileServiceAction;
    TextFileServiceAction: ITextFileServiceAction;
    TextFileOperationResult: ITextFileOperationResult;
    ResourceEncoding: IResourceEncoding;
    FileStateChange: IFileStateChange;
    FileResult: IFileResult;
    ModelLoadOrCreateOptions_Input_reload: IModelLoadOrCreateOptions_Input_reload;
    ModelLoadOrCreateOptions_Input: IModelLoadOrCreateOptions_Input;
    CursorState: ICursorState;
    ViewState: IViewState;
    CursorState_Input: ICursorState_Input;
    ViewState_Input: IViewState_Input;
    EDITOR_INPUT_RESOURCE_TYPE_ID: IEDITOR_INPUT_RESOURCE_TYPE_ID;
};
export declare type IActionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Action'] = IResolversParentTypes['Action']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    tooltip?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    class?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    enabled?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    checked?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    radio?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    run?: Resolver<Maybe<IResolversTypes['ActionRun']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IActionItemResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ActionItem'] = IResolversParentTypes['ActionItem']> = {
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IActionRunResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ActionRun'] = IResolversParentTypes['ActionRun']> = {
    type?: Resolver<Maybe<IResolversTypes['GraphqlCallType']>, ParentType, ContextType>;
    document?: Resolver<Maybe<IResolversTypes['AnyObject']>, ParentType, ContextType>;
    variables?: Resolver<Maybe<IResolversTypes['AnyObject']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IActionsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Actions'] = IResolversParentTypes['Actions']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    command?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    title?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    category?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    actionItem?: Resolver<Maybe<IResolversTypes['ActionItem']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IAddFoldersRequestResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['AddFoldersRequest'] = IResolversParentTypes['AddFoldersRequest']> = {
    foldersToAdd?: Resolver<Maybe<Array<Maybe<IResolversTypes['URI']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IAnchorResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Anchor'] = IResolversParentTypes['Anchor']> = {
    x?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    y?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    height?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    width?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export interface IAnyObjectScalarConfig extends GraphQLScalarTypeConfig<IResolversTypes['AnyObject'], any> {
    name: 'AnyObject';
}
export declare type IAssetsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Assets'] = IResolversParentTypes['Assets']> = {
    Type?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    Content?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IAuthorResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Author'] = IResolversParentTypes['Author']> = {
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IBaseExtensionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['BaseExtension'] = IResolversParentTypes['BaseExtension']> = {
    type?: Resolver<Maybe<IResolversTypes['ExtensionType']>, ParentType, ContextType>;
    identifier?: Resolver<Maybe<IResolversTypes['ExtensionIdentifier']>, ParentType, ContextType>;
    galleryIdentifier?: Resolver<Maybe<IResolversTypes['ExtensionIdentifier']>, ParentType, ContextType>;
    manifest?: Resolver<Maybe<IResolversTypes['ExtensionManifest']>, ParentType, ContextType>;
    location?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export interface IBigIntScalarConfig extends GraphQLScalarTypeConfig<IResolversTypes['BigInt'], any> {
    name: 'BigInt';
}
export declare type IBundlesResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Bundles'] = IResolversParentTypes['Bundles']> = {
    server?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    browser?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IChangeRangeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ChangeRange'] = IResolversParentTypes['ChangeRange']> = {
    startLineNumber?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    startColumn?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    endLineNumber?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    endColumn?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IChangesChunkResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ChangesChunk'] = IResolversParentTypes['ChangesChunk']> = {
    range?: Resolver<Maybe<IResolversTypes['ChangeRange']>, ParentType, ContextType>;
    rangeLength?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    text?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    rangeOffset?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    forceMoveMarkers?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ICheckboxOptionsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CheckboxOptions'] = IResolversParentTypes['CheckboxOptions']> = {
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    checked?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ICloseEditorsFilterResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CloseEditorsFilter'] = IResolversParentTypes['CloseEditorsFilter']> = {
    direction?: Resolver<Maybe<IResolversTypes['CloseDirection']>, ParentType, ContextType>;
    except?: Resolver<Maybe<IResolversTypes['EditorInput']>, ParentType, ContextType>;
    savedOnly?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ICodeEditorViewStateResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CodeEditorViewState'] = IResolversParentTypes['CodeEditorViewState']> = {
    cursorState?: Resolver<Maybe<IResolversTypes['JSON']>, ParentType, ContextType>;
    viewState?: Resolver<Maybe<IResolversTypes['JSON']>, ParentType, ContextType>;
    contributionsState?: Resolver<Maybe<IResolversTypes['JSON']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IConfigurationResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Configuration'] = IResolversParentTypes['Configuration']> = {
    defaultSetting?: Resolver<Maybe<Array<Maybe<IResolversTypes['SettingsGroup']>>>, ParentType, ContextType>;
    files?: Resolver<Maybe<IResolversTypes['Files']>, ParentType, ContextType>;
    git?: Resolver<Maybe<IResolversTypes['Git']>, ParentType, ContextType>;
    languages?: Resolver<Maybe<IResolversTypes['Languages']>, ParentType, ContextType>;
    output?: Resolver<Maybe<IResolversTypes['Output']>, ParentType, ContextType>;
    search?: Resolver<Maybe<IResolversTypes['Search']>, ParentType, ContextType>;
    terminal?: Resolver<Maybe<IResolversTypes['Terminal']>, ParentType, ContextType>;
    workspace?: Resolver<Maybe<IResolversTypes['WorkspacePreferenceWorkbench']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IConfigurationDataResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ConfigurationData'] = IResolversParentTypes['ConfigurationData']> = {
    defaults?: Resolver<Maybe<IResolversTypes['ConfigurationModel']>, ParentType, ContextType>;
    user?: Resolver<Maybe<IResolversTypes['ConfigurationModel']>, ParentType, ContextType>;
    workspace?: Resolver<Maybe<IResolversTypes['ConfigurationModel']>, ParentType, ContextType>;
    folders?: Resolver<Maybe<Array<Maybe<IResolversTypes['FolderConfigurationModel']>>>, ParentType, ContextType>;
    isComplete?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IConfigurationExtensionInfoResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ConfigurationExtensionInfo'] = IResolversParentTypes['ConfigurationExtensionInfo']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IConfigurationModelResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ConfigurationModel'] = IResolversParentTypes['ConfigurationModel']> = {
    contents?: Resolver<Maybe<IResolversTypes['AnyObject']>, ParentType, ContextType>;
    keys?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    overrides?: Resolver<Maybe<Array<Maybe<IResolversTypes['Overrides']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IConfigurationOverridesResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ConfigurationOverrides'] = IResolversParentTypes['ConfigurationOverrides']> = {
    resource?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    overrideIdentifier?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IContentChangedEventResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ContentChangedEvent'] = IResolversParentTypes['ContentChangedEvent']> = {
    changes?: Resolver<Maybe<Array<Maybe<IResolversTypes['ChangesChunk']>>>, ParentType, ContextType>;
    eol?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    versionId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    isUndoing?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isRedoing?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isFlush?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IContextResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Context'] = IResolversParentTypes['Context']> = {
    originalResourceScheme?: Resolver<Maybe<IResolversTypes['scmResourceGroups']>, ParentType, ContextType>;
    view?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    viewItem?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    gitOpenRepositoryCount?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    isInDiffEditor?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isInDiffRightEditor?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    resourceScheme?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    resourceFilename?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    resourceLangId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    resource?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    resourceExtName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    resourceSet?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isFileSystemResource?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inputFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    suggestWidgetVisible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    suggestWidgetMultipleSuggestions?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    suggestionMakesTextEdit?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    acceptSuggestionOnEnter?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    hasOtherSuggestions?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    groupFocusedInOpenEditors?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    dirtyEditor?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    resourceSelectedForCompare?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    fileCopied?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    breadcrumbsPossible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    breadcrumbsVisible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    breadcrumbsActive?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    canNavigateBack?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    canNavigateForward?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    canNavigateToLastEditLocation?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    dirtyDiffVisible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    cancellableOperation?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    parameterHintsVisible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    parameterHintsMultipleSignatures?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    markdownPreviewFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isMac?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isLinux?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isWindows?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    remoteAuthority?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    remoteConnectionState?: Resolver<Maybe<IResolversTypes['ProvidedRemoteConnectionStates']>, ParentType, ContextType>;
    hasMacNativeTabs?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    supportsWorkspaces?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isDevelopment?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    workbenchState?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    workspaceFolderCount?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    remoteFileDialogVisible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isFullscreen?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    atEndOfWord?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    scmRepository?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    scmProvider?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    scmResourceGroup?: Resolver<Maybe<IResolversTypes['scmResourceGroups']>, ParentType, ContextType>;
    inDiffEditorKey?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isDominatedByLongLines?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isWordWrapMinified?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    commentThread?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    commentThreadisEmpty?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    commentIsEmpty?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    commentEditorFocused?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    interfaceOverviewVisible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inReferenceSearchEditor?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    referenceSearchVisible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    listFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    listSupportsMultiSelect?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    listHasSelectionOrFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    listDoubleSelection?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    listMultiSelection?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    listSupportsKeyboardNavigation?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    WorkbenchListAutomaticKeyboardNavigationKey?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    accessibilityHelpWidgetVisible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inQuickOpenKey?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    supportedCodeAction?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    hasSymbols?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    hasSnippetCompletions?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    messageVisible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorHasCallHierarchyProvider?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    callHierarchyVisible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    searchViewletVisible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    searchViewletFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inputBoxFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    searchInputBoxFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    replaceInputBoxFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    patternIncludesInputBoxFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    patternExcludesInputBoxFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    replaceActive?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    hasSearchResult?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    firstMatchFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    fileMatchOrMatchFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    fileMatchOrFolderMatchFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    fileMatchFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    folderMatchFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    matchFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inRecentFilesPicker?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inWindowsPicker?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    findWidgetVisible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    findInputFocussed?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    replaceInputFocussed?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorTextFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    textInputFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorReadonly?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorHasSelection?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorHasMultipleSelections?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorTabMoveFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isInEmbeddedEditor?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    canUndo?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    canRedo?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorLangId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    editorHasCompletionItemProvider?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorHasCodeActionsProvider?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorHasDefinitionProvider?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorHasDeclarationProvider?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorHasImplementationProvider?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorHasTypeDefinitionProvider?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorHasHoverProvider?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorHadDocumentHighlightProvider?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorHasDocumentSymbolProvider?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorHasReferenceProvider?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorHasRenameProvider?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorHasSignatureHelpProvider?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorHasDocumentFormattingProvider?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorHasDocumentSelectionFormattingProvider?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorHasMultipleDocumentSelectionFormattingProvider?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    activeEditor?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    editorIsOpen?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorPinned?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    groupActiveEditorDirty?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    groupEditorsCount?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    textCompareEditorVisible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    textCompareEditorActive?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    activeEditorGroupEmpty?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    multipleEditorGroups?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inZenMode?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inCenteredLayout?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    splitEditorsVertically?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    sideBarVisible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    sideBarFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    activeViewlet?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    activePanel?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    panelFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    panelPosition?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    debugType?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    debugConfigurationType?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    debugState?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    inDebugMode?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inDebugRepl?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    breakpointWidgetVisible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    watchExpressionsFocused?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    variablesFocused?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    expressionSelected?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    breakpointSelected?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    callStackItemType?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    loadedScriptsSupported?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    loadedScriptsItemType?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    focusedSessionIsAttach?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    stepBackSupported?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    restartFrameSupported?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inSettingsEditor?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inSettingsJSONEditor?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inSettingsSearch?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    settingsTocRowFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inKeybindings?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inKeybindingsSearch?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    keybindingFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    explorerViewletVisible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    explorerResourceIsFolder?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    explorerResourceReadonly?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    explorerResourceIsRoot?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    explorerResourceCut?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    explorerResourceMoveableToTrash?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    filesExplorerFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    openEditorsVisible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    openEditorsFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    explorerViewletFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    terminalIsOpen?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    terminalFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    terminalTextSelected?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    terminalFindWidgetVisible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    terminalFindWidgetInputFocused?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    terminalFindWidgetFocused?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    webviewFindWidgetVisible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    taskRunning?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    referenceSearchTreeFocused?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    interactivePlaygroundFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    outlineFiltered?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    outlineFocused?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    problemsViewFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    problemFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    problemsFilterFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    relatedInformationFocus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inOutput?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    activeLogOutput?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    multiCursorModifier?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    saveConflictResolutionContext?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    markersNavigationVisible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    hasWordHighlights?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    profileSessionState?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    extensionHostProfileRecorded?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    historyNavigationEnabled?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    historyNavigationWidget?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    nonEmptyWorkspace?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    defaultExtensionViews?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    searchMarketplaceExtensions?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    searchInstalledExtensions?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    searchOutdatedExtensions?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    searchEnabledExtensions?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    searchDisabledExtensions?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    hasInstalledExtensions?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    searchBuiltInExtensions?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    recommendedExtensions?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    defaultRecommendedExtensions?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    workspaceRecommendations?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    workspaceFolderRecommendations?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    addToWorkspaceRecommendations?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    addToWorkspaceFolderRecommendations?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IContextMenuResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ContextMenu'] = IResolversParentTypes['ContextMenu']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    isShow?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    anchor?: Resolver<Maybe<IResolversTypes['Anchor']>, ParentType, ContextType>;
    menuItems?: Resolver<Maybe<Array<Maybe<IResolversTypes['MenuItem']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IContributesResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Contributes'] = IResolversParentTypes['Contributes']> = {
    menus?: Resolver<Maybe<IResolversTypes['Menus']>, ParentType, ContextType>;
    actions?: Resolver<Maybe<Array<Maybe<IResolversTypes['Actions']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ICrashReporterStartOptionsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CrashReporterStartOptions'] = IResolversParentTypes['CrashReporterStartOptions']> = {
    companyName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    submitURL?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    productName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    uploadToServer?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    ignoreSystemCrashHandler?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    extra?: Resolver<Maybe<IResolversTypes['AnyObject']>, ParentType, ContextType>;
    crashesDirectory?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ICursorStateResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['CursorState'] = IResolversParentTypes['CursorState']> = {
    inSelectionMode?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    selectionStart?: Resolver<Maybe<IResolversTypes['Position']>, ParentType, ContextType>;
    position?: Resolver<Maybe<IResolversTypes['Position']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IDataUriEditorInputResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['DataUriEditorInput'] = IResolversParentTypes['DataUriEditorInput']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    resource?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    typeId?: Resolver<Maybe<IResolversTypes['EDITOR_INPUT_ID']>, ParentType, ContextType>;
    description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    fileReference?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType>;
    preferredEditorId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    isSupportsSplitEditor?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isActive?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    preview?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isPinned?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    status?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    closable?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    mime?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    etag?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    size?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IDebuggerResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Debugger'] = IResolversParentTypes['Debugger']> = {
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    type?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    runtime?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IDefaultPreferencesResponseResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['DefaultPreferencesResponse'] = IResolversParentTypes['DefaultPreferencesResponse']> = {
    preferences?: Resolver<Maybe<Array<Maybe<IResolversTypes['PreferencesType']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IDefaultSettingsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['DefaultSettings'] = IResolversParentTypes['DefaultSettings']> = {
    id?: Resolver<Maybe<IResolversTypes['ID']>, ParentType, ContextType>;
    latestSettings?: Resolver<Maybe<IResolversTypes['Settings']>, ParentType, ContextType>;
    settingsURL?: Resolver<IResolversTypes['URI'], ParentType, ContextType>;
    viewerCanAdminister?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>;
    settingsCascade?: Resolver<IResolversTypes['SettingsCascade'], ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IDetailResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Detail'] = IResolversParentTypes['Detail']> = {
    inputName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    inputType?: Resolver<Maybe<IResolversTypes['InputTypeDetail']>, ParentType, ContextType>;
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    placeholder?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    defaultValue?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    required?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IDevToolsOptionsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['DevToolsOptions'] = IResolversParentTypes['DevToolsOptions']> = {
    mode?: Resolver<Maybe<IResolversTypes['DevToolsOptionsMode']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IDialogResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Dialog'] = IResolversParentTypes['Dialog']> = {
    dialogType?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    detail?: Resolver<Maybe<Array<Maybe<IResolversTypes['Detail']>>>, ParentType, ContextType>;
    primaryButton?: Resolver<Maybe<IResolversTypes['PrimaryButtonAction']>, ParentType, ContextType>;
    secondaryButton?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    checkbox?: Resolver<Maybe<IResolversTypes['CheckboxOptions']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IDialogResultResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['DialogResult'] = IResolversParentTypes['DialogResult']> = {
    confirmed?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    checkboxChecked?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IDiffEditorInputResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['DiffEditorInput'] = IResolversParentTypes['DiffEditorInput']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    resource?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    typeId?: Resolver<Maybe<IResolversTypes['EDITOR_INPUT_ID']>, ParentType, ContextType>;
    description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    fileReference?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType>;
    preferredEditorId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    isSupportsSplitEditor?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isActive?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    preview?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isPinned?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    status?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    closable?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    originalInput?: Resolver<Maybe<IResolversTypes['EditorInput']>, ParentType, ContextType>;
    modifiedInput?: Resolver<Maybe<IResolversTypes['EditorInput']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IDockLayoutResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['DockLayout'] = IResolversParentTypes['DockLayout']> = {
    id?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    size?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    activeId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    mode?: Resolver<Maybe<IResolversTypes['GroupOrientation']>, ParentType, ContextType>;
    children?: Resolver<Maybe<Array<Maybe<IResolversTypes['DockLayout']>>>, ParentType, ContextType>;
    tabs?: Resolver<Maybe<Array<Maybe<IResolversTypes['EditorInput']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IEditKeybindingItemResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EditKeybindingItem'] = IResolversParentTypes['EditKeybindingItem']> = {
    command?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    key?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    when?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    isDefault?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IEditorChildrenResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EditorChildren'] = IResolversParentTypes['EditorChildren']> = {
    __resolveType: TypeResolveFn<'EditorPart' | 'EditorGroup', ParentType, ContextType>;
};
export declare type IEditorGroupResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EditorGroup'] = IResolversParentTypes['EditorGroup']> = {
    activeId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    id?: Resolver<IResolversTypes['Int'], ParentType, ContextType>;
    isActive?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    size?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    tabs?: Resolver<Maybe<Array<Maybe<IResolversTypes['EditorInput']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IEditorGroupLayoutResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EditorGroupLayout'] = IResolversParentTypes['EditorGroupLayout']> = {
    groups?: Resolver<Maybe<Array<Maybe<IResolversTypes['GroupLayoutArgument']>>>, ParentType, ContextType>;
    orientation?: Resolver<Maybe<IResolversTypes['GroupOrientation']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IEditorIdentifierResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EditorIdentifier'] = IResolversParentTypes['EditorIdentifier']> = {
    groupId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    editor?: Resolver<Maybe<IResolversTypes['EditorInput']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IEditorInputResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EditorInput'] = IResolversParentTypes['EditorInput']> = {
    __resolveType: TypeResolveFn<'DataUriEditorInput' | 'DiffEditorInput' | 'FileEditorInput' | 'KeybindingEditorInput' | 'ResourceEditorInput' | 'SideBySideEditorInput' | 'UntitledEditorInput', ParentType, ContextType>;
};
export declare type IEditorPartResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EditorPart'] = IResolversParentTypes['EditorPart']> = {
    id?: Resolver<IResolversTypes['Int'], ParentType, ContextType>;
    mode?: Resolver<Maybe<IResolversTypes['GroupOrientation']>, ParentType, ContextType>;
    height?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    size?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    children?: Resolver<Maybe<Array<Maybe<IResolversTypes['EditorChildren']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IEditorPartOptions_InputResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EditorPartOptions_Input'] = IResolversParentTypes['EditorPartOptions_Input']> = {
    showTabs?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    highlightModifiedTabs?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    tabCloseButton?: Resolver<Maybe<IResolversTypes['TabCloseButtonType']>, ParentType, ContextType>;
    tabSizing?: Resolver<Maybe<IResolversTypes['TabSizingType']>, ParentType, ContextType>;
    focusRecentEditorAfterClose?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    showIcons?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    enablePreview?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    enablePreviewFromQuickOpen?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    closeOnFileDelete?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    openPositioning?: Resolver<Maybe<IResolversTypes['OpenPositioningType']>, ParentType, ContextType>;
    openSideBySideDirection?: Resolver<Maybe<IResolversTypes['OpenSideBySideDirection']>, ParentType, ContextType>;
    closeEmptyGroup?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    revealIfOpen?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    swipeToNavigate?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    labelFormat?: Resolver<Maybe<IResolversTypes['LableFormatType']>, ParentType, ContextType>;
    restoreViewState?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    iconTheme?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IEditorSettingsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EditorSettings'] = IResolversParentTypes['EditorSettings']> = {
    editorOpenPositioning?: Resolver<Maybe<IResolversTypes['EditorOpenPositioning']>, ParentType, ContextType>;
    focusRecentEditorAfterClose?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IEncodingStatusResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EncodingStatus'] = IResolversParentTypes['EncodingStatus']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    alignment?: Resolver<Maybe<IResolversTypes['StatusbarAlignment']>, ParentType, ContextType>;
    entry?: Resolver<Maybe<IResolversTypes['StatusbarEntry']>, ParentType, ContextType>;
    priority?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    container?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    labelContainer?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    typeId?: Resolver<Maybe<IResolversTypes['STATUSBAR_ITEM_ID']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IEndOfLineSequenceResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EndOfLineSequence'] = IResolversParentTypes['EndOfLineSequence']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    alignment?: Resolver<Maybe<IResolversTypes['StatusbarAlignment']>, ParentType, ContextType>;
    entry?: Resolver<Maybe<IResolversTypes['StatusbarEntry']>, ParentType, ContextType>;
    priority?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    container?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    labelContainer?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    typeId?: Resolver<Maybe<IResolversTypes['STATUSBAR_ITEM_ID']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IEnginesResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Engines'] = IResolversParentTypes['Engines']> = {
    node?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    vscode?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IEnterWorkspaceResultResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['EnterWorkspaceResult'] = IResolversParentTypes['EnterWorkspaceResult']> = {
    workspace?: Resolver<IResolversTypes['WorkspaceIdentifier'], ParentType, ContextType>;
    backupPath?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IEnvironmentResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Environment'] = IResolversParentTypes['Environment']> = {
    args?: Resolver<Maybe<IResolversTypes['AnyObject']>, ParentType, ContextType>;
    execPath?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    cliPath?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    appRoot?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    userHome?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    userDataPath?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    appNameLong?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    appQuality?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    appSettingsHome?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    appSettingsPath?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    appKeybindingsPath?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    settingsSearchBuildId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    settingsSearchUrl?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    globalStorageHome?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    workspaceStorageHome?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    backupHome?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    backupWorkspacesPath?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    untitledWorkspacesHome?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    workspacesHome?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    workspacesProjectPath?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    workspaceSettingsPath?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    isExtensionDevelopment?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    disableExtensions?: Resolver<Maybe<IResolversTypes['AnyObject']>, ParentType, ContextType>;
    builtinExtensionsPath?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    extensionsPath?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    extensionDevelopmentLocationURI?: Resolver<Maybe<Array<Maybe<IResolversTypes['URI']>>>, ParentType, ContextType>;
    extensionTestsPath?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    debugExtensionHost?: Resolver<Maybe<IResolversTypes['ExtensionHostDebugParams']>, ParentType, ContextType>;
    debugSearch?: Resolver<Maybe<IResolversTypes['IDebugParams']>, ParentType, ContextType>;
    logExtensionHostCommunication?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isBuilt?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    wait?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    status?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    performance?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    log?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    logsPath?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    verbose?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    logLevel?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    skipGettingStarted?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    skipReleaseNotes?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    skipAddToRecentlyOpened?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    nodeCachedDataDir?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    installSourcePath?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    disableUpdates?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    disableCrashReporter?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    driverHandle?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    driverVerbose?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    keyboardLayoutResource?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    keybindingsResource?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IExtensionColorResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ExtensionColor'] = IResolversParentTypes['ExtensionColor']> = {
    id?: Resolver<Maybe<IResolversTypes['ID']>, ParentType, ContextType>;
    description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    defaults?: Resolver<Maybe<IResolversTypes['ExtensionColorTypes']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IExtensionColorTypesResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ExtensionColorTypes'] = IResolversParentTypes['ExtensionColorTypes']> = {
    light?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    dark?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    highContrast?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IExtensionConfigurationResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ExtensionConfiguration'] = IResolversParentTypes['ExtensionConfiguration']> = {
    properties?: Resolver<Maybe<IResolversTypes['JSON']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IExtensionConfigurationPropertyResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ExtensionConfigurationProperty'] = IResolversParentTypes['ExtensionConfigurationProperty']> = {
    description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    type?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    defaults?: Resolver<Maybe<IResolversTypes['JSON']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IExtensionContributionsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ExtensionContributions'] = IResolversParentTypes['ExtensionContributions']> = {
    actions?: Resolver<Maybe<Array<Maybe<IResolversTypes['Actions']>>>, ParentType, ContextType>;
    commands?: Resolver<Maybe<Array<Maybe<IResolversTypes['Actions']>>>, ParentType, ContextType>;
    configuration?: Resolver<Maybe<Array<Maybe<IResolversTypes['ExtensionConfiguration']>>>, ParentType, ContextType>;
    debuggers?: Resolver<Maybe<Array<Maybe<IResolversTypes['Debugger']>>>, ParentType, ContextType>;
    grammars?: Resolver<Maybe<Array<Maybe<IResolversTypes['Grammar']>>>, ParentType, ContextType>;
    jsonValidation?: Resolver<Maybe<Array<Maybe<IResolversTypes['ExtensionJSONValidation']>>>, ParentType, ContextType>;
    keybindings?: Resolver<Maybe<Array<Maybe<IResolversTypes['KeyBinding']>>>, ParentType, ContextType>;
    languages?: Resolver<Maybe<Array<Maybe<IResolversTypes['ExtensionLanguage']>>>, ParentType, ContextType>;
    menus?: Resolver<Maybe<IResolversTypes['Menus']>, ParentType, ContextType>;
    snippets?: Resolver<Maybe<Array<Maybe<IResolversTypes['Snippet']>>>, ParentType, ContextType>;
    themes?: Resolver<Maybe<Array<Maybe<IResolversTypes['ThemeLabel']>>>, ParentType, ContextType>;
    iconThemes?: Resolver<Maybe<Array<Maybe<IResolversTypes['ThemeLabel']>>>, ParentType, ContextType>;
    viewsContainers?: Resolver<Maybe<IResolversTypes['JSON']>, ParentType, ContextType>;
    views?: Resolver<Maybe<IResolversTypes['JSON']>, ParentType, ContextType>;
    colors?: Resolver<Maybe<Array<Maybe<IResolversTypes['ExtensionColor']>>>, ParentType, ContextType>;
    localizations?: Resolver<Maybe<Array<Maybe<IResolversTypes['Localization']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IExtensionHostDebugParamsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ExtensionHostDebugParams'] = IResolversParentTypes['ExtensionHostDebugParams']> = {
    port?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    break?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    debugId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IExtensionIdentifierResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ExtensionIdentifier'] = IResolversParentTypes['ExtensionIdentifier']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    uuid?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IExtensionJSONValidationResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ExtensionJSONValidation'] = IResolversParentTypes['ExtensionJSONValidation']> = {
    fileMatch?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    url?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IExtensionLanguageResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ExtensionLanguage'] = IResolversParentTypes['ExtensionLanguage']> = {
    id?: Resolver<Maybe<IResolversTypes['ID']>, ParentType, ContextType>;
    extensions?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    aliases?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IExtensionManifestResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ExtensionManifest'] = IResolversParentTypes['ExtensionManifest']> = {
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    version?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    main?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    badges?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    preview?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    keywords?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    license?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    homepage?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    publisher?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    categories?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    extensionID?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    displayName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    dependencies?: Resolver<Maybe<IResolversTypes['JSON']>, ParentType, ContextType>;
    devDependencies?: Resolver<Maybe<IResolversTypes['JSON']>, ParentType, ContextType>;
    extensionPack?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    extensionKind?: Resolver<Maybe<IResolversTypes['ExtensionKind']>, ParentType, ContextType>;
    extensionDependencies?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    bundle?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    raw?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    assets?: Resolver<Maybe<Array<Maybe<IResolversTypes['Assets']>>>, ParentType, ContextType>;
    scripts?: Resolver<Maybe<IResolversTypes['Scripts']>, ParentType, ContextType>;
    bundles?: Resolver<Maybe<IResolversTypes['Bundles']>, ParentType, ContextType>;
    bundleURL?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    extension?: Resolver<Maybe<IResolversTypes['ExtensionPackageType']>, ParentType, ContextType>;
    engines?: Resolver<Maybe<IResolversTypes['Engines']>, ParentType, ContextType>;
    makrdown?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    qna?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    author?: Resolver<Maybe<IResolversTypes['Author']>, ParentType, ContextType>;
    galleryBanner?: Resolver<Maybe<IResolversTypes['GalleryBanner']>, ParentType, ContextType>;
    activationEvents?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    contributes?: Resolver<Maybe<IResolversTypes['ExtensionContributions']>, ParentType, ContextType>;
    icon?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    bugs?: Resolver<Maybe<IResolversTypes['ExtensionManifestBugs']>, ParentType, ContextType>;
    repository?: Resolver<Maybe<IResolversTypes['ExtensionManifestRepository']>, ParentType, ContextType>;
    enableProposedApi?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    api?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IExtensionManifestBugsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ExtensionManifestBugs'] = IResolversParentTypes['ExtensionManifestBugs']> = {
    url?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    email?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IExtensionManifestRepositoryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ExtensionManifestRepository'] = IResolversParentTypes['ExtensionManifestRepository']> = {
    type?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    url?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IExtensionPackageTypeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ExtensionPackageType'] = IResolversParentTypes['ExtensionPackageType']> = {
    type?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFieldErrorResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['FieldError'] = IResolversParentTypes['FieldError']> = {
    field?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    message?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFileChangeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['FileChange'] = IResolversParentTypes['FileChange']> = {
    type?: Resolver<Maybe<IResolversTypes['FileChangeType']>, ParentType, ContextType>;
    resource?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFileContentResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['FileContent'] = IResolversParentTypes['FileContent']> = {
    resource?: Resolver<IResolversTypes['URI'], ParentType, ContextType>;
    name?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    mtime?: Resolver<IResolversTypes['BigInt'], ParentType, ContextType>;
    etag?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    size?: Resolver<IResolversTypes['Int'], ParentType, ContextType>;
    isReadonly?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    value?: Resolver<Maybe<IResolversTypes['VSBuffer']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFileDeleteOptionsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['FileDeleteOptions'] = IResolversParentTypes['FileDeleteOptions']> = {
    recursive?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>;
    useTrash?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFileEditorInputResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['FileEditorInput'] = IResolversParentTypes['FileEditorInput']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    resource?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    typeId?: Resolver<Maybe<IResolversTypes['EDITOR_INPUT_ID']>, ParentType, ContextType>;
    description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    fileReference?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType>;
    preferredEditorId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    isSupportsSplitEditor?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isActive?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    preview?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isPinned?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    status?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    closable?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    preferredEncoding?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    preferredMode?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    forceOpenAsBinary?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    encoding?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    mode?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFileFilterResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['FileFilter'] = IResolversParentTypes['FileFilter']> = {
    extensions?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFileOpenOptionsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['FileOpenOptions'] = IResolversParentTypes['FileOpenOptions']> = {
    create?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFileOperationOutputResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['FileOperationOutput'] = IResolversParentTypes['FileOperationOutput']> = {
    resource?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    target?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType>;
    operation?: Resolver<Maybe<IResolversTypes['FileOperation']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFileOverwriteOptionsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['FileOverwriteOptions'] = IResolversParentTypes['FileOverwriteOptions']> = {
    overwrite?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFileResultResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['FileResult'] = IResolversParentTypes['FileResult']> = {
    source?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    target?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    success?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFilesResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Files'] = IResolversParentTypes['Files']> = {
    eol?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    hotExit?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    encoding?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    autoSave?: Resolver<Maybe<IResolversTypes['AutoSaveConfigurationType']>, ParentType, ContextType>;
    autoSaveDelay?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    defaultLanguage?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    autoGuessEncoding?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    insertFinalNewline?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    trimTrailingWhitespace?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    useExperimentalFileWatcher?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    watcherExclude?: Resolver<Maybe<IResolversTypes['JSON']>, ParentType, ContextType>;
    exclude?: Resolver<Maybe<IResolversTypes['JSON']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFiles_StatResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Files_Stat'] = IResolversParentTypes['Files_Stat']> = {
    type?: Resolver<Maybe<IResolversTypes['FileType']>, ParentType, ContextType>;
    mtime?: Resolver<Maybe<IResolversTypes['BigInt']>, ParentType, ContextType>;
    ctime?: Resolver<Maybe<IResolversTypes['BigInt']>, ParentType, ContextType>;
    size?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFileStatResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['FileStat'] = IResolversParentTypes['FileStat']> = {
    resource?: Resolver<IResolversTypes['URI'], ParentType, ContextType>;
    name?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    size?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    mtime?: Resolver<Maybe<IResolversTypes['BigInt']>, ParentType, ContextType>;
    etag?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    isReadonly?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isDirectory?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isSymbolicLink?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    children?: Resolver<Maybe<Array<Maybe<IResolversTypes['FileStat']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFileStatWithMetadataResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['FileStatWithMetadata'] = IResolversParentTypes['FileStatWithMetadata']> = {
    active?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    changes?: Resolver<Maybe<IResolversTypes['JSON']>, ParentType, ContextType>;
    children?: Resolver<Maybe<Array<Maybe<IResolversTypes['FileStatWithMetadata']>>>, ParentType, ContextType>;
    childrenGen?: Resolver<Maybe<Array<Maybe<IResolversTypes['FileStatWithMetadata']>>>, ParentType, ContextType>;
    dirty?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    encoding?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    eol?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    etag?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    expanded?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    hasChildren?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inConflictMode?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inErrorMode?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inOrphanMode?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inPendingSave?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isDirectory?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isEmpty?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isFlush?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isReadonly?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isRedoing?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isSymbolicLink?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isUndoing?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    mtime?: Resolver<IResolversTypes['BigInt'], ParentType, ContextType>;
    name?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    path?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    preferredEncoding?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    preferredMode?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    resource?: Resolver<IResolversTypes['URI'], ParentType, ContextType>;
    resourcePath?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    size?: Resolver<IResolversTypes['Int'], ParentType, ContextType>;
    state?: Resolver<Maybe<IResolversTypes['FileModelState']>, ParentType, ContextType>;
    subtitle?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    title?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    value?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    versionId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFileStreamContentResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['FileStreamContent'] = IResolversParentTypes['FileStreamContent']> = {
    resource?: Resolver<IResolversTypes['URI'], ParentType, ContextType>;
    name?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    mtime?: Resolver<IResolversTypes['BigInt'], ParentType, ContextType>;
    etag?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    size?: Resolver<IResolversTypes['Int'], ParentType, ContextType>;
    isReadonly?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    value?: Resolver<Maybe<IResolversTypes['VSBufferReadableStream']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFileToOpenResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['FileToOpen'] = IResolversParentTypes['FileToOpen']> = {
    fileUri?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFileWriteOptionsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['FileWriteOptions'] = IResolversParentTypes['FileWriteOptions']> = {
    overwrite?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>;
    create?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFolderConfigurationModelResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['FolderConfigurationModel'] = IResolversParentTypes['FolderConfigurationModel']> = {
    id?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    contents?: Resolver<Maybe<IResolversTypes['AnyObject']>, ParentType, ContextType>;
    keys?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    overrides?: Resolver<Maybe<IResolversTypes['ConfigurationOverrides']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFolderSettingsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['FolderSettings'] = IResolversParentTypes['FolderSettings']> = {
    id?: Resolver<Maybe<IResolversTypes['ID']>, ParentType, ContextType>;
    latestSettings?: Resolver<Maybe<IResolversTypes['Settings']>, ParentType, ContextType>;
    settingsURL?: Resolver<IResolversTypes['URI'], ParentType, ContextType>;
    viewerCanAdminister?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>;
    settingsCascade?: Resolver<IResolversTypes['SettingsCascade'], ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IFolderToOpenResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['FolderToOpen'] = IResolversParentTypes['FolderToOpen']> = {
    folderUri?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IGalleryBannerResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['GalleryBanner'] = IResolversParentTypes['GalleryBanner']> = {
    color?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    theme?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IGitResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Git'] = IResolversParentTypes['Git']> = {
    path?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    enabled?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    autofetch?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    countBadge?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    autorefresh?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    confirmSync?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    checkoutType?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    inputValidation?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    detectSubmodules?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    enableSmartCommit?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    ignoreLimitWarning?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    ignoreLegacyWarning?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    enableCommitSigning?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    defaultCloneDirectory?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    autoRepositoryDetection?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    ignoreMissingGitWarning?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    showInlineOpenFileAction?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    promptToSaveFilesBeforeCommit?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    decorations?: Resolver<Maybe<IResolversTypes['GitDecorations']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IGitDecorationsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['GitDecorations'] = IResolversParentTypes['GitDecorations']> = {
    enabled?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IGlobalSettingsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['GlobalSettings'] = IResolversParentTypes['GlobalSettings']> = {
    id?: Resolver<Maybe<IResolversTypes['ID']>, ParentType, ContextType>;
    latestSettings?: Resolver<Maybe<IResolversTypes['Settings']>, ParentType, ContextType>;
    settingsURL?: Resolver<IResolversTypes['URI'], ParentType, ContextType>;
    viewerCanAdminister?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>;
    settingsCascade?: Resolver<IResolversTypes['SettingsCascade'], ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IGoToLineQuickAccessResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['GoToLineQuickAccess'] = IResolversParentTypes['GoToLineQuickAccess']> = {
    range?: Resolver<Maybe<IResolversTypes['LineRange']>, ParentType, ContextType>;
    highlight?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    focus?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IGrammarResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Grammar'] = IResolversParentTypes['Grammar']> = {
    language?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IGroupLayoutArgumentResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['GroupLayoutArgument'] = IResolversParentTypes['GroupLayoutArgument']> = {
    groups?: Resolver<Maybe<Array<Maybe<IResolversTypes['GroupLayoutArgument']>>>, ParentType, ContextType>;
    size?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IIBaseStatResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['IBaseStat'] = IResolversParentTypes['IBaseStat']> = {
    __resolveType: TypeResolveFn<'FileStatWithMetadata' | 'TextFileStreamContent' | 'TextFilePublishContent' | 'TextFileContent' | 'FileContent' | 'FileStat' | 'FileStreamContent', ParentType, ContextType>;
    resource?: Resolver<IResolversTypes['URI'], ParentType, ContextType>;
    name?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    size?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    mtime?: Resolver<Maybe<IResolversTypes['BigInt']>, ParentType, ContextType>;
    etag?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    isReadonly?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
};
export declare type IIBaseStatWithMetadataResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['IBaseStatWithMetadata'] = IResolversParentTypes['IBaseStatWithMetadata']> = {
    __resolveType: TypeResolveFn<'FileStatWithMetadata' | 'TextFileStreamContent' | 'TextFileContent' | 'FileContent' | 'FileStreamContent', ParentType, ContextType>;
    mtime?: Resolver<IResolversTypes['BigInt'], ParentType, ContextType>;
    etag?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    size?: Resolver<IResolversTypes['Int'], ParentType, ContextType>;
};
export declare type IIBaseTextFileContentResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['IBaseTextFileContent'] = IResolversParentTypes['IBaseTextFileContent']> = {
    __resolveType: TypeResolveFn<'TextFileStreamContent' | 'TextFilePublishContent' | 'TextFileContent', ParentType, ContextType>;
    encoding?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
};
export declare type IIConfigurationChangeEventResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['IConfigurationChangeEvent'] = IResolversParentTypes['IConfigurationChangeEvent']> = {
    source?: Resolver<Maybe<IResolversTypes['ConfigurationTarget']>, ParentType, ContextType>;
    affectedKeys?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    sourceConfig?: Resolver<Maybe<IResolversTypes['AnyObject']>, ParentType, ContextType>;
    changedConfiguration?: Resolver<Maybe<IResolversTypes['ConfigurationModel']>, ParentType, ContextType>;
    changedConfigurationByResource?: Resolver<Maybe<IResolversTypes['ResourceMapConfigurationModel']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IIContentChangedEventResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['IContentChangedEvent'] = IResolversParentTypes['IContentChangedEvent']> = {
    __resolveType: TypeResolveFn<'FileStatWithMetadata', ParentType, ContextType>;
    changes?: Resolver<Maybe<IResolversTypes['JSON']>, ParentType, ContextType>;
    eol?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    versionId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    isUndoing?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isRedoing?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isFlush?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
};
export declare type IIDebugParamsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['IDebugParams'] = IResolversParentTypes['IDebugParams']> = {
    __resolveType: TypeResolveFn<'ExtensionHostDebugParams', ParentType, ContextType>;
    port?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    break?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
};
export declare type IIEditorGroupResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['IEditorGroup'] = IResolversParentTypes['IEditorGroup']> = {
    __resolveType: TypeResolveFn<'EditorGroup', ParentType, ContextType>;
    id?: Resolver<IResolversTypes['Int'], ParentType, ContextType>;
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
};
export declare type IIEditorInputResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['IEditorInput'] = IResolversParentTypes['IEditorInput']> = {
    __resolveType: TypeResolveFn<'DataUriEditorInput' | 'DiffEditorInput' | 'FileEditorInput' | 'KeybindingEditorInput' | 'ResourceEditorInput' | 'SideBySideEditorInput' | 'UntitledEditorInput', ParentType, ContextType>;
    resource?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    typeId?: Resolver<Maybe<IResolversTypes['EDITOR_INPUT_ID']>, ParentType, ContextType>;
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    fileReference?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType>;
    preferredEditorId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    isSupportsSplitEditor?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
};
export declare type IIEditorInputWithGroupFieldsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['IEditorInputWithGroupFields'] = IResolversParentTypes['IEditorInputWithGroupFields']> = {
    __resolveType: TypeResolveFn<'DataUriEditorInput' | 'DiffEditorInput' | 'FileEditorInput' | 'KeybindingEditorInput' | 'ResourceEditorInput' | 'SideBySideEditorInput' | 'UntitledEditorInput', ParentType, ContextType>;
    isActive?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isPinned?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    preview?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    status?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    closable?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
};
export declare type IIEncodingSupportResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['IEncodingSupport'] = IResolversParentTypes['IEncodingSupport']> = {
    __resolveType: TypeResolveFn<'FileEditorInput', ParentType, ContextType>;
    encoding?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
};
export declare type IIFileClientMetadataResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['IFileClientMetadata'] = IResolversParentTypes['IFileClientMetadata']> = {
    __resolveType: TypeResolveFn<'FileStatWithMetadata' | 'TextFileContent', ParentType, ContextType>;
    dirty?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inConflictMode?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inOrphanMode?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inErrorMode?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inPendingSave?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    preferredMode?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    encoding?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    preferredEncoding?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    state?: Resolver<Maybe<IResolversTypes['FileModelState']>, ParentType, ContextType>;
};
export declare type IIFileEditorInputResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['IFileEditorInput'] = IResolversParentTypes['IFileEditorInput']> = {
    __resolveType: TypeResolveFn<'FileEditorInput', ParentType, ContextType>;
    preferredEncoding?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    preferredMode?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    forceOpenAsBinary?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
};
export declare type IIModeSupportResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['IModeSupport'] = IResolversParentTypes['IModeSupport']> = {
    __resolveType: TypeResolveFn<'FileEditorInput', ParentType, ContextType>;
    mode?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
};
export declare type IImportResultResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ImportResult'] = IResolversParentTypes['ImportResult']> = {
    stat?: Resolver<Maybe<IResolversTypes['FileStat']>, ParentType, ContextType>;
    isNew?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IIndentationResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Indentation'] = IResolversParentTypes['Indentation']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    alignment?: Resolver<Maybe<IResolversTypes['StatusbarAlignment']>, ParentType, ContextType>;
    entry?: Resolver<Maybe<IResolversTypes['StatusbarEntry']>, ParentType, ContextType>;
    priority?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    container?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    labelContainer?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    typeId?: Resolver<Maybe<IResolversTypes['STATUSBAR_ITEM_ID']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IInputTypeDetailResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['InputTypeDetail'] = IResolversParentTypes['InputTypeDetail']> = {
    type?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    options?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IIntegratedResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Integrated'] = IResolversParentTypes['Integrated']> = {
    setLocaleVariables?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    shellArgs?: Resolver<Maybe<IResolversTypes['ShellArgs']>, ParentType, ContextType>;
    shell?: Resolver<Maybe<IResolversTypes['Shell']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IIPathDataResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['IPathData'] = IResolversParentTypes['IPathData']> = {
    __resolveType: TypeResolveFn<'Path', ParentType, ContextType>;
    fileUri?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    lineNumber?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    columnNumber?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    exists?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
};
export declare type IIPathsToWaitForDataResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['IPathsToWaitForData'] = IResolversParentTypes['IPathsToWaitForData']> = {
    __resolveType: TypeResolveFn<'PathsToWaitFor', ParentType, ContextType>;
    paths?: Resolver<Maybe<Array<Maybe<IResolversTypes['IPathData']>>>, ParentType, ContextType>;
    waitMarkerFileUri?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
};
export declare type IISettingsSubjectResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ISettingsSubject'] = IResolversParentTypes['ISettingsSubject']> = {
    __resolveType: TypeResolveFn<'DefaultSettings' | 'UserSettings' | 'LocalUserSettings' | 'RemoteUserSettings' | 'FolderSettings' | 'GlobalSettings' | 'WorkspaceSettings' | 'MemorySettings', ParentType, ContextType>;
    id?: Resolver<Maybe<IResolversTypes['ID']>, ParentType, ContextType>;
    latestSettings?: Resolver<Maybe<IResolversTypes['Settings']>, ParentType, ContextType>;
    settingsURL?: Resolver<IResolversTypes['URI'], ParentType, ContextType>;
    viewerCanAdminister?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>;
    settingsCascade?: Resolver<IResolversTypes['SettingsCascade'], ParentType, ContextType>;
};
export declare type IISideBySideEditorInputResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ISideBySideEditorInput'] = IResolversParentTypes['ISideBySideEditorInput']> = {
    __resolveType: TypeResolveFn<'SideBySideEditorInput', ParentType, ContextType>;
    master?: Resolver<Maybe<IResolversTypes['EditorInput']>, ParentType, ContextType>;
    details?: Resolver<Maybe<IResolversTypes['EditorInput']>, ParentType, ContextType>;
};
export declare type IIStaticWorkspaceDataResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['IStaticWorkspaceData'] = IResolversParentTypes['IStaticWorkspaceData']> = {
    __resolveType: TypeResolveFn<'WorkspaceData', ParentType, ContextType>;
    id?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    configuration?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    isUntitled?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
};
export declare type IIStatusbarItemResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['IStatusbarItem'] = IResolversParentTypes['IStatusbarItem']> = {
    __resolveType: TypeResolveFn<'Terminal' | 'SelectionStatus' | 'Indentation' | 'EncodingStatus' | 'EndOfLineSequence' | 'LanguageMode', ParentType, ContextType>;
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    alignment?: Resolver<Maybe<IResolversTypes['StatusbarAlignment']>, ParentType, ContextType>;
    entry?: Resolver<Maybe<IResolversTypes['StatusbarEntry']>, ParentType, ContextType>;
    priority?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    container?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    labelContainer?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    typeId?: Resolver<Maybe<IResolversTypes['STATUSBAR_ITEM_ID']>, ParentType, ContextType>;
};
export declare type IITreeItemResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ITreeItem'] = IResolversParentTypes['ITreeItem']> = {
    __resolveType: TypeResolveFn<'FileStatWithMetadata', ParentType, ContextType>;
    path?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    title?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    subtitle?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    isDirectory?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    active?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    expanded?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    hasChildren?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isEmpty?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
};
export declare type IIUntitledFileValueResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['IUntitledFileValue'] = IResolversParentTypes['IUntitledFileValue']> = {
    __resolveType: TypeResolveFn<'FileStatWithMetadata', ParentType, ContextType>;
    value?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
};
export declare type IIUserPreferencesResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['IUserPreferences'] = IResolversParentTypes['IUserPreferences']> = {
    content?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    user?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IIUserSettingsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['IUserSettings'] = IResolversParentTypes['IUserSettings']> = {
    data?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export interface IJSONScalarConfig extends GraphQLScalarTypeConfig<IResolversTypes['JSON'], any> {
    name: 'JSON';
}
export interface IJSONObjectScalarConfig extends GraphQLScalarTypeConfig<IResolversTypes['JSONObject'], any> {
    name: 'JSONObject';
}
export declare type IKeyBindingResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['KeyBinding'] = IResolversParentTypes['KeyBinding']> = {
    command?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    key?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    when?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    mac?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    linux?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    win?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IKeybindingContextMenuResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['KeybindingContextMenu'] = IResolversParentTypes['KeybindingContextMenu']> = {
    editItem?: Resolver<Maybe<IResolversTypes['EditKeybindingItem']>, ParentType, ContextType>;
    selectedItemIndex?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    editWhenIndex?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    newWhen?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    isOpenDialog?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    search?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IKeybindingEditorInputResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['KeybindingEditorInput'] = IResolversParentTypes['KeybindingEditorInput']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    resource?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    typeId?: Resolver<Maybe<IResolversTypes['EDITOR_INPUT_ID']>, ParentType, ContextType>;
    description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    fileReference?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType>;
    preferredEditorId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    isSupportsSplitEditor?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isActive?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    preview?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isPinned?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    status?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    closable?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IKeybindingItemResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['KeybindingItem'] = IResolversParentTypes['KeybindingItem']> = {
    command?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    key?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    when?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    source?: Resolver<Maybe<IResolversTypes['KeybindingSource']>, ParentType, ContextType>;
    run?: Resolver<Maybe<IResolversTypes['ActionRun']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IKeybindingsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Keybindings'] = IResolversParentTypes['Keybindings']> = {
    items?: Resolver<Maybe<Array<Maybe<IResolversTypes['KeybindingItem']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IKeyboardEvent_outputResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['KeyboardEvent_output'] = IResolversParentTypes['KeyboardEvent_output']> = {
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    key?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ILanguageModeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['LanguageMode'] = IResolversParentTypes['LanguageMode']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    alignment?: Resolver<Maybe<IResolversTypes['StatusbarAlignment']>, ParentType, ContextType>;
    entry?: Resolver<Maybe<IResolversTypes['StatusbarEntry']>, ParentType, ContextType>;
    priority?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    container?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    labelContainer?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    typeId?: Resolver<Maybe<IResolversTypes['STATUSBAR_ITEM_ID']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ILanguagesResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Languages'] = IResolversParentTypes['Languages']> = {
    go?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    css?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    html?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    json?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    yaml?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    typescript?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    javascript?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ILineRangeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['LineRange'] = IResolversParentTypes['LineRange']> = {
    endColumn?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    endLine?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    startColumn?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    startLine?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ILocalizationResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Localization'] = IResolversParentTypes['Localization']> = {
    languageId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    languageName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    localizedLanguageName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    translations?: Resolver<Maybe<Array<Maybe<IResolversTypes['LocalizationTranslation']>>>, ParentType, ContextType>;
    minimalTranslations?: Resolver<Maybe<IResolversTypes['JSON']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ILocalizationTranslationResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['LocalizationTranslation'] = IResolversParentTypes['LocalizationTranslation']> = {
    id?: Resolver<Maybe<IResolversTypes['ID']>, ParentType, ContextType>;
    path?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ILocalUserSettingsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['LocalUserSettings'] = IResolversParentTypes['LocalUserSettings']> = {
    id?: Resolver<Maybe<IResolversTypes['ID']>, ParentType, ContextType>;
    latestSettings?: Resolver<Maybe<IResolversTypes['Settings']>, ParentType, ContextType>;
    settingsURL?: Resolver<IResolversTypes['URI'], ParentType, ContextType>;
    viewerCanAdminister?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>;
    settingsCascade?: Resolver<IResolversTypes['SettingsCascade'], ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IMatchResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Match'] = IResolversParentTypes['Match']> = {
    start?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    end?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IMemorySettingsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['MemorySettings'] = IResolversParentTypes['MemorySettings']> = {
    id?: Resolver<Maybe<IResolversTypes['ID']>, ParentType, ContextType>;
    latestSettings?: Resolver<Maybe<IResolversTypes['Settings']>, ParentType, ContextType>;
    settingsURL?: Resolver<IResolversTypes['URI'], ParentType, ContextType>;
    viewerCanAdminister?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>;
    settingsCascade?: Resolver<IResolversTypes['SettingsCascade'], ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IMenuItemResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['MenuItem'] = IResolversParentTypes['MenuItem']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    enabled?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    run?: Resolver<Maybe<IResolversTypes['ActionRun']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IMenuItemActionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['MenuItemAction'] = IResolversParentTypes['MenuItemAction']> = {
    action?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    when?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IMenuItemActionContextResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['MenuItemActionContext'] = IResolversParentTypes['MenuItemActionContext']> = {
    context?: Resolver<Maybe<Array<Maybe<IResolversTypes['MenuItemAction']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IMenuItemActionDebugResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['MenuItemActionDebug'] = IResolversParentTypes['MenuItemActionDebug']> = {
    callstack?: Resolver<Maybe<IResolversTypes['MenuItemActionContext']>, ParentType, ContextType>;
    toolbar?: Resolver<Maybe<Array<Maybe<IResolversTypes['MenuItemAction']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IMenuItemActionEditorResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['MenuItemActionEditor'] = IResolversParentTypes['MenuItemActionEditor']> = {
    context?: Resolver<Maybe<Array<Maybe<IResolversTypes['MenuItemAction']>>>, ParentType, ContextType>;
    title?: Resolver<Maybe<IResolversTypes['MenuItemActionEditorTitle']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IMenuItemActionEditorTitleResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['MenuItemActionEditorTitle'] = IResolversParentTypes['MenuItemActionEditorTitle']> = {
    own?: Resolver<Maybe<Array<Maybe<IResolversTypes['MenuItemAction']>>>, ParentType, ContextType>;
    context?: Resolver<Maybe<Array<Maybe<IResolversTypes['MenuItemAction']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IMenuItemActionScmResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['MenuItemActionScm'] = IResolversParentTypes['MenuItemActionScm']> = {
    title?: Resolver<Maybe<Array<Maybe<IResolversTypes['MenuItemAction']>>>, ParentType, ContextType>;
    resourceGroup?: Resolver<Maybe<IResolversTypes['MenuItemActionContext']>, ParentType, ContextType>;
    resource?: Resolver<Maybe<IResolversTypes['MenuItemActionContext']>, ParentType, ContextType>;
    change?: Resolver<Maybe<IResolversTypes['MenuItemActionScmChange']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IMenuItemActionScmChangeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['MenuItemActionScmChange'] = IResolversParentTypes['MenuItemActionScmChange']> = {
    title?: Resolver<Maybe<Array<Maybe<IResolversTypes['MenuItemAction']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IMenuItemActionViewResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['MenuItemActionView'] = IResolversParentTypes['MenuItemActionView']> = {
    title?: Resolver<Maybe<Array<Maybe<IResolversTypes['MenuItemAction']>>>, ParentType, ContextType>;
    item?: Resolver<Maybe<IResolversTypes['MenuItemActionContext']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IMenusResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Menus'] = IResolversParentTypes['Menus']> = {
    commandPalette?: Resolver<Maybe<Array<Maybe<IResolversTypes['MenuItemAction']>>>, ParentType, ContextType>;
    explorer?: Resolver<Maybe<IResolversTypes['MenuItemActionContext']>, ParentType, ContextType>;
    editor?: Resolver<Maybe<IResolversTypes['MenuItemActionEditor']>, ParentType, ContextType>;
    debug?: Resolver<Maybe<IResolversTypes['MenuItemActionDebug']>, ParentType, ContextType>;
    scm?: Resolver<Maybe<IResolversTypes['MenuItemActionScm']>, ParentType, ContextType>;
    view?: Resolver<Maybe<IResolversTypes['MenuItemActionView']>, ParentType, ContextType>;
    touchBar?: Resolver<Maybe<Array<Maybe<IResolversTypes['MenuItemAction']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IMessageBoxOptionsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['MessageBoxOptions'] = IResolversParentTypes['MessageBoxOptions']> = {
    type?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    buttons?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    defaultId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    title?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    message?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    detail?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    checkboxLabel?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    checkboxChecked?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    cancelId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    noLink?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    normalizeAccessKeys?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IMessageBoxResultResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['MessageBoxResult'] = IResolversParentTypes['MessageBoxResult']> = {
    button?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    checkboxChecked?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IMessageLinkResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['MessageLink'] = IResolversParentTypes['MessageLink']> = {
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    href?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    offset?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    length?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IMutationResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Mutation'] = IResolversParentTypes['Mutation']> = {
    activateEditor?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationactivateEditorArgs, never>>;
    addEntry?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationaddEntryArgs, never>>;
    addNotification?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationaddNotificationArgs, never>>;
    canHandleResource?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationcanHandleResourceArgs, 'resource'>>;
    changeEdit?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationchangeEditArgs, never>>;
    changeKeybinding?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationchangeKeybindingArgs, never>>;
    changeWhenExpression?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationchangeWhenExpressionArgs, never>>;
    closeAllEditors?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    closeDialog?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    closeEditor?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationcloseEditorArgs, never>>;
    closeEditors?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationcloseEditorsArgs, never>>;
    closeNotification?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationcloseNotificationArgs, never>>;
    copy?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationcopyArgs, never>>;
    copyFile?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType, RequireFields<IMutationcopyFileArgs, 'source' | 'target'>>;
    createFile?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType, RequireFields<IMutationcreateFileArgs, 'resource'>>;
    createFolder?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType, RequireFields<IMutationcreateFolderArgs, 'resource'>>;
    createTextFile?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType, RequireFields<IMutationcreateTextFileArgs, 'resource'>>;
    createUntitledFile?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType, RequireFields<IMutationcreateUntitledFileArgs, never>>;
    del?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationdelArgs, 'resource'>>;
    deleteTextFile?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationdeleteTextFileArgs, 'resource'>>;
    dummy?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    editKeybinding?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationeditKeybindingArgs, never>>;
    findFileStat?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType, RequireFields<IMutationfindFileStatArgs, 'resource'>>;
    getEditorState?: Resolver<Maybe<IResolversTypes['CodeEditorViewState']>, ParentType, ContextType, RequireFields<IMutationgetEditorStateArgs, 'editorId' | 'resource'>>;
    getFilesTreeData?: Resolver<Maybe<Array<Maybe<IResolversTypes['FileStatWithMetadata']>>>, ParentType, ContextType, RequireFields<IMutationgetFilesTreeDataArgs, 'resource'>>;
    gotoLine?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationgotoLineArgs, never>>;
    handler?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationhandlerArgs, never>>;
    hideContextMenu?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    hideInputModel?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    hideKeybindingDialog?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    highlightLine?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationhighlightLineArgs, never>>;
    jsonWrite?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationjsonWriteArgs, never>>;
    keepOpen?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationkeepOpenArgs, never>>;
    loadFile?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType, RequireFields<IMutationloadFileArgs, 'resource'>>;
    loadFileContent?: Resolver<Maybe<IResolversTypes['FileContent']>, ParentType, ContextType, RequireFields<IMutationloadFileContentArgs, 'resource'>>;
    loadFileWithContent?: Resolver<Maybe<IResolversTypes['TextFileContent']>, ParentType, ContextType, RequireFields<IMutationloadFileWithContentArgs, 'resource'>>;
    loadFilesTreeData?: Resolver<Maybe<Array<Maybe<IResolversTypes['FileStatWithMetadata']>>>, ParentType, ContextType, RequireFields<IMutationloadFilesTreeDataArgs, 'resource'>>;
    lookupKeybinding?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType, RequireFields<IMutationlookupKeybindingArgs, never>>;
    makePinEditor?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationmakePinEditorArgs, never>>;
    moveEditorInsideGroup?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationmoveEditorInsideGroupArgs, never>>;
    moveFile?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType, RequireFields<IMutationmoveFileArgs, 'source' | 'target'>>;
    moveTextFile?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType, RequireFields<IMutationmoveTextFileArgs, 'source' | 'target'>>;
    notify?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationnotifyArgs, never>>;
    notifyError?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationnotifyErrorArgs, never>>;
    notifyInfo?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationnotifyInfoArgs, never>>;
    notifyPrompt?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationnotifyPromptArgs, never>>;
    notifyWarn?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationnotifyWarnArgs, never>>;
    openEditor?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationopenEditorArgs, 'content'>>;
    openEditorWithResourceDiffInput?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationopenEditorWithResourceDiffInputArgs, 'editor'>>;
    openEditorWithResourceInput?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationopenEditorWithResourceInputArgs, 'editor'>>;
    openEditorWithResourceSideBySideInput?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationopenEditorWithResourceSideBySideInputArgs, 'editor'>>;
    openEditorWithUntitledResourceInput?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationopenEditorWithUntitledResourceInputArgs, 'editor'>>;
    openFile?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationopenFileArgs, 'content'>>;
    readTextFile?: Resolver<Maybe<IResolversTypes['TextFileContent']>, ParentType, ContextType, RequireFields<IMutationreadTextFileArgs, 'resource'>>;
    registerKeybinding?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationregisterKeybindingArgs, never>>;
    removeChangedContent?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationremoveChangedContentArgs, 'resource'>>;
    removeEdit?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationremoveEditArgs, never>>;
    removeKeybinding?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationremoveKeybindingArgs, never>>;
    removeStatusbarEntry?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationremoveStatusbarEntryArgs, 'id'>>;
    rename?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType, RequireFields<IMutationrenameArgs, 'resource' | 'target'>>;
    resetKeybinding?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationresetKeybindingArgs, never>>;
    resolveKeyboardEvent?: Resolver<Maybe<IResolversTypes['KeyboardEvent_output']>, ParentType, ContextType, RequireFields<IMutationresolveKeyboardEventArgs, never>>;
    runMenuAction?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationrunMenuActionArgs, never>>;
    saveAllEditor?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationsaveAllEditorArgs, never>>;
    saveFile?: Resolver<Maybe<IResolversTypes['FileStat']>, ParentType, ContextType, RequireFields<IMutationsaveFileArgs, 'resource' | 'options'>>;
    saveFileAs?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType, RequireFields<IMutationsaveFileAsArgs, 'resource' | 'options'>>;
    saveUserSettings?: Resolver<Maybe<IResolversTypes['SaveWorkspaceRes']>, ParentType, ContextType, RequireFields<IMutationsaveUserSettingsArgs, never>>;
    saveWorkspaceSettings?: Resolver<Maybe<IResolversTypes['SaveWorkspaceRes']>, ParentType, ContextType>;
    searchKeybinding?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationsearchKeybindingArgs, never>>;
    selectEdit?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationselectEditArgs, never>>;
    setEncoding?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationsetEncodingArgs, 'resource'>>;
    setFilesTreeData?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationsetFilesTreeDataArgs, never>>;
    setSelected?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationsetSelectedArgs, never>>;
    setSelectedKeybindingIndex?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationsetSelectedKeybindingIndexArgs, never>>;
    setStatusMessage?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType, RequireFields<IMutationsetStatusMessageArgs, never>>;
    show?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationshowArgs, never>>;
    showContextMenu?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationshowContextMenuArgs, never>>;
    showInput?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationshowInputArgs, never>>;
    showPickInput?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationshowPickInputArgs, never>>;
    stopEditWhenExpression?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    testNotification?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    unwatch?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationunwatchArgs, 'resource' | 'session'>>;
    unwatchFileChanges?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationunwatchFileChangesArgs, 'resource' | 'session'>>;
    updateChangedContent?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationupdateChangedContentArgs, 'resource' | 'changedEvent'>>;
    updateConfigurationValue?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationupdateConfigurationValueArgs, 'key' | 'value'>>;
    updateContent?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType, RequireFields<IMutationupdateContentArgs, 'resource' | 'value' | 'options'>>;
    updateContext?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationupdateContextArgs, never>>;
    updateEditorState?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationupdateEditorStateArgs, 'editorId' | 'resource' | 'state'>>;
    updateFileDirtyState?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationupdateFileDirtyStateArgs, 'resource' | 'isFileDirty'>>;
    updateLayout?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationupdateLayoutArgs, never>>;
    updateSelectedResource?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationupdateSelectedResourceArgs, 'resource'>>;
    updateStatusbarEntry?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationupdateStatusbarEntryArgs, never>>;
    watchFile?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType, RequireFields<IMutationwatchFileArgs, 'resource'>>;
    watchFileChanges?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IMutationwatchFileChangesArgs, 'resource' | 'options'>>;
    writeChunk?: Resolver<Maybe<IResolversTypes['UpdatedResource']>, ParentType, ContextType, RequireFields<IMutationwriteChunkArgs, 'resource' | 'changes' | 'options'>>;
    writeChunkWithDelay?: Resolver<Maybe<IResolversTypes['UpdateDelayedResource']>, ParentType, ContextType, RequireFields<IMutationwriteChunkWithDelayArgs, 'resource' | 'changes' | 'options'>>;
    writeContent?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    writeTextFile?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType, RequireFields<IMutationwriteTextFileArgs, 'resource' | 'value' | 'options'>>;
};
export declare type INativeOpenDialogOptionsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['NativeOpenDialogOptions'] = IResolversParentTypes['NativeOpenDialogOptions']> = {
    windowId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    forceNewWindow?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    defaultPath?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    telemetryEventName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type INewWindowOptionsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['NewWindowOptions'] = IResolversParentTypes['NewWindowOptions']> = {
    remoteAuthority?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    reuseWindow?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type INotificationResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Notification'] = IResolversParentTypes['Notification']> = {
    index?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    severity?: Resolver<Maybe<IResolversTypes['NotificationSeverity']>, ParentType, ContextType>;
    message?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    source?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    actions?: Resolver<Maybe<IResolversTypes['NotificationActions']>, ParentType, ContextType>;
    sticky?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type INotificationActionsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['NotificationActions'] = IResolversParentTypes['NotificationActions']> = {
    primary?: Resolver<Maybe<Array<Maybe<IResolversTypes['Action']>>>, ParentType, ContextType>;
    secondary?: Resolver<Maybe<Array<Maybe<IResolversTypes['Action']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type INotificationChangeEventResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['NotificationChangeEvent'] = IResolversParentTypes['NotificationChangeEvent']> = {
    index?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    item?: Resolver<Maybe<IResolversTypes['NotificationViewItem']>, ParentType, ContextType>;
    kind?: Resolver<Maybe<IResolversTypes['NotificationChangeType']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type INotificationMessageResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['NotificationMessage'] = IResolversParentTypes['NotificationMessage']> = {
    raw?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    original?: Resolver<Maybe<IResolversTypes['NotificationMessage']>, ParentType, ContextType>;
    value?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    links?: Resolver<Maybe<Array<Maybe<IResolversTypes['MessageLink']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type INotificationsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Notifications'] = IResolversParentTypes['Notifications']> = {
    notifications?: Resolver<Maybe<Array<Maybe<IResolversTypes['Notification']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type INotificationViewItemResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['NotificationViewItem'] = IResolversParentTypes['NotificationViewItem']> = {
    severity?: Resolver<Maybe<IResolversTypes['NotificationSeverity']>, ParentType, ContextType>;
    sticky?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    silent?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    message?: Resolver<Maybe<IResolversTypes['NotificationMessage']>, ParentType, ContextType>;
    source?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    action?: Resolver<Maybe<IResolversTypes['NotificationActions']>, ParentType, ContextType>;
    progress?: Resolver<Maybe<IResolversTypes['NotificationViewItemProgress']>, ParentType, ContextType>;
    expanded?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    canCollapse?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type INotificationViewItemProgressResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['NotificationViewItemProgress'] = IResolversParentTypes['NotificationViewItemProgress']> = {
    state?: Resolver<Maybe<IResolversTypes['NotificationViewItemProgressState']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type INotificationViewItemProgressStateResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['NotificationViewItemProgressState'] = IResolversParentTypes['NotificationViewItemProgressState']> = {
    infinite?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    total?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    worked?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    done?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IOpenConfigurationResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OpenConfiguration'] = IResolversParentTypes['OpenConfiguration']> = {
    context?: Resolver<Maybe<IResolversTypes['OpenContext']>, ParentType, ContextType>;
    contextWindowId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    cli?: Resolver<Maybe<IResolversTypes['AnyObject']>, ParentType, ContextType>;
    userEnv?: Resolver<Maybe<IResolversTypes['AnyObject']>, ParentType, ContextType>;
    urisToOpen?: Resolver<Maybe<Array<Maybe<IResolversTypes['URIToOpen']>>>, ParentType, ContextType>;
    waitMarkerFileURI?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    preferNewWindow?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    forceNewWindow?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    forceNewTabbedWindow?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    forceReuseWindow?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    forceEmpty?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    diffMode?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    addMode?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    initialStartup?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    noRecentEntry?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IOpenDialogOptionsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OpenDialogOptions'] = IResolversParentTypes['OpenDialogOptions']> = {
    title?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    defaultPath?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    buttonLabel?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    filters?: Resolver<Maybe<Array<Maybe<IResolversTypes['FileFilter']>>>, ParentType, ContextType>;
    properties?: Resolver<Maybe<Array<Maybe<IResolversTypes['OpenDialogOptionsProperties']>>>, ParentType, ContextType>;
    message?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IOpenFileRequestResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OpenFileRequest'] = IResolversParentTypes['OpenFileRequest']> = {
    filesToOpenOrCreate?: Resolver<Maybe<Array<Maybe<IResolversTypes['IPathData']>>>, ParentType, ContextType>;
    filesToDiff?: Resolver<Maybe<Array<Maybe<IResolversTypes['IPathData']>>>, ParentType, ContextType>;
    filesToWait?: Resolver<Maybe<IResolversTypes['IPathsToWaitForData']>, ParentType, ContextType>;
    termProgram?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IOpenSettingsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['OpenSettings'] = IResolversParentTypes['OpenSettings']> = {
    forceNewWindow?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    forceReuseWindow?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    diffMode?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    addMode?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    noRecentEntry?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    waitMarkerFileURI?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    args?: Resolver<Maybe<IResolversTypes['AnyObject']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IOutputResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Output'] = IResolversParentTypes['Output']> = {
    maxChannelHistory?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IOverridesResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Overrides'] = IResolversParentTypes['Overrides']> = {
    contents?: Resolver<Maybe<IResolversTypes['AnyObject']>, ParentType, ContextType>;
    identifiers?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IPathResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Path'] = IResolversParentTypes['Path']> = {
    lineNumber?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    columnNumber?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    exists?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    fileUri?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IPathsToWaitForResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PathsToWaitFor'] = IResolversParentTypes['PathsToWaitFor']> = {
    paths?: Resolver<Maybe<Array<Maybe<IResolversTypes['Path']>>>, ParentType, ContextType>;
    waitMarkerFileUri?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IPendingStatusbarEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PendingStatusbarEntry'] = IResolversParentTypes['PendingStatusbarEntry']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    alignment?: Resolver<Maybe<IResolversTypes['StatusbarAlignment']>, ParentType, ContextType>;
    priority?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IPositionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Position'] = IResolversParentTypes['Position']> = {
    lineNumber?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    column?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    line?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    character?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IPreferenceItemResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PreferenceItem'] = IResolversParentTypes['PreferenceItem']> = {
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    type?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    default?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    categoryType?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    settings?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    enum?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    enumDescriptions?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IPreferencesTypeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PreferencesType'] = IResolversParentTypes['PreferencesType']> = {
    type?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    data?: Resolver<Maybe<Array<Maybe<IResolversTypes['Setting']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IPrimaryButtonActionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['PrimaryButtonAction'] = IResolversParentTypes['PrimaryButtonAction']> = {
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    run?: Resolver<Maybe<IResolversTypes['ActionRun']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IQueryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Query'] = IResolversParentTypes['Query']> = {
    contextMenu?: Resolver<Maybe<IResolversTypes['ContextMenu']>, ParentType, ContextType>;
    defaultPreferences?: Resolver<Maybe<IResolversTypes['DefaultPreferencesResponse']>, ParentType, ContextType>;
    defaultSetting?: Resolver<Maybe<IResolversTypes['Setting']>, ParentType, ContextType>;
    defaultViewerSettingsSubject?: Resolver<IResolversTypes['DefaultSettings'], ParentType, ContextType, RequireFields<IQuerydefaultViewerSettingsSubjectArgs, never>>;
    dialog?: Resolver<Maybe<IResolversTypes['Dialog']>, ParentType, ContextType>;
    dummy?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    editorPart?: Resolver<Maybe<IResolversTypes['EditorPart']>, ParentType, ContextType>;
    editorState?: Resolver<Maybe<IResolversTypes['CodeEditorViewState']>, ParentType, ContextType, RequireFields<IQueryeditorStateArgs, 'editorId' | 'resource'>>;
    existsFile?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IQueryexistsFileArgs, 'resource'>>;
    getChangedEvent?: Resolver<Maybe<IResolversTypes['IContentChangedEvent']>, ParentType, ContextType, RequireFields<IQuerygetChangedEventArgs, 'resource'>>;
    getConfigurationData?: Resolver<Maybe<IResolversTypes['ConfigurationData']>, ParentType, ContextType>;
    getConfigurationTarget?: Resolver<Maybe<IResolversTypes['ConfigurationScope']>, ParentType, ContextType>;
    getContextData?: Resolver<Maybe<IResolversTypes['Context']>, ParentType, ContextType>;
    getContextProperty?: Resolver<Maybe<IResolversTypes['Context']>, ParentType, ContextType, RequireFields<IQuerygetContextPropertyArgs, never>>;
    getDefaultSettings?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType, RequireFields<IQuerygetDefaultSettingsArgs, never>>;
    getDefaultSettingsResource?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType, RequireFields<IQuerygetDefaultSettingsResourceArgs, never>>;
    getEnvironment?: Resolver<Maybe<IResolversTypes['Environment']>, ParentType, ContextType>;
    getKeybindings?: Resolver<Maybe<IResolversTypes['Keybindings']>, ParentType, ContextType>;
    getSelectedValue?: Resolver<Maybe<IResolversTypes['SelectedOutput']>, ParentType, ContextType>;
    getWorkspace?: Resolver<Maybe<IResolversTypes['WorkspaceData']>, ParentType, ContextType>;
    getWorkspaceValue?: Resolver<Maybe<IResolversTypes['AnyObject']>, ParentType, ContextType, RequireFields<IQuerygetWorkspaceValueArgs, never>>;
    gotoLineQuickAccess?: Resolver<Maybe<IResolversTypes['GoToLineQuickAccess']>, ParentType, ContextType>;
    keybindingContextMenu?: Resolver<Maybe<IResolversTypes['KeybindingContextMenu']>, ParentType, ContextType>;
    keybindings?: Resolver<Maybe<IResolversTypes['Keybindings']>, ParentType, ContextType>;
    notifications?: Resolver<Maybe<IResolversTypes['Notifications']>, ParentType, ContextType>;
    quickInputModel?: Resolver<Maybe<IResolversTypes['QuickInputModel']>, ParentType, ContextType>;
    readStreamTextFile?: Resolver<Maybe<IResolversTypes['TextFileStreamContent']>, ParentType, ContextType, RequireFields<IQueryreadStreamTextFileArgs, 'resource'>>;
    readStringStreamTextFile?: Resolver<Maybe<IResolversTypes['TextFilePublishContent']>, ParentType, ContextType, RequireFields<IQueryreadStringStreamTextFileArgs, 'resource'>>;
    readTextFile?: Resolver<Maybe<IResolversTypes['TextFileContent']>, ParentType, ContextType, RequireFields<IQueryreadTextFileArgs, 'resource'>>;
    resolveContent?: Resolver<Maybe<IResolversTypes['FileContent']>, ParentType, ContextType, RequireFields<IQueryresolveContentArgs, 'resource'>>;
    resolveContents?: Resolver<Maybe<Array<Maybe<IResolversTypes['ResolveFileResultWithMetadata']>>>, ParentType, ContextType, RequireFields<IQueryresolveContentsArgs, never>>;
    resolveFile?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType, RequireFields<IQueryresolveFileArgs, 'resource'>>;
    resolveFileContent?: Resolver<Maybe<IResolversTypes['TextFileContent']>, ParentType, ContextType, RequireFields<IQueryresolveFileContentArgs, 'resource'>>;
    resolveUntitledFileContent?: Resolver<Maybe<IResolversTypes['TextFileContent']>, ParentType, ContextType, RequireFields<IQueryresolveUntitledFileContentArgs, 'resource'>>;
    selectedResource?: Resolver<Maybe<IResolversTypes['Context']>, ParentType, ContextType>;
    settingsSubject?: Resolver<Maybe<IResolversTypes['ISettingsSubject']>, ParentType, ContextType, RequireFields<IQuerysettingsSubjectArgs, 'id'>>;
    showDialog?: Resolver<Maybe<IResolversTypes['DialogResult']>, ParentType, ContextType, RequireFields<IQueryshowDialogArgs, never>>;
    showNotification?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<IQueryshowNotificationArgs, never>>;
    statusbar?: Resolver<Maybe<IResolversTypes['Statusbar']>, ParentType, ContextType>;
    statusbarItem?: Resolver<Maybe<IResolversTypes['StatusbarItem']>, ParentType, ContextType, RequireFields<IQuerystatusbarItemArgs, never>>;
    untitledResources?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    userPreferences?: Resolver<Maybe<IResolversTypes['UserPreferencesRes']>, ParentType, ContextType, RequireFields<IQueryuserPreferencesArgs, never>>;
    viewerSettings?: Resolver<IResolversTypes['SettingsCascade'], ParentType, ContextType>;
    workspaces?: Resolver<Maybe<Array<Maybe<IResolversTypes['WorkspaceRes']>>>, ParentType, ContextType>;
};
export declare type IQuickInputResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['QuickInput'] = IResolversParentTypes['QuickInput']> = {
    title?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    step?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    totalSteps?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    enabled?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    ignoreFocusOut?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    value?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    placeholder?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    prompt?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    validationMessage?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IQuickInputModelResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['QuickInputModel'] = IResolversParentTypes['QuickInputModel']> = {
    show?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    title?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    input?: Resolver<Maybe<IResolversTypes['QuickInput']>, ParentType, ContextType>;
    quickPick?: Resolver<Maybe<IResolversTypes['QuickPick']>, ParentType, ContextType>;
    inputValue?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    selectedValue?: Resolver<Maybe<Array<Maybe<IResolversTypes['QuickPickItem']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IQuickPickResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['QuickPick'] = IResolversParentTypes['QuickPick']> = {
    placeholder?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    canSelectMany?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    autoFocusOnList?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    items?: Resolver<Maybe<Array<Maybe<IResolversTypes['QuickPickItem']>>>, ParentType, ContextType>;
    activeItem?: Resolver<Maybe<IResolversTypes['QuickPickItem']>, ParentType, ContextType>;
    selectedItems?: Resolver<Maybe<Array<Maybe<IResolversTypes['QuickPickItem']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IQuickPickItemResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['QuickPickItem'] = IResolversParentTypes['QuickPickItem']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    detail?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    keybinding?: Resolver<Maybe<IResolversTypes['KeybindingItem']>, ParentType, ContextType>;
    italic?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    highlights?: Resolver<Maybe<IResolversTypes['QuickPickItemHighlights']>, ParentType, ContextType>;
    picked?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    alwaysShow?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IQuickPickItemHighlightsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['QuickPickItemHighlights'] = IResolversParentTypes['QuickPickItemHighlights']> = {
    label?: Resolver<Maybe<Array<Maybe<IResolversTypes['Match']>>>, ParentType, ContextType>;
    description?: Resolver<Maybe<Array<Maybe<IResolversTypes['Match']>>>, ParentType, ContextType>;
    detail?: Resolver<Maybe<Array<Maybe<IResolversTypes['Match']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IRangeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Range'] = IResolversParentTypes['Range']> = {
    start?: Resolver<Maybe<IResolversTypes['Position']>, ParentType, ContextType>;
    end?: Resolver<Maybe<IResolversTypes['Position']>, ParentType, ContextType>;
    startLineNumber?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    startColumn?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    endLineNumber?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    endColumn?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IRemoteUserSettingsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RemoteUserSettings'] = IResolversParentTypes['RemoteUserSettings']> = {
    id?: Resolver<Maybe<IResolversTypes['ID']>, ParentType, ContextType>;
    latestSettings?: Resolver<Maybe<IResolversTypes['Settings']>, ParentType, ContextType>;
    settingsURL?: Resolver<IResolversTypes['URI'], ParentType, ContextType>;
    viewerCanAdminister?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>;
    settingsCascade?: Resolver<IResolversTypes['SettingsCascade'], ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IResolveFileResultResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ResolveFileResult'] = IResolversParentTypes['ResolveFileResult']> = {
    stat?: Resolver<Maybe<IResolversTypes['FileStat']>, ParentType, ContextType>;
    success?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>;
    value?: Resolver<Maybe<IResolversTypes['VSBufferReadableStream']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IResolveFileResultWithMetadataResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ResolveFileResultWithMetadata'] = IResolversParentTypes['ResolveFileResultWithMetadata']> = {
    stat?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType>;
    success?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IResourceEditorInputResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ResourceEditorInput'] = IResolversParentTypes['ResourceEditorInput']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    resource?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    typeId?: Resolver<Maybe<IResolversTypes['EDITOR_INPUT_ID']>, ParentType, ContextType>;
    description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    fileReference?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType>;
    preferredEditorId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    isSupportsSplitEditor?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isActive?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    preview?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isPinned?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    status?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    closable?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    mode?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    preferredMode?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IResourceEncodingResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ResourceEncoding'] = IResolversParentTypes['ResourceEncoding']> = {
    encoding?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    hasBOM?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IResourceMapConfigurationModelResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ResourceMapConfigurationModel'] = IResolversParentTypes['ResourceMapConfigurationModel']> = {
    resource?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    contents?: Resolver<Maybe<IResolversTypes['AnyObject']>, ParentType, ContextType>;
    keys?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    overrides?: Resolver<Maybe<IResolversTypes['ConfigurationOverrides']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IRunActionInWindowRequestResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RunActionInWindowRequest'] = IResolversParentTypes['RunActionInWindowRequest']> = {
    id?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    from?: Resolver<Maybe<IResolversTypes['RunActionInWindowRequestFrom']>, ParentType, ContextType>;
    args?: Resolver<Maybe<Array<Maybe<IResolversTypes['AnyObject']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IRunKeybindingInWindowRequestResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['RunKeybindingInWindowRequest'] = IResolversParentTypes['RunKeybindingInWindowRequest']> = {
    userSettingsLabel?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ISaveDialogOptionsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['SaveDialogOptions'] = IResolversParentTypes['SaveDialogOptions']> = {
    title?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    defaultPath?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    buttonLabel?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    filters?: Resolver<Maybe<Array<Maybe<IResolversTypes['FileFilter']>>>, ParentType, ContextType>;
    message?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    nameFieldLabel?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    showTagField?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ISaveWorkspaceResResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['SaveWorkspaceRes'] = IResolversParentTypes['SaveWorkspaceRes']> = {
    updated?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IScriptsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Scripts'] = IResolversParentTypes['Scripts']> = {
    cdebasebuild?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    cdebasepublish?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ISearchResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Search'] = IResolversParentTypes['Search']> = {
    location?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    smartCase?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    useRipgrep?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    useIgnoreFiles?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    followSymlinks?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    globalFindClipboard?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    quickOpen?: Resolver<Maybe<IResolversTypes['SearchQuickOpen']>, ParentType, ContextType>;
    exclude?: Resolver<Maybe<IResolversTypes['JSON']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ISearchQuickOpenResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['SearchQuickOpen'] = IResolversParentTypes['SearchQuickOpen']> = {
    includeSymbols?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ISelectedOutputResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['SelectedOutput'] = IResolversParentTypes['SelectedOutput']> = {
    title?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    inputValue?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    selectedValue?: Resolver<Maybe<Array<Maybe<IResolversTypes['QuickPickItem']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ISelectionStatusResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['SelectionStatus'] = IResolversParentTypes['SelectionStatus']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    alignment?: Resolver<Maybe<IResolversTypes['StatusbarAlignment']>, ParentType, ContextType>;
    entry?: Resolver<Maybe<IResolversTypes['StatusbarEntry']>, ParentType, ContextType>;
    priority?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    container?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    labelContainer?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    typeId?: Resolver<Maybe<IResolversTypes['STATUSBAR_ITEM_ID']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ISettingResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Setting'] = IResolversParentTypes['Setting']> = {
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    range?: Resolver<Maybe<IResolversTypes['Range']>, ParentType, ContextType>;
    key?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    keyRange?: Resolver<Maybe<IResolversTypes['Range']>, ParentType, ContextType>;
    default?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    value?: Resolver<Maybe<IResolversTypes['AnyObject']>, ParentType, ContextType>;
    valueRange?: Resolver<Maybe<IResolversTypes['Range']>, ParentType, ContextType>;
    description?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    descriptionIsMarkdown?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    descriptionRanges?: Resolver<Maybe<Array<Maybe<IResolversTypes['Range']>>>, ParentType, ContextType>;
    overrides?: Resolver<Maybe<Array<Maybe<IResolversTypes['Setting']>>>, ParentType, ContextType>;
    overrideOf?: Resolver<Maybe<IResolversTypes['Setting']>, ParentType, ContextType>;
    deprecationMessage?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    scope?: Resolver<Maybe<IResolversTypes['ConfigurationScope']>, ParentType, ContextType>;
    type?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    enum?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    enumDescriptions?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    enumDescriptionsAreMarkdown?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    tags?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    extensionInfo?: Resolver<Maybe<IResolversTypes['ConfigurationExtensionInfo']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ISettingsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Settings'] = IResolversParentTypes['Settings']> = {
    createdAt?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    contents?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ISettingsCascadeResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['SettingsCascade'] = IResolversParentTypes['SettingsCascade']> = {
    subjects?: Resolver<Maybe<Array<Maybe<IResolversTypes['SettingsSubject']>>>, ParentType, ContextType>;
    final?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    finalConfiguration?: Resolver<Maybe<IResolversTypes['Configuration']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ISettingsGroupResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['SettingsGroup'] = IResolversParentTypes['SettingsGroup']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    range?: Resolver<Maybe<IResolversTypes['Range']>, ParentType, ContextType>;
    title?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    titleRange?: Resolver<Maybe<IResolversTypes['Range']>, ParentType, ContextType>;
    sections?: Resolver<Maybe<Array<Maybe<IResolversTypes['SettingsSection']>>>, ParentType, ContextType>;
    contributedByExtension?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ISettingsSectionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['SettingsSection'] = IResolversParentTypes['SettingsSection']> = {
    titleRange?: Resolver<Maybe<IResolversTypes['Range']>, ParentType, ContextType>;
    title?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    settings?: Resolver<Maybe<Array<Maybe<IResolversTypes['Setting']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ISettingsSubjectResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['SettingsSubject'] = IResolversParentTypes['SettingsSubject']> = {
    __resolveType: TypeResolveFn<'UserSettings' | 'LocalUserSettings' | 'RemoteUserSettings' | 'FolderSettings' | 'GlobalSettings' | 'WorkspaceSettings' | 'MemorySettings' | 'DefaultSettings', ParentType, ContextType>;
};
export declare type IShellResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Shell'] = IResolversParentTypes['Shell']> = {
    osx?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    linux?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    windows?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    container?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IShellArgsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ShellArgs'] = IResolversParentTypes['ShellArgs']> = {
    container?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    windows?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    linux?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    osx?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ISideBySideEditorInputResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['SideBySideEditorInput'] = IResolversParentTypes['SideBySideEditorInput']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    resource?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    typeId?: Resolver<Maybe<IResolversTypes['EDITOR_INPUT_ID']>, ParentType, ContextType>;
    description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    fileReference?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType>;
    preferredEditorId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    isSupportsSplitEditor?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isActive?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    preview?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isPinned?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    status?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    closable?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    master?: Resolver<Maybe<IResolversTypes['EditorInput']>, ParentType, ContextType>;
    details?: Resolver<Maybe<IResolversTypes['EditorInput']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ISnippetResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Snippet'] = IResolversParentTypes['Snippet']> = {
    language?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IStatusbarResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Statusbar'] = IResolversParentTypes['Statusbar']> = {
    items?: Resolver<Maybe<Array<Maybe<IResolversTypes['StatusbarItem']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IStatusbarEntryResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['StatusbarEntry'] = IResolversParentTypes['StatusbarEntry']> = {
    showTabsButtons?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    showIcons?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    showStatusbar?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    text?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    ariaLabel?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    tooltip?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    color?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    backgroundColor?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    command?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    arguments?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    showBeak?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IStatusbarItemResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['StatusbarItem'] = IResolversParentTypes['StatusbarItem']> = {
    __resolveType: TypeResolveFn<'Terminal' | 'SelectionStatus' | 'Indentation' | 'EncodingStatus' | 'EndOfLineSequence' | 'LanguageMode', ParentType, ContextType>;
};
export declare type IStreamContentResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['StreamContent'] = IResolversParentTypes['StreamContent']> = {
    resource?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    mtime?: Resolver<Maybe<IResolversTypes['BigInt']>, ParentType, ContextType>;
    etag?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    value?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    status?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    encoding?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    linesRange?: Resolver<Maybe<IResolversTypes['LineRange']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ISubscriptionResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Subscription'] = IResolversParentTypes['Subscription']> = {
    dummy?: SubscriptionResolver<Maybe<IResolversTypes['Int']>, "dummy", ParentType, ContextType>;
    fileData?: SubscriptionResolver<Maybe<Array<Maybe<IResolversTypes['FileChange']>>>, "fileData", ParentType, ContextType, RequireFields<ISubscriptionfileDataArgs, 'resource'>>;
    fileOperation?: SubscriptionResolver<Maybe<IResolversTypes['FileOperationOutput']>, "fileOperation", ParentType, ContextType, RequireFields<ISubscriptionfileOperationArgs, 'resource'>>;
    onDidChangeConfiguration?: SubscriptionResolver<Maybe<IResolversTypes['IConfigurationChangeEvent']>, "onDidChangeConfiguration", ParentType, ContextType>;
    readStreamTextFile?: SubscriptionResolver<Maybe<IResolversTypes['TextFileStreamContent']>, "readStreamTextFile", ParentType, ContextType, RequireFields<ISubscriptionreadStreamTextFileArgs, 'resource'>>;
    readStreamTextString?: SubscriptionResolver<Maybe<IResolversTypes['TextFilePublishContent']>, "readStreamTextString", ParentType, ContextType, RequireFields<ISubscriptionreadStreamTextStringArgs, 'resource'>>;
};
export declare type ITerminalResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['Terminal'] = IResolversParentTypes['Terminal']> = {
    alignment?: Resolver<Maybe<IResolversTypes['StatusbarAlignment']>, ParentType, ContextType>;
    container?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    entry?: Resolver<Maybe<IResolversTypes['StatusbarEntry']>, ParentType, ContextType>;
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    integrated?: Resolver<Maybe<IResolversTypes['Integrated']>, ParentType, ContextType>;
    labelContainer?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    priority?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    typeId?: Resolver<Maybe<IResolversTypes['STATUSBAR_ITEM_ID']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ITextBufferDataResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['TextBufferData'] = IResolversParentTypes['TextBufferData']> = {
    EOL?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    lines?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    containsRTL?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isBasicASCII?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ITextFileContentResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['TextFileContent'] = IResolversParentTypes['TextFileContent']> = {
    dirty?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    encoding?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    etag?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    inConflictMode?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inErrorMode?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inOrphanMode?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    inPendingSave?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isReadonly?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    mtime?: Resolver<IResolversTypes['BigInt'], ParentType, ContextType>;
    name?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    preferredEncoding?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    preferredMode?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    resource?: Resolver<IResolversTypes['URI'], ParentType, ContextType>;
    size?: Resolver<IResolversTypes['Int'], ParentType, ContextType>;
    state?: Resolver<Maybe<IResolversTypes['FileModelState']>, ParentType, ContextType>;
    value?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ITextFilePublishContentResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['TextFilePublishContent'] = IResolversParentTypes['TextFilePublishContent']> = {
    resource?: Resolver<IResolversTypes['URI'], ParentType, ContextType>;
    name?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    mtime?: Resolver<Maybe<IResolversTypes['BigInt']>, ParentType, ContextType>;
    etag?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    size?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    isReadonly?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    streamSeq?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    encoding?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    value?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    status?: Resolver<Maybe<IResolversTypes['FileContentStatus']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type ITextFileStreamContentResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['TextFileStreamContent'] = IResolversParentTypes['TextFileStreamContent']> = {
    resource?: Resolver<IResolversTypes['URI'], ParentType, ContextType>;
    name?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    size?: Resolver<IResolversTypes['Int'], ParentType, ContextType>;
    mtime?: Resolver<IResolversTypes['BigInt'], ParentType, ContextType>;
    etag?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    isReadonly?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    encoding?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    value?: Resolver<Maybe<IResolversTypes['TextBufferData']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IThemeLabelResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ThemeLabel'] = IResolversParentTypes['ThemeLabel']> = {
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    uiTheme?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    path?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IUntitledEditorInputResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UntitledEditorInput'] = IResolversParentTypes['UntitledEditorInput']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    resource?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    typeId?: Resolver<Maybe<IResolversTypes['EDITOR_INPUT_ID']>, ParentType, ContextType>;
    description?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    fileReference?: Resolver<Maybe<IResolversTypes['FileStatWithMetadata']>, ParentType, ContextType>;
    preferredEditorId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    isSupportsSplitEditor?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isActive?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    preview?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    isPinned?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    editorId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    status?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    closable?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    hasAssociatedFilePath?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    shortDescription?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    mediumDescription?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    longDescription?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    shortTitle?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    mediumTitle?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    longTitle?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    suggestFileName?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    enconding?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    mode?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IUpdateDelayedResourceResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UpdateDelayedResource'] = IResolversParentTypes['UpdateDelayedResource']> = {
    resource?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IUpdatedResourceResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UpdatedResource'] = IResolversParentTypes['UpdatedResource']> = {
    resource?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    etag?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export interface IURIScalarConfig extends GraphQLScalarTypeConfig<IResolversTypes['URI'], any> {
    name: 'URI';
}
export declare type IURIToOpenResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['URIToOpen'] = IResolversParentTypes['URIToOpen']> = {
    __resolveType: TypeResolveFn<'WorkspaceToOpen' | 'FolderToOpen' | 'FileToOpen', ParentType, ContextType>;
};
export declare type IUserPreferencesResResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UserPreferencesRes'] = IResolversParentTypes['UserPreferencesRes']> = {
    prefs?: Resolver<Maybe<IResolversTypes['IUserPreferences']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IUserSettingsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['UserSettings'] = IResolversParentTypes['UserSettings']> = {
    id?: Resolver<Maybe<IResolversTypes['ID']>, ParentType, ContextType>;
    latestSettings?: Resolver<Maybe<IResolversTypes['Settings']>, ParentType, ContextType>;
    settingsURL?: Resolver<IResolversTypes['URI'], ParentType, ContextType>;
    viewerCanAdminister?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>;
    settingsCascade?: Resolver<IResolversTypes['SettingsCascade'], ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IViewResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['View'] = IResolversParentTypes['View']> = {
    id?: Resolver<Maybe<IResolversTypes['ID']>, ParentType, ContextType>;
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IViewContainerResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ViewContainer'] = IResolversParentTypes['ViewContainer']> = {
    id?: Resolver<Maybe<IResolversTypes['ID']>, ParentType, ContextType>;
    title?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IViewStateResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['ViewState'] = IResolversParentTypes['ViewState']> = {
    scrollTop?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    scrollTopWithoutViewZones?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    scrollLeft?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    firstPosition?: Resolver<Maybe<IResolversTypes['Position']>, ParentType, ContextType>;
    firstPositionDeltaTop?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export interface IVSBufferScalarConfig extends GraphQLScalarTypeConfig<IResolversTypes['VSBuffer'], any> {
    name: 'VSBuffer';
}
export interface IVSBufferReadableStreamScalarConfig extends GraphQLScalarTypeConfig<IResolversTypes['VSBufferReadableStream'], any> {
    name: 'VSBufferReadableStream';
}
export declare type IWindowConfigurationResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['WindowConfiguration'] = IResolversParentTypes['WindowConfiguration']> = {
    machineId?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    windowId?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    logLevel?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    mainPid?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    appRoot?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    execPath?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    isInitialStartup?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    nodeCacheDataDir?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    backupPath?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    workspace?: Resolver<Maybe<IResolversTypes['WorkspaceIdentifier']>, ParentType, ContextType>;
    folderUri?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    remoteAuthority?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    zoomLevel?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    fullscreen?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    maximized?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    highContrast?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    frameless?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    accessibilitySupport?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    partsSplashPath?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    perfStartTime?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    perfAppReady?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    perfWindowLoadTime?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    perfEntries?: Resolver<Maybe<IResolversTypes['AnyObject']>, ParentType, ContextType>;
    filesToOpenOrCreate?: Resolver<Maybe<Array<Maybe<IResolversTypes['Path']>>>, ParentType, ContextType>;
    filesToDiff?: Resolver<Maybe<Array<Maybe<IResolversTypes['Path']>>>, ParentType, ContextType>;
    filesToWait?: Resolver<Maybe<IResolversTypes['PathsToWaitFor']>, ParentType, ContextType>;
    termProgram?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IWorkspaceDataResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['WorkspaceData'] = IResolversParentTypes['WorkspaceData']> = {
    id?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    folders?: Resolver<Array<Maybe<IResolversTypes['WorkspaceFolderData']>>, ParentType, ContextType>;
    configuration?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    name?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    isUntitled?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IWorkspaceFolderDataResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['WorkspaceFolderData'] = IResolversParentTypes['WorkspaceFolderData']> = {
    uri?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    name?: Resolver<IResolversTypes['String'], ParentType, ContextType>;
    index?: Resolver<IResolversTypes['Int'], ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IWorkspaceIdentifierResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['WorkspaceIdentifier'] = IResolversParentTypes['WorkspaceIdentifier']> = {
    id?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    configPath?: Resolver<Maybe<IResolversTypes['URI']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IWorkspacePreferenceActivityBarResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['WorkspacePreferenceActivityBar'] = IResolversParentTypes['WorkspacePreferenceActivityBar']> = {
    visible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IWorkspacePreferenceCommandPaletteResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['WorkspacePreferenceCommandPalette'] = IResolversParentTypes['WorkspacePreferenceCommandPalette']> = {
    history?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    preserveInput?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IWorkspacePreferenceEditorResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['WorkspacePreferenceEditor'] = IResolversParentTypes['WorkspacePreferenceEditor']> = {
    centeredLayoutAutoResize?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    closeEmptyGroups?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    closeOnFileDelete?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    enablePreview?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    enablePreviewFromQuickOpen?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    focusRecentEditorAfterClose?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    highlightModifiedTabs?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    labelFormat?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    openPositioning?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    openSideBySideDirection?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    restoreViewState?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    revealIfOpen?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    showIcons?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    showTabs?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    splitSizing?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    tabCloseButton?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    tabSizing?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IWorkspacePreferenceExperimentalResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['WorkspacePreferenceExperimental'] = IResolversParentTypes['WorkspacePreferenceExperimental']> = {
    editorAssociations?: Resolver<Maybe<Array<Maybe<IResolversTypes['String']>>>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IWorkspacePreferenceListResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['WorkspacePreferenceList'] = IResolversParentTypes['WorkspacePreferenceList']> = {
    automaticKeyboardNavigation?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    horizontalScrolling?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    keyboardNavigation?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    multiSelectModifier?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    openMode?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IWorkspacePreferencePanelResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['WorkspacePreferencePanel'] = IResolversParentTypes['WorkspacePreferencePanel']> = {
    defaultLocation?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IWorkspacePreferenceQuickOpenResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['WorkspacePreferenceQuickOpen'] = IResolversParentTypes['WorkspacePreferenceQuickOpen']> = {
    closeOnFocusLost?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    preserveInput?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IWorkspacePreferenceSettingsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['WorkspacePreferenceSettings'] = IResolversParentTypes['WorkspacePreferenceSettings']> = {
    editor?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    enableNaturalLanguageSearch?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    openDefaultKeybindings?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    settingsSearchTocBehavior?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    useSplitJSON?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IWorkspacePreferenceSideBarResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['WorkspacePreferenceSideBar'] = IResolversParentTypes['WorkspacePreferenceSideBar']> = {
    location?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IWorkspacePreferenceStatusBarResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['WorkspacePreferenceStatusBar'] = IResolversParentTypes['WorkspacePreferenceStatusBar']> = {
    visible?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IWorkspacePreferenceTipsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['WorkspacePreferenceTips'] = IResolversParentTypes['WorkspacePreferenceTips']> = {
    enabled?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    horizontalScrolling?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    indent?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    renderIndentGuides?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IWorkspacePreferenceViewResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['WorkspacePreferenceView'] = IResolversParentTypes['WorkspacePreferenceView']> = {
    alwaysShowHeaderActions?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IWorkspacePreferenceWorkbenchResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['WorkspacePreferenceWorkbench'] = IResolversParentTypes['WorkspacePreferenceWorkbench']> = {
    colorTheme?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    enableExperiments?: Resolver<Maybe<IResolversTypes['Boolean']>, ParentType, ContextType>;
    fontAliasing?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    iconTheme?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    startupEditor?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    view?: Resolver<Maybe<IResolversTypes['WorkspacePreferenceView']>, ParentType, ContextType>;
    tips?: Resolver<Maybe<IResolversTypes['WorkspacePreferenceTips']>, ParentType, ContextType>;
    statusBar?: Resolver<Maybe<IResolversTypes['WorkspacePreferenceStatusBar']>, ParentType, ContextType>;
    sideBar?: Resolver<Maybe<IResolversTypes['WorkspacePreferenceSideBar']>, ParentType, ContextType>;
    settings?: Resolver<Maybe<IResolversTypes['WorkspacePreferenceSettings']>, ParentType, ContextType>;
    quickOpen?: Resolver<Maybe<IResolversTypes['WorkspacePreferenceQuickOpen']>, ParentType, ContextType>;
    panel?: Resolver<Maybe<IResolversTypes['WorkspacePreferencePanel']>, ParentType, ContextType>;
    list?: Resolver<Maybe<IResolversTypes['WorkspacePreferenceList']>, ParentType, ContextType>;
    experimental?: Resolver<Maybe<IResolversTypes['WorkspacePreferenceExperimental']>, ParentType, ContextType>;
    editor?: Resolver<Maybe<IResolversTypes['WorkspacePreferenceEditor']>, ParentType, ContextType>;
    commandPalette?: Resolver<Maybe<IResolversTypes['WorkspacePreferenceCommandPalette']>, ParentType, ContextType>;
    activityBar?: Resolver<Maybe<IResolversTypes['WorkspacePreferenceActivityBar']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IWorkspaceResResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['WorkspaceRes'] = IResolversParentTypes['WorkspaceRes']> = {
    uri?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IWorkspaceSettingsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['WorkspaceSettings'] = IResolversParentTypes['WorkspaceSettings']> = {
    id?: Resolver<Maybe<IResolversTypes['ID']>, ParentType, ContextType>;
    latestSettings?: Resolver<Maybe<IResolversTypes['Settings']>, ParentType, ContextType>;
    settingsURL?: Resolver<IResolversTypes['URI'], ParentType, ContextType>;
    viewerCanAdminister?: Resolver<IResolversTypes['Boolean'], ParentType, ContextType>;
    settingsCascade?: Resolver<IResolversTypes['SettingsCascade'], ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IWorkspaceStackSettingsResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['WorkspaceStackSettings'] = IResolversParentTypes['WorkspaceStackSettings']> = {
    dummy?: Resolver<Maybe<IResolversTypes['Int']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IWorkspaceToOpenResolvers<ContextType = MyContext, ParentType extends IResolversParentTypes['WorkspaceToOpen'] = IResolversParentTypes['WorkspaceToOpen']> = {
    workspaceUri?: Resolver<IResolversTypes['URI'], ParentType, ContextType>;
    label?: Resolver<Maybe<IResolversTypes['String']>, ParentType, ContextType>;
    __isTypeOf?: isTypeOfResolverFn<ParentType>;
};
export declare type IResolvers<ContextType = MyContext> = {
    Action?: IActionResolvers<ContextType>;
    ActionItem?: IActionItemResolvers<ContextType>;
    ActionRun?: IActionRunResolvers<ContextType>;
    Actions?: IActionsResolvers<ContextType>;
    AddFoldersRequest?: IAddFoldersRequestResolvers<ContextType>;
    Anchor?: IAnchorResolvers<ContextType>;
    AnyObject?: GraphQLScalarType;
    Assets?: IAssetsResolvers<ContextType>;
    Author?: IAuthorResolvers<ContextType>;
    BaseExtension?: IBaseExtensionResolvers<ContextType>;
    BigInt?: GraphQLScalarType;
    Bundles?: IBundlesResolvers<ContextType>;
    ChangeRange?: IChangeRangeResolvers<ContextType>;
    ChangesChunk?: IChangesChunkResolvers<ContextType>;
    CheckboxOptions?: ICheckboxOptionsResolvers<ContextType>;
    CloseEditorsFilter?: ICloseEditorsFilterResolvers<ContextType>;
    CodeEditorViewState?: ICodeEditorViewStateResolvers<ContextType>;
    Configuration?: IConfigurationResolvers<ContextType>;
    ConfigurationData?: IConfigurationDataResolvers<ContextType>;
    ConfigurationExtensionInfo?: IConfigurationExtensionInfoResolvers<ContextType>;
    ConfigurationModel?: IConfigurationModelResolvers<ContextType>;
    ConfigurationOverrides?: IConfigurationOverridesResolvers<ContextType>;
    ContentChangedEvent?: IContentChangedEventResolvers<ContextType>;
    Context?: IContextResolvers<ContextType>;
    ContextMenu?: IContextMenuResolvers<ContextType>;
    Contributes?: IContributesResolvers<ContextType>;
    CrashReporterStartOptions?: ICrashReporterStartOptionsResolvers<ContextType>;
    CursorState?: ICursorStateResolvers<ContextType>;
    DataUriEditorInput?: IDataUriEditorInputResolvers<ContextType>;
    Debugger?: IDebuggerResolvers<ContextType>;
    DefaultPreferencesResponse?: IDefaultPreferencesResponseResolvers<ContextType>;
    DefaultSettings?: IDefaultSettingsResolvers<ContextType>;
    Detail?: IDetailResolvers<ContextType>;
    DevToolsOptions?: IDevToolsOptionsResolvers<ContextType>;
    Dialog?: IDialogResolvers<ContextType>;
    DialogResult?: IDialogResultResolvers<ContextType>;
    DiffEditorInput?: IDiffEditorInputResolvers<ContextType>;
    DockLayout?: IDockLayoutResolvers<ContextType>;
    EditKeybindingItem?: IEditKeybindingItemResolvers<ContextType>;
    EditorChildren?: IEditorChildrenResolvers;
    EditorGroup?: IEditorGroupResolvers<ContextType>;
    EditorGroupLayout?: IEditorGroupLayoutResolvers<ContextType>;
    EditorIdentifier?: IEditorIdentifierResolvers<ContextType>;
    EditorInput?: IEditorInputResolvers;
    EditorPart?: IEditorPartResolvers<ContextType>;
    EditorPartOptions_Input?: IEditorPartOptions_InputResolvers<ContextType>;
    EditorSettings?: IEditorSettingsResolvers<ContextType>;
    EncodingStatus?: IEncodingStatusResolvers<ContextType>;
    EndOfLineSequence?: IEndOfLineSequenceResolvers<ContextType>;
    Engines?: IEnginesResolvers<ContextType>;
    EnterWorkspaceResult?: IEnterWorkspaceResultResolvers<ContextType>;
    Environment?: IEnvironmentResolvers<ContextType>;
    ExtensionColor?: IExtensionColorResolvers<ContextType>;
    ExtensionColorTypes?: IExtensionColorTypesResolvers<ContextType>;
    ExtensionConfiguration?: IExtensionConfigurationResolvers<ContextType>;
    ExtensionConfigurationProperty?: IExtensionConfigurationPropertyResolvers<ContextType>;
    ExtensionContributions?: IExtensionContributionsResolvers<ContextType>;
    ExtensionHostDebugParams?: IExtensionHostDebugParamsResolvers<ContextType>;
    ExtensionIdentifier?: IExtensionIdentifierResolvers<ContextType>;
    ExtensionJSONValidation?: IExtensionJSONValidationResolvers<ContextType>;
    ExtensionLanguage?: IExtensionLanguageResolvers<ContextType>;
    ExtensionManifest?: IExtensionManifestResolvers<ContextType>;
    ExtensionManifestBugs?: IExtensionManifestBugsResolvers<ContextType>;
    ExtensionManifestRepository?: IExtensionManifestRepositoryResolvers<ContextType>;
    ExtensionPackageType?: IExtensionPackageTypeResolvers<ContextType>;
    FieldError?: IFieldErrorResolvers<ContextType>;
    FileChange?: IFileChangeResolvers<ContextType>;
    FileContent?: IFileContentResolvers<ContextType>;
    FileDeleteOptions?: IFileDeleteOptionsResolvers<ContextType>;
    FileEditorInput?: IFileEditorInputResolvers<ContextType>;
    FileFilter?: IFileFilterResolvers<ContextType>;
    FileOpenOptions?: IFileOpenOptionsResolvers<ContextType>;
    FileOperationOutput?: IFileOperationOutputResolvers<ContextType>;
    FileOverwriteOptions?: IFileOverwriteOptionsResolvers<ContextType>;
    FileResult?: IFileResultResolvers<ContextType>;
    Files?: IFilesResolvers<ContextType>;
    Files_Stat?: IFiles_StatResolvers<ContextType>;
    FileStat?: IFileStatResolvers<ContextType>;
    FileStatWithMetadata?: IFileStatWithMetadataResolvers<ContextType>;
    FileStreamContent?: IFileStreamContentResolvers<ContextType>;
    FileToOpen?: IFileToOpenResolvers<ContextType>;
    FileWriteOptions?: IFileWriteOptionsResolvers<ContextType>;
    FolderConfigurationModel?: IFolderConfigurationModelResolvers<ContextType>;
    FolderSettings?: IFolderSettingsResolvers<ContextType>;
    FolderToOpen?: IFolderToOpenResolvers<ContextType>;
    GalleryBanner?: IGalleryBannerResolvers<ContextType>;
    Git?: IGitResolvers<ContextType>;
    GitDecorations?: IGitDecorationsResolvers<ContextType>;
    GlobalSettings?: IGlobalSettingsResolvers<ContextType>;
    GoToLineQuickAccess?: IGoToLineQuickAccessResolvers<ContextType>;
    Grammar?: IGrammarResolvers<ContextType>;
    GroupLayoutArgument?: IGroupLayoutArgumentResolvers<ContextType>;
    IBaseStat?: IIBaseStatResolvers;
    IBaseStatWithMetadata?: IIBaseStatWithMetadataResolvers;
    IBaseTextFileContent?: IIBaseTextFileContentResolvers;
    IConfigurationChangeEvent?: IIConfigurationChangeEventResolvers<ContextType>;
    IContentChangedEvent?: IIContentChangedEventResolvers;
    IDebugParams?: IIDebugParamsResolvers;
    IEditorGroup?: IIEditorGroupResolvers;
    IEditorInput?: IIEditorInputResolvers;
    IEditorInputWithGroupFields?: IIEditorInputWithGroupFieldsResolvers;
    IEncodingSupport?: IIEncodingSupportResolvers;
    IFileClientMetadata?: IIFileClientMetadataResolvers;
    IFileEditorInput?: IIFileEditorInputResolvers;
    IModeSupport?: IIModeSupportResolvers;
    ImportResult?: IImportResultResolvers<ContextType>;
    Indentation?: IIndentationResolvers<ContextType>;
    InputTypeDetail?: IInputTypeDetailResolvers<ContextType>;
    Integrated?: IIntegratedResolvers<ContextType>;
    IPathData?: IIPathDataResolvers;
    IPathsToWaitForData?: IIPathsToWaitForDataResolvers;
    ISettingsSubject?: IISettingsSubjectResolvers;
    ISideBySideEditorInput?: IISideBySideEditorInputResolvers;
    IStaticWorkspaceData?: IIStaticWorkspaceDataResolvers;
    IStatusbarItem?: IIStatusbarItemResolvers;
    ITreeItem?: IITreeItemResolvers;
    IUntitledFileValue?: IIUntitledFileValueResolvers;
    IUserPreferences?: IIUserPreferencesResolvers<ContextType>;
    IUserSettings?: IIUserSettingsResolvers<ContextType>;
    JSON?: GraphQLScalarType;
    JSONObject?: GraphQLScalarType;
    KeyBinding?: IKeyBindingResolvers<ContextType>;
    KeybindingContextMenu?: IKeybindingContextMenuResolvers<ContextType>;
    KeybindingEditorInput?: IKeybindingEditorInputResolvers<ContextType>;
    KeybindingItem?: IKeybindingItemResolvers<ContextType>;
    Keybindings?: IKeybindingsResolvers<ContextType>;
    KeyboardEvent_output?: IKeyboardEvent_outputResolvers<ContextType>;
    LanguageMode?: ILanguageModeResolvers<ContextType>;
    Languages?: ILanguagesResolvers<ContextType>;
    LineRange?: ILineRangeResolvers<ContextType>;
    Localization?: ILocalizationResolvers<ContextType>;
    LocalizationTranslation?: ILocalizationTranslationResolvers<ContextType>;
    LocalUserSettings?: ILocalUserSettingsResolvers<ContextType>;
    Match?: IMatchResolvers<ContextType>;
    MemorySettings?: IMemorySettingsResolvers<ContextType>;
    MenuItem?: IMenuItemResolvers<ContextType>;
    MenuItemAction?: IMenuItemActionResolvers<ContextType>;
    MenuItemActionContext?: IMenuItemActionContextResolvers<ContextType>;
    MenuItemActionDebug?: IMenuItemActionDebugResolvers<ContextType>;
    MenuItemActionEditor?: IMenuItemActionEditorResolvers<ContextType>;
    MenuItemActionEditorTitle?: IMenuItemActionEditorTitleResolvers<ContextType>;
    MenuItemActionScm?: IMenuItemActionScmResolvers<ContextType>;
    MenuItemActionScmChange?: IMenuItemActionScmChangeResolvers<ContextType>;
    MenuItemActionView?: IMenuItemActionViewResolvers<ContextType>;
    Menus?: IMenusResolvers<ContextType>;
    MessageBoxOptions?: IMessageBoxOptionsResolvers<ContextType>;
    MessageBoxResult?: IMessageBoxResultResolvers<ContextType>;
    MessageLink?: IMessageLinkResolvers<ContextType>;
    Mutation?: IMutationResolvers<ContextType>;
    NativeOpenDialogOptions?: INativeOpenDialogOptionsResolvers<ContextType>;
    NewWindowOptions?: INewWindowOptionsResolvers<ContextType>;
    Notification?: INotificationResolvers<ContextType>;
    NotificationActions?: INotificationActionsResolvers<ContextType>;
    NotificationChangeEvent?: INotificationChangeEventResolvers<ContextType>;
    NotificationMessage?: INotificationMessageResolvers<ContextType>;
    Notifications?: INotificationsResolvers<ContextType>;
    NotificationViewItem?: INotificationViewItemResolvers<ContextType>;
    NotificationViewItemProgress?: INotificationViewItemProgressResolvers<ContextType>;
    NotificationViewItemProgressState?: INotificationViewItemProgressStateResolvers<ContextType>;
    OpenConfiguration?: IOpenConfigurationResolvers<ContextType>;
    OpenDialogOptions?: IOpenDialogOptionsResolvers<ContextType>;
    OpenFileRequest?: IOpenFileRequestResolvers<ContextType>;
    OpenSettings?: IOpenSettingsResolvers<ContextType>;
    Output?: IOutputResolvers<ContextType>;
    Overrides?: IOverridesResolvers<ContextType>;
    Path?: IPathResolvers<ContextType>;
    PathsToWaitFor?: IPathsToWaitForResolvers<ContextType>;
    PendingStatusbarEntry?: IPendingStatusbarEntryResolvers<ContextType>;
    Position?: IPositionResolvers<ContextType>;
    PreferenceItem?: IPreferenceItemResolvers<ContextType>;
    PreferencesType?: IPreferencesTypeResolvers<ContextType>;
    PrimaryButtonAction?: IPrimaryButtonActionResolvers<ContextType>;
    Query?: IQueryResolvers<ContextType>;
    QuickInput?: IQuickInputResolvers<ContextType>;
    QuickInputModel?: IQuickInputModelResolvers<ContextType>;
    QuickPick?: IQuickPickResolvers<ContextType>;
    QuickPickItem?: IQuickPickItemResolvers<ContextType>;
    QuickPickItemHighlights?: IQuickPickItemHighlightsResolvers<ContextType>;
    Range?: IRangeResolvers<ContextType>;
    RemoteUserSettings?: IRemoteUserSettingsResolvers<ContextType>;
    ResolveFileResult?: IResolveFileResultResolvers<ContextType>;
    ResolveFileResultWithMetadata?: IResolveFileResultWithMetadataResolvers<ContextType>;
    ResourceEditorInput?: IResourceEditorInputResolvers<ContextType>;
    ResourceEncoding?: IResourceEncodingResolvers<ContextType>;
    ResourceMapConfigurationModel?: IResourceMapConfigurationModelResolvers<ContextType>;
    RunActionInWindowRequest?: IRunActionInWindowRequestResolvers<ContextType>;
    RunKeybindingInWindowRequest?: IRunKeybindingInWindowRequestResolvers<ContextType>;
    SaveDialogOptions?: ISaveDialogOptionsResolvers<ContextType>;
    SaveWorkspaceRes?: ISaveWorkspaceResResolvers<ContextType>;
    Scripts?: IScriptsResolvers<ContextType>;
    Search?: ISearchResolvers<ContextType>;
    SearchQuickOpen?: ISearchQuickOpenResolvers<ContextType>;
    SelectedOutput?: ISelectedOutputResolvers<ContextType>;
    SelectionStatus?: ISelectionStatusResolvers<ContextType>;
    Setting?: ISettingResolvers<ContextType>;
    Settings?: ISettingsResolvers<ContextType>;
    SettingsCascade?: ISettingsCascadeResolvers<ContextType>;
    SettingsGroup?: ISettingsGroupResolvers<ContextType>;
    SettingsSection?: ISettingsSectionResolvers<ContextType>;
    SettingsSubject?: ISettingsSubjectResolvers;
    Shell?: IShellResolvers<ContextType>;
    ShellArgs?: IShellArgsResolvers<ContextType>;
    SideBySideEditorInput?: ISideBySideEditorInputResolvers<ContextType>;
    Snippet?: ISnippetResolvers<ContextType>;
    Statusbar?: IStatusbarResolvers<ContextType>;
    StatusbarEntry?: IStatusbarEntryResolvers<ContextType>;
    StatusbarItem?: IStatusbarItemResolvers;
    StreamContent?: IStreamContentResolvers<ContextType>;
    Subscription?: ISubscriptionResolvers<ContextType>;
    Terminal?: ITerminalResolvers<ContextType>;
    TextBufferData?: ITextBufferDataResolvers<ContextType>;
    TextFileContent?: ITextFileContentResolvers<ContextType>;
    TextFilePublishContent?: ITextFilePublishContentResolvers<ContextType>;
    TextFileStreamContent?: ITextFileStreamContentResolvers<ContextType>;
    ThemeLabel?: IThemeLabelResolvers<ContextType>;
    UntitledEditorInput?: IUntitledEditorInputResolvers<ContextType>;
    UpdateDelayedResource?: IUpdateDelayedResourceResolvers<ContextType>;
    UpdatedResource?: IUpdatedResourceResolvers<ContextType>;
    URI?: GraphQLScalarType;
    URIToOpen?: IURIToOpenResolvers;
    UserPreferencesRes?: IUserPreferencesResResolvers<ContextType>;
    UserSettings?: IUserSettingsResolvers<ContextType>;
    View?: IViewResolvers<ContextType>;
    ViewContainer?: IViewContainerResolvers<ContextType>;
    ViewState?: IViewStateResolvers<ContextType>;
    VSBuffer?: GraphQLScalarType;
    VSBufferReadableStream?: GraphQLScalarType;
    WindowConfiguration?: IWindowConfigurationResolvers<ContextType>;
    WorkspaceData?: IWorkspaceDataResolvers<ContextType>;
    WorkspaceFolderData?: IWorkspaceFolderDataResolvers<ContextType>;
    WorkspaceIdentifier?: IWorkspaceIdentifierResolvers<ContextType>;
    WorkspacePreferenceActivityBar?: IWorkspacePreferenceActivityBarResolvers<ContextType>;
    WorkspacePreferenceCommandPalette?: IWorkspacePreferenceCommandPaletteResolvers<ContextType>;
    WorkspacePreferenceEditor?: IWorkspacePreferenceEditorResolvers<ContextType>;
    WorkspacePreferenceExperimental?: IWorkspacePreferenceExperimentalResolvers<ContextType>;
    WorkspacePreferenceList?: IWorkspacePreferenceListResolvers<ContextType>;
    WorkspacePreferencePanel?: IWorkspacePreferencePanelResolvers<ContextType>;
    WorkspacePreferenceQuickOpen?: IWorkspacePreferenceQuickOpenResolvers<ContextType>;
    WorkspacePreferenceSettings?: IWorkspacePreferenceSettingsResolvers<ContextType>;
    WorkspacePreferenceSideBar?: IWorkspacePreferenceSideBarResolvers<ContextType>;
    WorkspacePreferenceStatusBar?: IWorkspacePreferenceStatusBarResolvers<ContextType>;
    WorkspacePreferenceTips?: IWorkspacePreferenceTipsResolvers<ContextType>;
    WorkspacePreferenceView?: IWorkspacePreferenceViewResolvers<ContextType>;
    WorkspacePreferenceWorkbench?: IWorkspacePreferenceWorkbenchResolvers<ContextType>;
    WorkspaceRes?: IWorkspaceResResolvers<ContextType>;
    WorkspaceSettings?: IWorkspaceSettingsResolvers<ContextType>;
    WorkspaceStackSettings?: IWorkspaceStackSettingsResolvers<ContextType>;
    WorkspaceToOpen?: IWorkspaceToOpenResolvers<ContextType>;
};
export declare const EditorsFileRefFragmentDoc: import("graphql").DocumentNode;
export declare const ChangeDirtyStateOnFileStatFragmentDoc: import("graphql").DocumentNode;
export declare const changedEventFragmentDoc: import("graphql").DocumentNode;
export declare const ChangesOnChangedEventFragmentDoc: import("graphql").DocumentNode;
export declare const FileContentFragmentDoc: import("graphql").DocumentNode;
export declare const TextContentFragmentDoc: import("graphql").DocumentNode;
export declare const EditorStateFragmentDoc: import("graphql").DocumentNode;
export declare const FileParentChildRefFragmentDoc: import("graphql").DocumentNode;
export declare const FileSaveConfigFragmentDoc: import("graphql").DocumentNode;
export declare const FileSelfStatFragmentDoc: import("graphql").DocumentNode;
export declare const FileStatNestedChildFragmentDoc: import("graphql").DocumentNode;
export declare const FilesTreeItemFragmentDoc: import("graphql").DocumentNode;
export declare const FilesTreeDataFragmentDoc: import("graphql").DocumentNode;
export declare const FilesTreeItemMiniFragmentDoc: import("graphql").DocumentNode;
export declare const FilesTreeDataMiniFragmentDoc: import("graphql").DocumentNode;
export declare const SelectedResourceFragmentDoc: import("graphql").DocumentNode;
export declare const TextFileOnFileStatFragmentDoc: import("graphql").DocumentNode;
export declare const TextFileOnFileStatLiteFragmentDoc: import("graphql").DocumentNode;
export declare const UntitledFileOnFileStatFragmentDoc: import("graphql").DocumentNode;
export declare const UntitledFileStatFragmentDoc: import("graphql").DocumentNode;
export declare const UpdateErrorFileOnFileStatFragmentDoc: import("graphql").DocumentNode;
export declare const CanHandleResource_WSDocument: import("graphql").DocumentNode;
export declare type CanHandleResource_WSMutationResult = ApolloReactCommon.MutationResult<ICanHandleResource_WSMutation>;
export declare type CanHandleResource_WSMutationOptions = ApolloReactCommon.BaseMutationOptions<ICanHandleResource_WSMutation, ICanHandleResource_WSMutationVariables>;
export declare const CopyFile_WSDocument: import("graphql").DocumentNode;
export declare type CopyFile_WSMutationResult = ApolloReactCommon.MutationResult<ICopyFile_WSMutation>;
export declare type CopyFile_WSMutationOptions = ApolloReactCommon.BaseMutationOptions<ICopyFile_WSMutation, ICopyFile_WSMutationVariables>;
export declare const CreateFile_WSDocument: import("graphql").DocumentNode;
export declare type CreateFile_WSMutationResult = ApolloReactCommon.MutationResult<ICreateFile_WSMutation>;
export declare type CreateFile_WSMutationOptions = ApolloReactCommon.BaseMutationOptions<ICreateFile_WSMutation, ICreateFile_WSMutationVariables>;
export declare const CreateFolder_WSDocument: import("graphql").DocumentNode;
export declare type CreateFolder_WSMutationResult = ApolloReactCommon.MutationResult<ICreateFolder_WSMutation>;
export declare type CreateFolder_WSMutationOptions = ApolloReactCommon.BaseMutationOptions<ICreateFolder_WSMutation, ICreateFolder_WSMutationVariables>;
export declare const CreateUntitledFileDocument: import("graphql").DocumentNode;
export declare type CreateUntitledFileMutationResult = ApolloReactCommon.MutationResult<ICreateUntitledFileMutation>;
export declare type CreateUntitledFileMutationOptions = ApolloReactCommon.BaseMutationOptions<ICreateUntitledFileMutation, ICreateUntitledFileMutationVariables>;
export declare const DeleteFile_WSDocument: import("graphql").DocumentNode;
export declare type DeleteFile_WSMutationResult = ApolloReactCommon.MutationResult<IDeleteFile_WSMutation>;
export declare type DeleteFile_WSMutationOptions = ApolloReactCommon.BaseMutationOptions<IDeleteFile_WSMutation, IDeleteFile_WSMutationVariables>;
export declare const FindFileStatDocument: import("graphql").DocumentNode;
export declare type FindFileStatMutationResult = ApolloReactCommon.MutationResult<IFindFileStatMutation>;
export declare type FindFileStatMutationOptions = ApolloReactCommon.BaseMutationOptions<IFindFileStatMutation, IFindFileStatMutationVariables>;
export declare const GetEditorStateDocument: import("graphql").DocumentNode;
export declare type GetEditorStateMutationResult = ApolloReactCommon.MutationResult<IGetEditorStateMutation>;
export declare type GetEditorStateMutationOptions = ApolloReactCommon.BaseMutationOptions<IGetEditorStateMutation, IGetEditorStateMutationVariables>;
export declare const GetFilesTreeDataDocument: import("graphql").DocumentNode;
export declare type GetFilesTreeDataMutationResult = ApolloReactCommon.MutationResult<IGetFilesTreeDataMutation>;
export declare type GetFilesTreeDataMutationOptions = ApolloReactCommon.BaseMutationOptions<IGetFilesTreeDataMutation, IGetFilesTreeDataMutationVariables>;
export declare const LoadFile_WSDocument: import("graphql").DocumentNode;
export declare type LoadFile_WSMutationResult = ApolloReactCommon.MutationResult<ILoadFile_WSMutation>;
export declare type LoadFile_WSMutationOptions = ApolloReactCommon.BaseMutationOptions<ILoadFile_WSMutation, ILoadFile_WSMutationVariables>;
export declare const LoadFileContent_WSDocument: import("graphql").DocumentNode;
export declare type LoadFileContent_WSMutationResult = ApolloReactCommon.MutationResult<ILoadFileContent_WSMutation>;
export declare type LoadFileContent_WSMutationOptions = ApolloReactCommon.BaseMutationOptions<ILoadFileContent_WSMutation, ILoadFileContent_WSMutationVariables>;
export declare const LoadFileWithContentDocument: import("graphql").DocumentNode;
export declare type LoadFileWithContentMutationResult = ApolloReactCommon.MutationResult<ILoadFileWithContentMutation>;
export declare type LoadFileWithContentMutationOptions = ApolloReactCommon.BaseMutationOptions<ILoadFileWithContentMutation, ILoadFileWithContentMutationVariables>;
export declare const LoadTreeDataDocument: import("graphql").DocumentNode;
export declare type LoadTreeDataMutationResult = ApolloReactCommon.MutationResult<ILoadTreeDataMutation>;
export declare type LoadTreeDataMutationOptions = ApolloReactCommon.BaseMutationOptions<ILoadTreeDataMutation, ILoadTreeDataMutationVariables>;
export declare const MoveFile_WSDocument: import("graphql").DocumentNode;
export declare type MoveFile_WSMutationResult = ApolloReactCommon.MutationResult<IMoveFile_WSMutation>;
export declare type MoveFile_WSMutationOptions = ApolloReactCommon.BaseMutationOptions<IMoveFile_WSMutation, IMoveFile_WSMutationVariables>;
export declare const RemoveChangedEventDocument: import("graphql").DocumentNode;
export declare type RemoveChangedEventMutationResult = ApolloReactCommon.MutationResult<IRemoveChangedEventMutation>;
export declare type RemoveChangedEventMutationOptions = ApolloReactCommon.BaseMutationOptions<IRemoveChangedEventMutation, IRemoveChangedEventMutationVariables>;
export declare const RenameFile_WSDocument: import("graphql").DocumentNode;
export declare type RenameFile_WSMutationResult = ApolloReactCommon.MutationResult<IRenameFile_WSMutation>;
export declare type RenameFile_WSMutationOptions = ApolloReactCommon.BaseMutationOptions<IRenameFile_WSMutation, IRenameFile_WSMutationVariables>;
export declare const SaveDelayFileChanges_WSDocument: import("graphql").DocumentNode;
export declare type SaveDelayFileChanges_WSMutationResult = ApolloReactCommon.MutationResult<ISaveDelayFileChanges_WSMutation>;
export declare type SaveDelayFileChanges_WSMutationOptions = ApolloReactCommon.BaseMutationOptions<ISaveDelayFileChanges_WSMutation, ISaveDelayFileChanges_WSMutationVariables>;
export declare const SaveFileDocument: import("graphql").DocumentNode;
export declare type SaveFileMutationResult = ApolloReactCommon.MutationResult<ISaveFileMutation>;
export declare type SaveFileMutationOptions = ApolloReactCommon.BaseMutationOptions<ISaveFileMutation, ISaveFileMutationVariables>;
export declare const SaveFile_WSDocument: import("graphql").DocumentNode;
export declare type SaveFile_WSMutationResult = ApolloReactCommon.MutationResult<ISaveFile_WSMutation>;
export declare type SaveFile_WSMutationOptions = ApolloReactCommon.BaseMutationOptions<ISaveFile_WSMutation, ISaveFile_WSMutationVariables>;
export declare const SaveFileAsDocument: import("graphql").DocumentNode;
export declare type SaveFileAsMutationResult = ApolloReactCommon.MutationResult<ISaveFileAsMutation>;
export declare type SaveFileAsMutationOptions = ApolloReactCommon.BaseMutationOptions<ISaveFileAsMutation, ISaveFileAsMutationVariables>;
export declare const SaveFileChanges_WSDocument: import("graphql").DocumentNode;
export declare type SaveFileChanges_WSMutationResult = ApolloReactCommon.MutationResult<ISaveFileChanges_WSMutation>;
export declare type SaveFileChanges_WSMutationOptions = ApolloReactCommon.BaseMutationOptions<ISaveFileChanges_WSMutation, ISaveFileChanges_WSMutationVariables>;
export declare const SetEncodingDocument: import("graphql").DocumentNode;
export declare type SetEncodingMutationResult = ApolloReactCommon.MutationResult<ISetEncodingMutation>;
export declare type SetEncodingMutationOptions = ApolloReactCommon.BaseMutationOptions<ISetEncodingMutation, ISetEncodingMutationVariables>;
export declare const SetTreeDataDocument: import("graphql").DocumentNode;
export declare type SetTreeDataMutationResult = ApolloReactCommon.MutationResult<ISetTreeDataMutation>;
export declare type SetTreeDataMutationOptions = ApolloReactCommon.BaseMutationOptions<ISetTreeDataMutation, ISetTreeDataMutationVariables>;
export declare const UnwatchFileDocument: import("graphql").DocumentNode;
export declare type UnwatchFileMutationResult = ApolloReactCommon.MutationResult<IUnwatchFileMutation>;
export declare type UnwatchFileMutationOptions = ApolloReactCommon.BaseMutationOptions<IUnwatchFileMutation, IUnwatchFileMutationVariables>;
export declare const UnwatchFile_WSDocument: import("graphql").DocumentNode;
export declare type UnwatchFile_WSMutationResult = ApolloReactCommon.MutationResult<IUnwatchFile_WSMutation>;
export declare type UnwatchFile_WSMutationOptions = ApolloReactCommon.BaseMutationOptions<IUnwatchFile_WSMutation, IUnwatchFile_WSMutationVariables>;
export declare const UpdateFileDirtyStateDocument: import("graphql").DocumentNode;
export declare type UpdateFileDirtyStateMutationResult = ApolloReactCommon.MutationResult<IUpdateFileDirtyStateMutation>;
export declare type UpdateFileDirtyStateMutationOptions = ApolloReactCommon.BaseMutationOptions<IUpdateFileDirtyStateMutation, IUpdateFileDirtyStateMutationVariables>;
export declare const UpdateContentByChangesDocument: import("graphql").DocumentNode;
export declare type UpdateContentByChangesMutationResult = ApolloReactCommon.MutationResult<IUpdateContentByChangesMutation>;
export declare type UpdateContentByChangesMutationOptions = ApolloReactCommon.BaseMutationOptions<IUpdateContentByChangesMutation, IUpdateContentByChangesMutationVariables>;
export declare const UpdateEditorStateDocument: import("graphql").DocumentNode;
export declare type UpdateEditorStateMutationResult = ApolloReactCommon.MutationResult<IUpdateEditorStateMutation>;
export declare type UpdateEditorStateMutationOptions = ApolloReactCommon.BaseMutationOptions<IUpdateEditorStateMutation, IUpdateEditorStateMutationVariables>;
export declare const UpdateFileContent_WSDocument: import("graphql").DocumentNode;
export declare type UpdateFileContent_WSMutationResult = ApolloReactCommon.MutationResult<IUpdateFileContent_WSMutation>;
export declare type UpdateFileContent_WSMutationOptions = ApolloReactCommon.BaseMutationOptions<IUpdateFileContent_WSMutation, IUpdateFileContent_WSMutationVariables>;
export declare const UpdateSelectedResourceDocument: import("graphql").DocumentNode;
export declare type UpdateSelectedResourceMutationResult = ApolloReactCommon.MutationResult<IUpdateSelectedResourceMutation>;
export declare type UpdateSelectedResourceMutationOptions = ApolloReactCommon.BaseMutationOptions<IUpdateSelectedResourceMutation, IUpdateSelectedResourceMutationVariables>;
export declare const WatchFileDocument: import("graphql").DocumentNode;
export declare type WatchFileMutationResult = ApolloReactCommon.MutationResult<IWatchFileMutation>;
export declare type WatchFileMutationOptions = ApolloReactCommon.BaseMutationOptions<IWatchFileMutation, IWatchFileMutationVariables>;
export declare const WatchFile_WSDocument: import("graphql").DocumentNode;
export declare type WatchFile_WSMutationResult = ApolloReactCommon.MutationResult<IWatchFile_WSMutation>;
export declare type WatchFile_WSMutationOptions = ApolloReactCommon.BaseMutationOptions<IWatchFile_WSMutation, IWatchFile_WSMutationVariables>;
export declare const ChangedContentDocument: import("graphql").DocumentNode;
export declare type ChangedContentQueryResult = ApolloReactCommon.QueryResult<IChangedContentQuery, IChangedContentQueryVariables>;
export declare const EditorStateDocument: import("graphql").DocumentNode;
export declare type EditorStateQueryResult = ApolloReactCommon.QueryResult<IEditorStateQuery, IEditorStateQueryVariables>;
export declare const FileExistsDocument: import("graphql").DocumentNode;
export declare type FileExistsQueryResult = ApolloReactCommon.QueryResult<IFileExistsQuery, IFileExistsQueryVariables>;
export declare const FileExists_WSDocument: import("graphql").DocumentNode;
export declare type FileExists_WSQueryResult = ApolloReactCommon.QueryResult<IFileExists_WSQuery, IFileExists_WSQueryVariables>;
export declare const FileContent_WSDocument: import("graphql").DocumentNode;
export declare type FileContent_WSQueryResult = ApolloReactCommon.QueryResult<IFileContent_WSQuery, IFileContent_WSQueryVariables>;
export declare const FileStat_WSDocument: import("graphql").DocumentNode;
export declare type FileStat_WSQueryResult = ApolloReactCommon.QueryResult<IFileStat_WSQuery, IFileStat_WSQueryVariables>;
export declare const ResolveFileContentDocument: import("graphql").DocumentNode;
export declare type ResolveFileContentQueryResult = ApolloReactCommon.QueryResult<IResolveFileContentQuery, IResolveFileContentQueryVariables>;
export declare const ResolveUntitledFileContentDocument: import("graphql").DocumentNode;
export declare type ResolveUntitledFileContentQueryResult = ApolloReactCommon.QueryResult<IResolveUntitledFileContentQuery, IResolveUntitledFileContentQueryVariables>;
export declare const SelectedResourceDocument: import("graphql").DocumentNode;
export declare type SelectedResourceQueryResult = ApolloReactCommon.QueryResult<ISelectedResourceQuery, ISelectedResourceQueryVariables>;
export declare const TextContent_WSDocument: import("graphql").DocumentNode;
export declare type TextContent_WSQueryResult = ApolloReactCommon.QueryResult<ITextContent_WSQuery, ITextContent_WSQueryVariables>;
export declare const FileStreamContent_WSDocument: import("graphql").DocumentNode;
export declare type FileStreamContent_WSQueryResult = ApolloReactCommon.QueryResult<IFileStreamContent_WSQuery, IFileStreamContent_WSQueryVariables>;
export declare const UntitledResourcesDocument: import("graphql").DocumentNode;
export declare type UntitledResourcesQueryResult = ApolloReactCommon.QueryResult<IUntitledResourcesQuery, IUntitledResourcesQueryVariables>;
export declare const FileDataDocument: import("graphql").DocumentNode;
export declare type FileDataSubscriptionResult = ApolloReactCommon.SubscriptionResult<IFileDataSubscription>;
export declare const FileOperationDocument: import("graphql").DocumentNode;
export declare type FileOperationSubscriptionResult = ApolloReactCommon.SubscriptionResult<IFileOperationSubscription>;
export declare const ReadStreamTextFileDocument: import("graphql").DocumentNode;
export declare type ReadStreamTextFileSubscriptionResult = ApolloReactCommon.SubscriptionResult<IReadStreamTextFileSubscription>;
