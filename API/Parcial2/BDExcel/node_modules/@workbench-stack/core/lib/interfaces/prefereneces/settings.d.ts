import { ISettingsSubject } from '../generated-model';
/**
 * A key path that refers to a location in a JSON document.
 *
 * Each successive array element specifies an index in an object or array to descend into. For example, in the
 * object `{"a": ["x", "y"]}`, the key path `["a", 1]` refers to the value `"y"`.
 */
export declare type IKeyPath = (string | number)[];
/**
 * An edit to apply to settings.
 */
export interface ISettingsEdit {
    /** The key path to the value. */
    path: IKeyPath;
    /** The new value to insert at the key path. */
    value: any;
}
export interface IRawSettings {
    createdAt: string | null;
    contents: string;
}
/**
 * A subset of the settings JSON Schema type containing the minimum needed by this library.
 */
export interface IGeneratedSettings {
    extensions?: {
        [extensionID: string]: boolean;
    };
    [key: string]: any;
    subjects?: never;
    final?: never;
}
declare type ISettings = IGeneratedSettings;
export declare type IConfiguredSettingsSubject = Pick<ISettingsSubject, 'id' | 'settingsURL' | 'viewerCanAdminister'> & {
    settingsCascade?: IConfiguredSettingsCascade;
};
/**
 * A subject and its settings.
 *
 * Callers that need to represent the null/error states should use {@link ConfiguredSubjectOrError}.
 *
 * @template S the settings type.
 */
export interface IConfiguredSubject<S extends ISettings = ISettings> {
    /** The subject.  */
    subject: IConfiguredSettingsSubject;
    /** The subject's settings. */
    settings: S | null;
    /** The sequential ID number of the settings, used to ensure that edits are applied to the correct version. */
    lastID: number | null;
}
/**
 * A cascade of settings from multiple subjects, from lowest precedence to highest precedence, and the final
 * settings, merged in order of precedence from the settings for each subject in the cascade.
 *
 * For example, the client might support settings globally and per-user, and it is designed so that
 * user settings override global settings. Then there would be two subjects, one for global settings and one for the
 * user.
 *
 * Callers that need to represent the null/error states should use {$link SettingsCascade}
 *
 * @template S the settings type
 */
export interface IConfiguredSettingsCascade<S extends ISettings = ISettings> {
    /**
     * The settings for each subject in the cascade, from lowest to highest precedence.
     */
    subjects: IConfiguredSubject<S>[];
    /**
     * The final settings (merged in order of precedence from the settings for each subject in the cascade).
     */
    final: S;
}
export {};
