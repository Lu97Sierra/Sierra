/* tslint:disable */
import { Event } from '@vscode-alt/monaco-editor/esm/vs/base/common/event';
import { IDisposable } from '@vscode-alt/monaco-editor/esm/vs/base/common/lifecycle';
import { CloseDirection  } from '../enum';
import { GroupIdentifier } from './core-editor';
import { IEditorOptions, ITextEditorOptions, IEditorPartOptions, IEditorInput, GroupDirection, GroupLocation,
	GroupOrientation, EditorGroupLayout, IEditorGroup,
	IMergeGroupOptions, IEditorLayout_Input,
	IAddGroupOptions, GroupsOrder, GroupsArrangement,
} from '../generated-model';
import { IDimension } from '@vscode-alt/monaco-editor/esm/vs/editor/common/editorCommon';


// copied from vs/workbench/services/editor/common/editorGroupsService.ts

export interface IFindGroupScope {
    direction?: GroupDirection;
    location?: GroupLocation;
}

export interface GroupLayoutArgument {
    size?: number;
    groups?: GroupLayoutArgument[];
}


export interface IEditorReplacement {
    editor: IEditorInput;
    replacement: IEditorInput;
    options?: IEditorOptions | ITextEditorOptions;
}


export interface IVscodeEditorGroupsService {


	/**
	 * An event for when the active editor group changes. The active editor
	 * group is the default location for new editors to open.
	 */
    readonly onDidActiveGroupChange: Event<IEditorGroup>;

	/**
	 * An event for when a new group was added.
	 */
    readonly onDidAddGroup: Event<IEditorGroup>;

	/**
	 * An event for when a group was removed.
	 */
    readonly onDidRemoveGroup: Event<IEditorGroup>;

	/**
	 * An event for when a group was moved.
	 */
    readonly onDidMoveGroup: Event<IEditorGroup>;

	/**
	 * An event for when a group gets activated.
	 */
    readonly onDidActivateGroup: Event<IEditorGroup>;

	/**
	 * An event for when the group container is layed out.
	 */
    readonly onDidLayout: Event<IDimension>;

	/**
	 * An active group is the default location for new editors to open.
	 */
    readonly activeGroup: IEditorGroup;

	/**
	 * All groups that are currently visible in the editor area in the
	 * order of their creation (oldest first).
	 */
    readonly groups: ReadonlyArray<IEditorGroup>;

	/**
	 * The number of editor groups that are currently opened.
	 */
    readonly count: number;

	/**
	 * The current layout orientation of the root group.
	 */
    readonly orientation: GroupOrientation;

	/**
	 * A promise that resolves when groups have been restored.
	 */
    readonly whenRestored: Promise<void>;

	/**
	 * Get all groups that are currently visible in the editor area optionally
	 * sorted by being most recent active or grid order. Will sort by creation
	 * time by default (oldest group first).
	 */
    getGroups(order?: GroupsOrder): ReadonlyArray<IEditorGroup>;

	/**
	 * Allows to convert a group identifier to a group.
	 */
    getGroup(identifier: GroupIdentifier): IEditorGroup;

	/**
	 * Set a group as active. An active group is the default location for new editors to open.
	 */
    activateGroup(group: IEditorGroup | GroupIdentifier): IEditorGroup;

	/**
	 * Returns the size of a group.
	 */
    getSize(group: IEditorGroup | GroupIdentifier): number;

	/**
	 * Sets the size of a group.
	 */
    setSize(group: IEditorGroup | GroupIdentifier, size: number): void;

	/**
	 * Arrange all groups according to the provided arrangement.
	 */
    arrangeGroups(arrangement: GroupsArrangement): void;

	/**
	 * Applies the provided layout by either moving existing groups or creating new groups.
	 */
    applyLayout(layout: EditorGroupLayout): void;

	/**
	 * Enable or disable centered editor layout.
	 */
    centerLayout(active: boolean): void;

	/**
	 * Find out if the editor layout is currently centered.
	 */
    isLayoutCentered(): boolean;

	/**
	 * Sets the orientation of the root group to be either vertical or horizontal.
	 */
    setGroupOrientation(orientation: GroupOrientation): void;

	/**
	 * Find a groupd in a specific scope:
	 * * `GroupLocation.FIRST`: the first group
	 * * `GroupLocation.LAST`: the last group
	 * * `GroupLocation.NEXT`: the next group from either the active one or `source`
	 * * `GroupLocation.PREVIOUS`: the previous group from either the active one or `source`
	 * * `GroupDirection.UP`: the next group above the active one or `source`
	 * * `GroupDirection.DOWN`: the next group below the active one or `source`
	 * * `GroupDirection.LEFT`: the next group to the left of the active one or `source`
	 * * `GroupDirection.RIGHT`: the next group to the right of the active one or `source`
	 *
	 * @param scope the scope of the group to search in
	 * @param source optional source to search from
	 * @param wrap optionally wrap around if reaching the edge of groups
	 */
    findGroup(scope: IFindGroupScope, source?: IEditorGroup | GroupIdentifier, wrap?: boolean): IEditorGroup;

	/**
	 * Add a new group to the editor area. A new group is added by splitting a provided one in
	 * one of the four directions.
	 *
	 * @param location the group from which to split to add a new group
	 * @param direction the direction of where to split to
	 * @param options configure the newly group with options
	 */
    addGroup(location: IEditorGroup | GroupIdentifier, direction: GroupDirection, options?: IAddGroupOptions): IEditorGroup;

	/**
	 * Remove a group from the editor area.
	 */
    removeGroup(group: IEditorGroup | GroupIdentifier): IEditorGroup[];

	/**
	 * Move a group to a new group in the editor area.
	 *
	 * @param group the group to move
	 * @param location the group from which to split to add the moved group
	 * @param direction the direction of where to split to
	 */
    moveGroup(group: IEditorGroup | GroupIdentifier, location: IEditorGroup | GroupIdentifier, direction: GroupDirection): IEditorGroup;

	/**
	 * Merge the editors of a group into a target group. By default, all editors will
	 * move and the source group will close. This behaviour can be configured via the
	 * `IMergeGroupOptions` options.
	 *
	 * @param group the group to merge
	 * @param target the target group to merge into
	 * @param options controls how the merge should be performed. by default all editors
	 * will be moved over to the target and the source group will close. Configure to
	 * `MOVE_EDITORS_KEEP_GROUP` to prevent the source group from closing. Set to
	 * `COPY_EDITORS` to copy the editors into the target instead of moding them.
	 */
    mergeGroup(group: IEditorGroup | GroupIdentifier, target: IEditorGroup | GroupIdentifier, options?: IMergeGroupOptions): IEditorGroup;

	/**
	 * Copy a group to a new group in the editor area.
	 *
	 * @param group the group to copy
	 * @param location the group from which to split to add the copied group
	 * @param direction the direction of where to split to
	 */
    copyGroup(group: IEditorGroup | GroupIdentifier, location: IEditorGroup | GroupIdentifier, direction: GroupDirection): IEditorGroup;

	/**
	 * Access the options of the editor part.
	 */
    readonly partOptions: IEditorPartOptions;

	/**
	 * Enforce editor part options temporarily.
	 */
    enforcePartOptions(options: IEditorPartOptions): IDisposable;
}

export interface IEditorGroupsService extends Pick<IVscodeEditorGroupsService,  Exclude<keyof IVscodeEditorGroupsService,
'onDidActiveGroupChange' |
'onDidAddGroup' |
'onDidRemoveGroup' |
'onDidMoveGroup' |
'onDidActivateGroup' |
'onDidLayout' |
'orientation' |
'whenRestored' |
'getSize' |
'setSize' |
'arrangeGroups' |
'applyLayout' |
'centerLayout' |
'isLayoutCentered' |
'setGroupOrientation' |
'enforcePartOptions' |
'moveGroup' |
// 'removeGroup' |
'mergeGroup' |
'copyGroup' |
'partOptions' |
'count'
>>{
	setGroups(data: IEditorGroup[]);

	/**
	 * Applies the provided layout by either moving existing groups or creating new groups.
	 */
    applyLayout(layout: IEditorLayout_Input): void;
}

export const enum GroupChangeKind {

    /* Group Changes */
    GROUP_ACTIVE,
    GROUP_LABEL,

    /* Editor Changes */
    EDITOR_OPEN,
    EDITOR_CLOSE,
    EDITOR_MOVE,
    EDITOR_ACTIVE,
    EDITOR_LABEL,
    EDITOR_PIN,
    EDITOR_DIRTY
}

export interface IGroupChangeEvent {
    kind: GroupChangeKind;
    editor?: IEditorInput;
    editorIndex?: number;
}


