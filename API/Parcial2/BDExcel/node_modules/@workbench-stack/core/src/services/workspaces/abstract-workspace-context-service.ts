/* tslint:disable */

import { injectable, inject } from 'inversify';
import {
    IWorkspaceFolder, IWorkspaceData, WorkbenchState, IConfigurationChangeEvent,
    IWorkspaceFoldersChangeEvent, IWorkspaceFolderCreationData, ISingleFolderWorkspaceIdentifier, IWorkspaceIdentifier, IConfigurationData, IConfigurationOverrides, IWorkspaceContextService, ConfigurationTarget, IConfigurationModel, IClientWorkspaceContextService,
} from '../../interfaces';
import { basenameOrAuthority, dirname, isEqual, relativePath } from '@vscode-alt/monaco-editor/esm/vs/base/common/resources';
import { Workspace, WorkspaceFolder, ConfigurationModel, isConfigurationOverrides, isSingleFolderWorkspaceIdentifier, isWorkspaceIdentifier, ConfigurationChangeEvent } from '../../core';
import { WorkspaceConfiguration as Configuration } from '../../core/workspace/configuration';
import { URI } from '@vscode-alt/monaco-editor/esm/vs/base/common/uri';
import { Event, Emitter } from '@vscode-alt/monaco-editor/esm/vs/base/common/event';
import { ResourceMap } from '@vscode-alt/monaco-editor/esm/vs/base/common/map';
import { Disposable } from '@vscode-alt/monaco-editor/esm/vs/base/common/lifecycle';
import { Queue, Barrier } from '@vscode-alt/monaco-editor/esm/vs/base/common/async';
import { CommonType } from '@common-stack/core';
import { CdmLogger } from '@cdm-logger/core';


type ILogger = CdmLogger.ILogger;
@injectable()
export abstract class AbstractWorkspaceContextService extends Disposable implements IClientWorkspaceContextService {


    protected workspace: Workspace;
    protected completeWorkspaceBarrier: Barrier;
    protected updateWorkspaceBarrier: Barrier;
    private _configuration: Configuration;
    protected logger: ILogger;

    protected readonly _onDidChangeConfiguration: Emitter<IConfigurationChangeEvent> = this._register(new Emitter<IConfigurationChangeEvent>());
    public readonly onDidChangeConfiguration: Event<IConfigurationChangeEvent> = this._onDidChangeConfiguration.event;

    protected readonly _onDidChangeWorkspaceFolders: Emitter<IWorkspaceFoldersChangeEvent> = this._register(new Emitter<IWorkspaceFoldersChangeEvent>());
    public readonly onDidChangeWorkspaceFolders: Event<IWorkspaceFoldersChangeEvent> = this._onDidChangeWorkspaceFolders.event;

    protected readonly _onDidChangeWorkspaceName: Emitter<void> = this._register(new Emitter<void>());
    public readonly onDidChangeWorkspaceName: Event<void> = this._onDidChangeWorkspaceName.event;

    protected readonly _onDidChangeWorkbenchState: Emitter<WorkbenchState> = this._register(new Emitter<WorkbenchState>());
    public readonly onDidChangeWorkbenchState: Event<WorkbenchState> = this._onDidChangeWorkbenchState.event;


    constructor(
        @inject(CommonType.LOGGER)
        logger: ILogger,
    ) {
        super();
        this.logger = logger.child({ className: 'AbstractWorkspaceService' })

        this.completeWorkspaceBarrier = new Barrier();
    }

    public abstract extInitialize();

    public abstract initialize(args);

    public getCompleteWorkspace(): Promise<Workspace> {
        return this.completeWorkspaceBarrier.wait().then(() => this.getWorkspace());
    }

    public getWorkspace(): Workspace {
        return this.workspace;
    }

    public getWorkbenchState(): WorkbenchState {
        // Workspace has configuration file
        if (this.workspace.configuration) {
            return WorkbenchState.WORKSPACE;
        }

        // Folder has single root
        if (this.workspace.folders.length === 1) {
            return WorkbenchState.FOLDER;
        }

        // Empty
        return WorkbenchState.EMPTY;
    }

    public getWorkspaceFolder(resource: URI): IWorkspaceFolder | null {
        return this.workspace.getFolder(resource);
    }

    abstract addFolders(foldersToAdd: IWorkspaceFolderCreationData[], index?: number): Promise<void>;
    
    abstract removeFolders(foldersToRemove: URI[]): Promise<void>;

    abstract updateFolders(foldersToAdd: IWorkspaceFolderCreationData[], foldersToRemove: URI[], index?: number): Promise<void>;

    public isInsideWorkspace(resource: URI): boolean {
        return !!this.getWorkspaceFolder(resource);
    }

    public isCurrentWorkspace(workspaceIdentifier: ISingleFolderWorkspaceIdentifier | IWorkspaceIdentifier): boolean {
        switch (this.getWorkbenchState()) {
            case WorkbenchState.FOLDER:
                return isSingleFolderWorkspaceIdentifier(workspaceIdentifier) && isEqual(workspaceIdentifier, this.workspace.folders[0].uri);
            case WorkbenchState.WORKSPACE:
                return isWorkspaceIdentifier(workspaceIdentifier) && this.workspace.id === workspaceIdentifier.id;
        }
        return false;
    }

    public extAcceptChangedWorkbenchState(workspace: IWorkspaceData, event: WorkbenchState) {
        this.workspace = this.reviveWorkspaceUris(workspace);
        this._onDidChangeWorkbenchState.fire(event);
        this.releaseUpdateWorkspaceBarrier();
    }
    public extAcceptChangedWorkspaceFolders(workspace: IWorkspaceData, event: IWorkspaceFoldersChangeEvent) {
        this.workspace = this.reviveWorkspaceUris(workspace);
        this._onDidChangeWorkspaceFolders.fire(event);
        this.releaseUpdateWorkspaceBarrier();
    }
    public extAcceptChangedWorkspaceName(workspace: IWorkspaceData) {
        this.workspace = this.reviveWorkspaceUris(workspace);
        this._onDidChangeWorkspaceName.fire();
        this.releaseUpdateWorkspaceBarrier();
    }

    protected releaseWorkspaceBarrier(): void {
		if (!this.completeWorkspaceBarrier.isOpen()) {
			this.completeWorkspaceBarrier.open();
		}
    }
    
    protected releaseUpdateWorkspaceBarrier(): void {
		if (this.updateWorkspaceBarrier && !this.updateWorkspaceBarrier.isOpen()) {
			this.updateWorkspaceBarrier.open();
		}
	}

    protected reviveWorkspaceUris(workspaceData: IWorkspaceData) {
        let workspaceConfig, workspaceFolders;
        if (workspaceData.folders) {
            workspaceFolders = workspaceData.folders.map(({ index, uri: uriComponent, name }) => (
                new WorkspaceFolder({ index, uri: URI.revive(uriComponent), name })
            ));
        }

        if (workspaceData.configuration) {
            workspaceConfig = URI.revive(workspaceData.configuration);
        }
        return new Workspace(workspaceData.id, workspaceFolders, workspaceConfig);
    }

}
