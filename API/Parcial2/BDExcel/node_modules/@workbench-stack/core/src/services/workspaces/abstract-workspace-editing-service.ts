// import { inject, injectable } from 'inversify';
// import { IWorkspaceEditingService, IJSONEditingService, IWorkspaceContextService,
//     INotificationService, ITextFileService, IWorkspaceFolderCreationData, WorkbenchState,
// } from '../../interfaces';
// import { ClientTypes } from '../../constants';
// import { URI } from '@vscode-alt/monaco-editor/esm/vs/base/common/uri';
// import { isEqual } from '@vscode-alt/monaco-editor/esm/vs/base/common/resources';
// import { IWorkspaceIdentifier } from '@vscode-alt/monaco-editor/esm/vs/platform/workspaces/common/workspaces';
// import { JSONEditingErrorCode } from '../../interfaces';
// import { IEnvironmentService } from '@vscode-alt/monaco-editor/esm/vs/platform/environment/common/environment';
// import * as nls from '@vscode-alt/monaco-editor/esm/vs/nls';

// @injectable()
// export abstract class AbstractWorkspaceEditingService implements IWorkspaceEditingService {

//     constructor(
//         @inject(ClientTypes.IWorkspaceContextService)
//         private contextService: IWorkspaceContextService,
//         @inject(ClientTypes.IEnvironmentService)
//         private environmentService: IEnvironmentService,
//         @inject(ClientTypes.IJSONEditingService)
//         private jsonEditingService: IJSONEditingService,
//     ){}


//     public updateFolders(index: number, deleteCount?: number, foldersToAdd?: IWorkspaceFolderCreationData[], donotNotifyError?: boolean): Promise<void> {
//         const folders = this.contextService.getWorkspace().folders;

//         let foldersToDelete: URI[] = [];
//         if (typeof deleteCount === 'number') {
//             foldersToDelete = folders.slice(index, index + deleteCount).map(f => f.uri);
//         }

//         const wantsToDelete = foldersToDelete.length > 0;
//         const wantsToAdd = Array.isArray(foldersToAdd) && foldersToAdd.length > 0;

//         if (!wantsToAdd && !wantsToDelete) {
//             return Promise.resolve(); // return early if there is nothing to do
//         }

//         // Add Folders
//         if (wantsToAdd && !wantsToDelete && Array.isArray(foldersToAdd)) {
//             return this.doAddFolders(foldersToAdd, index, donotNotifyError);
//         }

//         // Add & Delete Folders
//         else {

//             // if we are in single-folder state and the folder is replaced with
//             // other folders, we handle this specially and just enter workspace
//             // mode with the folders that are being added.
//             if (this.includesSingleFolderWorkspace(foldersToDelete)) {
//                 return this.createAndEnterWorkspace(foldersToDelete!);
//             }

//             // if we are not in workspace-state, we just add the folders
//             if (this.contextService.getWorkbenchState() !== WorkbenchState.WORKSPACE) {
//                 return this.doAddFolders(foldersToAdd!, index, donotNotifyError);
//             }

//             // finally, update folders within the workspace
//             return this.doUpdateFolders(foldersToAdd!, foldersToDelete, index, donotNotifyError);
//         }
//     }

//     private async doUpdateFolders(foldersToAdd: IWorkspaceFolderCreationData[], foldersToDelete: URI[], index?: number, donotNotifyError: boolean = false): Promise<void> {
//         try {
//             await this.contextService.updateFolders(foldersToAdd, foldersToDelete, index);
//         } catch (error) {
//             if (donotNotifyError) {
//                 throw error;
//             }
//             this.handleWorkspaceConfigurationEditingError(error);
//         }
//     }

//     public addFolders(foldersToAdd: IWorkspaceFolderCreationData[], donotNotifyError: boolean = false): Promise<void> {
//         return this.doAddFolders(foldersToAdd, undefined, donotNotifyError);
//     }

//     private async doAddFolders(foldersToAdd: IWorkspaceFolderCreationData[], index?: number, donotNotifyError: boolean = false): Promise<void> {
//         const state = this.contextService.getWorkbenchState();
//         if (this.environmentService.configuration.remoteAuthority) {

//             // Do not allow workspace folders with scheme different than the current remote scheme
//             const schemas = this.contextService.getWorkspace().folders.map(f => f.uri.scheme);
//             if (schemas.length && foldersToAdd.some(f => schemas.indexOf(f.uri.scheme) === -1)) {
//                 throw new Error(nls.localize('differentSchemeRoots', "Workspace folders from different providers are not allowed in the same workspace."));
//             }
//         }

//         // If we are in no-workspace or single-folder workspace, adding folders has to
//         // enter a workspace
//         if (state !== WorkbenchState.WORKSPACE) {
//             let newWorkspaceFolders = this.contextService.getWorkspace().folders.map(folder => ({ uri: folder.uri}));
//             newWorkspaceFolders.splice(typeof index === 'number' ? index : newWorkspaceFolders.length, 0, ...foldersToAdd);
//             newWorkspaceFolders = distinct(newWorkspaceFolders, folder => getComparisionKey(folder.uri));

//             if (state === WorkbenchState.EMPTY && newWorkspaceFolders.length === 0 || state === WorkbenchState.FOLDER && newWorkspaceFolders.length === 1) {
//                 return; // return if the operation is a no-op for the current state
//             }
//             return this.createAndEnterWorkspace(newWorkspaceFolders);
//         }

//         // Delegate addition of folders to workspace service otherwise
//         try {
//             await this.contextService.addFolders(foldersToAdd, index);
//         } catch (error) {
//             if (donotNotifyError) {
//                 throw error;
//             }

//             this.handleWorkspaceConfigurationEditingErorr(error);
//         }
//     }

//     public removeFolders(foldersToRemove: URI[], donotNotifyError: boolean = false): Promise<void> {

//         // if we are in single-folder state and the opened folder is to be removed,
//         // we reate an empty workspace and enter it.
//         if (this.includesSingleFolderWorkspace(foldersToRemove)) {
//             return this.createAndEnterWorkspace([]);
//         }

//         // Delegate removal of folders to workspace service otherwise
//         try {
//             await this.contextService.removeFolders(foldersToRemove);
//         } catch (error) {
//             if (donotNotifyError) {
//                 throw error;
//             }

//             this.handleWorkspaceConfigurationEditingError(error);
//         }
//     }

//     private includesSingleFolderWorkspace(folders: URI[]): boolean {
// 		if (this.contextService.getWorkbenchState() === WorkbenchState.FOLDER) {
// 			const workspaceFolder = this.contextService.getWorkspace().folders[0];
// 			return (folders.some(folder => isEqual(folder, workspaceFolder.uri)));
// 		}

// 		return false;
//     }

//     public async createAndEnterWorkspace(folders: IWorkspaceFolderCreationData[], path?: URI): Promise<void> {
//         if (path && !await this.isValidTargetWorkspacePath(path)) {
//             return;
//         }

//         const remoteAuthority = this.environmentService.configuration.remoteAuthority;
//         const untitledWorkspace = await this.workspacesService.createUntitledWorkspace(folders, remoteAuthority);
//         if (path) {
//             await this.saveWorkspaceAs(untitledWorkspace, path);
//         } else {
//             path = untitledWorkspace.configPath;
//         }

//         return this.enterWorkspace(path);
//     }

//     public async saveAndEnterWorkspace(path: URI): Promise<void> {
//         if (!await this.isValidTargetWorkspacePath(path)) {
//             return;
//         }

//         const workspaceIdentifier = this.getCurrentWorkspaceIdentifier();
//         if (!workspaceIdentifier) {
//             return;
//         }

//         await this.saveWorkspaceAs(workspaceIdentifier, path);
//         return this.enterWorkspace(path);
//     }

//     public async isValidTargetWorkspacePath(path: URI): Promise<boolean> {
//         return true; // OK
//     }

//     protected async saveWorkspaceAs(workspace: IWorkspaceIdentifier, targetConfigPathURI: URI): Promise<any> {
//         const configPathURI = workspace.configPath;

//         // Return early if target is same as source
//         if (isEqual(configPathURI, targetConfigPathURI)) {
//             return;
//         }

//         // Read the contents of the workspace file, update it to new location and save it.
//         const raw = await this.fileService.readFile(configPathURI);
//         const newRawWorkspaceContents = rewriteWorkspaceFileForNewLocation(raw.value.toString(), configPathURI, targetConfigPathURI);
//         await this.textFileService.create(targetConfigPathURI, newRawWorkspaceContents, { overwrite: true });
//     }

//     private handleWorkspaceConfigurationEditingError(error: JSONEditingError): void {
//         switch (error.code) {
//             case JSONEditingErrorCode.ERROR_INVALID_FILE:
//                 this.onInvalidWorkspaceConfigurationFileError();
//                 break;
//             case JSONEditingErrorCode.ERROR_FILE_DIRTY:
//                 this.onWorkspaceConfigurationFileDirtyError();
//                 break;
//             default: 
//                 this.notificationService.error(error.message);
//         }
//     }

//     private onInvalidWorkspaceConfigurationFileError(): void {
// 		const message = nls.localize('errorInvalidTaskConfiguration', "Unable to write into workspace configuration file. Please open the file to correct errors/warnings in it and try again.");
// 		this.askToOpenWorkspaceConfigurationFile(message);
// 	}

// 	private onWorkspaceConfigurationFileDirtyError(): void {
// 		const message = nls.localize('errorWorkspaceConfigurationFileDirty', "Unable to write into workspace configuration file because the file is dirty. Please save it and try again.");
// 		this.askToOpenWorkspaceConfigurationFile(message);
// 	}

// 	private askToOpenWorkspaceConfigurationFile(message: string): void {
// 		this.notificationService.prompt(Severity.Error, message,
// 			[{
// 				label: nls.localize('openWorkspaceConfigurationFile', "Open Workspace Configuration"),
// 				run: () => this.commandService.executeCommand('workbench.action.openWorkspaceConfigFile')
// 			}]
// 		);
// 	}

// 	abstract async enterWorkspace(path: URI): Promise<void>;

// 	protected async doEnterWorkspace(path: URI): Promise<IEnterWorkspaceResult | null> {
// 		if (!!this.environmentService.extensionTestsLocationURI) {
// 			throw new Error('Entering a new workspace is not possible in tests.');
// 		}

// 		const workspace = await this.workspacesService.getWorkspaceIdentifier(path);

// 		// Settings migration (only if we come from a folder workspace)
// 		if (this.contextService.getWorkbenchState() === WorkbenchState.FOLDER) {
// 			await this.migrateWorkspaceSettings(workspace);
// 		}

// 		const workspaceImpl = this.contextService as WorkspaceService;
// 		await workspaceImpl.initialize(workspace);

// 		return this.workspacesService.enterWorkspace(path);
// 	}

// 	private migrateWorkspaceSettings(toWorkspace: IWorkspaceIdentifier): Promise<void> {
// 		return this.doCopyWorkspaceSettings(toWorkspace, setting => setting.scope === ConfigurationScope.WINDOW);
// 	}

// 	copyWorkspaceSettings(toWorkspace: IWorkspaceIdentifier): Promise<void> {
// 		return this.doCopyWorkspaceSettings(toWorkspace);
//     }
    
//     private doCopyWorkspaceSettings(toWorkspace: IWorkspaceIdentifier, filter?: (config: IConfigurationPropertySchema) => boolean): Promise<void> {
//         const configurationProperties = Registry.as<IConfigurationRegistry>(ConfigurationExtensions.Configuration).getConfigurationProperties();
//         const targetWorkspaceConfiguration: any = {};
//         for (const key of this.configurationService.keys().workspace) {
//             if (configurationProperties[key]) {
//                 if (filter && !filter(configurationProperties[key])) {
//                     continue;
//                 }
//                 targetWorkspaceConfiguration[key] = this.configurationService.inspect(key).workspaceValue;
//             }
//         }

//         return this.jsonEditingService.write(toWorkspace.configPath, [{key: 'settings', value: targetWorkspaceConfiguration }], true);
//     }

//     protected getCurrentWorkspaceIdentifier(): IWorkspaceIdentifier | undefined {
//         const workspace = this.contextService.getWorkspace();
//         if (workspace?.configuration) {
//             return { id: workspace.id, configPath: workspace.configuration };
//         }

//         return undefined;
//     }

// }