import { IWorkspaceIdentifier } from '../../interfaces';
/* tslint:disable */
import { URI } from '@vscode-alt/monaco-editor/esm/vs/base/common/uri';
import { IWorkspace, IWorkspaceFolder, IWorkspaceFolderData, IStoredWorkspaceFolder } from '../../interfaces';
import { TernarySearchTree } from '@vscode-alt/monaco-editor/esm/vs/base/common/map';
import * as resources from '@vscode-alt/monaco-editor/esm/vs/base/common/resources';
import { isAbsolute } from '@vscode-alt/monaco-editor/esm/vs/base/common/path';
import { isRawFileWorkspaceFolder, isRawUriWorkspaceFolder } from './helpers';

// src/vs/platform/workspace/common/workspace.ts
export class Workspace implements IWorkspace {

	private _foldersMap: TernarySearchTree<string, WorkspaceFolder> = TernarySearchTree.forPaths<WorkspaceFolder>();
	private _folders: WorkspaceFolder[];

	constructor(
		private _id: string,
		folders: WorkspaceFolder[] = [],
		private _configuration: URI | null = null
	) {
		this.folders = folders;
	}

	update(workspace: Workspace) {
		this._id = workspace.id;
		this._configuration = workspace.configuration;
		this.folders = workspace.folders;
	}

	get folders(): WorkspaceFolder[] {
		return this._folders;
	}

	set folders(folders: WorkspaceFolder[]) {
		this._folders = folders;
		this.updateFoldersMap();
	}

	get id(): string {
		return this._id;
	}

	get name(): string {
		return this._id;
	}

	get configuration(): URI | null {
		return this._configuration;
	}

	set configuration(configuration: URI | null) {
		this._configuration = configuration;
	}

	getFolder(resource: URI): IWorkspaceFolder | null {
		if (!resource) {
			return null;
		}

		return this._foldersMap.findSubstr(resource.toString()) || null;
	}

	private updateFoldersMap(): void {
		this._foldersMap = TernarySearchTree.forPaths<WorkspaceFolder>();
		for (const folder of this.folders) {
			this._foldersMap.set(folder.uri.toString(), folder);
		}
	}

	toJSON(): IWorkspace {
		return { id: this.id, name: this.name, folders: this.folders, configuration: this.configuration };
	}
}

export class WorkspaceFolder implements IWorkspaceFolder {

	readonly uri: URI;
	name: string;
	index: number;

	constructor(data: IWorkspaceFolderData,
		readonly raw?: IStoredWorkspaceFolder) {
		this.uri = data.uri;
		this.index = data.index;
		this.name = data.name;
	}

	toResource(relativePath: string): URI {
		return resources.joinPath(this.uri, relativePath);
	}

	toJSON(): IWorkspaceFolderData {
		return { uri: this.uri, name: this.name, index: this.index };
	}
}

export function toWorkspaceFolder(resource: URI): WorkspaceFolder {
	return new WorkspaceFolder({ uri: resource, index: 0, name: resources.basenameOrAuthority(resource) }, { uri: resource.toString() });
}

export function toWorkspaceFolders(configuredFolders: IStoredWorkspaceFolder[], workspaceConfigFile: URI): WorkspaceFolder[] {
	let result: WorkspaceFolder[] = [];
	let seen: { [uri: string]: boolean } = Object.create(null);

	const relativeTo = resources.dirname(workspaceConfigFile);
	for (let configuredFolder of configuredFolders) {
		let uri: URI | null = null;
		if (isRawFileWorkspaceFolder(configuredFolder)) {
			if (configuredFolder.path) {
				uri = resources.resolvePath(relativeTo, configuredFolder.path);
			}
		} else if (isRawUriWorkspaceFolder(configuredFolder)) {
			try {
				uri = URI.parse(configuredFolder.uri);
				// this makes sure all workspace folder are absolute
				if (uri.path[0] !== '/') {
					uri = uri.with({ path: '/' + uri.path });
				}
			} catch (e) {
				console.warn(e);
				// ignore
			}
		}
		if (uri) {
			// remove duplicates
			let comparisonKey = resources.getComparisonKey(uri);
			if (!seen[comparisonKey]) {
				seen[comparisonKey] = true;

				const name = configuredFolder.name || resources.basenameOrAuthority(uri);
				result.push(new WorkspaceFolder({ uri, name, index: result.length }, configuredFolder));
			}
		}
	}
	return result;
}


export function toUri(path: string, relativeTo: URI | undefined): URI | null {
    if (path) {
        if (isAbsolute(path)) {
            return URI.file(path);
        }
        if (relativeTo) {
            return resources.joinPath(relativeTo, path);
        }
    }
    return null;
}


