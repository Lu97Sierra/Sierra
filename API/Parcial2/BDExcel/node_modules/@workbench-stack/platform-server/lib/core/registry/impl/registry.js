"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Registry = exports.schema = exports.ExtensionPoint = exports.ExtensionPointUserDelta = void 0;
const nls_1 = require("@vscode-alt/monaco-editor/esm/vs/nls");
const Types = require("@vscode-alt/monaco-editor/esm/vs/base/common/types");
const Assert = require("@vscode-alt/monaco-editor/esm/vs/base/common/assert");
const core_1 = require("@workbench-stack/core");
const errors_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/errors");
class ExtensionPointUserDelta {
    constructor(added, removed) {
        this.added = added;
        this.removed = removed;
    }
    static _toSet(arr) {
        const result = new Set();
        for (let i = 0, len = arr.length; i < len; i++) {
            result.add(core_1.ExtensionIdentifier.toKey(arr[i].description.identifier));
        }
        return result;
    }
    static compute(previous, current) {
        if (!previous || !previous.length) {
            return new ExtensionPointUserDelta(current, []);
        }
        if (!current || !current.length) {
            return new ExtensionPointUserDelta([], previous);
        }
        const previousSet = this._toSet(previous);
        const currentSet = this._toSet(current);
        let added = current.filter(user => !previousSet.has(core_1.ExtensionIdentifier.toKey(user.description.identifier)));
        let removed = previous.filter(user => !currentSet.has(core_1.ExtensionIdentifier.toKey(user.description.identifier)));
        return new ExtensionPointUserDelta(added, removed);
    }
}
exports.ExtensionPointUserDelta = ExtensionPointUserDelta;
class ExtensionPoint {
    constructor(name) {
        this.name = name;
        this._handler = null;
        this._users = null;
        this._delta = null;
    }
    setHandler(handler) {
        if (this._handler !== null) {
            throw new Error('Handler already set!');
        }
        this._handler = handler;
        this._handle();
    }
    acceptUsers(users) {
        this._delta = ExtensionPointUserDelta.compute(this._users, users);
        this._users = users;
        this._handle();
    }
    _handle() {
        if (this._handler === null || this._users === null || this._delta === null) {
            return;
        }
        try {
            this._handler(this._users, this._delta);
        }
        catch (err) {
            errors_1.onUnexpectedError(err);
        }
    }
}
exports.ExtensionPoint = ExtensionPoint;
const hasOwnProperty = Object.hasOwnProperty;
const schemaId = 'vscode://schemas/vscode-extensions';
exports.schema = {
    properties: {
        engines: {
            type: 'object',
            description: nls_1.localize('vscode.extension.engines', 'Engine compatibility.'),
            properties: {
                'vscode': {
                    type: 'string',
                    description: nls_1.localize('vscode.extension.engines.vscode', 'For VS Code extensions, specifies the VS Code version that the extension is compatible with.'
                        + 'Cannot be *. For example: ^0.10.5 indicates compatibility with a minimum VS Code version of 0.10.5.'),
                    default: '^1.22.0',
                },
            },
        },
        publisher: {
            type: 'string',
            description: nls_1.localize('vscode.extension.publisher', 'The publisher of the VS Code extension.'),
        },
        displayName: {
            description: nls_1.localize('vscode.extension.displayName', 'The display name for the extension used in the VS Code gallery.'),
            type: 'string',
        },
        categories: {
            description: nls_1.localize('vscode.extension.categories', 'The categories used by the VS Code gallery to categorize the extension.'),
            type: 'array',
            uniqueItems: true,
            items: {
                oneOf: [{
                        type: 'string',
                        enum: ['Programming Languages', 'Snippets', 'Linters', 'Themes', 'Debuggers', 'Other', 'Keymaps', 'Formatters', 'Extension Packs', 'SCM Providers', 'Azure', 'Language Packs'],
                    },
                    {
                        type: 'string',
                        const: 'Languages',
                        deprecationMessage: nls_1.localize('vscode.extension.category.languages.deprecated', 'Use \'Programming  Languages\' instead'),
                    }],
            },
        },
        galleryBanner: {
            type: 'object',
            description: nls_1.localize('vscode.extension.galleryBanner', 'Banner used in the VS Code marketplace.'),
            properties: {
                color: {
                    description: nls_1.localize('vscode.extension.galleryBanner.color', 'The banner color on the VS Code marketplace page header.'),
                    type: 'string',
                },
                theme: {
                    description: nls_1.localize('vscode.extension.galleryBanner.theme', 'The color theme for the font used in the banner.'),
                    type: 'string',
                    enum: ['dark', 'light'],
                },
            },
        },
        contributes: {
            description: nls_1.localize('vscode.extension.contributes', 'All contributions of the VS Code extension represented by this package.'),
            type: 'object',
            properties: {
            // extensions will fill in
            },
            default: {},
        },
        preview: {
            type: 'boolean',
            description: nls_1.localize('vscode.extension.preview', 'Sets the extension to be flagged as a Preview in the Marketplace.'),
        },
        activationEvents: {
            description: nls_1.localize('vscode.extension.activationEvents', 'Activation events for the VS Code extension.'),
            type: 'array',
            items: {
                type: 'string',
                defaultSnippets: [
                    {
                        label: 'onLanguage',
                        description: nls_1.localize('vscode.extension.activationEvents.onLanguage', 'An activation event emitted whenever a file that resolves to the specified language gets opened.'),
                        body: 'onLanguage:${1:languageId}',
                    },
                    {
                        label: 'onCommand',
                        description: nls_1.localize('vscode.extension.activationEvents.onCommand', 'An activation event emitted whenever the specified command gets invoked.'),
                        body: 'onCommand:${2:commandId}',
                    },
                    {
                        label: 'onDebug',
                        description: nls_1.localize('vscode.extension.activationEvents.onDebug', 'An activation event emitted whenever a user is about to start debugging or about to setup debug configurations.'),
                        body: 'onDebug',
                    },
                    {
                        label: 'onDebugInitialConfigurations',
                        description: nls_1.localize('vscode.extension.activationEvents.onDebugInitialConfigurations', 'An activation event emitted whenever a "launch.json" needs to be created (and all provideDebugConfigurations methods need to be called).'),
                        body: 'onDebugInitialConfigurations',
                    },
                    {
                        label: 'onDebugResolve',
                        description: nls_1.localize('vscode.extension.activationEvents.onDebugResolve', 'An activation event emitted whenever a debug session with the specific type is about to be launched'
                            + '(and a corresponding resolveDebugConfiguration method needs to be called).'),
                        body: 'onDebugResolve:${6:type}',
                    },
                    {
                        label: 'onDebugAdapterProtocolTracker',
                        description: nls_1.localize('vscode.extension.activationEvents.onDebugAdapterProtocolTracker', 'An activation event emitted whenever a debug session with the specific type is about to be launched and a debug protocol tracker might be needed.'),
                        body: 'onDebugAdapterProtocolTracker:${6:type}',
                    },
                    {
                        label: 'workspaceContains',
                        description: nls_1.localize('vscode.extension.activationEvents.workspaceContains', 'An activation event emitted whenever a folder is opened that contains at least a file matching the specified glob pattern.'),
                        body: 'workspaceContains:${4:filePattern}',
                    },
                    {
                        label: 'onFileSystem',
                        description: nls_1.localize('vscode.extension.activationEvents.onFileSystem', 'An activation event emitted whenever a file or folder is accessed with the given scheme.'),
                        body: 'onFileSystem:${1:scheme}',
                    },
                    {
                        label: 'onSearch',
                        description: nls_1.localize('vscode.extension.activationEvents.onSearch', 'An activation event emitted whenever a search is started in the folder with the given scheme.'),
                        body: 'onSearch:${7:scheme}',
                    },
                    {
                        label: 'onView',
                        body: 'onView:${5:viewId}',
                        description: nls_1.localize('vscode.extension.activationEvents.onView', 'An activation event emitted whenever the specified view is expanded.'),
                    },
                    {
                        label: 'onUri',
                        body: 'onUri',
                        description: nls_1.localize('vscode.extension.activationEvents.onUri', 'An activation event emitted whenever a system-wide Uri directed towards this extension is open.'),
                    },
                    {
                        label: '*',
                        description: nls_1.localize('vscode.extension.activationEvents.star', 'An activation event emitted on VS Code startup. '
                            + 'To ensure a great end user experience, please use this activation event in your extension only when no other activation events combination works in your use-case.'),
                        body: '*',
                    },
                ],
            },
        },
        badges: {
            type: 'array',
            description: nls_1.localize('vscode.extension.badges', 'Array of badges to display in the sidebar of the Marketplace\'s extension page.'),
            items: {
                type: 'object',
                required: ['url', 'href', 'description'],
                properties: {
                    url: {
                        type: 'string',
                        description: nls_1.localize('vscode.extension.badges.url', 'Badge image URL.'),
                    },
                    href: {
                        type: 'string',
                        description: nls_1.localize('vscode.extension.badges.href', 'Badge link.'),
                    },
                    description: {
                        type: 'string',
                        description: nls_1.localize('vscode.extension.badges.description', 'Badge description.'),
                    },
                },
            },
        },
        markdown: {
            type: 'string',
            description: nls_1.localize('vscode.extension.markdown', 'Controls the Markdown rendering engine used in the Marketplace. Either github (default) or standard.'),
            enum: ['github', 'standard'],
            default: 'github',
        },
        qna: {
            default: 'marketplace',
            description: nls_1.localize('vscode.extension.qna', 'Controls the Q&A link in the Marketplace. Set to marketplace to enable the default Marketplace Q & A site. '
                + ' Set to a string to provide the URL of a custom Q & A site. Set to false to disable Q & A altogether.'),
            anyOf: [
                {
                    type: ['string', 'boolean'],
                    enum: ['marketplace', false],
                },
                {
                    type: 'string',
                },
            ],
        },
        extensionDependencies: {
            description: nls_1.localize('vscode.extension.extensionDependencies', 'Dependencies to other extensions. The identifier of an extension is always ${publisher}.${name}. For example: vscode.csharp.'),
            type: 'array',
            uniqueItems: true,
            items: {
                type: 'string',
                pattern: core_1.EXTENSION_IDENTIFIER_PATTERN,
            },
        },
        extensionPack: {
            description: nls_1.localize('vscode.extension.contributes.extensionPack', 'A set of extensions that can be installed together. The identifier of an extension is always ${publisher}.${name}. '
                + ' For example: vscode.csharp.'),
            type: 'array',
            uniqueItems: true,
            items: {
                type: 'string',
                pattern: core_1.EXTENSION_IDENTIFIER_PATTERN,
            },
        },
        scripts: {
            type: 'object',
            properties: {
                'vscode:prepublish': {
                    description: nls_1.localize('vscode.extension.scripts.prepublish', 'Script executed before the package is published as a VS Code extension.'),
                    type: 'string',
                },
                'vscode:uninstall': {
                    description: nls_1.localize('vscode.extension.scripts.uninstall', 'Uninstall hook for VS Code extension. '
                        + 'Script that gets executed when the extension is completely uninstalled from VS Code which is when '
                        + 'VS Code is restarted (shutdown and start) after the extension is uninstalled.'
                        + 'Only Node scripts are supported.'),
                    type: 'string',
                },
            },
        },
        icon: {
            type: 'string',
            description: nls_1.localize('vscode.extension.icon', 'The path to a 128x128 pixel icon.'),
        },
    },
};
class Registry {
    constructor() {
        this.data = {};
    }
    add(id, data) {
        console.log('registry.add', id);
        Assert.ok(Types.isString(id));
        Assert.ok(Types.isObject(data));
        Assert.ok(!this.data.hasOwnProperty(id), 'There is already an extension with this id');
        this.data[id] = data;
    }
    knows(id) {
        return this.data.hasOwnProperty(id);
    }
    as(id) {
        return this.data[id] || null;
    }
    // private _extensionPoints: { [extPoint: string]: ExtensionPointContribution<any>; };
    registerExtensionPoint(desc) {
        console.log('registerExtensionPoint: ', { desc });
        if (hasOwnProperty.call(this._extensionPoints, desc.extensionPoint)) {
            throw new Error('Duplicate extension point: ' + desc.extensionPoint);
        }
        let result = new ExtensionPoint(desc.extensionPoint);
        this._extensionPoints[desc.extensionPoint] = result;
        exports.schema.properties['contributes'].properties[desc.extensionPoint] = desc.jsonSchema;
        schemaRegistry.registerSchema(schemaId, exports.schema);
        return result;
    }
    getExtensionPoints() {
        return Object.keys(this._extensionPoints).map(point => this._extensionPoints[point]);
    }
    getExtensionPointsMap() {
        console.log('getExtensionPointsMap: ', { map: this._extensionPoints });
        return this._extensionPoints;
    }
}
exports.Registry = Registry;
Registry.Instance = new Registry();
const schemaRegistry = Registry.Instance.as(core_1.Extensions.JSONContribution);
//# sourceMappingURL=registry.js.map