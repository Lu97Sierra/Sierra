"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FolderConfiguration = void 0;
/* tslint:disable */
const lifecycle_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/lifecycle");
const uri_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/uri");
const event_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/event");
const core_1 = require("@workbench-stack/core");
const resources = require("@vscode-alt/monaco-editor/esm/vs/base/common/resources");
const errors = require("@vscode-alt/monaco-editor/esm/vs/base/common/errors");
const objects_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/objects");
const network_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/network");
const async_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/async");
const core_2 = require("@files-stack/core");
const parser_1 = require("./parser");
const core_3 = require("@workbench-stack/core");
const parsers_1 = require("../../configuration/parsers");
const path_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/path");
const utils_1 = require("../../../utils");
const fileservice_based_configuration_with_names_1 = require("./fileservice-based-configuration-with-names");
function isFolderConfigurationFile(resource) {
    const configurationNameResource = uri_1.URI.from({ scheme: resource.scheme, path: resources.basename(resource) });
    return [`${core_3.FOLDER_SETTINGS_NAME}.json`, `${core_3.TASKS_CONFIGURATION_KEY}.json`, `${core_3.LAUNCH_CONFIGURATION_KEY}.json`].some(configurationFileName => resources.isEqual(configurationNameResource, uri_1.URI.from({ scheme: resource.scheme, path: configurationFileName }))); // only workspace config files
}
function isFolderSettingsConfigurationFile(resource) {
    return resources.isEqual(uri_1.URI.from({ scheme: resource.scheme, path: resources.basename(resource) }), uri_1.URI.from({ scheme: resource.scheme, path: `${core_3.FOLDER_SETTINGS_NAME}.json` }));
}
class FileServiceBasedFolderConfiguration extends lifecycle_1.Disposable {
    constructor(configurationFolder, workbenchState, configurationFileService) {
        super();
        this.configurationFolder = configurationFolder;
        this.configurationFileService = configurationFileService;
        this._onDidChange = this._register(new event_1.Emitter());
        this.onDidChange = this._onDidChange.event;
        this.configurationNames = [core_3.FOLDER_SETTINGS_NAME /*First one should be settings */, core_3.TASKS_CONFIGURATION_KEY, core_3.LAUNCH_CONFIGURATION_KEY];
        this.configurationResources = this.configurationNames.map(name => resources.joinPath(this.configurationFolder, `${name}.json`));
        this._folderSettingsModelParser = new parsers_1.ConfigurationModelParser(core_3.FOLDER_SETTINGS_PATH, 3 /* WORKSPACE */ === workbenchState ? core_3.FOLDER_SCOPES : core_3.WORKSPACE_SCOPES);
        this._standAloneConfigurations = [];
        this._cache = new core_1.ConfigurationModel();
        this.changeEventTriggerScheduler = this._register(new async_1.RunOnceScheduler(() => this._onDidChange.fire(), 50));
        this._register(configurationFileService.onFileChanges(e => this.handleWorkspaceFileEvents(e)));
        if (!this.configurationFileService.isWatching) {
            this.configurationFileService.whenWatchingStarted.then(() => this.onWatchStarted());
        }
    }
    loadConfiguration() {
        return __awaiter(this, void 0, void 0, function* () {
            const configurationContents = yield Promise.all(this.configurationResources.map((resource) => __awaiter(this, void 0, void 0, function* () {
                try {
                    return yield this.configurationFileService.readFile(resource);
                }
                catch (error) {
                    const exists = yield this.configurationFileService.exists(resource);
                    if (exists) {
                        errors.onUnexpectedError(error);
                    }
                }
                return undefined;
            })));
            // reset
            this._standAloneConfigurations = [];
            this._folderSettingsModelParser.parseContent('');
            // parse
            if (configurationContents[0]) {
                this._folderSettingsModelParser.parseContent(configurationContents[0]);
            }
            for (let index = 1; index < configurationContents.length; index++) {
                const contents = configurationContents[index];
                if (contents) {
                    const standAloneConfigurationModelParser = new parser_1.StandaloneConfigurationModelParser(this.configurationResources[index].toString(), this.configurationNames[index]);
                    standAloneConfigurationModelParser.parseContent(contents);
                    this._standAloneConfigurations.push(standAloneConfigurationModelParser.configurationModel);
                }
            }
            // Consolidate (support *.json files in the workspace settings folder)
            this.consolidate();
            return this._cache;
        });
    }
    reprocess() {
        const oldContents = this._folderSettingsModelParser.configurationModel.contents;
        this._folderSettingsModelParser.parse();
        if (!objects_1.equals(oldContents, this._folderSettingsModelParser.configurationModel.contents)) {
            this.consolidate();
        }
        return this._cache;
    }
    consolidate() {
        this._cache = this._folderSettingsModelParser.configurationModel.merge(...this._standAloneConfigurations);
    }
    onWatchStarted() {
        return __awaiter(this, void 0, void 0, function* () {
            const currentModel = this._cache;
            const newModel = yield this.loadConfiguration();
            const { added, removed, updated } = core_3.compare(currentModel, newModel);
            if (added.length || removed.length || updated.length) {
                this._onDidChange.fire();
            }
        });
    }
    handleWorkspaceFileEvents(event) {
        const events = event.changes;
        let affectedByChanges = false;
        // Find changes that affect workspace configuration files
        for (let i = 0, len = events.length; i < len; i++) {
            const resource = events[i].resource;
            const basename = resources.basename(resource);
            const isJson = path_1.extname(basename) === '.json';
            const isConfigurationFolderDeleted = (events[i].type === core_2.FileChangeType.DELETED && resources.isEqual(resource, this.configurationFolder));
            if (!isJson && !isConfigurationFolderDeleted) {
                continue; // only JSON files or the actual settings folder
            }
            const folderRelativePath = this.toFolderRelativePath(resource);
            if (!folderRelativePath) {
                continue; // event is not inside folder
            }
            // Handle case where ".vscode" got deleted
            if (isConfigurationFolderDeleted) {
                affectedByChanges = true;
                break;
            }
            // only valid workspace config files
            if (this.configurationResources.some(configurationResource => resources.isEqual(configurationResource, resource))) {
                affectedByChanges = true;
                break;
            }
        }
        if (affectedByChanges) {
            this.changeEventTriggerScheduler.schedule();
        }
    }
    toFolderRelativePath(resource) {
        if (resources.isEqualOrParent(resource, this.configurationFolder)) {
            return resources.relativePath(this.configurationFolder, resource);
        }
        return undefined;
    }
}
class CachedFolderConfiguration extends lifecycle_1.Disposable {
    constructor(folder, configFolderRelativePath, configurationCache) {
        super();
        this.configurationCache = configurationCache;
        this._onDidChange = this._register(new event_1.Emitter());
        this.onDidChange = this._onDidChange.event;
        this.key = utils_1.createSHA1(path_1.join(folder.path, configFolderRelativePath)).then(key => ({ type: 'folder', key }));
        this.configurationModel = new core_1.ConfigurationModel();
    }
    loadConfiguration() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const key = yield this.key;
                const contents = yield this.configurationCache.read(key);
                const parsed = JSON.parse(contents.toString());
                this.configurationModel = new core_1.ConfigurationModel(parsed.contents, parsed.keys, parsed.overrides);
            }
            catch (e) {
            }
            return this.configurationModel;
        });
    }
    updateConfiguration(configurationModel) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = yield this.key;
            if (configurationModel.keys.length) {
                yield this.configurationCache.write(key, JSON.stringify(configurationModel.toJSON()));
            }
            else {
                yield this.configurationCache.remove(key);
            }
        });
    }
    reprocess() {
        return this.configurationModel;
    }
    getUnsupportedKeys() {
        return [];
    }
}
class FolderConfiguration extends lifecycle_1.Disposable {
    constructor(workspaceFolder, configFolderRelativePath, workbenchState, configurationFileService, configurationCache) {
        super();
        this.workspaceFolder = workspaceFolder;
        this.workbenchState = workbenchState;
        this._onDidChange = this._register(new event_1.Emitter());
        this.onDidChange = this._onDidChange.event;
        this.folderConfigurationDisposable = lifecycle_1.Disposable.None;
        this.configurationFolder = resources.joinPath(workspaceFolder.uri, configFolderRelativePath);
        this.folderConfiguration = this.cachedFolderConfiguration = new CachedFolderConfiguration(workspaceFolder.uri, configFolderRelativePath, configurationCache);
        if (workspaceFolder.uri.scheme === network_1.Schemas.file) {
            this.folderConfiguration = new FileServiceBasedFolderConfiguration(this.configurationFolder, this.workbenchState, configurationFileService);
        }
        else {
            configurationFileService.whenProviderRegistered(workspaceFolder.uri.scheme)
                .then(() => {
                this.folderConfiguration.dispose();
                this.folderConfigurationDisposable.dispose();
                this.folderConfiguration = new FileServiceBasedFolderConfiguration(this.configurationFolder, this.workbenchState, configurationFileService);
                this._register(this.folderConfiguration.onDidChange(e => this.onDidFolderConfigurationChange()));
                this.onDidFolderConfigurationChange();
            });
        }
        this.folderConfigurationDisposable = this._register(this.folderConfiguration.onDidChange(e => this.onDidFolderConfigurationChange()));
    }
    loadConfiguration() {
        return this.folderConfiguration.loadConfiguration();
    }
    reprocess() {
        return this.folderConfiguration.reprocess();
    }
    onDidFolderConfigurationChange() {
        this.updateCache();
        this._onDidChange.fire();
    }
    updateCache() {
        if (this.configurationFolder.scheme !== network_1.Schemas.file && this.folderConfiguration instanceof FileServiceBasedFolderConfiguration) {
            return this.folderConfiguration.loadConfiguration()
                .then(configurationModel => this.cachedFolderConfiguration.updateConfiguration(configurationModel));
        }
        return Promise.resolve(undefined);
    }
}
exports.FolderConfiguration = FolderConfiguration;
/// latest "1.42.0", uses following method.
class NewFileServiceBasedFolderConfiguration extends fileservice_based_configuration_with_names_1.FileServiceBasedConfigurationWithNames {
    constructor(configurationFolder, workbenchState, fileService) {
        super(configurationFolder, [core_3.FOLDER_SETTINGS_NAME /*First one should be settings */, core_3.TASKS_CONFIGURATION_KEY, core_3.LAUNCH_CONFIGURATION_KEY], 3 /* WORKSPACE */ === workbenchState ? core_3.FOLDER_SCOPES : core_3.WORKSPACE_SCOPES, fileService);
    }
}
//# sourceMappingURL=folder-configuration.js.map