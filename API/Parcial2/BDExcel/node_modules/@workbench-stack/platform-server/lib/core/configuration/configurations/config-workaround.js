"use strict";
/// this is temporary workaround as vscode removed this file, we placed this.
// copy of https://github.com/microsoft/vscode/blob/1.35.1/src/vs/base/node/config.ts
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigWatcher = void 0;
const fs = require("fs");
const path_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/path");
const objects = require("@vscode-alt/monaco-editor/esm/vs/base/common/objects");
const lifecycle_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/lifecycle");
const event_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/event");
const json = require("@vscode-alt/monaco-editor/esm/vs/base/common/json");
const pfs_1 = require("@vscode-alt/monaco-editor/esm/vs/base/node/pfs");
const extpath_1 = require("@vscode-alt/monaco-editor/esm/vs/base/node/extpath");
const watcher_1 = require("@vscode-alt/monaco-editor/esm/vs/base/node/watcher");
/**
 * A simple helper to watch a configured file for changes and process its contents as JSON object.
 * Supports:
 * - comments in JSON files and errors
 * - symlinks for the config file itself
 * - delayed processing of changes to accomodate for lots of changes
 * - configurable defaults
 */
class ConfigWatcher {
    constructor(_path, options = { defaultConfig: Object.create(null), onError: error => console.error(error) }) {
        this._path = _path;
        this.options = options;
        this.disposables = new lifecycle_1.DisposableStore();
        this._onDidUpdateConfiguration = new event_1.Emitter();
        this.disposables.add(this._onDidUpdateConfiguration);
        this.registerWatcher();
        this.initAsync();
    }
    get path() {
        return this._path;
    }
    get hasParseErrors() {
        return this.parseErrors && this.parseErrors.length > 0;
    }
    get onDidUpdateConfiguration() {
        return this._onDidUpdateConfiguration.event;
    }
    initAsync() {
        this.loadAsync(config => {
            if (!this.loaded) {
                this.updateCache(config); // prevent race condition if config was loaded sync already
            }
            if (this.options.initCallback) {
                this.options.initCallback(this.getConfig());
            }
        });
    }
    updateCache(value) {
        this.cache = value;
        this.loaded = true;
    }
    loadSync() {
        try {
            return this.parse(fs.readFileSync(this._path).toString());
        }
        catch (error) {
            return this.options.defaultConfig;
        }
    }
    loadAsync(callback) {
        fs.readFile(this._path, (error, raw) => {
            if (error) {
                return callback(this.options.defaultConfig);
            }
            return callback(this.parse(raw.toString()));
        });
    }
    parse(raw) {
        let res;
        try {
            this.parseErrors = [];
            res = this.options.parse ? this.options.parse(raw, this.parseErrors) : json.parse(raw, this.parseErrors);
            return res || this.options.defaultConfig;
        }
        catch (error) {
            // Ignore parsing errors
            return this.options.defaultConfig;
        }
    }
    registerWatcher() {
        // Watch the parent of the path so that we detect ADD and DELETES
        const parentFolder = path_1.dirname(this._path);
        this.watch(parentFolder, true);
        // Check if the path is a symlink and watch its target if so
        this.handleSymbolicLink().then(undefined, error => { });
    }
    handleSymbolicLink() {
        return __awaiter(this, void 0, void 0, function* () {
            const { stat, symbolicLink } = yield pfs_1.statLink(this._path);
            if (symbolicLink && !stat.isDirectory()) {
                const realPath = yield extpath_1.realpath(this._path);
                this.watch(realPath, false);
            }
        });
    }
    watch(path, isFolder) {
        if (this.disposed) {
            return; // avoid watchers that will never get disposed by checking for being disposed
        }
        if (isFolder) {
            this.disposables.add(watcher_1.watchFolder(path, (type, path) => path === this._path ? this.onConfigFileChange() : undefined, error => this.options.onError(error)));
        }
        else {
            this.disposables.add(watcher_1.watchFile(path, (type, path) => this.onConfigFileChange(), error => this.options.onError(error)));
        }
    }
    onConfigFileChange() {
        if (this.timeoutHandle) {
            global.clearTimeout(this.timeoutHandle);
            this.timeoutHandle = null;
        }
        // we can get multiple change events for one change, so we buffer through a timeout
        this.timeoutHandle = global.setTimeout(() => this.reload(), this.options.changeBufferDelay || 0);
    }
    reload(callback) {
        this.loadAsync(currentConfig => {
            if (!objects.equals(currentConfig, this.cache)) {
                this.updateCache(currentConfig);
                this._onDidUpdateConfiguration.fire({ config: this.cache });
            }
            if (callback) {
                return callback(currentConfig);
            }
        });
    }
    getConfig() {
        this.ensureLoaded();
        return this.cache;
    }
    ensureLoaded() {
        if (!this.loaded) {
            this.updateCache(this.loadSync());
        }
    }
    dispose() {
        this.disposed = true;
        this.disposables.dispose();
    }
}
exports.ConfigWatcher = ConfigWatcher;
//# sourceMappingURL=config-workaround.js.map