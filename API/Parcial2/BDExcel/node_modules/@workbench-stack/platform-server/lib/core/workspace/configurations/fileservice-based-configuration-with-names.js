"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileServiceBasedConfigurationWithNames = void 0;
const event_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/event");
const resources = require("@vscode-alt/monaco-editor/esm/vs/base/common/resources");
const lifecycle_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/lifecycle");
const path_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/path");
const objects_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/objects");
const core_1 = require("@workbench-stack/core");
const core_2 = require("@files-stack/core");
const errors_1 = require("../../errors");
const async_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/async");
const parsers_1 = require("../../configuration/parsers");
const parser_1 = require("./parser");
class FileServiceBasedConfigurationWithNames extends lifecycle_1.Disposable {
    constructor(configurationFolder, configurationNames, scopes, fileService) {
        super();
        this.configurationFolder = configurationFolder;
        this.configurationNames = configurationNames;
        this.scopes = scopes;
        this.fileService = fileService;
        this._onDidChange = this._register(new event_1.Emitter());
        this.onDidChange = this._onDidChange.event;
        this.configurationResources = this.configurationNames.map(name => resources.joinPath(this.configurationFolder, `${name}.json`));
        this._folderSettingsModelParser = new parsers_1.ConfigurationModelParser(this.configurationFolder.toString(), this.scopes);
        this._standAloneConfigurations = [];
        this._cache = new core_1.ConfigurationModel();
        this.changeEventTriggerScheduler = this._register(new async_1.RunOnceScheduler(() => this._onDidChange.fire(), 50));
        this._register(this.fileService.onFileChanges((e) => this.handleFileEvents(e)));
    }
    loadConfiguration() {
        return __awaiter(this, void 0, void 0, function* () {
            const configurationContents = yield Promise.all(this.configurationResources.map((resource) => __awaiter(this, void 0, void 0, function* () {
                try {
                    const content = yield this.fileService.readFile(resource);
                    return content.value.toString();
                }
                catch (error) {
                    if (error.fileOperationResult !== "FILE_NOT_FOUND" /* FILE_NOT_FOUND */) {
                        errors_1.errors.onUnexpectedError(error);
                    }
                }
                return undefined;
            })));
            // reset
            this._standAloneConfigurations = [];
            this._folderSettingsModelParser.parseContent('');
            // parse
            if (configurationContents[0]) {
                this._folderSettingsModelParser.parseContent(configurationContents[0]);
            }
            for (let index = 1; index < configurationContents.length; index++) {
                const contents = configurationContents[index];
                if (contents) {
                    const standAloneConfigurationModelParser = new parser_1.StandaloneConfigurationModelParser(this.configurationResources[index].toString(), this.configurationNames[index]);
                    standAloneConfigurationModelParser.parseContent(contents);
                    this._standAloneConfigurations.push(standAloneConfigurationModelParser.configurationModel);
                }
            }
            // Consolidate (support *.json files in the workspace settings folder)
            this.consolidate();
            return this._cache;
        });
    }
    reprocess() {
        const oldContents = this._folderSettingsModelParser.configurationModel.contents;
        this._folderSettingsModelParser.parse();
        if (!objects_1.equals(oldContents, this._folderSettingsModelParser.configurationModel.contents)) {
            this.consolidate();
        }
        return this._cache;
    }
    consolidate() {
        this._cache = this._folderSettingsModelParser.configurationModel.merge(...this._standAloneConfigurations);
    }
    handleFileEvents(event) {
        return __awaiter(this, void 0, void 0, function* () {
            const events = event.changes;
            let affectedByChanges = false;
            // Find changes that affect workspace configuration files
            for (let i = 0, len = events.length; i < len; i++) {
                const resource = events[i].resource;
                const basename = resources.basename(resource);
                const isJson = path_1.extname(basename) === '.json';
                const isConfigurationFolderDeleted = (events[i].type === core_2.FileChangeType.DELETED && resources.isEqual(resource, this.configurationFolder));
                if (!isJson && !isConfigurationFolderDeleted) {
                    continue; // only JSON files or the actual settings folder
                }
                const folderRelativePath = this.toFolderRelativePath(resource);
                if (!folderRelativePath) {
                    continue; // event is not inside folder
                }
                // Handle case where ".vscode" got deleted
                if (isConfigurationFolderDeleted) {
                    affectedByChanges = true;
                    break;
                }
                // only valid workspace config files
                if (this.configurationResources.some(configurationResource => resources.isEqual(configurationResource, resource))) {
                    affectedByChanges = true;
                    break;
                }
            }
            if (affectedByChanges) {
                this.changeEventTriggerScheduler.schedule();
            }
        });
    }
    toFolderRelativePath(resource) {
        if (resources.isEqualOrParent(resource, this.configurationFolder)) {
            return resources.relativePath(this.configurationFolder, resource);
        }
        return undefined;
    }
}
exports.FileServiceBasedConfigurationWithNames = FileServiceBasedConfigurationWithNames;
//# sourceMappingURL=fileservice-based-configuration-with-names.js.map