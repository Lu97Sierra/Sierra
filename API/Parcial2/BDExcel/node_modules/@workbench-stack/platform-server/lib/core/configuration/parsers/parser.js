"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigurationModelParser = void 0;
/* tslint:disable */
const core_1 = require("@workbench-stack/core");
const helpers_1 = require("../helpers");
const json = require("@vscode-alt/monaco-editor/esm/vs/base/common/json");
const registry_1 = require("../../registry");
class ConfigurationModelParser {
    constructor(_name, _scopes) {
        this._name = _name;
        this._scopes = _scopes;
        this._raw = null;
        this._configurationModel = null;
        this._parseErrors = [];
    }
    get configurationModel() {
        return this._configurationModel || new core_1.ConfigurationModel();
    }
    get errors() {
        return this._parseErrors;
    }
    parseContent(content) {
        if (content) {
            const raw = this.doParseContent(content);
            this.parseRaw(raw);
        }
    }
    parseRaw(raw) {
        this._raw = raw;
        const configurationModel = this.doParseRaw(raw);
        this._configurationModel = new core_1.ConfigurationModel(configurationModel.contents, configurationModel.keys, configurationModel.overrides);
    }
    parse() {
        if (this._raw) {
            this.parseRaw(this._raw);
        }
    }
    doParseContent(content) {
        let raw = {};
        let currentProperty = null;
        let currentParent = [];
        let previousParents = [];
        let parseErrors = [];
        function onValue(value) {
            if (Array.isArray(currentParent)) {
                currentParent.push(value);
            }
            else if (currentProperty) {
                currentParent[currentProperty] = value;
            }
        }
        let visitor = {
            onObjectBegin: () => {
                let object = {};
                onValue(object);
                previousParents.push(currentParent);
                currentParent = object;
                currentProperty = null;
            },
            onObjectProperty: (name) => {
                currentProperty = name;
            },
            onObjectEnd: () => {
                currentParent = previousParents.pop();
            },
            onArrayBegin: () => {
                let array = [];
                onValue(array);
                previousParents.push(currentParent);
                currentParent = array;
                currentProperty = null;
            },
            onArrayEnd: () => {
                currentParent = previousParents.pop();
            },
            onLiteralValue: onValue,
            onError: (error, offset, length) => {
                parseErrors.push({ error, offset, length });
            }
        };
        if (content) {
            try {
                json.visit(content, visitor);
                raw = currentParent[0] || {};
            }
            catch (e) {
                console.error(`Error while parsing settings file ${this._name}: ${e}`);
                this._parseErrors = [e];
            }
        }
        return raw;
    }
    doParseRaw(raw) {
        if (this._scopes) {
            const configurationProperties = registry_1.Registry.Instance.as(core_1.Extensions.Configuration).getConfigurationProperties();
            raw = this.filterByScope(raw, configurationProperties, true, this._scopes);
        }
        const contents = core_1.toValuesTree(raw, message => console.error(`Conflict in settings file ${this._name}: ${message}`));
        const keys = Object.keys(raw);
        const overrides = helpers_1.toOverrides(raw, message => console.error(`Conflict in settings file ${this._name}: ${message}`));
        return { contents, keys, overrides };
    }
    filterByScope(properties, configurationProperties, filterOverriddenProperties, scopes) {
        const result = {};
        for (let key in properties) {
            if (core_1.OVERRIDE_PROPERTY_PATTERN.test(key) && filterOverriddenProperties) {
                result[key] = this.filterByScope(properties[key], configurationProperties, false, scopes);
            }
            else {
                const scope = this.getScope(key, configurationProperties);
                if (scopes.indexOf(scope) !== -1) {
                    result[key] = properties[key];
                }
            }
        }
        return result;
    }
    getScope(key, configurationProperties) {
        const propertySchema = configurationProperties[key];
        return propertySchema && typeof propertySchema.scope !== 'undefined' ? propertySchema.scope : 3 /* WINDOW */;
    }
}
exports.ConfigurationModelParser = ConfigurationModelParser;
//# sourceMappingURL=parser.js.map