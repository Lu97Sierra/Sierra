"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyValueLogProvider = void 0;
const core_1 = require("@workbench-stack/core");
const core_2 = require("@files-stack/core");
const event_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/event");
const uri_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/uri");
const resources_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/resources");
const nls_1 = require("@vscode-alt/monaco-editor/esm/vs/nls");
const buffer_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/buffer");
class KeyValueLogProvider extends core_1.Disposable {
    constructor(scheme) {
        super();
        this.scheme = scheme;
        this.capabilities = 2 /* FileReadWrite */;
        this.onDidChangeCapabilities = event_1.Event.None;
        this._onDidChangeFile = this._register(new event_1.Emitter());
        this.onDidChangeFile = this._onDidChangeFile.event;
        this.versions = new Map();
    }
    watch(resource, opts) {
        return core_1.Disposable.None;
    }
    mkdir(resource) {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    stat(resource) {
        return __awaiter(this, void 0, void 0, function* () {
            const content = yield this.readFile(resource);
            return {
                type: core_2.FileType.File,
                ctime: 0,
                mtime: this.versions.get(resource.toString()) || 0,
                size: content.byteLength,
            };
            // const files = await this.readdir(resource);
            // if (files.length) {
            //     return {
            //         type: FileType.Directory,
            //         ctime: 0,
            //         mtime: 0,
            //         size: 0,
            //     };
            // }
            // throw createFileSystemProviderError(new Error(localize('collectionNotExists', 'Collection Document field does not exist')), FileSystemProviderErrorCode.FileNotADirectory);
        });
    }
    readdir(resource) {
        return __awaiter(this, void 0, void 0, function* () {
            console.log('=====>> readdir');
            const key = this.generateKey(resource);
            const hasKey = yield this.hasKey(key);
            if (hasKey && typeof hasKey === 'string') {
                throw core_2.createFileSystemProviderError(new Error(nls_1.localize('fileNotDirectory', 'File is not a directory')), core_2.FileSystemProviderErrorCode.FileNotADirectory);
            }
            const keys = yield this.getAllKeys(key);
            const files = new Map();
            const resourcePaths = resource.path.split('/');
            for (const k of keys) {
                const keyResource = this.toResource(`${resourcePaths[1]}/${resourcePaths[2]}/${k}`, resource.authority);
                if (resources_1.isEqualOrParent(keyResource, resource, false)) {
                    const path = resources_1.relativePath(resource, keyResource);
                    if (path) {
                        const keySegments = path.split('/');
                        files.set(keySegments[0], [keySegments[0], keySegments.length === 1 ? core_2.FileType.File : core_2.FileType.Directory]);
                    }
                }
            }
            console.log('=====>> readdir done');
            return [...files.values()];
        });
    }
    readFile(resource) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = this.generateKey(resource);
            const hasKey = yield this.hasKey(key);
            if (!hasKey) {
                throw core_2.createFileSystemProviderError(new Error(nls_1.localize('collectionNotFound', 'Collection not found')), core_2.FileSystemProviderErrorCode.FileNotADirectory);
            }
            const value = yield this.getValue(key);
            if (!value) {
                throw core_2.createFileSystemProviderError(new Error(nls_1.localize('fileFragmentNotFound', "Expected fragment {0} is not found")), core_2.FileSystemProviderErrorCode.FileNotFound);
            }
            return buffer_1.VSBuffer.fromString(value).buffer;
        });
    }
    writeFile(resource, content, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = this.generateKey(resource);
            const hasKey = yield this.hasKey(key);
            if (!hasKey) {
                const files = yield this.readdir(resource);
                if (files.length) {
                    throw core_2.createFileSystemProviderError(new Error(nls_1.localize('fileIsDirectory', 'File is Directory')), core_2.FileSystemProviderErrorCode.FileIsADirectory);
                }
            }
            yield this.setValue(key, buffer_1.VSBuffer.wrap(content).toString());
            this.versions.set(resource.toString(), (this.versions.get(resource.toString()) || 0) + 1);
            this._onDidChangeFile.fire([{ resource, type: core_2.FileChangeType.UPDATED }]);
        });
    }
    delete(resource, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = this.generateKey(resource);
            const hasKey = yield this.hasKey(key);
            if (hasKey) {
                yield this.deleteKey(key);
                this.versions.delete(resource.path);
                this._onDidChangeFile.fire([{ resource, type: core_2.FileChangeType.DELETED }]);
                return;
            }
            if (opts.recursive) {
                const files = yield this.readdir(resource);
                yield Promise.all(files.map(([key]) => this.delete(resources_1.joinPath(resource, key), opts)));
            }
        });
    }
    rename(from, to, opts) {
        return Promise.reject(new Error('Not Supported'));
    }
    toResource(key, authority) {
        return uri_1.URI.file(key).with({ scheme: this.scheme, authority });
    }
    generateKey(resource) {
        const [, collection] = resource.path.split('/');
        const key = {
            collection,
            query: resource.query,
            fragment: resource.fragment,
        };
        return key;
    }
}
exports.KeyValueLogProvider = KeyValueLogProvider;
//# sourceMappingURL=key-value-log-provider.js.map