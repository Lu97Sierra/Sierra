"use strict";
/* tslint:disable */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkspaceService = exports.isSingleFolderWorkspaceInitializationPayload = void 0;
const resources_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/resources");
const event_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/event");
const map_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/map");
const objects_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/objects");
// import { Disposable } from '@vscode-alt/monaco-editor/esm/vs/base/common/lifecycle';
const async_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/async");
const core_1 = require("@workbench-stack/core");
const core_2 = require("@workbench-stack/core");
const core_3 = require("@workbench-stack/core");
const platform_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/platform");
const models_1 = require("../../core/configuration/models");
const core_4 = require("@workbench-stack/core");
const configurations_1 = require("../../core/workspace/configurations");
const core_5 = require("@workbench-stack/core");
const registry_1 = require("../../core/registry");
const interfaces_1 = require("../../interfaces");
const configuration_1 = require("../configuration");
const configurations_2 = require("../../core/workspace/configurations");
const core_6 = require("@workbench-stack/core");
const core_7 = require("@workbench-stack/core");
const resources_2 = require("@vscode-alt/monaco-editor/esm/vs/base/common/resources");
const nls_1 = require("@vscode-alt/monaco-editor/esm/vs/nls");
const configuration_2 = require("../../core/configuration");
const inversify_1 = require("inversify");
const ILogger = require("bunyan");
const performance_1 = require("../../core/performance/performance");
function isSingleFolderWorkspaceInitializationPayload(obj) {
    return core_6.isSingleFolderWorkspaceIdentifier(obj.folder);
}
exports.isSingleFolderWorkspaceInitializationPayload = isSingleFolderWorkspaceInitializationPayload;
let WorkspaceService = class WorkspaceService extends core_1.Disposable {
    constructor({ userSettingsResource, remoteAuthority, configurationCache }, configurationFileService, remoteAgentService, logger) {
        super();
        this.configurationFileService = configurationFileService;
        this.localUserConfiguration = null;
        this.remoteUserConfiguration = null;
        this._onDidChangeConfiguration = this._register(new event_1.Emitter());
        this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;
        this._onDidChangeWorkspaceFolders = this._register(new event_1.Emitter());
        this.onDidChangeWorkspaceFolders = this._onDidChangeWorkspaceFolders.event;
        this._onDidChangeWorkspaceName = this._register(new event_1.Emitter());
        this.onDidChangeWorkspaceName = this._onDidChangeWorkspaceName.event;
        this._onDidChangeWorkbenchState = this._register(new event_1.Emitter());
        this.onDidChangeWorkbenchState = this._onDidChangeWorkbenchState.event;
        this.cyclicDependency = new Promise(resolve => this.cyclicDependencyReady = resolve);
        this.logger = logger.child({ className: 'WorkspaceService' });
        this.completeWorkspaceBarrier = new async_1.Barrier();
        this.defaultConfiguration = new models_1.DefaultConfigurationModel();
        this.configurationCache = configurationCache;
        if (userSettingsResource) {
            this.localUserConfiguration = this._register(new configuration_2.UserConfiguration(userSettingsResource, remoteAuthority ? core_2.LOCAL_MACHINE_SCOPES : undefined, configurationFileService));
            this._register(this.localUserConfiguration.onDidChangeConfiguration(userConfiguration => this.onLocalUserConfigurationChanged(userConfiguration)));
        }
        if (remoteAuthority) {
            this.remoteUserConfiguration = this._register(new configuration_2.RemoteUserConfiguration(remoteAuthority, configurationCache, configurationFileService, remoteAgentService));
            this._register(this.remoteUserConfiguration.onDidChangeConfiguration(userConfiguration => this.onRemoteUserConfigurationChanged(userConfiguration)));
        }
        this.workspaceConfiguration = this._register(new configurations_2.WorkspaceConfiguration(configurationCache, this.configurationFileService));
        this._register(this.workspaceConfiguration.onDidUpdateConfiguration(() => {
            this.onWorkspaceConfigurationChanged();
            if (this.workspaceConfiguration.loaded) {
                this.releaseWorkspaceBarrier();
            }
        }));
        this._register(registry_1.Registry.Instance.as(core_1.Extensions.Configuration).onDidSchemaChange(e => this.registerConfigurationSchemas()));
        this._register(registry_1.Registry.Instance.as(core_1.Extensions.Configuration).onDidUpdateConfiguration(configurationProperties => this.onDefaultConfigurationChanged(configurationProperties)));
        this.workspaceEditingQueue = new async_1.Queue();
    }
    // Workspace Context Service Impl
    getCompleteWorkspace() {
        return this.completeWorkspaceBarrier.wait().then(() => this.getWorkspace());
    }
    getWorkspace() {
        return this.workspace;
    }
    getWorkbenchState() {
        // Workspace has configuration file
        if (this.workspace.configuration) {
            return 3 /* WORKSPACE */;
        }
        // Folder has single root
        if (this.workspace.folders.length === 1) {
            return 2 /* FOLDER */;
        }
        // Empty
        return 1 /* EMPTY */;
    }
    getWorkspaceFolder(resource) {
        return this.workspace.getFolder(resource);
    }
    addFolders(foldersToAdd, index) {
        return this.updateFolders(foldersToAdd, [], index);
    }
    removeFolders(foldersToRemove) {
        return this.updateFolders([], foldersToRemove);
    }
    updateFolders(foldersToAdd, foldersToRemove, index) {
        return this.cyclicDependency.then(() => {
            return this.workspaceEditingQueue.queue(() => this.doUpdateFolders(foldersToAdd, foldersToRemove, index));
        });
    }
    isInsideWorkspace(resource) {
        return !!this.getWorkspaceFolder(resource);
    }
    isCurrentWorkspace(workspaceIdentifier) {
        switch (this.getWorkbenchState()) {
            case 2 /* FOLDER */:
                return core_6.isSingleFolderWorkspaceIdentifier(workspaceIdentifier) && resources_2.isEqual(workspaceIdentifier, this.workspace.folders[0].uri);
            case 3 /* WORKSPACE */:
                return core_7.isWorkspaceIdentifier(workspaceIdentifier) && this.workspace.id === workspaceIdentifier.id;
        }
        return false;
    }
    doUpdateFolders(foldersToAdd, foldersToRemove, index) {
        this.logger.trace('  (doUpdateFolders) foldersToAdd: [%j], foldersToRemove: [%j]', foldersToAdd, foldersToRemove);
        if (this.getWorkbenchState() !== 3 /* WORKSPACE */) {
            return Promise.resolve(undefined); // we need a workspace to begin with
        }
        if (foldersToAdd.length + foldersToRemove.length === 0) {
            return Promise.resolve(undefined); // nothing to do
        }
        let foldersHaveChanged = false;
        // Remove first (if any)
        let currentWorkspaceFolders = this.getWorkspace().folders;
        let newStoredFolders = currentWorkspaceFolders.map(f => f.raw).filter((folder, index) => {
            if (!core_6.isStoredWorkspaceFolder(folder)) {
                return true; // keep entries which are unrelated
            }
            return !this.contains(foldersToRemove, currentWorkspaceFolders[index].uri); // keep entries which are unrelated
        });
        const slashForPath = core_2.useSlashForPath(newStoredFolders);
        foldersHaveChanged = currentWorkspaceFolders.length !== newStoredFolders.length;
        // Add afterwards (if any)
        if (foldersToAdd.length) {
            // Recompute current workspace folders if we have folders to add
            const workspaceConfigPath = this.getWorkspace().configuration;
            const workspaceConfigFolder = resources_1.dirname(workspaceConfigPath);
            currentWorkspaceFolders = core_6.toWorkspaceFolders(newStoredFolders, workspaceConfigPath);
            const currentWorkspaceFolderUris = currentWorkspaceFolders.map(folder => folder.uri);
            const storedFoldersToAdd = [];
            foldersToAdd.forEach(folderToAdd => {
                const folderURI = folderToAdd.uri;
                if (this.contains(currentWorkspaceFolderUris, folderURI)) {
                    return; // already existing
                }
                storedFoldersToAdd.push(core_2.getStoredWorkspaceFolder(folderURI, folderToAdd.name, workspaceConfigFolder, slashForPath));
            });
            // Apply to array of newStoredFolders
            if (storedFoldersToAdd.length > 0) {
                foldersHaveChanged = true;
                if (typeof index === 'number' && index >= 0 && index < newStoredFolders.length) {
                    newStoredFolders = newStoredFolders.slice(0);
                    newStoredFolders.splice(index, 0, ...storedFoldersToAdd);
                }
                else {
                    newStoredFolders = [...newStoredFolders, ...storedFoldersToAdd];
                }
            }
        }
        // Set folders if we recorded a change
        if (foldersHaveChanged) {
            return this.setFolders(newStoredFolders);
        }
        return Promise.resolve(undefined);
    }
    setFolders(folders) {
        return this.cyclicDependency.then(() => {
            return this.workspaceConfiguration.setFolders(folders, this.jsonEditingService)
                .then(() => this.onWorkspaceConfigurationChanged());
        });
    }
    contains(resources, toCheck) {
        return resources.some(resource => {
            if (platform_1.isLinux) {
                return resource.toString() === toCheck.toString();
            }
            return resource.toString().toLowerCase() === toCheck.toString().toLowerCase();
        });
    }
    // Workspace Configuration Service Impl
    getConfigurationData() {
        return this._configuration.toData();
    }
    getValue(arg1, arg2) {
        const section = typeof arg1 === 'string' ? arg1 : undefined;
        const overrides = core_2.isConfigurationOverrides(arg1) ? arg1 : core_2.isConfigurationOverrides(arg2) ? arg2 : undefined;
        return this._configuration.getValue(section, overrides);
    }
    updateValue(key, value, arg3, arg4, donotNotifyError) {
        return this.cyclicDependency.then(() => {
            console.log('--key', key, 'value', value, 'target', arg4);
            const overrides = core_2.isConfigurationOverrides(arg3) ? arg3 : undefined;
            const target = this.deriveConfigurationTarget(key, value, overrides, overrides ? arg4 : arg3);
            console.log('---target---', target);
            return target ? this.writeConfigurationValue(key, value, target, overrides, donotNotifyError)
                : Promise.resolve();
        });
    }
    reloadConfiguration(folder, key) {
        this.logger.debug(' (  reloadConfiguration) with arg [%s, %s]', folder, key);
        if (folder) {
            return this.reloadWorkspaceFolderConfiguration(folder, key);
        }
        return this.reloadUserConfiguration()
            .then(({ local, remote }) => this.reloadWorkspaceConfiguration()
            .then(() => this.loadConfiguration(local, remote)));
    }
    inspect(key, overrides) {
        return this._configuration.inspect(key, overrides);
    }
    keys() {
        return this._configuration.keys();
    }
    initialize(arg) {
        performance_1.mark('willInitWorkspaceService');
        this.logger.debug(' (initialize) with arg [%j]', arg);
        return this.createWorkspace(arg)
            .then(workspace => {
            return this.updateWorkspaceAndInitializeConfiguration(workspace).then(() => {
                performance_1.mark('didInitWorkspaceService');
                return this.workspace;
            });
        });
    }
    acquireInstantiationService(container) {
        this.logger.debug(' (acquireInstantiationService) with container');
        try {
            container.bind(core_2.TYPES.IConfigurationEditingService).to(configuration_1.ConfigurationEditingService);
            // container.bind<JSONEditingService>(TYPES.IJSONEditingService).to(JSONEditingService);
        }
        catch (err) {
            console.log('Avoid failure due to ambigous match on ConfigurationEditingService');
        }
        this.configurationEditingService = container.get(core_2.TYPES.IConfigurationEditingService);
        this.jsonEditingService = container.get(core_2.TYPES.IJSONEditingService);
        if (this.cyclicDependencyReady) {
            this.cyclicDependencyReady();
        }
        else {
            this.cyclicDependency = Promise.resolve(undefined);
        }
    }
    createWorkspace(arg) {
        this.logger.debug('     (createWorkspace) with arg');
        this.logger.trace('         arg -- [%j]', arg);
        if (core_7.isWorkspaceIdentifier(arg)) {
            return this.createMultiFolderWorkspace(arg);
        }
        if (isSingleFolderWorkspaceInitializationPayload(arg)) {
            return this.createSingleFolderWorkspace(arg);
        }
        return this.createEmptyWorkspace(arg);
    }
    createMultiFolderWorkspace(workspaceIdentifier) {
        return this.workspaceConfiguration.load({ id: workspaceIdentifier.id, configPath: workspaceIdentifier.configPath })
            .then(() => {
            const workspaceConfigPath = workspaceIdentifier.configPath;
            const workspaceFolders = core_6.toWorkspaceFolders(this.workspaceConfiguration.getFolders(), workspaceConfigPath);
            const workspaceId = workspaceIdentifier.id;
            const workspace = new core_3.Workspace(workspaceId, workspaceFolders, workspaceConfigPath);
            if (this.workspaceConfiguration.loaded) {
                this.releaseWorkspaceBarrier();
            }
            return workspace;
        });
    }
    createSingleFolderWorkspace(singleFolder) {
        this.logger.debug('     (createSingleFolderWorkspace) with singleFolder');
        const workspace = new core_3.Workspace(singleFolder.id, [core_2.toWorkspaceFolder(singleFolder.folder)]);
        this.releaseWorkspaceBarrier(); // Release barrier as workspace is complete because it is single folder.
        return Promise.resolve(workspace);
    }
    createEmptyWorkspace(emptyWorkspace) {
        this.logger.debug('     (createEmptyWorkspace) with emptyWorkspace');
        this.logger.trace('             emptyWorkspace ---[%j]', emptyWorkspace);
        const workspace = new core_3.Workspace(emptyWorkspace.id);
        this.releaseWorkspaceBarrier(); // Release barrier as workspace is complete because it is an empty workspace.
        return Promise.resolve(workspace);
    }
    releaseWorkspaceBarrier() {
        if (!this.completeWorkspaceBarrier.isOpen()) {
            this.completeWorkspaceBarrier.open();
        }
    }
    updateWorkspaceAndInitializeConfiguration(workspace) {
        this.logger.debug('         (updateWorkspaceAndInitializeConfiguration) with workspace');
        this.logger.trace('                 workspace: [%j]', workspace);
        const hasWorkspaceBefore = !!this.workspace;
        let previousState;
        let previousWorkspacePath;
        let previousFolders;
        if (hasWorkspaceBefore) {
            previousState = this.getWorkbenchState();
            previousWorkspacePath = this.workspace.configuration ? this.workspace.configuration.fsPath : undefined;
            previousFolders = this.workspace.folders;
            this.workspace.update(workspace);
        }
        else {
            this.workspace = workspace;
        }
        this.logger.trace('                 set this workspace to: [%j]', this.workspace);
        return this.initializeConfiguration().then(() => {
            this.logger.trace('                         initializeConfiguration, was there changes to trigger (%s)', hasWorkspaceBefore);
            // Trigger changes after configuration initialization so that configuration is up to date.
            if (hasWorkspaceBefore) {
                const newState = this.getWorkbenchState();
                if (previousState && newState !== previousState) {
                    this._onDidChangeWorkbenchState.fire(newState);
                }
                const newWorkspacePath = this.workspace.configuration ? this.workspace.configuration.fsPath : undefined;
                if (previousWorkspacePath && newWorkspacePath !== previousWorkspacePath || newState !== previousState) {
                    this._onDidChangeWorkspaceName.fire();
                }
                const folderChanges = this.compareFolders(previousFolders, this.workspace.folders);
                if (folderChanges && (folderChanges.added.length || folderChanges.removed.length || folderChanges.changed.length)) {
                    this._onDidChangeWorkspaceFolders.fire(folderChanges);
                }
            }
        });
    }
    compareFolders(currentFolders, newFolders) {
        this.logger.debug('         (compareFolders)');
        const result = { added: [], removed: [], changed: [] };
        result.added = newFolders.filter(newFolder => !currentFolders.some(currentFolder => newFolder.uri.toString() === currentFolder.uri.toString()));
        for (let currentIndex = 0; currentIndex < currentFolders.length; currentIndex++) {
            let currentFolder = currentFolders[currentIndex];
            let newIndex = 0;
            for (newIndex = 0; newIndex < newFolders.length && currentFolder.uri.toString() !== newFolders[newIndex].uri.toString(); newIndex++) { }
            if (newIndex < newFolders.length) {
                if (currentIndex !== newIndex || currentFolder.name !== newFolders[newIndex].name) {
                    result.changed.push(currentFolder);
                }
            }
            else {
                result.removed.push(currentFolder);
            }
        }
        return result;
    }
    initializeConfiguration() {
        this.logger.debug('         (initializeConfiguration)');
        this.registerConfigurationSchemas();
        return this.initializeUserConfiguration()
            .then(({ local, remote }) => this.loadConfiguration(local, remote));
    }
    initializeUserConfiguration() {
        return Promise.all([this.localUserConfiguration ? this.localUserConfiguration.initialize() : Promise.resolve(new core_4.ConfigurationModel()), this.remoteUserConfiguration ? this.remoteUserConfiguration.initialize() : Promise.resolve(new core_4.ConfigurationModel())])
            .then(([local, remote]) => ({ local, remote }));
    }
    reloadUserConfiguration(key) {
        this.logger.debug('         (reloadUserConfiguration)');
        return Promise.all([this.reloadLocalUserConfiguration(), this.reloadRemoteUserConfiguration()]).then(([local, remote]) => ({ local, remote }));
    }
    reloadLocalUserConfiguration(key) {
        return this.localUserConfiguration ? this.localUserConfiguration.reload() : Promise.resolve(new core_4.ConfigurationModel());
    }
    reloadRemoteUserConfiguration(key) {
        return this.remoteUserConfiguration ? this.remoteUserConfiguration.reload() : Promise.resolve(new core_4.ConfigurationModel());
    }
    reloadWorkspaceConfiguration(key) {
        this.logger.debug('         (reloadWorkspaceConfiguration)');
        const workbenchState = this.getWorkbenchState();
        if (workbenchState === 2 /* FOLDER */) {
            return this.onWorkspaceFolderConfigurationChanged(this.workspace.folders[0], key);
        }
        if (workbenchState === 3 /* WORKSPACE */) {
            return this.workspaceConfiguration.reload().then(() => this.onWorkspaceConfigurationChanged());
        }
        return Promise.resolve(undefined);
    }
    reloadWorkspaceFolderConfiguration(folder, key) {
        this.logger.debug('         (reloadWorkspaceFolderConfiguration)');
        return this.onWorkspaceFolderConfigurationChanged(folder, key);
    }
    loadConfiguration(userConfigurationModel, remoteUserConfigurationModel) {
        this.logger.debug('         (loadConfiguration)');
        // reset caches
        this.cachedFolderConfigs = new map_1.ResourceMap();
        const folders = this.workspace.folders;
        return this.loadFolderConfigurations(folders)
            .then((folderConfigurations) => {
            let workspaceConfiguration = this.getWorkspaceConfigurationModel(folderConfigurations);
            const folderConfigurationModels = new map_1.ResourceMap();
            folderConfigurations.forEach((folderConfiguration, index) => folderConfigurationModels.set(folders[index].uri, folderConfiguration));
            const currentConfiguration = this._configuration;
            this._configuration = new configurations_1.Configuration(this.defaultConfiguration, userConfigurationModel, remoteUserConfigurationModel, workspaceConfiguration, folderConfigurationModels, new core_4.ConfigurationModel(), new map_1.ResourceMap(), this.workspace);
            if (currentConfiguration) {
                const changedKeys = this._configuration.compare(currentConfiguration);
                this.triggerConfigurationChange(new core_4.ConfigurationChangeEvent().change(changedKeys), 4 /* WORKSPACE */);
            }
            else {
                this._onDidChangeConfiguration.fire(new configurations_1.AllKeysConfigurationChangeEvent(this._configuration, 4 /* WORKSPACE */, this.getTargetConfiguration(4 /* WORKSPACE */)));
            }
        });
    }
    getWorkspaceConfigurationModel(folderConfigurations) {
        this.logger.debug('         (getWorkspaceConfigurationModel, workbenchState: %s)', this.getWorkbenchState());
        switch (this.getWorkbenchState()) {
            case 2 /* FOLDER */:
                return folderConfigurations[0];
            case 3 /* WORKSPACE */:
                return this.workspaceConfiguration.getConfiguration();
            default:
                return new core_4.ConfigurationModel();
        }
    }
    onDefaultConfigurationChanged(keys) {
        this.logger.debug('         (onDefaultConfigurationChanged) with keys');
        this.logger.trace('             keys --[%j]', keys);
        this.defaultConfiguration = new models_1.DefaultConfigurationModel();
        this.registerConfigurationSchemas();
        if (this.workspace && this._configuration) {
            this._configuration.updateDefaultConfiguration(this.defaultConfiguration);
            if (this.remoteUserConfiguration) {
                this._configuration.updateRemoteUserConfiguration(this.remoteUserConfiguration.reprocess());
            }
            if (this.getWorkbenchState() === 2 /* FOLDER */) {
                this._configuration.updateWorkspaceConfiguration(this.cachedFolderConfigs.get(this.workspace.folders[0].uri).reprocess());
            }
            else {
                this._configuration.updateWorkspaceConfiguration(this.workspaceConfiguration.reprocessWorkspaceSettings());
                this.workspace.folders.forEach(folder => this._configuration.updateFolderConfiguration(folder.uri, this.cachedFolderConfigs.get(folder.uri).reprocess()));
            }
            this.triggerConfigurationChange(new core_4.ConfigurationChangeEvent().change(keys), 6 /* DEFAULT */);
        }
    }
    registerConfigurationSchemas() {
        if (this.workspace) {
            const jsonRegistry = registry_1.Registry.Instance.as(core_1.Extensions.JSONContribution);
            const convertToNotSuggestedProperties = (properties, errorMessage) => {
                return Object.keys(properties).reduce((result, property) => {
                    result[property] = objects_1.deepClone(properties[property]);
                    result[property].deprecationMessage = errorMessage;
                    return result;
                }, {});
            };
            const unsupportedApplicationSettings = convertToNotSuggestedProperties(interfaces_1.applicationSettings.properties, nls_1.localize('unsupportedApplicationSetting', "This setting can be applied only in application user settings"));
            const unsupportedMachineSettings = convertToNotSuggestedProperties(interfaces_1.machineSettings.properties, nls_1.localize('unsupportedMachineSetting', "This setting can be applied only in user settings"));
            const unsupportedRemoteMachineSettings = convertToNotSuggestedProperties(interfaces_1.machineSettings.properties, nls_1.localize('unsupportedRemoteMachineSetting', "This setting can be applied only in remote machine settings"));
            const allSettingsSchema = { properties: interfaces_1.allSettings.properties, patternProperties: interfaces_1.allSettings.patternProperties, additionalProperties: false, errorMessage: 'Unknown configuration setting' };
            const userSettingsSchema = this.remoteUserConfiguration ? { properties: Object.assign(Object.assign(Object.assign(Object.assign({}, interfaces_1.applicationSettings.properties), unsupportedRemoteMachineSettings), interfaces_1.windowSettings.properties), interfaces_1.resourceSettings.properties), patternProperties: interfaces_1.allSettings.patternProperties, additionalProperties: false, errorMessage: 'Unknown configuration setting' } : allSettingsSchema;
            const machineSettingsSchema = { properties: Object.assign(Object.assign(Object.assign({}, unsupportedApplicationSettings), interfaces_1.windowSettings.properties), interfaces_1.resourceSettings.properties), patternProperties: interfaces_1.allSettings.patternProperties, additionalProperties: false, errorMessage: 'Unknown configuration setting' };
            const workspaceSettingsSchema = { properties: Object.assign(Object.assign(Object.assign(Object.assign({}, unsupportedApplicationSettings), unsupportedMachineSettings), interfaces_1.windowSettings.properties), interfaces_1.resourceSettings.properties), patternProperties: interfaces_1.allSettings.patternProperties, additionalProperties: false, errorMessage: 'Unknown configuration setting' };
            jsonRegistry.registerSchema(core_5.defaultSettingsSchemaId, allSettingsSchema);
            jsonRegistry.registerSchema(core_5.userSettingsSchemaId, userSettingsSchema);
            jsonRegistry.registerSchema(core_5.machineSettingsSchemaId, machineSettingsSchema);
            if (3 /* WORKSPACE */ === this.getWorkbenchState()) {
                const unsupportedWindowSettings = convertToNotSuggestedProperties(interfaces_1.windowSettings.properties, nls_1.localize('unsupportedWindowSetting', "This setting cannot be applied now. It will be applied when you open this folder directly."));
                const folderSettingsSchema = { properties: Object.assign(Object.assign(Object.assign(Object.assign({}, unsupportedApplicationSettings), unsupportedMachineSettings), unsupportedWindowSettings), interfaces_1.resourceSettings.properties), patternProperties: interfaces_1.allSettings.patternProperties, additionalProperties: false, errorMessage: 'Unknown configuration setting' };
                jsonRegistry.registerSchema(core_5.workspaceSettingsSchemaId, workspaceSettingsSchema);
                jsonRegistry.registerSchema(core_5.folderSettingsSchemaId, folderSettingsSchema);
            }
            else {
                jsonRegistry.registerSchema(core_5.workspaceSettingsSchemaId, workspaceSettingsSchema);
                jsonRegistry.registerSchema(core_5.folderSettingsSchemaId, workspaceSettingsSchema);
            }
        }
    }
    onLocalUserConfigurationChanged(userConfiguration) {
        this.logger.debug('         (onUserConfigurationChanged)');
        const keys = this._configuration.compareAndUpdateLocalUserConfiguration(userConfiguration);
        this.triggerConfigurationChange(keys, 1 /* USER */);
    }
    onRemoteUserConfigurationChanged(userConfiguration) {
        if (this._configuration) {
            const keys = this._configuration.compareAndUpdateRemoteUserConfiguration(userConfiguration);
            this.triggerConfigurationChange(keys, 1 /* USER */);
        }
    }
    onWorkspaceConfigurationChanged() {
        this.logger.debug('         (onWorkspaceConfigurationChanged)');
        if (this.workspace && this.workspace.configuration && this._configuration) {
            const workspaceConfigurationChangeEvent = this._configuration.compareAndUpdateWorkspaceConfiguration(this.workspaceConfiguration.getConfiguration());
            let configuredFolders = core_6.toWorkspaceFolders(this.workspaceConfiguration.getFolders(), this.workspace.configuration);
            const changes = this.compareFolders(this.workspace.folders, configuredFolders);
            if (changes.added.length || changes.removed.length || changes.changed.length) {
                this.workspace.folders = configuredFolders;
                return this.onFoldersChanged()
                    .then(foldersConfigurationChangeEvent => {
                    this.triggerConfigurationChange(foldersConfigurationChangeEvent.change(workspaceConfigurationChangeEvent), 5 /* WORKSPACE_FOLDER */);
                    this.logger.debug('				foldersConfiguration changed');
                    this._onDidChangeWorkspaceFolders.fire(changes);
                });
            }
            else {
                this.triggerConfigurationChange(workspaceConfigurationChangeEvent, 4 /* WORKSPACE */);
            }
        }
        return Promise.resolve(undefined);
    }
    onWorkspaceFolderConfigurationChanged(folder, key) {
        this.logger.debug('         (onWorkspaceFolderConfigurationChanged)');
        return this.loadFolderConfigurations([folder])
            .then(([folderConfiguration]) => {
            const folderChangedKeys = this._configuration.compareAndUpdateFolderConfiguration(folder.uri, folderConfiguration);
            if (this.getWorkbenchState() === 2 /* FOLDER */) {
                const workspaceChangedKeys = this._configuration.compareAndUpdateWorkspaceConfiguration(folderConfiguration);
                this.triggerConfigurationChange(workspaceChangedKeys, 4 /* WORKSPACE */);
            }
            else {
                this.triggerConfigurationChange(folderChangedKeys, 5 /* WORKSPACE_FOLDER */);
            }
        });
    }
    onFoldersChanged() {
        this.logger.debug('         (onFoldersChanged)');
        let changeEvent = new core_4.ConfigurationChangeEvent();
        // Remove the configurations of deleted folders
        for (const key of this.cachedFolderConfigs.keys()) {
            if (!this.workspace.folders.filter(folder => folder.uri.toString() === key.toString())[0]) {
                const folderConfiguration = this.cachedFolderConfigs.get(key);
                folderConfiguration.dispose();
                this.cachedFolderConfigs.delete(key);
                changeEvent = changeEvent.change(this._configuration.compareAndDeleteFolderConfiguration(key));
            }
        }
        const toInitialize = this.workspace.folders.filter(folder => !this.cachedFolderConfigs.has(folder.uri));
        if (toInitialize.length) {
            return this.loadFolderConfigurations(toInitialize)
                .then(folderConfigurations => {
                folderConfigurations.forEach((folderConfiguration, index) => {
                    changeEvent = changeEvent.change(this._configuration.compareAndUpdateFolderConfiguration(toInitialize[index].uri, folderConfiguration));
                });
                return changeEvent;
            });
        }
        return Promise.resolve(changeEvent);
    }
    loadFolderConfigurations(folders) {
        this.logger.debug('         (loadFolderConfigurations)');
        return Promise.all([...folders.map(folder => {
                let folderConfiguration = this.cachedFolderConfigs.get(folder.uri);
                if (!folderConfiguration) {
                    folderConfiguration = new configurations_2.FolderConfiguration(folder, core_5.FOLDER_CONFIG_FOLDER_NAME, this.getWorkbenchState(), this.configurationFileService, this.configurationCache);
                    this._register(folderConfiguration.onDidChange(() => this.onWorkspaceFolderConfigurationChanged(folder)));
                    this.cachedFolderConfigs.set(folder.uri, this._register(folderConfiguration));
                }
                return folderConfiguration.loadConfiguration();
            })]);
    }
    writeConfigurationValue(key, value, target, overrides, donotNotifyError) {
        this.logger.debug('         (writeConfigurationValue)');
        if (target === 6 /* DEFAULT */) {
            return Promise.reject(new Error('Invalid configuration target'));
        }
        if (target === 7 /* MEMORY */) {
            this._configuration.updateValue(key, value, overrides);
            this.triggerConfigurationChange(new core_4.ConfigurationChangeEvent().change(overrides && overrides.overrideIdentifier ? [core_2.keyFromOverrideIdentifier(overrides.overrideIdentifier)] : [key], overrides && overrides.resource || undefined), target);
            return Promise.resolve(undefined);
        }
        const editableConfigurationTarget = this.toEditableConfigurationTarget(target, key);
        if (!editableConfigurationTarget) {
            return Promise.reject(new Error('Invalid configuration target'));
        }
        if (editableConfigurationTarget === 2 /* USER_REMOTE */ && !this.remoteUserConfiguration) {
            return Promise.reject(new Error('Invalid configuration target'));
        }
        return this.configurationEditingService.writeConfiguration(editableConfigurationTarget, { key, value }, { scopes: overrides, donotNotifyError })
            .then(() => {
            switch (editableConfigurationTarget) {
                case 1 /* USER_LOCAL */:
                    return this.reloadLocalUserConfiguration().then(local => this.onLocalUserConfigurationChanged(local));
                case 2 /* USER_REMOTE */:
                    return this.reloadRemoteUserConfiguration().then(remote => this.onRemoteUserConfigurationChanged(remote));
                case 3 /* WORKSPACE */:
                    return this.reloadWorkspaceConfiguration();
                case 4 /* WORKSPACE_FOLDER */:
                    const workspaceFolder = overrides && overrides.resource ? this.workspace.getFolder(overrides.resource) : null;
                    if (workspaceFolder) {
                        return this.reloadWorkspaceFolderConfiguration(workspaceFolder, key);
                    }
            }
            return Promise.resolve();
        });
    }
    deriveConfigurationTarget(key, value, overrides, target) {
        this.logger.debug('         (deriveConfigurationTarget)');
        console.log('---dervied ---terget', target);
        if (target) {
            return target;
        }
        if (value === undefined) {
            // Ignore. But expected is to remove the value from all targets
            return undefined;
        }
        const inspect = this.inspect(key, overrides);
        if (objects_1.equals(value, inspect.value)) {
            // No change. So ignore.
            return undefined;
        }
        if (inspect.workspaceFolder !== undefined) {
            return 5 /* WORKSPACE_FOLDER */;
        }
        if (inspect.workspace !== undefined) {
            return 4 /* WORKSPACE */;
        }
        return 1 /* USER */;
    }
    triggerConfigurationChange(configurationEvent, target) {
        this.logger.debug('         (triggerConfigurationChange, with event [%j])', configurationEvent);
        if (configurationEvent.affectedKeys.length) {
            configurationEvent.telemetryData(target, this.getTargetConfiguration(target));
            this._onDidChangeConfiguration.fire(new core_3.WorkspaceConfigurationChangeEvent(configurationEvent, this.workspace));
        }
    }
    getTargetConfiguration(target) {
        this.logger.debug('         (getTargetConfiguration) with target');
        this.logger.trace('         target -- [%j]', target);
        this.logger.trace('            _configuration  -- [%j]', this._configuration);
        switch (target) {
            case 6 /* DEFAULT */:
                return this._configuration.defaults.contents;
            case 1 /* USER */:
                return this._configuration.userConfiguration.contents;
            case 4 /* WORKSPACE */:
                return this._configuration.workspaceConfiguration.contents;
        }
        return {};
    }
    toEditableConfigurationTarget(target, key) {
        if (target === 1 /* USER */) {
            if (this.inspect(key).userRemote !== undefined) {
                return 2 /* USER_REMOTE */;
            }
            return 1 /* USER_LOCAL */;
        }
        if (target === 2 /* USER_LOCAL */) {
            return 1 /* USER_LOCAL */;
        }
        if (target === 3 /* USER_REMOTE */) {
            return 2 /* USER_REMOTE */;
        }
        if (target === 4 /* WORKSPACE */) {
            return 3 /* WORKSPACE */;
        }
        if (target === 5 /* WORKSPACE_FOLDER */) {
            return 4 /* WORKSPACE_FOLDER */;
        }
        return null;
    }
};
WorkspaceService = __decorate([
    inversify_1.injectable(),
    __metadata("design:paramtypes", [Object, Object, Object, ILogger])
], WorkspaceService);
exports.WorkspaceService = WorkspaceService;
//# sourceMappingURL=workspace-service.js.map