"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleVetos = exports.StartupKindToString = exports.LifecyclePhaseToString = void 0;
const async_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/async");
function LifecyclePhaseToString(phase) {
    switch (phase) {
        case 1 /* Starting */: return 'Starting';
        case 2 /* Ready */: return 'Ready';
        case 3 /* Restored */: return 'Restored';
        case 4 /* Eventually */: return 'Eventually';
    }
}
exports.LifecyclePhaseToString = LifecyclePhaseToString;
function StartupKindToString(startupKind) {
    switch (startupKind) {
        case 1 /* NewWindow */: return 'NewWindow';
        case 3 /* ReloadedWindow */: return 'ReloadedWindow';
        case 4 /* ReopenedWindow */: return 'ReopenedWindow';
    }
}
exports.StartupKindToString = StartupKindToString;
// Shared veto handling across main and renderer
function handleVetos(vetos, onError) {
    if (vetos.length === 0) {
        return Promise.resolve(false);
    }
    const promises = [];
    let lazyValue = false;
    for (let valueOrPromise of vetos) {
        // veto, done
        if (valueOrPromise === true) {
            return Promise.resolve(true);
        }
        if (async_1.isThenable(valueOrPromise)) {
            promises.push(valueOrPromise.then(value => {
                if (value) {
                    lazyValue = true; // veto, done
                }
            }, err => {
                onError(err); // error, treated like a veto, done
                lazyValue = true;
            }));
        }
    }
    return Promise.all(promises).then(() => lazyValue);
}
exports.handleVetos = handleVetos;
//# sourceMappingURL=util.js.map