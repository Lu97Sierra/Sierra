"use strict";
/* tslint:disable */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigurationEditingService = void 0;
const nls = require("@vscode-alt/monaco-editor/esm/vs/nls");
const uri_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/uri");
const json = require("@vscode-alt/monaco-editor/esm/vs/base/common/json");
const jsonEdit_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/jsonEdit");
const async_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/async");
const editOperation_1 = require("@vscode-alt/monaco-editor/esm/vs/editor/common/core/editOperation");
const registry_1 = require("../../core/registry");
const range_1 = require("@vscode-alt/monaco-editor/esm/vs/editor/common/core/range");
const selection_1 = require("@vscode-alt/monaco-editor/esm/vs/editor/common/core/selection");
const core_1 = require("@workbench-stack/core");
// import { ITextFileService } from 'vs/workbench/services/textfile/common/textfiles';
const core_2 = require("@workbench-stack/core");
const core_3 = require("@files-stack/core");
// import { ITextModelService, ITextEditorModel } from 'vs/editor/common/services/resolverService';
const core_4 = require("@workbench-stack/core");
const textModel_1 = require("@vscode-alt/monaco-editor/esm/vs/editor/common/model/textModel");
const core_5 = require("@workbench-stack/core");
const types_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/types");
const interfaces_1 = require("../../interfaces");
const inversify_1 = require("inversify");
let ConfigurationEditingService = class ConfigurationEditingService {
    constructor(configurationService, contextService, environmentService, fileService, 
    // @inject('ITextModelService') private textModelResolverService: ITextModelService,
    textFileService, notificationService) {
        this.configurationService = configurationService;
        this.contextService = contextService;
        this.environmentService = environmentService;
        this.fileService = fileService;
        this.textFileService = textFileService;
        this.notificationService = notificationService;
        this.queue = new async_1.Queue();
        // remoteAgentService.getEnvironment().then(environment => {
        // 	if (environment) {
        // 		this.remoteSettingsResource = environment.settingsPath;
        // 	}
        // });
    }
    writeConfiguration(target, value, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const operation = this.getConfigurationEditOperation(target, value, options.scopes || {});
            // await this.fileService.updateContent(resource, JSON.stringify({[value.key]: value.value}));
            return yield this.doWriteConfiguration(operation, options);
            // return Promise.resolve(this.queue.queue(() => this.doWriteConfiguration(operation, options) // queue up writes to prevent race conditions
            // .then(() => null,
            //     error => {
            //         if (!options.donotNotifyError) {
            //             this.onError(error, operation, options.scopes);
            //         }
            //         return Promise.reject(error);
            //     })));
        });
    }
    doWriteConfiguration(operation, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const checkDirtyConfiguration = !(options.force || options.donotSave);
            const saveConfiguration = options.force || !options.donotSave;
            return yield this.resolveAndValidate(operation.target, operation, checkDirtyConfiguration, options.scopes || {})
                .then(() => this.writeToBuffer({}, operation, saveConfiguration));
            // return this.resolveAndValidate(operation.target, operation, checkDirtyConfiguration, options.scopes || {})
            // 	.then(reference => this.writeToBuffer(reference.object.textEditorModel, operation, saveConfiguration)
            // 		.then(() => reference.dispose()));
        });
    }
    writeToBuffer(model, operation, save) {
        return __awaiter(this, void 0, void 0, function* () {
            const content = yield this.textFileService.read(operation.resource);
            const editorModel = new textModel_1.TextModel(content.value, {}, null, operation.resource, null); // @sri setting fourth argument null can break something
            const edit = this.getEdits(editorModel, operation)[0];
            if (edit && this.applyEditsToBuffer(edit, editorModel) && save) {
                // return this.textFileService.save(operation.resource, { skipSaveParticipants: true /* programmatic change */ });
                //return Promise.resolve(console.log('writeToBudfferSave: operation.resource', operation.resource))
                return yield this.textFileService.write(operation.resource, editorModel.getValue());
            }
        });
    }
    applyEditsToBuffer(edit, model) {
        const startPosition = model.getPositionAt(edit.offset);
        const endPosition = model.getPositionAt(edit.offset + edit.length);
        const range = new range_1.Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);
        let currentText = model.getValueInRange(range);
        if (edit.content !== currentText) {
            const editOperation = currentText ? editOperation_1.EditOperation.replace(range, edit.content) : editOperation_1.EditOperation.insert(startPosition, edit.content);
            model.pushEditOperations([new selection_1.Selection(startPosition.lineNumber, startPosition.column, startPosition.lineNumber, startPosition.column)], [editOperation], () => []);
            return true;
        }
        return false;
    }
    onError(error, operation, scopes) {
        switch (error.code) {
            case 8 /* ERROR_INVALID_CONFIGURATION */:
                this.onInvalidConfigurationError(error, operation);
                break;
            case 7 /* ERROR_CONFIGURATION_FILE_DIRTY */:
                this.onConfigurationFileDirtyError(error, operation, scopes);
                break;
            default:
                this.notificationService.error(error.message);
        }
    }
    onInvalidConfigurationError(error, operation) {
        const openStandAloneConfigurationActionLabel = operation.workspaceStandAloneConfigurationKey === core_2.TASKS_CONFIGURATION_KEY ? nls.localize('openTasksConfiguration', "Open Tasks Configuration")
            : operation.workspaceStandAloneConfigurationKey === core_2.LAUNCH_CONFIGURATION_KEY ? nls.localize('openLaunchConfiguration', "Open Launch Configuration")
                : null;
        if (openStandAloneConfigurationActionLabel) {
            this.notificationService.prompt(core_5.NotificationSeverity.Error, error.message, [{
                    label: openStandAloneConfigurationActionLabel,
                    // run: () => this.openFile(operation.resource)
                    run: {
                        type: "mutation" /* mutation */,
                        document: core_5.OpenEditorFileDocument,
                        variables: {
                            content: {
                                resource: core_2.resourcePath(operation.resource),
                                name: null,
                            },
                        },
                    }
                }]);
        }
        else {
            this.notificationService.prompt(core_5.NotificationSeverity.Error, error.message, [{
                    label: nls.localize('open', "Open Settings"),
                    // run: () => this.openSettings(operation)
                    run: {
                        type: "mutation" /* mutation */,
                    }
                }]);
        }
    }
    onConfigurationFileDirtyError(error, operation, scopes) {
        const openStandAloneConfigurationActionLabel = operation.workspaceStandAloneConfigurationKey === core_2.TASKS_CONFIGURATION_KEY ? nls.localize('openTasksConfiguration', "Open Tasks Configuration")
            : operation.workspaceStandAloneConfigurationKey === core_2.LAUNCH_CONFIGURATION_KEY ? nls.localize('openLaunchConfiguration', "Open Launch Configuration")
                : null;
        if (openStandAloneConfigurationActionLabel) {
            const key = operation.key ? `${operation.workspaceStandAloneConfigurationKey}.${operation.key}` : operation.workspaceStandAloneConfigurationKey;
            this.notificationService.prompt(core_5.NotificationSeverity.Error, error.message, [{
                    label: nls.localize('saveAndRetry', "Save and Retry"),
                    // run: () => {
                    //     const key = operation.key ? `${operation.workspaceStandAloneConfigurationKey}.${operation.key}` : operation.workspaceStandAloneConfigurationKey;
                    //     this.writeConfiguration(operation.target, { key, value: operation.value }, <ConfigurationEditingOptions>{ force: true, scopes });
                    // }
                    run: {
                        type: "mutation" /* mutation */,
                        document: '',
                        variables: {
                            target: operation.target,
                            value: { key, value: operation.value },
                            options: { force: true, scopes },
                        }
                    }
                }, {
                    label: openStandAloneConfigurationActionLabel,
                    // run: () => this.openFile(operation.resource)
                    run: {
                        type: "mutation" /* mutation */,
                        document: core_5.OpenEditorFileDocument,
                        variables: {
                            content: {
                                resource: core_2.resourcePath(operation.resource),
                                name: null,
                            },
                        },
                    }
                }]);
        }
        else {
            this.notificationService.prompt(core_5.NotificationSeverity.Error, error.message, [{
                    label: nls.localize('saveAndRetry', "Save and Retry"),
                    // run: () => this.writeConfiguration(operation.target, { key: operation.key, value: operation.value }, <ConfigurationEditingOptions>{ force: true, scopes })
                    run: {
                        document: '',
                        type: "mutation" /* mutation */,
                        variables: {
                            target: operation.target,
                            value: { key: operation.key, value: operation.value },
                            options: { force: true, scopes },
                        }
                    }
                },
                {
                    label: nls.localize('open', "Open Settings"),
                }]);
        }
    }
    openSettings(operation) {
        console.log('openSettings not implemented');
        // switch (operation.target) {
        // 	case EditableConfigurationTarget.USER_LOCAL:
        // 		this.preferencesService.openGlobalSettings(true);
        // 		break;
        // 	case EditableConfigurationTarget.USER_REMOTE:
        // 		this.preferencesService.openRemoteSettings();
        // 		break;
        // 	case EditableConfigurationTarget.WORKSPACE:
        // 		this.preferencesService.openWorkspaceSettings(true);
        // 		break;
        // 	case EditableConfigurationTarget.WORKSPACE_FOLDER:
        // 		if (operation.resource) {
        // 			const workspaceFolder = this.contextService.getWorkspaceFolder(operation.resource);
        // 			if (workspaceFolder) {
        // 				this.preferencesService.openFolderSettings(workspaceFolder.uri, true);
        // 			}
        // 		}
        // 		break;
        // }
    }
    openFile(resource) {
        // this.editorService.openEditor({ resource });
        console.log('openFile not defined');
    }
    wrapError(code, target, operation) {
        const message = this.toErrorMessage(code, target, operation);
        return Promise.reject(new interfaces_1.ConfigurationEditingError(message, code));
    }
    toErrorMessage(error, target, operation) {
        switch (error) {
            // API constraints
            case 0 /* ERROR_UNKNOWN_KEY */: return nls.localize('errorUnknownKey', "Unable to write to {0} because {1} is not a registered configuration.", this.stringifyTarget(target), operation.key);
            case 1 /* ERROR_INVALID_WORKSPACE_CONFIGURATION_APPLICATION */: return nls.localize('errorInvalidWorkspaceConfigurationApplication', "Unable to write {0} to Workspace Settings. This setting can be written only into User settings.", operation.key);
            case 2 /* ERROR_INVALID_FOLDER_CONFIGURATION */: return nls.localize('errorInvalidFolderConfiguration', "Unable to write to Folder Settings because {0} does not support the folder resource scope.", operation.key);
            case 3 /* ERROR_INVALID_USER_TARGET */: return nls.localize('errorInvalidUserTarget', "Unable to write to User Settings because {0} does not support for global scope.", operation.key);
            case 4 /* ERROR_INVALID_WORKSPACE_TARGET */: return nls.localize('errorInvalidWorkspaceTarget', "Unable to write to Workspace Settings because {0} does not support for workspace scope in a multi folder workspace.", operation.key);
            case 5 /* ERROR_INVALID_FOLDER_TARGET */: return nls.localize('errorInvalidFolderTarget', "Unable to write to Folder Settings because no resource is provided.");
            case 6 /* ERROR_NO_WORKSPACE_OPENED */: return nls.localize('errorNoWorkspaceOpened', "Unable to write to {0} because no workspace is opened. Please open a workspace first and try again.", this.stringifyTarget(target));
            // User issues
            case 8 /* ERROR_INVALID_CONFIGURATION */: {
                if (operation.workspaceStandAloneConfigurationKey === core_2.TASKS_CONFIGURATION_KEY) {
                    return nls.localize('errorInvalidTaskConfiguration', "Unable to write into the tasks configuration file. Please open it to correct errors/warnings in it and try again.");
                }
                if (operation.workspaceStandAloneConfigurationKey === core_2.LAUNCH_CONFIGURATION_KEY) {
                    return nls.localize('errorInvalidLaunchConfiguration', "Unable to write into the launch configuration file. Please open it to correct errors/warnings in it and try again.");
                }
                switch (target) {
                    case 1 /* USER_LOCAL */:
                        return nls.localize('errorInvalidConfiguration', "Unable to write into user settings. Please open the user settings to correct errors/warnings in it and try again.");
                    case 2 /* USER_REMOTE */:
                        return nls.localize('errorInvalidRemoteConfiguration', "Unable to write into remote user settings. Please open the remote user settings to correct errors/warnings in it and try again.");
                    case 3 /* WORKSPACE */:
                        return nls.localize('errorInvalidConfigurationWorkspace', "Unable to write into workspace settings. Please open the workspace settings to correct errors/warnings in the file and try again.");
                    case 4 /* WORKSPACE_FOLDER */:
                        let workspaceFolderName = '<<unknown>>';
                        if (operation.resource) {
                            const folder = this.contextService.getWorkspaceFolder(operation.resource);
                            if (folder) {
                                workspaceFolderName = folder.name;
                            }
                        }
                        return nls.localize('errorInvalidConfigurationFolder', "Unable to write into folder settings. Please open the '{0}' folder settings to correct errors/warnings in it and try again.", workspaceFolderName);
                }
                return '';
            }
            case 7 /* ERROR_CONFIGURATION_FILE_DIRTY */: {
                if (operation.workspaceStandAloneConfigurationKey === core_2.TASKS_CONFIGURATION_KEY) {
                    return nls.localize('errorTasksConfigurationFileDirty', "Unable to write into tasks configuration file because the file is dirty. Please save it first and then try again.");
                }
                if (operation.workspaceStandAloneConfigurationKey === core_2.LAUNCH_CONFIGURATION_KEY) {
                    return nls.localize('errorLaunchConfigurationFileDirty', "Unable to write into launch configuration file because the file is dirty. Please save it first and then try again.");
                }
                switch (target) {
                    case 1 /* USER_LOCAL */:
                        return nls.localize('errorConfigurationFileDirty', "Unable to write into user settings because the file is dirty. Please save the user settings file first and then try again.");
                    case 2 /* USER_REMOTE */:
                        return nls.localize('errorRemoteConfigurationFileDirty', "Unable to write into remote user settings because the file is dirty. Please save the remote user settings file first and then try again.");
                    case 3 /* WORKSPACE */:
                        return nls.localize('errorConfigurationFileDirtyWorkspace', "Unable to write into workspace settings because the file is dirty. Please save the workspace settings file first and then try again.");
                    case 4 /* WORKSPACE_FOLDER */:
                        let workspaceFolderName = '<<unknown>>';
                        if (operation.resource) {
                            const folder = this.contextService.getWorkspaceFolder(operation.resource);
                            if (folder) {
                                workspaceFolderName = folder.name;
                            }
                        }
                        return nls.localize('errorConfigurationFileDirtyFolder', "Unable to write into folder settings because the file is dirty. Please save the '{0}' folder settings file first and then try again.", workspaceFolderName);
                }
                return '';
            }
        }
    }
    stringifyTarget(target) {
        switch (target) {
            case 1 /* USER_LOCAL */:
                return nls.localize('userTarget', "User Settings");
            case 2 /* USER_REMOTE */:
                return nls.localize('remoteUserTarget', "Remote User Settings");
            case 3 /* WORKSPACE */:
                return nls.localize('workspaceTarget', "Workspace Settings");
            case 4 /* WORKSPACE_FOLDER */:
                return nls.localize('folderTarget', "Folder Settings");
        }
        return '';
    }
    getEdits(model, edit) {
        const { tabSize, insertSpaces } = model.getOptions();
        const eol = model.getEOL();
        const { value, jsonPath } = edit;
        // Without jsonPath, the entire configuration file is being replaced, so we just use JSON.stringify
        if (!jsonPath.length) {
            const content = JSON.stringify(value, null, insertSpaces ? ' '.repeat(tabSize) : '\t');
            return [{
                    content,
                    length: model.getValue().length,
                    offset: 0
                }];
        }
        return jsonEdit_1.setProperty(model.getValue(), jsonPath, value, { tabSize, insertSpaces, eol });
    }
    // @sri made changes to skip textFileService
    resolveModelReference(resource) {
        return __awaiter(this, void 0, void 0, function* () {
            const exists = yield this.fileService.exists(resource);
            if (!exists) {
                yield this.textFileService.write(resource, '{}', { encoding: 'utf8' });
            }
            return {}; //this.textModelResolverService.createModelReference(resource);
        });
    }
    hasParseErrors(model, operation) {
        // If we write to a workspace standalone file and replace the entire contents (no key provided)
        // we can return here because any parse errors can safely be ignored since all contents are replaced
        if (operation.workspaceStandAloneConfigurationKey && !operation.key) {
            return false;
        }
        const parseErrors = [];
        json.parse(model.getValue(), parseErrors);
        return parseErrors.length > 0;
    }
    resolveAndValidate(target, operation, checkDirty, overrides) {
        // Any key must be a known setting from the registry (unless this is a standalone config)
        if (!operation.workspaceStandAloneConfigurationKey) {
            const validKeys = this.configurationService.keys().default;
            if (validKeys.indexOf(operation.key) < 0 && !core_2.OVERRIDE_PROPERTY_PATTERN.test(operation.key)) {
                return this.wrapError(0 /* ERROR_UNKNOWN_KEY */, target, operation);
            }
        }
        if (operation.workspaceStandAloneConfigurationKey) {
            // Global tasks and launches are not supported
            if (target === 1 /* USER_LOCAL */ || target === 2 /* USER_REMOTE */) {
                return this.wrapError(3 /* ERROR_INVALID_USER_TARGET */, target, operation);
            }
            // Workspace tasks are not supported
            if (operation.workspaceStandAloneConfigurationKey === core_2.TASKS_CONFIGURATION_KEY && this.contextService.getWorkbenchState() === 3 /* WORKSPACE */ && operation.target === 3 /* WORKSPACE */) {
                return this.wrapError(4 /* ERROR_INVALID_WORKSPACE_TARGET */, target, operation);
            }
        }
        // Target cannot be workspace or folder if no workspace opened
        if ((target === 3 /* WORKSPACE */ || target === 4 /* WORKSPACE_FOLDER */) && this.contextService.getWorkbenchState() === 1 /* EMPTY */) {
            return this.wrapError(6 /* ERROR_NO_WORKSPACE_OPENED */, target, operation);
        }
        if (target === 3 /* WORKSPACE */) {
            if (!operation.workspaceStandAloneConfigurationKey) {
                const configurationProperties = registry_1.Registry.Instance.as(core_2.Extensions.Configuration).getConfigurationProperties();
                if (configurationProperties[operation.key].scope === 1 /* APPLICATION */) {
                    return this.wrapError(1 /* ERROR_INVALID_WORKSPACE_CONFIGURATION_APPLICATION */, target, operation);
                }
            }
        }
        if (target === 4 /* WORKSPACE_FOLDER */) {
            if (!operation.resource) {
                return this.wrapError(5 /* ERROR_INVALID_FOLDER_TARGET */, target, operation);
            }
            if (!operation.workspaceStandAloneConfigurationKey) {
                const configurationProperties = registry_1.Registry.Instance.as(core_2.Extensions.Configuration).getConfigurationProperties();
                if (configurationProperties[operation.key].scope !== 4 /* RESOURCE */) {
                    return this.wrapError(2 /* ERROR_INVALID_FOLDER_CONFIGURATION */, target, operation);
                }
            }
        }
        return this.resolveModelReference(operation.resource);
        // .then(reference => {
        //     const model = reference.object.textEditorModel;
        //     if (this.hasParseErrors(model, operation)) {
        //         return this.wrapError<typeof reference>(ConfigurationEditingErrorCode.ERROR_INVALID_CONFIGURATION, target, operation);
        //     }
        //     // Target cannot be dirty if not writing into buffer
        //     // if (checkDirty && this.textFileService.isDirty(operation.resource)) {
        //     //     return this.wrapError<typeof reference>(ConfigurationEditingErrorCode.ERROR_CONFIGURATION_FILE_DIRTY, target, operation);
        //     // }
        //     return reference;
        // });
    }
    getConfigurationEditOperation(target, config, overrides) {
        // Check for standalone workspace configurations
        if (config.key) {
            const standaloneConfigurationKeys = Object.keys(core_2.WORKSPACE_STANDALONE_CONFIGURATIONS);
            for (let i = 0; i < standaloneConfigurationKeys.length; i++) {
                const key = standaloneConfigurationKeys[i];
                const resource = this.getConfigurationFileResource(target, core_2.WORKSPACE_STANDALONE_CONFIGURATIONS[key], overrides.resource);
                // Check for prefix
                if (config.key === key) {
                    const jsonPath = this.isWorkspaceConfigurationResource(resource) ? [key] : [];
                    return { key: jsonPath[jsonPath.length - 1], jsonPath, value: config.value, resource: types_1.withNullAsUndefined(resource), workspaceStandAloneConfigurationKey: key, target };
                }
                // Check for prefix.<setting>
                const keyPrefix = `${key}.`;
                if (config.key.indexOf(keyPrefix) === 0) {
                    const jsonPath = this.isWorkspaceConfigurationResource(resource) ? [key, config.key.substr(keyPrefix.length)] : [config.key.substr(keyPrefix.length)];
                    return { key: jsonPath[jsonPath.length - 1], jsonPath, value: config.value, resource: types_1.withNullAsUndefined(resource), workspaceStandAloneConfigurationKey: key, target };
                }
            }
        }
        let key = config.key;
        let jsonPath = overrides.overrideIdentifier ? [core_1.keyFromOverrideIdentifier(overrides.overrideIdentifier), key] : [key];
        if (target === 1 /* USER_LOCAL */ || target === 2 /* USER_REMOTE */) {
            return { key, jsonPath, value: config.value, resource: uri_1.URI.file(this.environmentService.appSettingsPath), target };
        }
        const resource = this.getConfigurationFileResource(target, core_2.FOLDER_SETTINGS_PATH, overrides.resource);
        if (this.isWorkspaceConfigurationResource(resource)) {
            jsonPath = ['settings', ...jsonPath];
        }
        return { key, jsonPath, value: config.value, resource: types_1.withNullAsUndefined(resource), target };
    }
    isWorkspaceConfigurationResource(resource) {
        const workspace = this.contextService.getWorkspace();
        return workspace.configuration && resource && workspace.configuration.fsPath === resource.fsPath;
    }
    getConfigurationFileResource(target, relativePath, resource) {
        if (target === 1 /* USER_LOCAL */) {
            return uri_1.URI.file(this.environmentService.appSettingsPath);
        }
        if (target === 2 /* USER_REMOTE */) {
            return this.remoteSettingsResource;
        }
        const workbenchState = this.contextService.getWorkbenchState();
        if (workbenchState !== 1 /* EMPTY */) {
            const workspace = this.contextService.getWorkspace();
            if (target === 3 /* WORKSPACE */) {
                if (workbenchState === 3 /* WORKSPACE */) {
                    return types_1.withUndefinedAsNull(workspace.configuration);
                }
                if (workbenchState === 2 /* FOLDER */) {
                    return workspace.folders[0].toResource(relativePath);
                }
            }
            if (target === 4 /* WORKSPACE_FOLDER */) {
                if (resource) {
                    const folder = this.contextService.getWorkspaceFolder(resource);
                    if (folder) {
                        return folder.toResource(relativePath);
                    }
                }
            }
        }
        return null;
    }
};
ConfigurationEditingService = __decorate([
    inversify_1.injectable(),
    __param(0, inversify_1.inject(core_4.TYPES.IConfigurationService)),
    __param(1, inversify_1.inject(core_4.TYPES.IWorkspaceContextService)),
    __param(2, inversify_1.inject(core_4.TYPES.IEnvironmentService)),
    __param(3, inversify_1.inject(core_3.TYPES.IFileService)),
    __param(4, inversify_1.inject(core_3.TYPES.ITextFileService)),
    __param(5, inversify_1.inject(core_4.TYPES.INotificationService)),
    __metadata("design:paramtypes", [Object, Object, Object, Object, Object, Object])
], ConfigurationEditingService);
exports.ConfigurationEditingService = ConfigurationEditingService;
//# sourceMappingURL=configuration-editing-service.js.map