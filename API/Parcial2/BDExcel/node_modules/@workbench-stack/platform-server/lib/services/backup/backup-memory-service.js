// /* tslint:disable */
// import * as path from 'path';
// import * as crypto from 'crypto';
// import { ITextSnapshot } from '@files-stack/core';
// import { IBackupFileService } from '../../interfaces';
// import { URI as Uri } from '@vscode-alt/monaco-editor/esm/vs/base/common/uri';
// import { keys } from '@vscode-alt/monaco-editor/esm/vs/base/common/map';
// import { createTextBufferFactoryFromSnapshot } from '@vscode-alt/monaco-editor/esm/vs/editor/common/model/textModel';
// import { ITextBufferFactory } from '@workbench-stack/core';
// import { Schemas } from '@vscode-alt/monaco-editor/esm/vs/base/common/network';
// export class InMemoryBackupFileService implements IBackupFileService {
// 	private backups: Map<string, ITextSnapshot> = new Map();
// 	hasBackups(): Promise<boolean> {
// 		return Promise.resolve(this.backups.size > 0);
// 	}
// 	loadBackupResource(resource: Uri): Promise<Uri | undefined> {
// 		const backupResource = this.toBackupResource(resource);
// 		if (this.backups.has(backupResource.toString())) {
// 			return Promise.resolve(backupResource);
// 		}
// 		return Promise.resolve(undefined);
// 	}
// 	backupResource(resource: Uri, content: ITextSnapshot, versionId?: number): Promise<void> {
// 		const backupResource = this.toBackupResource(resource);
// 		this.backups.set(backupResource.toString(), content);
// 		return Promise.resolve();
// 	}
// 	resolveBackupContent(backupResource: Uri): Promise<ITextBufferFactory | undefined> {
// 		const snapshot = this.backups.get(backupResource.toString());
// 		if (snapshot) {
// 			return Promise.resolve(createTextBufferFactoryFromSnapshot(snapshot));
// 		}
// 		return Promise.resolve(undefined);
// 	}
// 	getWorkspaceFileBackups(): Promise<Uri[]> {
// 		return Promise.resolve(keys(this.backups).map(key => Uri.parse(key)));
// 	}
// 	discardResourceBackup(resource: Uri): Promise<void> {
// 		this.backups.delete(this.toBackupResource(resource).toString());
// 		return Promise.resolve();
// 	}
// 	discardAllWorkspaceBackups(): Promise<void> {
// 		this.backups.clear();
// 		return Promise.resolve();
// 	}
// 	toBackupResource(resource: Uri): Uri {
// 		return Uri.file(path.join(resource.scheme, hashPath(resource)));
// 	}
// }
// /*
//  * Exported only for testing
//  */
// export function hashPath(resource: Uri): string {
// 	const str = resource.scheme === Schemas.file || resource.scheme === Schemas.untitled ? resource.fsPath : resource.toString();
// 	return crypto.createHash('md5').update(str).digest('hex');
// }
//# sourceMappingURL=backup-memory-service.js.map