"use strict";
/* tslint:disable */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getWorkspaceIdentifier = exports.WorkspacesMainService = void 0;
const core_1 = require("@workbench-stack/core");
const pfs_1 = require("@vscode-alt/monaco-editor/esm/vs/base/node/pfs");
const path_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/path");
const platform_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/platform");
const resources_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/resources");
const crypto_1 = require("crypto");
const inversify_1 = require("inversify");
const event_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/event");
const lifecycle_1 = require("@vscode-alt/monaco-editor/esm/vs/base/common/lifecycle");
const fs_1 = require("fs");
const json = require("@vscode-alt/monaco-editor/esm/vs/base/common/json");
let WorkspacesMainService = class WorkspacesMainService extends lifecycle_1.Disposable {
    constructor(environmentService, logService) {
        super();
        this.environmentService = environmentService;
        this.logService = logService;
        this._onUntitledWorkspaceDeleted = this._register(new event_1.Emitter());
        this.untitledWorkspacesHome = environmentService.untitledWorkspacesHome;
    }
    get onUntitledWorkspaceDeleted() { return this._onUntitledWorkspaceDeleted.event; }
    resolveLocalWorkspaceSync(uri) {
        if (!this.isWorkspacePath(uri)) {
            return null; // does not look like a valid workspace config file
        }
        if (uri.scheme !== core_1.Schemas.file) {
            return null;
        }
        let contents;
        try {
            contents = fs_1.readFileSync(uri.fsPath, 'utf8');
        }
        catch (error) {
            return null; // invalid workspace
        }
        return this.doResolveWorkspace(uri, contents);
    }
    isWorkspacePath(uri) {
        console.log('LJSLDJFLSJFLSJDLFJSLDFJL isWrokspacePath', uri);
        return this.isInsideWorkspacesHome(uri) || core_1.hasWorkspaceFileExtension(uri);
    }
    doResolveWorkspace(path, contents) {
        try {
            const workspace = this.doParseStoredWorkspace(path, contents);
            const workspaceIdentifier = getWorkspaceIdentifier(path);
            return {
                id: workspaceIdentifier.id,
                configPath: workspaceIdentifier.configPath,
                folders: core_1.toWorkspaceFolders(workspace.folders, workspaceIdentifier.configPath),
                remoteAuthority: workspace.remoteAuthority
            };
        }
        catch (error) {
            this.logService.warn(error.toString());
        }
        return null;
    }
    doParseStoredWorkspace(path, contents) {
        // Parse workspace file
        let storedWorkspace = json.parse(contents); // use fault tolerant parser
        // Filter out folders which do not have a path or uri set
        if (Array.isArray(storedWorkspace.folders)) {
            storedWorkspace.folders = storedWorkspace.folders.filter(folder => core_1.isStoredWorkspaceFolder(folder));
        }
        // Validate
        if (!Array.isArray(storedWorkspace.folders)) {
            throw new Error(`${path.toString()} looks like an invalid workspace file.`);
        }
        return storedWorkspace;
    }
    isInsideWorkspacesHome(path) {
        return resources_1.isEqualOrParent(path, this.environmentService.untitledWorkspacesHome);
    }
    createUntitledWorkspace(folders, remoteAuthority) {
        return __awaiter(this, void 0, void 0, function* () {
            const { workspace, storedWorkspace } = this.newUntitledWorkspace(folders, remoteAuthority);
            const configPath = workspace.configPath.fsPath;
            yield pfs_1.mkdirp(path_1.dirname(configPath));
            yield pfs_1.writeFile(configPath, JSON.stringify(storedWorkspace, null, '\t'));
            return workspace;
        });
    }
    createUntitledWorkspaceSync(folders, remoteAuthority) {
        const { workspace, storedWorkspace } = this.newUntitledWorkspace(folders, remoteAuthority);
        const configPath = workspace.configPath.fsPath;
        const configPathDir = path_1.dirname(configPath);
        if (!fs_1.existsSync(configPathDir)) {
            const configPathDirDir = path_1.dirname(configPathDir);
            if (!fs_1.existsSync(configPathDirDir)) {
                fs_1.mkdirSync(configPathDirDir);
            }
            fs_1.mkdirSync(configPathDir);
        }
        pfs_1.writeFileSync(configPath, JSON.stringify(storedWorkspace, null, '\t'));
        return workspace;
    }
    newUntitledWorkspace(folders = [], remoteAuthority) {
        const randomId = (Date.now() + Math.round(Math.random() * 1000)).toString();
        const untitledWorkspaceConfigFolder = resources_1.joinPath(this.untitledWorkspacesHome, randomId);
        const untitledWorkspaceConfigPath = resources_1.joinPath(untitledWorkspaceConfigFolder, core_1.UNTITLED_WORKSPACE_NAME);
        const storedWorkspaceFolder = [];
        for (const folder of folders) {
            storedWorkspaceFolder.push(core_1.getStoredWorkspaceFolder(folder.uri, folder.name, untitledWorkspaceConfigFolder));
        }
        return {
            workspace: getWorkspaceIdentifier(untitledWorkspaceConfigPath),
            storedWorkspace: { folders: storedWorkspaceFolder, remoteAuthority }
        };
    }
    getWorkspaceIdentifier(configPath) {
        return Promise.resolve(getWorkspaceIdentifier(configPath));
    }
    isUntitledWorkspace(workspace) {
        return this.isInsideWorkspacesHome(workspace.configPath);
    }
    deleteUntitledWorkspaceSync(workspace) {
        if (!this.isUntitledWorkspace(workspace)) {
            return; // only supported for untitled workspaces
        }
        // Delete from disk
        this.doDeleteUntitledWorkspaceSync(workspace);
        // Event
        this._onUntitledWorkspaceDeleted.fire(workspace);
    }
    deleteUntitledWorkspace(workspace) {
        this.deleteUntitledWorkspaceSync(workspace);
        return Promise.resolve();
    }
    doDeleteUntitledWorkspaceSync(workspace) {
        const configPath = resources_1.originalFSPath(workspace.configPath);
        try {
            // Delete Workspace
            pfs_1.rimrafSync(path_1.dirname(configPath));
            // Mark Workspace Storage to be deleted
            const workspaceStoragePath = path_1.join(this.environmentService.workspaceStorageHome, workspace.id);
            if (fs_1.existsSync(workspaceStoragePath)) {
                pfs_1.writeFileSync(path_1.join(workspaceStoragePath, 'obsolete'), '');
            }
        }
        catch (error) {
            this.logService.warn(`Unable to delete untitled workspace ${configPath} (${error}).`);
        }
    }
    getUntitledWorkspacesSync() {
        let untitledWorkspaces = [];
        try {
            const untitledWorkspacePaths = pfs_1.readdirSync(this.untitledWorkspacesHome.fsPath).map(folder => resources_1.joinPath(this.untitledWorkspacesHome, folder, core_1.UNTITLED_WORKSPACE_NAME));
            for (const untitledWorkspacePath of untitledWorkspacePaths) {
                const workspace = getWorkspaceIdentifier(untitledWorkspacePath);
                const resolvedWorkspace = this.resolveLocalWorkspaceSync(untitledWorkspacePath);
                if (!resolvedWorkspace) {
                    this.doDeleteUntitledWorkspaceSync(workspace);
                }
                else {
                    untitledWorkspaces.push({ workspace, remoteAuthority: resolvedWorkspace.remoteAuthority });
                }
            }
        }
        catch (error) {
            if (error && error.code !== 'ENOENT') {
                this.logService.warn(`Unable to read folders in ${this.untitledWorkspacesHome} (${error}).`);
            }
        }
        return untitledWorkspaces;
    }
};
WorkspacesMainService = __decorate([
    inversify_1.injectable(),
    __param(0, inversify_1.inject(core_1.TYPES.IEnvironmentService)),
    __param(1, inversify_1.inject(core_1.TYPES.ILogService)),
    __metadata("design:paramtypes", [Object, Object])
], WorkspacesMainService);
exports.WorkspacesMainService = WorkspacesMainService;
function getWorkspaceId(configPath) {
    let workspaceConfigPath = configPath.scheme === core_1.Schemas.file ? resources_1.originalFSPath(configPath) : configPath.toString();
    if (!platform_1.isLinux) {
        workspaceConfigPath = workspaceConfigPath.toLowerCase(); // sanitize for platform file system
    }
    return crypto_1.createHash('md5').update(workspaceConfigPath).digest('hex');
}
function getWorkspaceIdentifier(configPath) {
    return {
        configPath,
        id: getWorkspaceId(configPath)
    };
}
exports.getWorkspaceIdentifier = getWorkspaceIdentifier;
//# sourceMappingURL=workspaces-main-service.js.map